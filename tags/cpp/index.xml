<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>cpp on SoByte</title>
    <link>https://www.sobyte.net/tags/cpp/</link>
    <description>Recent content in cpp on SoByte</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 20 Jan 2022 11:22:21 +0800</lastBuildDate><atom:link href="https://www.sobyte.net/tags/cpp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>C&#43;&#43; std::thread join() and deconstruct function</title>
      <link>https://www.sobyte.net/post/2022-01/cpp-std-thread-destruct-before-join/</link>
      <pubDate>Thu, 20 Jan 2022 11:22:21 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2022-01/cpp-std-thread-destruct-before-join/</guid>
      <description>During a debugging session a few days ago, I noticed that the Stack Trace printed by the program was not quite what I expected. After much research, I found a problematic piece of code. Can you see what the problem is?
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  #include &amp;lt;chrono&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;thread&amp;gt; int subtask1(int x) { std::this_thread::sleep_for(std::chrono::milliseconds(1000)); return x; } int subtask2(int x) { std::this_thread::sleep_for(std::chrono::milliseconds(500)); return x; } int run(int a, int b) { int result1; std::thread t([&amp;amp;]() { result1 = subtask1(a); }); int result2 = subtask2(b); if (result2 &amp;lt; 0) { return -2; } t.</description>
    </item>
    
    <item>
      <title>C&#43;&#43; threading: how to use promise, future, packaged_task and async</title>
      <link>https://www.sobyte.net/post/2022-01/cpp-threading/</link>
      <pubDate>Thu, 20 Jan 2022 11:08:17 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2022-01/cpp-threading/</guid>
      <description>Today I would like to introduce the C++ threaded high-level APIs: std::promise, std::future, std::packaged_task and std::async. The content of this article can be condensed into the following diagram.
where std::promise and std::future are synchronisation channels between threads. The std::packed_task class template is an adapter for a function or a function object. It wraps the return value of a function in std::future, allowing us to easily execute any function with std::thread. The std::async function is equivalent to the sum of std::packaged_task and std::thread.</description>
    </item>
    
    <item>
      <title>Usage of std::any in C&#43;&#43; 17</title>
      <link>https://www.sobyte.net/post/2022-01/cpp-17-std-any-usage/</link>
      <pubDate>Thu, 20 Jan 2022 10:53:37 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2022-01/cpp-17-std-any-usage/</guid>
      <description>This article introduces the new std::any class in C++ 17. It can store all values that are &amp;ldquo;Copy Constructible&amp;rdquo;. In the following we will first introduce the basic usage of std::any, and then describe the practical use of it.
Usage The use of the std::any class is broken down as follows.
 Constructed objects Assigning operators any_cast function has_value member function reset member function emplace member function type member function  Constructed objects The std::any category is defined in the &amp;lt;any&amp;gt; header file.</description>
    </item>
    
  </channel>
</rss>
