<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>grpc on SoByte</title>
    <link>https://www.sobyte.net/tags/grpc/</link>
    <description>Recent content in grpc on SoByte</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 29 Mar 2022 09:22:45 +0800</lastBuildDate><atom:link href="https://www.sobyte.net/tags/grpc/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Things to know about the gRPC client</title>
      <link>https://www.sobyte.net/post/2022-03/golang-grpc/</link>
      <pubDate>Tue, 29 Mar 2022 09:22:45 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2022-03/golang-grpc/</guid>
      <description>In the era of cloud-native and microservices-dominated architectural models, there are only two types of communication protocols used for internal service interactions: HTTP API (RESTful API) and RPC. With today&amp;rsquo;s hardware configurations and network conditions, modern RPC implementations generally perform better than HTTP API. We compare json over http with gRPC(insecure), using ghz and hey stress test the gRPC and json over http implementations. The performance of gRPC (Requests/sec: 59924.34)</description>
    </item>
    
    <item>
      <title>Response design for gRPC services</title>
      <link>https://www.sobyte.net/post/2022-03/the-design-of-the-response-for-grpc-server/</link>
      <pubDate>Sat, 26 Mar 2022 11:20:36 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2022-03/the-design-of-the-response-for-grpc-server/</guid>
      <description>1. Status of server-side response Developers doing back-end services are always sensitive to error handling, so they will always be very careful when doing the service response (response/reply) design.
If the back-end service is selected from HTTP API (rest api), such as json over http, the API response (Response) will mostly contain the following information.
1 2 3 4 5 6 7  { &amp;#34;code&amp;#34;: 0, &amp;#34;msg&amp;#34;: &amp;#34;ok&amp;#34;, &amp;#34;payload&amp;#34; : { .</description>
    </item>
    
    <item>
      <title>Understanding the gRPC Protocol</title>
      <link>https://www.sobyte.net/post/2022-03/understanding-the-gprc-protocol/</link>
      <pubDate>Wed, 23 Mar 2022 09:35:31 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2022-03/understanding-the-gprc-protocol/</guid>
      <description>gRPC is Google&amp;rsquo;s open source RPC protocol framework. Because it comes with the aura of a big company, the use of gRPC is also becoming more and more widespread. So should we use gRPC when we make technology choices? This requires consideration of both positive and negative aspects. If gRPC is good, what is it good for? What does it sacrifice for this good? What problems do we face in</description>
    </item>
    
    <item>
      <title>Memory-based communication for gRPC calls</title>
      <link>https://www.sobyte.net/post/2022-03/grpc-in-memory/</link>
      <pubDate>Sun, 06 Mar 2022 16:16:22 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2022-03/grpc-in-memory/</guid>
      <description>Apache Dubbo has the injvm method of communication, which can avoid the latency caused by the network, and also does not occupy the local port, which is a more convenient way of RPC communication for testing and local verification. I recently saw containerd&amp;rsquo;s code and found that it has similar requirements. But using ip port communication, there may be port conflict; using unix socket, there may be path conflict. I</description>
    </item>
    
    <item>
      <title>NGINX proxy gRPC requests</title>
      <link>https://www.sobyte.net/post/2022-03/nginx-grpc/</link>
      <pubDate>Wed, 02 Mar 2022 09:43:04 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2022-03/nginx-grpc/</guid>
      <description>My blog server has two ports open, one for serving HTTP requests and one for serving gRPC requests from clients. Later, after learning more about gRPC, I found out that the underlying transport layer protocol is actually based on HTTP/2. At the same time, I saw the official NGINX gRPC support. So I wanted to use NGINX to proxy gRPC requests so that I wouldn&amp;rsquo;t have to think about the</description>
    </item>
    
    <item>
      <title>WebSocket, HTTP/2 and gRPC</title>
      <link>https://www.sobyte.net/post/2022-01/websocket-http2-and-grpc/</link>
      <pubDate>Sun, 09 Jan 2022 10:09:55 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2022-01/websocket-http2-and-grpc/</guid>
      <description>I. WebSocket WebSocket is a two-way communication protocol that uses the HTTP/1.1 protocol in the handshake phase (HTTP/2 is not supported at this time). The handshake process is as follows. First the client initiates a special HTTP request to the server with the following message header. 1 2 3 4 5 6 7 8 GET /chat HTTP/1.1 // 请求行 Host: server.example.com Upgrade: websocket // required Connection: Upgrade //</description>
    </item>
    
  </channel>
</rss>
