<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>fsck on SoByte</title>
    <link>https://www.sobyte.net/tags/fsck/</link>
    <description>Recent content in fsck on SoByte</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 17 Jan 2022 13:14:13 +0800</lastBuildDate><atom:link href="https://www.sobyte.net/tags/fsck/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>How fsck works</title>
      <link>https://www.sobyte.net/post/2022-01/how-fsck-works/</link>
      <pubDate>Mon, 17 Jan 2022 13:14:13 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2022-01/how-fsck-works/</guid>
      <description>Background We usually encounter a lot of file system anomalies after a system crash. We usually fix them with the fsck tool, today we will learn what fsck does and how it does it.
Workload example Suppose there is a workload that appends a single block of data to an existing file. The append is done by opening the file, calling lseek() to move the file offset to the end of the file, and then issuing a single 4KB write to the file before closing it.</description>
    </item>
    
  </channel>
</rss>
