<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>goroutine on SoByte</title>
    <link>https://www.sobyte.net/tags/goroutine/</link>
    <description>Recent content in goroutine on SoByte</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 29 Jun 2021 11:05:40 +0800</lastBuildDate><atom:link href="https://www.sobyte.net/tags/goroutine/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Golang - Number of Threads in the Running Program</title>
      <link>https://www.sobyte.net/post/2021-06/golang-number-of-threads-in-the-running-program/</link>
      <pubDate>Tue, 29 Jun 2021 11:05:40 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2021-06/golang-number-of-threads-in-the-running-program/</guid>
      <description>Programmers who are a little bit introduced to the Go language know that the GOMAXPROCS variable can limit the maximum number of threads that can concurrently run the user-state Go code operating system, and you can even change the size of the maximum number of threads at program runtime by calling the function func GOMAXPROCS(n int) int, but when you read the documentation further, or more When you read the documentation further, or go deeper into Go language development, you will find that the actual number of threads is larger than the number you set, sometimes much larger than the value you set, and even more tragically, even when your concurrent tasks are backed up to no more than a few, the number of threads has not come down, wasting memory space and CPU scheduling for nothing.</description>
    </item>
    
    <item>
      <title>Several Ways to Stop Goroutine in Golang</title>
      <link>https://www.sobyte.net/post/2021-06/several-ways-to-stop-goroutine-in-golang/</link>
      <pubDate>Thu, 17 Jun 2021 10:16:44 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2021-06/several-ways-to-stop-goroutine-in-golang/</guid>
      <description>goroutine case In our daily work, we often have code that starts a goroutine using the go keyword.
1 2 3 4 5 6 7 8  func main() { ch := make(chan string, 6) go func() { for { ch &amp;lt;- &amp;#34;Hello&amp;#34; } }() }   A first-time goroutine developer may think it&amp;rsquo;s over, but after running for a while, he may run into some problems and struggle to figure out&amp;hellip;</description>
    </item>
    
    <item>
      <title>Several Cases of Goroutine Leaks in Golang</title>
      <link>https://www.sobyte.net/post/2021-06/several-cases-of-goroutine-leaks-in-golang/</link>
      <pubDate>Mon, 14 Jun 2021 10:34:56 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2021-06/several-cases-of-goroutine-leaks-in-golang/</guid>
      <description>Goroutine 1 2 3  for { go func() {}() }   The threshold for using Goroutine is really low, and there are a lot of abuses.
Goroutine Leak The causes of Goroutine leaks are usually:
 Read/write operations such as channel/mutex are being performed inside Goroutine, but due to logic problems, they are blocked all the time in some cases. The business logic within the Goroutine enters a dead loop and resources are never released.</description>
    </item>
    
  </channel>
</rss>
