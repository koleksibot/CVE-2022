<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>c&#43;&#43; on SoByte</title>
    <link>https://www.sobyte.net/tags/c&#43;&#43;/</link>
    <description>Recent content in c&#43;&#43; on SoByte</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 19 Mar 2022 18:30:32 +0800</lastBuildDate><atom:link href="https://www.sobyte.net/tags/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Conditional compilation using if constexpr </title>
      <link>https://www.sobyte.net/post/2022-03/if-constexpr/</link>
      <pubDate>Sat, 19 Mar 2022 18:30:32 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2022-03/if-constexpr/</guid>
      <description>In project development, we usually use conditional compilation to trim code and selectively exclude code that is not needed, for example, if a feature is not supported at all under a certain platform, then that feature should not be compiled. Generally we use macros to determine the code, selectively pick the parts that need to be compiled, and turn on such conditions in the build system. 1 2 3 4</description>
    </item>
    
    <item>
      <title>C&#43;&#43; Standard Library Explanation - Unordered Associative Containers</title>
      <link>https://www.sobyte.net/post/2022-02/unordered-set-and-map/</link>
      <pubDate>Sat, 19 Feb 2022 12:02:18 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2022-02/unordered-set-and-map/</guid>
      <description>Starting with C++11, the standard library has been extended for associative containers to provide associative containers based on hash table implementations. A hash table will take up more memory than the stored elements in exchange for evenly spreading O(1) performance. Hash Tables There are many strategies for resolving conflicts, the standard library chooses to use the separate linking method, where conflicting elements are placed in one location and stored in</description>
    </item>
    
    <item>
      <title>std::move() and std::forward()</title>
      <link>https://www.sobyte.net/post/2022-02/move-and-forward/</link>
      <pubDate>Sat, 19 Feb 2022 11:52:33 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2022-02/move-and-forward/</guid>
      <description>Move Semantics Move semantics is a new concept introduced in C++11 for the case when an object is assigned to another object and is no longer used by itself. Instead of calling the copy constructor of the new object and then destroying the original object, with move semantics, the resources of the original object are &amp;ldquo;moved&amp;rdquo; to the new object, e.g. std::vector assigns a pointer to an array to the</description>
    </item>
    
    <item>
      <title>Type derivation in modern C&#43;&#43;</title>
      <link>https://www.sobyte.net/post/2022-02/type-deduction/</link>
      <pubDate>Sat, 19 Feb 2022 11:41:19 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2022-02/type-deduction/</guid>
      <description>Template Type Derivation The following is a common function template. 1 2 template&amp;lt;typename T&amp;gt; void func(ParamType p); When we call it as func(x), the compiler will automatically derive the types T and ParamType for us, and they may not be the same because ParamType may have a const or &amp;amp; reference modifier. Parameter type is a reference or pointer 1 2 template&amp;lt;typename T&amp;gt; void func(T&amp;amp; p); This case does not</description>
    </item>
    
    <item>
      <title>Elegant use of #include</title>
      <link>https://www.sobyte.net/post/2022-02/include/</link>
      <pubDate>Tue, 15 Feb 2022 10:38:29 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2022-02/include/</guid>
      <description>#include is not just for referencing header files. Proper use of #include can make the code more elegant.
 Usually we use #include to include header files, as follows.
1  #include &amp;lt;stdio.h&amp;gt;  Understand that the purpose of #include is to copy the specified file to the reference as is during the pre-compilation phase. There is actually some logic that can be handled elegantly using #include.
Referencing code blocks Suppose there is a C file that contains different blocks of code.</description>
    </item>
    
    <item>
      <title>C&#43;&#43; implementation for friendly handling of Json data</title>
      <link>https://www.sobyte.net/post/2022-02/cpp-json/</link>
      <pubDate>Sat, 12 Feb 2022 11:20:29 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2022-02/cpp-json/</guid>
      <description>Background C/C++ client needs to receive and send JSON format data to the backend to achieve communication and data interaction, but there is no ready-made interface for handling JSON format data in C++, so we can&amp;rsquo;t avoid splitting and splicing by directly referring to third-party libraries. Considering that there will be a lot of JSON data to be processed in this project, we can&amp;rsquo;t avoid the repetitive splitting and splicing.</description>
    </item>
    
    <item>
      <title>Communicating with C&#43;&#43; code in NodeJS</title>
      <link>https://www.sobyte.net/post/2022-02/communicate-with-cpp-code-in-node/</link>
      <pubDate>Wed, 09 Feb 2022 13:17:53 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2022-02/communicate-with-cpp-code-in-node/</guid>
      <description>I recently encountered a problem in my project where I needed to call C++ code in NodeJS, so here&amp;rsquo;s a quick summary.
The main options In NodeJS, there are two main options for communicating with code written in other languages.
 Using the AddOn technique, write an extension to NodeJS using C++ and then call the source code or dynamic libraries written in other languages in the code using the FFI (Foreign Function Interface) technique, which brings in dynamic libraries written in other languages directly in Node  A comparison of these two approaches shows that each has its own advantages and disadvantages.</description>
    </item>
    
    <item>
      <title>The underlying implementation of pointers and references in C&#43;&#43;</title>
      <link>https://www.sobyte.net/post/2022-02/cpp-pointers-references/</link>
      <pubDate>Wed, 09 Feb 2022 13:09:45 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2022-02/cpp-pointers-references/</guid>
      <description>References are an important feature introduced in C++ as opposed to C. They make the syntax much more concise in many places, but how are they actually implemented underneath? In Wikipedia, pointers are described as follows. In computer science, a pointer is a programming language object that stores the memory address of another value located in computer memory. A pointer references a location in memory, and obtaining the value stored</description>
    </item>
    
    <item>
      <title>High Performance C&#43;&#43; HTTP Client Principles and Implementation</title>
      <link>https://www.sobyte.net/post/2022-01/cpp-http-client/</link>
      <pubDate>Thu, 13 Jan 2022 15:05:23 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2022-01/cpp-http-client/</guid>
      <description>1. What is Http Client The Http protocol, a common language across the Internet, and the Http Client, arguably the most basic method we need to get data from the Internet world, is essentially a URL to a webpage conversion process. And with the basic Http Client functionality, paired with the rules and policies we want, everything from content retrieval down to data analysis can be implemented.
Today we&amp;rsquo;re giving you a high-performance Http client in C++, and it&amp;rsquo;s easy!</description>
    </item>
    
    <item>
      <title>Basic usage of std::thread in C&#43;&#43;</title>
      <link>https://www.sobyte.net/post/2022-01/cpp-threads-usage/</link>
      <pubDate>Tue, 04 Jan 2022 17:15:15 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2022-01/cpp-threads-usage/</guid>
      <description>C++11 introduces std::thread to make it easier to create and manage multiple threads, and this note briefly documents my learning process. This note is a brief record of my learning process, including the management of thread creation and related usage in classes. requirement In order to use std::thread we need to add &amp;lt;thread&amp;gt; as a header file, and if we use cmake for project compilation management, we need to add</description>
    </item>
    
    <item>
      <title>How to build a c/c&#43;&#43; development environment in Linux/MacOS using vscode</title>
      <link>https://www.sobyte.net/post/2022-01/how-to-build-a-c-c-development-environment-using-vscode-on-linux-macos/</link>
      <pubDate>Sat, 01 Jan 2022 17:02:53 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2022-01/how-to-build-a-c-c-development-environment-using-vscode-on-linux-macos/</guid>
      <description>Whether you&amp;rsquo;re a fan of the Lord of the Rings movies or not, you&amp;rsquo;ll agree that almost everyone loves unity, and having a unified development experience is something that developers have always strived for and welcomed.
Development environments have long been tightly coupled with specific technologies, such as Visual Studio, for primarily .NET-based development. We&amp;rsquo;ve seen heated debates among developers who endlessly argue for one tool over another. This will never end, nor should it, because many times these arguments result in the awesome tools we are using today.</description>
    </item>
    
    <item>
      <title>Type conversion in C&#43;&#43;</title>
      <link>https://www.sobyte.net/post/2021-12/cpp-type-conversions/</link>
      <pubDate>Fri, 31 Dec 2021 14:36:30 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2021-12/cpp-type-conversions/</guid>
      <description>Introduction This blog is about the four type conversions in C++: static_cast, const_cast, reinterpret_cast, const_cast, their usage and some usage scenarios.
static_cast The reference scenario of static_cast compares conversions, according to CppReference, to perform static type conversions from the expression e to T in the following cases.
Common types  for the expression e can be converted from an implicit type to T If a standard conversion sequence exists for types from T to e, a static type conversion can perform the inverse of that implicit type conversion sequence.</description>
    </item>
    
    <item>
      <title>Basic usage of smart pointers in C&#43;&#43;</title>
      <link>https://www.sobyte.net/post/2021-12/cpp-smart-pointers/</link>
      <pubDate>Fri, 31 Dec 2021 14:09:44 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2021-12/cpp-smart-pointers/</guid>
      <description>Introduction Smart pointers are mainly used to automate the management of resources. There are std::unqiue_ptr, std::shared_ptr and std::weak_ptr according to their usage.
unique_ptr unique_ptr is mainly used to implement exclusive management of a resource object whose life cycle will end at the end of the unique_ptr declaration cycle or when it is pointed to another resource. A resource managed by unique_ptr can be transferred to another unqiue_ptr via std::move.
The following are some simple examples.</description>
    </item>
    
    <item>
      <title>Understand declval and decltype</title>
      <link>https://www.sobyte.net/post/2021-10/cplusplus-std-declval-and-decltype/</link>
      <pubDate>Thu, 21 Oct 2021 22:20:27 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2021-10/cplusplus-std-declval-and-decltype/</guid>
      <description>std::declval and decltype About decltype decltype(expr) is a new keyword added to C++11 to type out entities or expressions.
1 2 3 4 5 6  #include &amp;lt;iostream&amp;gt;int main() { int i = 33; decltype(i) j = i * 2; std::cout &amp;lt;&amp;lt; j; }   It is simple and needs no additional explanation.
But how can something so simple require such a big thing as a new keyword? It&amp;rsquo;s metaprogramming!</description>
    </item>
    
    <item>
      <title>Pipeable Programming in C&#43;&#43;</title>
      <link>https://www.sobyte.net/post/2021-10/cplusplus-pipeable/</link>
      <pubDate>Tue, 05 Oct 2021 16:46:28 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2021-10/cplusplus-pipeable/</guid>
      <description>Pipeable Pipeable is perhaps a rather controversial way of programming C++.
There is pipeable in Boost: pipeable - Boost.HigherOrderFunctions 0.6 documentation - master. It is a part of the hof library
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #include &amp;lt;boost/hof.hpp&amp;gt;#include &amp;lt;cassert&amp;gt;using namespace boost::hof; struct sum { template&amp;lt;class T, class U&amp;gt; T operator()(T x, U y) const { return x+y; } }; int main() { assert(3 == (1 | pipable(sum())(2))); assert(3 == pipable(sum())(1, 2)); }   The HOF library stands for Higher-order functions for C++, and its author Paul Fultz II is also a celebrity.</description>
    </item>
    
    <item>
      <title>Cplusplus 17 Visitor Pattern</title>
      <link>https://www.sobyte.net/post/2021-10/cplusplus-17-visitor-pattern/</link>
      <pubDate>Tue, 05 Oct 2021 16:38:23 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2021-10/cplusplus-17-visitor-pattern/</guid>
      <description>Visitor Pattern The accessor pattern is a behavioral pattern that allows arbitrary detached visitors to be able to access managed elements under the control of the manager. The visitor cannot change the definition of the object (but this is not mandatory, you can agree to allow changes). For the manager, it does not care how many visitors there actually are, it only cares about a defined order of access to the elements (for example, for a binary tree, you can provide multiple access orders such as mid-order, pre-order, etc.</description>
    </item>
    
    <item>
      <title>Observer mode in C&#43;&#43;17</title>
      <link>https://www.sobyte.net/post/2021-10/cplusplus-17-observer-pattern/</link>
      <pubDate>Tue, 05 Oct 2021 16:25:37 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2021-10/cplusplus-17-observer-pattern/</guid>
      <description>Observer Pattern The Observer pattern is a behavioral pattern that is a subscription-publishing mechanism. Objects are able to make announcements, and anyone who has registered observer status with the object will be able to receive notifications when such announcement events occur. Registering an identity means subscribing, and the event occurs means publishing. There can be many observers doing subscriptions, at which point an observer chain is held in the observed</description>
    </item>
    
    <item>
      <title>The Strategy pattern in C&#43;&#43;17</title>
      <link>https://www.sobyte.net/post/2021-10/the-strategy-pattern-in-cplusplus17/</link>
      <pubDate>Mon, 04 Oct 2021 18:24:19 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2021-10/the-strategy-pattern-in-cplusplus17/</guid>
      <description>Strategy Pattern Route planning for two points on a map is a typical strategy mode application scenario. When we do a start to finish route planning, we expect the map to give us the best route for these modes: walking. Public transit, driving. Sometimes it may be subdivided into several strategies such as transit (rail priority), bus (transfer priority), etc.
Standard work Following our construction convention, here is a framework code for path planning</description>
    </item>
    
    <item>
      <title>Sorting using the standard library std::sort function </title>
      <link>https://www.sobyte.net/post/2021-09/cpp-sort/</link>
      <pubDate>Thu, 16 Sep 2021 14:23:29 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2021-09/cpp-sort/</guid>
      <description>The sort method of std accepts two iterators, begin and end, and abstracts access to the elements through the iterators, hiding the internal implementation.
This is a simple example:
1 2 3 4 5 6 7 8 9  std::list&amp;lt;int&amp;gt; list { 0, 4, 2, 1, 3, }; std::sort(list.begin(), list.end());   The result is that the list is sorted, and we don&amp;rsquo;t need to care about what sorting algorithm is used.</description>
    </item>
    
    <item>
      <title>The Pitfalls of Cpp Projects</title>
      <link>https://www.sobyte.net/post/2021-09/the-pitfalls-of-cpp-projects/</link>
      <pubDate>Tue, 14 Sep 2021 16:22:22 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2021-09/the-pitfalls-of-cpp-projects/</guid>
      <description>This article records some of the problems and optimization methods of C++ in these years&#39; projects. It is important to note that there is no one-size-fits-all method for code optimization, and you can only see what you can do, and you have to avoid problems such as premature optimization, code optimization must be done in the middle and late stages, and don&amp;rsquo;t optimize for the sake of optimization. const and</description>
    </item>
    
    <item>
      <title>Intel fully adopts LLVM for its C/C&#43;&#43; compiler</title>
      <link>https://www.sobyte.net/post/2021-08/intel-adoption-of-llvm-complete-icx/</link>
      <pubDate>Wed, 11 Aug 2021 10:07:46 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2021-08/intel-adoption-of-llvm-complete-icx/</guid>
      <description>In a blog post, James Reinders, Intel&amp;rsquo;s long-time compiler expert, revealed that they will be using the LLVM open source infrastructure for the next generation of Intel C/C++ compilers; and shared some information about it.
&amp;ldquo;LLVM helps us achieve our goal of providing the best C/C++ compiler for the Intel architecture. The latest Intel C/C++ compilers use LLVM to provide faster compile times, better optimizations, enhanced standards support, and support for GPU and FPGA offloading &amp;hellip;&amp;hellip; The benefits of using LLVM are many and I will provide recommendations for upgrading from a classic compiler to an LLVM-based compiler.</description>
    </item>
    
    <item>
      <title>Opencv4 C&#43;&#43; Compilation</title>
      <link>https://www.sobyte.net/post/2021-06/opencv4-c&#43;&#43;-compilation/</link>
      <pubDate>Mon, 14 Jun 2021 15:59:20 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2021-06/opencv4-c&#43;&#43;-compilation/</guid>
      <description>1. Download  https://github.com/opencv/opencv/releases https://github.com/opencv/opencv_contrib/releases  Download the two zip packages and unzip them.
2. Cmake 1 2  cd opencv-4.2.0 mkdir build &amp;amp;&amp;amp; cd build   If you are simply using the C++ version of opencv for cpu, you can use the following cmake command
1 2 3 4 5 6 7 8 9 10 11 12 13  cmake -D CMAKE_BUILD_TYPE=RELEASE \ -D CMAKE_INSTALL_PREFIX=/home/test/opt/opencv \ -D WITH_CUDA=OFF \ -D WITH_IPP=OFF \ -D OPENCV_EXTRA_MODULES_PATH=/home/test/opencv/opencv_contrib-4.</description>
    </item>
    
  </channel>
</rss>
