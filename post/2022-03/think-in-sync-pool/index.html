<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Deep analysis of Golang sync.Pool underlying principles - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="In this article, we will explore the underlying implementation of sync.Pool based on go-1.16 source code." /><meta name="keywords" content="golang, sync.Pool" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-03/think-in-sync-pool/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Deep analysis of Golang sync.Pool underlying principles" />
<meta property="og:description" content="In this article, we will explore the underlying implementation of sync.Pool based on go-1.16 source code." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-03/think-in-sync-pool/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-03-23T17:11:40+08:00" />
<meta property="article:modified_time" content="2022-03-23T17:11:40+08:00" />

<meta itemprop="name" content="Deep analysis of Golang sync.Pool underlying principles">
<meta itemprop="description" content="In this article, we will explore the underlying implementation of sync.Pool based on go-1.16 source code."><meta itemprop="datePublished" content="2022-03-23T17:11:40+08:00" />
<meta itemprop="dateModified" content="2022-03-23T17:11:40+08:00" />
<meta itemprop="wordCount" content="2910">
<meta itemprop="keywords" content="golang," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Deep analysis of Golang sync.Pool underlying principles"/>
<meta name="twitter:description" content="In this article, we will explore the underlying implementation of sync.Pool based on go-1.16 source code."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Deep analysis of Golang sync.Pool underlying principles</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-03-23 17:11:40 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 2910 words </span>
          <span class="more-meta"> 6 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#basic-usage">Basic Usage</a></li>
        <li><a href="#the-underlying-implementation-of-syncpool">The underlying implementation of sync.Pool</a>
          <ul>
            <li><a href="#poolchain-implementation">poolChain implementation</a></li>
            <li><a href="#implementation-of-put">Implementation of Put</a></li>
            <li><a href="#implementation-of-get">Implementation of Get</a></li>
            <li><a href="#object-cleanup">Object cleanup</a></li>
            <li><a href="#other-optimizations">Other optimizations</a></li>
            <li><a href="#false-sharing-problem-avoidance">false sharing problem avoidance</a></li>
          </ul>
        </li>
        <li><a href="#how-syncpool-performs">How sync.Pool performs</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>sync.Pool is Golang&rsquo;s built-in object pooling technology, which can be used to cache temporary objects to avoid the consumption and pressure on GC caused by frequent creation of temporary objects.</p>
<p>You can see sync.Pool used extensively in many well-known open source libraries. For example, the HTTP framework Gin uses sync.Pool to reuse the <code>gin.Context</code> object that is created with each request. sync.Pool can also be found in grpc-Go, kubernates, and others.</p>
<p>Note, however, that sync.Pool cached objects can be cleared without notice at any time, so sync.Pool should not be used in scenarios where persistent objects are stored.</p>
<p>The sync.Pool is the official library built into goroutine and is very well designed. sync.Pool is not only concurrency-safe, but also lock free, and there is a lot to learn about it.</p>
<p>This article will explore the underlying implementation of sync.Pool based on the <a href="https://github.com/golang/go/blob/release-branch.go1.16/src/sync/pool.go">go-1.16 source code</a>.</p>
<h2 id="basic-usage">Basic Usage</h2>
<p>Before we talk about the underlying sync.Pool, let&rsquo;s take a look at the basic usage of sync.Pool. The sample code is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Test</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">A</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">pool</span> <span class="o">:=</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Pool</span><span class="p">{</span>
		<span class="nx">New</span><span class="p">:</span> <span class="kd">func</span><span class="p">()</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
			<span class="k">return</span> <span class="o">&amp;</span><span class="nx">Test</span><span class="p">{</span>
				<span class="nx">A</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
			<span class="p">}</span>
		<span class="p">},</span>
	<span class="p">}</span>

	<span class="nx">testObject</span> <span class="o">:=</span> <span class="nx">pool</span><span class="p">.</span><span class="nf">Get</span><span class="p">().(</span><span class="o">*</span><span class="nx">Test</span><span class="p">)</span>
	<span class="nb">println</span><span class="p">(</span><span class="nx">testObject</span><span class="p">.</span><span class="nx">A</span><span class="p">)</span> <span class="c1">// print 1
</span><span class="c1"></span>
	<span class="nx">pool</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="nx">testObject</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>When sync.Pool is initialized, it requires the user to provide a constructor <code>New</code> for the object. The user uses <code>Get</code> to get the object from the object pool and <code>Put</code> to return the object to the object pool. The entire usage is relatively simple.</p>
<p>Next, let&rsquo;s take a closer look at how sync.Pool is implemented.</p>
<h2 id="the-underlying-implementation-of-syncpool">The underlying implementation of sync.Pool</h2>
<p>Before we talk about sync.Pool, let&rsquo;s talk about Golang&rsquo;s GMP scheduling. In the GMP scheduling model, M represents the system threads, and only one P can be running on an M at the same time, which means that the logic on P is single-threaded from the thread dimension.</p>
<p>sync.Pool takes advantage of this feature of GMP. For the same sync.Pool, each P has its own local object pool <code>poolLocal</code>. This is shown in the figure below.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/23/7cdc15463dde46878a8fa4aaf39e87bb.png" alt="golang sync.Pool"></p>
<p>The code for sync.Pool is defined as follows <a href="https://github.com/golang/go/blob/release-branch.go1.16/src/sync/pool.go#L44">sync/pool.go#L44</a>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Pool</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">noCopy</span> <span class="nx">noCopy</span>

	<span class="nx">local</span>     <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// local fixed-size per-P pool, actual type is [P]poolLocal
</span><span class="c1"></span>	<span class="nx">localSize</span> <span class="kt">uintptr</span>        <span class="c1">// size of the local array
</span><span class="c1"></span>
	<span class="nx">victim</span>     <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// local from previous cycle
</span><span class="c1"></span>	<span class="nx">victimSize</span> <span class="kt">uintptr</span>        <span class="c1">// size of victims array
</span><span class="c1"></span>
	<span class="nx">New</span> <span class="kd">func</span><span class="p">()</span> <span class="kd">interface</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Among them, we need to focus on the following three fields.</p>
<ul>
<li><code>local</code> is an array with the length of the number of P&rsquo;s. Its element type is <code>poolLocal</code>. This stores the local pool of objects corresponding to each P. It can be approximated as <code>[P]poolLocal</code>.</li>
<li><code>localSize</code>. represents the length of the local array. Since P can be modified at runtime by calling runtime.GOMAXPROCS, we still have to use <code>localSize</code> to correspond to the length of the <code>local</code> array.</li>
<li><code>New</code> is the user-supplied function that creates the object. This option is also not required. Get may return nil when it is not filled in.</li>
</ul>
<p>A few other fields that we don&rsquo;t need to care too much about for now, here&rsquo;s a quick overview.</p>
<ul>
<li><code>victim</code> and <code>victimSize</code>. This pair of variables represents the pool of objects before the last round of cleanup, with the same semantics local and localSize. victim is described in more detail below.</li>
<li><code>noCopy</code> is a detection method in the Golang source code that disables copying. A copy of a sync.Pool can be detected with the <code>go vet</code> command.</li>
</ul>
<p>Since each P has its own poolLocal, Get and Put operations give priority to accessing the pool. Due to the nature of P, the whole concurrency problem is much simpler when manipulating local object pools, and concurrency conflicts can be avoided as much as possible.</p>
<p>Let&rsquo;s look at the definition of the local object pool <code>poolLocal</code>, as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 每个 P 都会有一个 poolLocal 的本地
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">poolLocal</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">poolLocalInternal</span>

	<span class="nx">pad</span> <span class="p">[</span><span class="mi">128</span> <span class="o">-</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">poolLocalInternal</span><span class="p">{})</span><span class="o">%</span><span class="mi">128</span><span class="p">]</span><span class="kt">byte</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">poolLocalInternal</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">private</span> <span class="kd">interface</span><span class="p">{}</span>
	<span class="nx">shared</span>  <span class="nx">poolChain</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The role of the <code>pad</code> variable is covered below and will not be discussed here for now. We can look directly at the definition of poolLocalInternal, where each local object pool contains two items: * <code>private</code> private variables.</p>
<ul>
<li><code>private</code> private variables; Get and Put operations give priority to accessing private variables, and do not go deeper than that if the private variables can satisfy the situation.</li>
<li><code>shared</code>. The type is poolChain, and it is easy to see from the name that this is a linked table structure, and this is the local object pool of P.</li>
</ul>
<h3 id="poolchain-implementation">poolChain implementation</h3>
<p>The entire storage structure of poolChain is shown in the following figure.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/23/d9f0d9f043974878ad4010feec5b6ae5.png" alt="golang poolChain"></p>
<p>As you can probably guess from the name, a poolChain is a linkedlist structure with the head HEAD pointing to the most recently allocated element item. Each item in the chain is a poolDequeue object. poolDequeue is essentially a ring buffer structure. The corresponding code is defined as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">poolChain</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">head</span> <span class="o">*</span><span class="nx">poolChainElt</span>
	<span class="nx">tail</span> <span class="o">*</span><span class="nx">poolChainElt</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">poolChainElt</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">poolDequeue</span>
	<span class="nx">next</span><span class="p">,</span> <span class="nx">prev</span> <span class="o">*</span><span class="nx">poolChainElt</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">poolDequeue</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">headTail</span> <span class="kt">uint64</span>
	<span class="nx">vals</span> <span class="p">[]</span><span class="nx">eface</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Why is poolChain such a complex structure of a linkedlist + ring buffer? Can&rsquo;t we simply have a single element for each link table item?</p>
<p>The ring buffer is used because it has the following advantages.</p>
<ul>
<li>The memory is pre-allocated and the allocated memory items can be reused over and over again.</li>
<li>Since ring buffer is essentially an array, it is a contiguous memory structure, which is very convenient for CPU Cache. when accessing an item of poolDequeue, all the data items in its vicinity may be loaded into the unified Cache Line, making access faster.</li>
</ul>
<p>These two features of the ring buffer are ideal for the sync.</p>
<p>As a ring buffer, poolDequeue naturally needs to record the values of its head and tail. However, in the definition of poolDequeue, head and tail are not separate variables, but only a uint64 headTail variable.</p>
<p>This is because the headTail variable wraps the head and tail together: the high 32 bits are the head variable and the low 32 bits are the tail variable. This is shown in the following figure.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/23/5a57c8e1c1bf461991b3db267c6c4ae7.png" alt="linkedlist"></p>
<p>Why this complex packing operation? This is actually a very common lock free optimization.</p>
<p>For a poolDequeue, it may be accessed by more than one P at the same time (see the object-stealing logic in the Get function below), which can cause concurrency problems.</p>
<p>For example, when there is only one ring buffer space left, i.e. <code>head - tail = 1</code>. If multiple P&rsquo;s access the ring buffer at the same time, without any concurrency measures, both P&rsquo;s may get the object, which is definitely not expected.</p>
<p>How does sync.Pool achieve this without introducing Mutex locks? sync.Pool makes use of the CAS operation in the atomic package. Both P&rsquo;s may get the object, but when the headTail is finally set, only one P will call CAS successfully and the other CAS will fail.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapUint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">d</span><span class="p">.</span><span class="nx">headTail</span><span class="p">,</span> <span class="nx">ptrs</span><span class="p">,</span> <span class="nx">ptrs2</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>When updating head and tail, the operation is also performed with atomic variables + bitwise operations. For example, when implementing <code>head++</code>, the following code is needed.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="nx">dequeueBits</span> <span class="p">=</span> <span class="mi">32</span>

<span class="nx">atomic</span><span class="p">.</span><span class="nf">AddUint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">d</span><span class="p">.</span><span class="nx">headTail</span><span class="p">,</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nx">dequeueBits</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="implementation-of-put">Implementation of Put</h3>
<p>Let&rsquo;s look at the implementation of the Put function. The Put function allows us to put unused objects back or forward into the sync.Pool.The code logic of the Put function is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Pool</span><span class="p">)</span> <span class="nf">Put</span><span class="p">(</span><span class="nx">x</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">x</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">l</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">pin</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">l</span><span class="p">.</span><span class="nx">private</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">l</span><span class="p">.</span><span class="nx">private</span> <span class="p">=</span> <span class="nx">x</span>
		<span class="nx">x</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">x</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">l</span><span class="p">.</span><span class="nx">shared</span><span class="p">.</span><span class="nf">pushHead</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nf">runtime_procUnpin</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>As you can see from the above code, <code>pin()</code> is called first in the Put function. The <code>pin</code> function is very important, it has three functions.</p>
<ul>
<li>
<p><strong>Initialize or recreate the local array.</strong> When the local array is empty, or does not match the current <code>runtime.GOMAXPROCS</code>, it triggers a re-creation of the local array to match the number of P&rsquo;s. ** When the local array is empty, or does not match the current `runtime.</p>
</li>
<li>
<p>The logic of the code is very simple: it takes the elements from the local array based on the index. The logic of this paragraph is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">indexLocal</span><span class="p">(</span><span class="nx">l</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">poolLocal</span> <span class="p">{</span>
    <span class="nx">lp</span> <span class="o">:=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">l</span><span class="p">)</span> <span class="o">+</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">poolLocal</span><span class="p">{}))</span>
    <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="nx">poolLocal</span><span class="p">)(</span><span class="nx">lp</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>Prevents the current P from being preempted.</strong> This is very important. Since Go 1.14, Golang has implemented preemptive scheduling: a goroutine will be forced to hang by the scheduler if it occupies P for too long. If a goroutine is hung during a Put or Get, it is possible that the next time it is restored, the binding will not be the same P as the last one. Then the whole process will be completely messed up. Therefore, procPin from the runtime package is used here to temporarily disallow P to be preempted.</p>
</li>
</ul>
<p>Next, the Put function will set the current poolLocal private variable <code>private</code> as a preference. If the private variable is set successfully, then it will not write to the shared cache pool. This makes the operation more efficient.</p>
<p>If the private variable has already been set, then it will only write to the poolChain of the current P&rsquo;s local cache pool. Next, let&rsquo;s see how the internal cache poolChain of each P of sync.Pool is implemented.</p>
<p>When putting, it will directly fetch the head element of the poolChain&rsquo;s chain, HEAD.</p>
<ul>
<li>If HEAD does not exist, a new poolDequeue with buffer length 8 is created and the object is placed in it.</li>
<li>If HEAD exists and the buffer is not full, the element will be placed in the poolDequeue directly.</li>
<li>If the HEAD exists but the buffer is full, create a new poolDequeue with 2 times the length of the previous HEAD. At the same time, the HEAD of the poolChain is pointed to the new element.</li>
</ul>
<p>The process of Put is relatively simple, the whole process does not need to interact with other P&rsquo;s poolLocal.</p>
<h3 id="implementation-of-get">Implementation of Get</h3>
<p>After understanding how Put is implemented, let&rsquo;s move on to the Get implementation. The Get operation allows you to get an object from a sync.Pool.</p>
<p>Compared to the Put function, the Get implementation is more complex. Not only does it involve manipulating the local object pool of the current P, but it also involves stealing objects from the local object pools of other P&rsquo;s. The code logic is as follows. The code logic is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Pool</span><span class="p">)</span> <span class="nf">Get</span><span class="p">()</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
	<span class="nx">l</span><span class="p">,</span> <span class="nx">pid</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">pin</span><span class="p">()</span>

	<span class="nx">x</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">private</span>
	<span class="nx">l</span><span class="p">.</span><span class="nx">private</span> <span class="p">=</span> <span class="kc">nil</span>

	<span class="k">if</span> <span class="nx">x</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">x</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">shared</span><span class="p">.</span><span class="nf">popHead</span><span class="p">()</span>

		<span class="k">if</span> <span class="nx">x</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">x</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">getSlow</span><span class="p">(</span><span class="nx">pid</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nf">runtime_procUnpin</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">x</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">p</span><span class="p">.</span><span class="nx">New</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">x</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">x</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The role of <code>pin()</code> and the role of the <code>private</code> object are the same as in the PUT operation, so we won&rsquo;t go over them here. Let&rsquo;s focus on the rest of the logic.</p>
<p>First, the Get function tries to fetch an object from the poolChain of the current P&rsquo;s local object pool. <strong>When fetching data from the current P&rsquo;s poolChain, the data is fetched from the head of the chain.</strong> Specifically, the poolDequeue at the head of the chain is fetched first, and then the data is fetched from the head of the poolDequeue.</p>
<p>If no data is fetched from the current P&rsquo;s poolChain, it means that the current P&rsquo;s cache pool is empty, so it will try to <strong>steal objects</strong> from other P&rsquo;s cache pools. This also corresponds to the internal implementation of the getSlow function.</p>
<p>In the getSlow function, the index value of the current P is incremented to try to fetch data from the poolChain of other P&rsquo;s one by one. Note that when trying to fetch data from other P&rsquo;s poolChain, it starts at the end of the chain.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span><span class="nb">int</span><span class="p">(</span><span class="nx">size</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
	<span class="nx">l</span> <span class="o">:=</span> <span class="nf">indexLocal</span><span class="p">(</span><span class="nx">locals</span><span class="p">,</span> <span class="p">(</span><span class="nx">pid</span><span class="o">+</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="nb">int</span><span class="p">(</span><span class="nx">size</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">shared</span><span class="p">.</span><span class="nf">popTail</span><span class="p">();</span> <span class="nx">x</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">x</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>When popTail is called on the poolChain of other P, the poolDequeue at the end of the chain is fetched first, and then the data is fetched from the end of the poolDequeue. If no data is fetched from this poolDequeue, it means that the poolDequeue is empty, and the poolDequeue is removed from the poolChain directly, and the next poolDequeue is tried.</p>
<p>If the data is not fetched from the local object pool of other P, it is also not fetched. Next, it tries to fetch data from victim. As mentioned above, victim is a pool of objects that was cleaned in the previous round, and fetching objects from victim is the same way as popTail.</p>
<p>Finally, if all the cache pools are out of data, the user-set <code>New</code> function is called to create a new object.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/23/f95f3388cb994d8ea797f76bc55a3dd8.png" alt="poolDequeue"></p>
<p>sync.Pool is designed to start from the head when manipulating the local poolChain, either push or pop. And when fetching data from other P&rsquo;s poolChain, only the tail popTail can be fetched. This minimizes concurrency conflicts.</p>
<h3 id="object-cleanup">Object cleanup</h3>
<p>sync.Pool does not have an object cleanup policy or cleanup interface open to the public. As we mentioned above, when stealing objects from other P&rsquo;s, the empty poolDequeue will be phased out, but in addition, the sync.Pool must also have other object cleanup mechanisms, otherwise the object pool will probably expand indefinitely and cause memory leaks.</p>
<p>Golang&rsquo;s cleanup logic for sync.Pool is very simple and brutal. Golang&rsquo;s runtime will trigger a call to poolCleanup to clean up allPools <strong>before each round of GC</strong>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">poolCleanup</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">oldPools</span> <span class="p">{</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">victim</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">victimSize</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allPools</span> <span class="p">{</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">victim</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">local</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">victimSize</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">localSize</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">local</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="nx">p</span><span class="p">.</span><span class="nx">localSize</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>

	<span class="nx">oldPools</span><span class="p">,</span> <span class="nx">allPools</span> <span class="p">=</span> <span class="nx">allPools</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Here we need to formally introduce the victim mechanism of the sync.Pool, which is also mentioned in the object-stealing logic of the Get function.</p>
<p>In each round of sync.Pool cleanup, the pool of objects is not completely cleaned up for the time being, but is placed in the victim. In other words, after each round of GC, the object pool of sync.Pool is transferred to victim, and the victim of the previous round is emptied out.</p>
<p>Why is this done?
This is because Golang wants to prevent the sync.Pool from being suddenly emptied after a GC, which would affect the performance of the program. So we use victim as a transition first, and if we can&rsquo;t get the data in the current round of object pool, we can also get it from victim, so that the program performance will be smoother.</p>
<p>The victim mechanism was first used in CPU Cache, you can read this wiki: <a href="https://en.wikipedia.org/wiki/Victim_cache">Victim_cache</a> for more details.</p>
<h3 id="other-optimizations">Other optimizations</h3>
<h3 id="false-sharing-problem-avoidance">false sharing problem avoidance</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">poolLocal</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">poolLocalInternal</span>

	<span class="c1">// Prevents false sharing on widespread platforms with
</span><span class="c1"></span>	<span class="c1">// 128 mod (cache line size) = 0 .
</span><span class="c1"></span>	<span class="nx">pad</span> <span class="p">[</span><span class="mi">128</span> <span class="o">-</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">poolLocalInternal</span><span class="p">{})</span><span class="o">%</span><span class="mi">128</span><span class="p">]</span><span class="kt">byte</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>When we talk about poolLocal above, we find this strange structure: poolLocal has a pad attribute, and from the way this attribute is defined, it is clearly designed to round up to an integer multiple of 128 Byte. Why is this done?</p>
<p>Here it is to avoid the <strong>false sharing</strong> problem with CPU Cache: CPU Cache Lines are usually in 64 byte or 128 byte units. In our scenario, the poolLocal of each P is in the form of an array. If the CPU Cache Line is 128 byte and the poolLocal is less than 128 byte, the cacheline will take the memory data of other P&rsquo;s poolLocal to make up a whole Cache Line. If two adjacent P&rsquo;s are running on two different CPU cores at the same time, they will overwrite the CacheLine and cause the Cacheline to fail repeatedly, and the CPU Cache will be useless.</p>
<p>CPU Cache is the closest cache to the CPU, and if it is used well, it will greatly improve the performance of the program. Golang uses the pad method to prevent false sharing, so that the CacheLine is not shared with other P&rsquo;s poolLocal.</p>
<h2 id="how-syncpool-performs">How sync.Pool performs</h2>
<p>To recap, sync.Pool maximizes performance by.</p>
<ul>
<li>Using the GMP feature to create a local object pool poolLocal for each P to minimize concurrency conflicts.</li>
<li>Each poolLocal has a private object, and access to private objects is prioritized to avoid complex logic.</li>
<li>Use <code>pin</code> to lock the current P during Get and Put to prevent goroutine from being preempted and causing program chaos.</li>
<li>Use object stealing mechanism to fetch objects from other P&rsquo;s local object pool and victim during Get.</li>
<li>Make full use of CPU Cache feature to improve program performance.</li>
</ul>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/golang/">golang</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-03/0777-or-777/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Should I use 777 or 0777 for os.Chmod?</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-03/web-components/">
            <span class="next-text nav-default">A First Look at Web Components</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
