<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>TypeScript generic development practices from a set perspective - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Some time ago I drilled into How to master advanced TypeScript patterns this article. This is an earlier blog post by Pierre-Antoine Mills, author of ts-toolbelt. The article raises a challenging topic: How can TS write type support for collinear functions? I did some practice with the original article, and then seemed to come to some knowledge about TS generics closer to the substance &amp;ndash; from the collection perspective. Based" /><meta name="keywords" content="typescript, Generic" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-03/typescript-generic-perspect-of-set-thoery/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="TypeScript generic development practices from a set perspective" />
<meta property="og:description" content="Some time ago I drilled into How to master advanced TypeScript patterns this article. This is an earlier blog post by Pierre-Antoine Mills, author of ts-toolbelt. The article raises a challenging topic: How can TS write type support for collinear functions? I did some practice with the original article, and then seemed to come to some knowledge about TS generics closer to the substance &ndash; from the collection perspective. Based" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-03/typescript-generic-perspect-of-set-thoery/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-03-07T15:54:26+08:00" />
<meta property="article:modified_time" content="2022-03-07T15:54:26+08:00" />

<meta itemprop="name" content="TypeScript generic development practices from a set perspective">
<meta itemprop="description" content="Some time ago I drilled into How to master advanced TypeScript patterns this article. This is an earlier blog post by Pierre-Antoine Mills, author of ts-toolbelt. The article raises a challenging topic: How can TS write type support for collinear functions? I did some practice with the original article, and then seemed to come to some knowledge about TS generics closer to the substance &ndash; from the collection perspective. Based"><meta itemprop="datePublished" content="2022-03-07T15:54:26+08:00" />
<meta itemprop="dateModified" content="2022-03-07T15:54:26+08:00" />
<meta itemprop="wordCount" content="5973">
<meta itemprop="keywords" content="typescript," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="TypeScript generic development practices from a set perspective"/>
<meta name="twitter:description" content="Some time ago I drilled into How to master advanced TypeScript patterns this article. This is an earlier blog post by Pierre-Antoine Mills, author of ts-toolbelt. The article raises a challenging topic: How can TS write type support for collinear functions? I did some practice with the original article, and then seemed to come to some knowledge about TS generics closer to the substance &ndash; from the collection perspective. Based"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">TypeScript generic development practices from a set perspective</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-03-07 15:54:26 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 5973 words </span>
          <span class="more-meta"> 12 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#propositions">Propositions</a></li>
        <li><a href="#curriedv1-the-simplest-currying">CurriedV1: The simplest currying</a></li>
        <li><a href="#generic-length">Generic <code>Length</code></a></li>
        <li><a href="#javascript-a-priori-knowledge">JavaScript: a priori knowledge</a></li>
        <li><a href="#generic-head">Generic <code>Head</code></a></li>
        <li><a href="#generic-tail">Generic <code>Tail</code></a></li>
        <li><a href="#types-of-conversion-functions">Types of conversion functions</a></li>
        <li><a href="#generic-type-curriedv1">Generic type <code>CurriedV1</code></a></li>
        <li><a href="#curriedv2-allowing-indefinite-arguments">CurriedV2: Allowing Indefinite Arguments</a></li>
        <li><a href="#generic-prepend">Generic <code>Prepend</code></a></li>
        <li><a href="#the-generic-type-drop">The generic type <code>Drop</code></a></li>
        <li><a href="#the-generic-partialtuple">The generic <code>PartialTuple</code></a></li>
        <li><a href="#pan-type-curriedv2">Pan type <code>CurriedV2</code></a></li>
        <li><a href="#curriedv3-support-for-remaining-arguments">CurriedV3: support for remaining arguments</a></li>
        <li><a href="#curriedv4-placeholder-support">CurriedV4: Placeholder support</a></li>
        <li><a href="#generic-equal">Generic <code>Equal</code></a></li>
        <li><a href="#generic-item">Generic <code>Item</code></a></li>
        <li><a href="#the-generic-placeholdertuple">The generic <code>PlaceholderTuple</code></a></li>
        <li><a href="#generic-reverse">Generic <code>Reverse</code></a></li>
        <li><a href="#generic-join">Generic <code>Join</code></a></li>
        <li><a href="#generic-concat">Generic <code>Concat</code></a></li>
        <li><a href="#generic-placeholdermatched">Generic <code>PlaceholderMatched</code></a></li>
        <li><a href="#the-generic-type-curriedv4">The generic type <code>CurriedV4</code></a></li>
        <li><a href="#summary">Summary</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>Some time ago I drilled into <a href="https://www.freecodecamp.org/news/typescript-curry-ramda-types-f747e99744ab/">How to master advanced TypeScript patterns</a> this article. This is an earlier blog post by <a href="https://github.com/millsp">Pierre-Antoine Mills</a>, author of <a href="https://github.com/millsp/ts-toolbelt">ts-toolbelt</a>. The article raises a challenging topic: <strong>How can TS write type support for collinear functions?</strong></p>
<p>I did some practice with the original article, and then seemed to come to some knowledge about TS generics <strong>closer to the substance</strong> &ndash; from the collection perspective. Based on this knowledge, I found that most of the generalizations in the original article are written in a much tighter way. I thought this practice and thought process was worth documenting, hence this paper.</p>
<p>As with the original article, this article does not expand on the issues of currying or functional programming; currying is just <strong>material</strong> for discussing TS generic development. The clue to this article is the role of each generic type in my complete implementation, but that&rsquo;s not the point, the point is the insight behind it &ndash; in the first half of the article, I often discuss a simple generic type at length, so please don&rsquo;t skip it.</p>
<h2 id="propositions">Propositions</h2>
<p>Collocalization is an important concept in the field of functional programming, and represents the process of converting a multi-argument function into a function that &ldquo;takes one argument at a time&rdquo;, such as converting <code>f(a,b,c)</code> to <code>f(a)(b)(c)</code>. To give a more detailed example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="c1">// toCurry 函数为待柯里化的普通函数
</span><span class="c1"></span><span class="kr">declare</span> <span class="kr">const</span> <span class="nx">toCurry</span><span class="o">:</span> <span class="p">(</span><span class="nx">a1</span>: <span class="kt">1</span><span class="p">,</span> <span class="nx">a2</span>: <span class="kt">2</span><span class="p">,</span> <span class="nx">a3</span>: <span class="kt">3</span><span class="p">,</span> <span class="nx">a4</span>: <span class="kt">4</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">// curry 是柯里化转换函数，接收普通函数 toCurry，返回转换后的函数（先用 unknown 类型表示）
</span><span class="c1"></span><span class="kr">declare</span> <span class="kr">const</span> <span class="nx">curry</span><span class="o">:</span> <span class="p">(</span><span class="nx">toCurry</span>: <span class="kt">Function</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">unknown</span><span class="p">;</span>

<span class="c1">// curried 是柯里化转换后的函数，调用者按次序每次传入一个参数，所有参数传入后，得到最终的返回值
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">curried</span> <span class="o">=</span> <span class="nx">curry</span><span class="p">(</span><span class="nx">toCurry</span><span class="p">);</span>
<span class="nx">curried</span><span class="p">(</span><span class="mi">1</span><span class="p">)(</span><span class="mi">2</span><span class="p">)(</span><span class="mi">3</span><span class="p">)(</span><span class="mi">4</span><span class="p">);</span>            <span class="c1">// =&gt; 0
</span></code></pre></td></tr></table>
</div>
</div><p>In its simplest form, the Currier can take only one argument at a time.</p>
<p>For advanced kriging, an indefinite number of parameters can be taken at a time.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="c1">// 调用 curried 一次传入多个参数
</span><span class="c1"></span><span class="nx">curried</span><span class="p">(</span><span class="mi">1</span><span class="p">)(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)(</span><span class="mi">4</span><span class="p">);</span>             <span class="c1">// =&gt; 0
</span></code></pre></td></tr></table>
</div>
</div><p>Even residual parameters and placeholders can be supported.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="c1">// toCurry 中包含剩余参数
</span><span class="c1"></span><span class="kr">declare</span> <span class="kr">const</span> <span class="nx">toCurry</span><span class="o">:</span> <span class="p">(</span><span class="nx">a1</span>: <span class="kt">1</span><span class="p">,</span> <span class="nx">a2</span>: <span class="kt">2</span><span class="p">,</span> <span class="nx">a3</span>: <span class="kt">3</span><span class="p">,</span> <span class="nx">a4</span>: <span class="kt">4</span><span class="p">,</span> <span class="p">...</span><span class="nx">args</span>: <span class="kt">5</span><span class="p">[])</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">curried</span> <span class="o">=</span> <span class="nx">curry</span><span class="p">(</span><span class="nx">toCurry</span><span class="p">);</span>

<span class="c1">// 调用 curried 时也可以传入剩余参数
</span><span class="c1"></span><span class="nx">curried</span><span class="p">(</span><span class="mi">1</span><span class="p">)(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>    <span class="c1">// =&gt; 0
</span><span class="c1"></span>
<span class="c1">// 调用 curried 时通过传入占位符把参数 2 移到了 3 之后
</span><span class="c1"></span><span class="nx">curried</span><span class="p">(</span><span class="mi">1</span><span class="p">)(</span><span class="nx">__</span><span class="p">,</span> <span class="mi">3</span><span class="p">)(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>     <span class="c1">// =&gt; 0
</span></code></pre></td></tr></table>
</div>
</div><p>The curried conversion function <code>curry</code> is the core of currying. The conversion function takes a normal function <code>toCurry</code> - temporarily denoted by the type <code>Function</code> - and returns the curried function <code>curried</code> (later also called <strong>curried function</strong> or <strong>curried function</strong>) - temporarily denoted by the type <code>unknown</code>. - temporarily represented by the type <code>unknown</code>. How to write a legal type expression for it is the main thread of this article.</p>
<h2 id="curriedv1-the-simplest-currying">CurriedV1: The simplest currying</h2>
<p>The simplest, one-argument-at-a-time currying is implemented by me as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">type</span> <span class="nx">Length</span><span class="p">&lt;</span><span class="nt">T</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[]</span><span class="p">&gt;</span> <span class="o">=</span> <span class="nx">T</span><span class="p">[</span><span class="s1">&#39;length&#39;</span><span class="p">];</span>

<span class="kr">type</span> <span class="nx">Head</span><span class="p">&lt;</span><span class="nt">T</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[]</span><span class="p">&gt;</span> <span class="o">=</span> <span class="nx">T</span> <span class="kr">extends</span> <span class="p">[]</span> <span class="o">?</span> <span class="kt">never</span> <span class="o">:</span> <span class="nx">T</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

<span class="kr">type</span> <span class="nx">Tail</span><span class="p">&lt;</span><span class="nt">T</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[]</span><span class="p">&gt;</span> <span class="o">=</span> <span class="nx">T</span> <span class="kr">extends</span> <span class="p">[]</span> <span class="o">?</span> <span class="kt">never</span> <span class="o">:</span> <span class="nx">T</span> <span class="kr">extends</span> <span class="p">[</span><span class="kt">unknown</span><span class="p">,</span> <span class="p">...</span><span class="k">infer</span> <span class="nx">R</span><span class="p">]</span> <span class="o">?</span> <span class="nx">R</span> : <span class="kt">T</span><span class="p">;</span>

<span class="kr">type</span> <span class="nx">CurriedV1</span><span class="p">&lt;</span><span class="nt">P</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[],</span> <span class="na">R</span><span class="p">&gt;</span> <span class="o">=</span> <span class="nx">P</span> <span class="kr">extends</span> <span class="p">[]</span> <span class="o">?</span> <span class="nx">R</span> <span class="o">:</span> <span class="p">(</span><span class="nx">arg</span>: <span class="kt">Head</span><span class="p">&lt;</span><span class="nt">P</span><span class="p">&gt;)</span> <span class="o">=&gt;</span> <span class="nx">CurriedV1</span><span class="p">&lt;</span><span class="nt">Tail</span><span class="err">&lt;</span><span class="na">P</span><span class="p">&gt;,</span> <span class="nx">R</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kr">type</span> <span class="nx">Curry</span> <span class="o">=</span> <span class="p">&lt;</span><span class="nt">P</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[],</span> <span class="na">R</span><span class="p">&gt;(</span><span class="nx">fn</span><span class="o">:</span> <span class="p">(...</span><span class="nx">args</span>: <span class="kt">P</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">R</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">CurriedV1</span><span class="p">&lt;</span><span class="nt">P</span><span class="err">,</span> <span class="na">R</span><span class="p">&gt;;</span>

<span class="kr">declare</span> <span class="kr">const</span> <span class="nx">curry</span>: <span class="kt">Curry</span><span class="p">;</span>
<span class="kr">declare</span> <span class="kr">const</span> <span class="nx">toCurry</span><span class="o">:</span> <span class="p">(</span><span class="nx">a1</span>: <span class="kt">1</span><span class="p">,</span> <span class="nx">a2</span>: <span class="kt">2</span><span class="p">,</span> <span class="nx">a3</span>: <span class="kt">3</span><span class="p">,</span> <span class="nx">a4</span>: <span class="kt">4</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="p">;</span>

<span class="kr">const</span> <span class="nx">curried</span> <span class="o">=</span> <span class="nx">curry</span><span class="p">(</span><span class="nx">toCurry</span><span class="p">);</span>
<span class="nx">curried</span><span class="p">(</span><span class="mi">1</span><span class="p">)(</span><span class="mi">2</span><span class="p">)(</span><span class="mi">3</span><span class="p">)(</span><span class="mi">4</span><span class="p">);</span> <span class="c1">// =&gt; 0
</span></code></pre></td></tr></table>
</div>
</div><h2 id="generic-length">Generic <code>Length</code></h2>
<p>The first generic <code>Length</code> returns the length of a tuple.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">type</span> <span class="nx">Length</span><span class="p">&lt;</span><span class="nt">T</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[]</span><span class="p">&gt;</span> <span class="o">=</span> <span class="nx">T</span><span class="p">[</span><span class="s1">&#39;length&#39;</span><span class="p">];</span>
</code></pre></td></tr></table>
</div>
</div><p>The first thing to understand is that a <strong>type is a collection of objects</strong> . For example, the type <code>number</code> is the set of all numbers, the type <code>1</code> represents a single set of elements consisting of the value <code>1</code>, and the type <code>string[]</code> is the set of all &ldquo;arrays where every item is a string&rdquo;.</p>
<p>A <strong>generic</strong>, formally, is a function of a type (converting one type to another); from a collection perspective, it is a <strong>map of a collection</strong> (changing one collection to another).</p>
<p>The mapping of a set must be based on rules that act on the elements within the set. Suppose there are sets A and B. We can say that there is a mapping relationship between A and B only if any element in A, according to some rule, can be transformed into an element in B.</p>
<blockquote>
<p>Since mapping can only be done from <strong>one</strong> set to another, how can we understand the case of multiple generic arguments? Answer: Think of multiple generic parameters as a tuple type.</p>
</blockquote>
<p>Take <code>Length</code> as an example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">type</span> <span class="nx">Length_Test1</span> <span class="o">=</span> <span class="nx">Length</span><span class="o">&lt;</span><span class="p">[</span><span class="kt">unknown</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>          <span class="c1">// =&gt; 1
</span><span class="c1"></span><span class="kr">type</span> <span class="nx">Length_Test2</span> <span class="o">=</span> <span class="nx">Length</span><span class="p">&lt;</span><span class="nt">unknown</span><span class="err">[]</span><span class="p">&gt;;</span>          <span class="c1">// =&gt; number
</span></code></pre></td></tr></table>
</div>
</div><p>Passing the type <code>[unknown]</code> to <code>Length</code> yields the type <code>1</code>, describing the fact that any of the countless elements belonging to the type <code>[unknown]</code>, whether <code>[1]</code> or <code>['foo']</code> or <code>[{foo: true}]</code>, <strong>to which the length is applied</strong>, yields the result <code>1</code>. These elements are transformed into the value <code>1</code> by the rule <code>Length</code>; in other words, the set represented by the type <code>[unknown]</code> is mapped by the rule <code>Length</code> to a single-element set containing only one element (that is, the value <code>1</code>), and the type of this set is the type <code>1</code>.</p>
<p>Passing the type <code>unknown[]</code> to <code>Length</code> yields the type <code>number</code>, because any one of the countless elements of the type <code>unknown[]</code>, whether <code>[]</code> or <code>[1]</code> or <code>['foo', true]</code>, <strong>which is given a length</strong>, yields <code>0</code>, <code>1</code> or <code>2</code>, etc. etc., all of type <code>number</code>. Note that <code>Length</code> does not guarantee that the rule-transformed value <strong>occupies</strong> the mapped set: there is no array with length <code>0.5</code> or <code>-1</code>. So the result of the generic operation <code>length&lt;unknown[]&gt;</code>, <code>number</code>, is actually a <strong>hyperset</strong> of the real-world mapped result set.</p>
<p>It is unavoidable that generics return a superset of the `real result set', which is often broader than we would expect from a collection. From a collection perspective, the purpose of writing a generic type is to provide a superset of the &ldquo;true result set&rdquo; <strong>that can be described by type rules</strong> and at the same time <strong>as small as possible</strong>. It is important to understand this.</p>
<blockquote>
<p>If JS supported unsigned integer types, <code>Length&lt;unknown[]&gt;</code>, it would seem to get the perfect result set, but this is really just a coincidence. More often than not, it is not possible to get a perfect result set: for example, <code>Length&lt;[unknown, . . unknown[]]&gt;</code> needs to return a set &ldquo;consisting of integers greater than 1&rdquo;.</p>
</blockquote>
<h2 id="javascript-a-priori-knowledge">JavaScript: a priori knowledge</h2>
<p>How does TS know that the result of <code>Length&lt;unknown[]&gt;</code> is <code>number</code>? Is there some <strong>principle</strong> between <code>Length&lt;unknown[]&gt;</code> and <code>number</code> that can still be understood? I think: there is <strong>no</strong> principle left, TS <strong>just</strong> gives a straightforward <strong>answer</strong> based on <strong>a priori</strong> (axiomatic) knowledge.</p>
<p>The type system of TS is tailored to JS: any JS literal is a single element type of TS; JS base types such as <code>number</code> or <code>string</code> also form the base types of TS; with a syntax similar to that used to define arrays, JSON objects, and functions, we can create array types and tuple types, object types, and function types to represent the types that contain the eligible TS is of course familiar with the <strong>habitat</strong> of all object types in JS - what member properties they have, how they transform into each other, etc. - this knowledge is a priori for TS, so TS can easily and correctly perform operations on base types.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="c1">// 基础类型间的运算
</span><span class="c1"></span><span class="kr">type</span> <span class="nx">T1</span> <span class="o">=</span> <span class="kt">number</span><span class="p">[</span><span class="s1">&#39;toFix&#39;</span><span class="p">];</span>                      <span class="c1">// =&gt; () =&gt; string
</span><span class="c1"></span><span class="kr">type</span> <span class="nx">T2</span> <span class="o">=</span> <span class="p">[</span><span class="kt">number</span><span class="p">,</span> <span class="kt">string</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>                  <span class="c1">// =&gt; string
</span><span class="c1"></span><span class="kr">type</span> <span class="nx">T3</span> <span class="o">=</span> <span class="k">keyof</span> <span class="p">{</span> <span class="nx">foo</span>: <span class="kt">number</span><span class="p">,</span> <span class="nx">bar</span>: <span class="kt">string</span> <span class="p">};</span>   <span class="c1">// =&gt; &#39;foo&#39; | &#39;bar&#39;
</span></code></pre></td></tr></table>
</div>
</div><h2 id="generic-head">Generic <code>Head</code></h2>
<p>The second generic <code>Head</code> takes the type of the first element in the tuple <code>T</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">type</span> <span class="nx">Head</span><span class="p">&lt;</span><span class="nt">T</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[]</span><span class="p">&gt;</span> <span class="o">=</span> <span class="nx">T</span> <span class="kr">extends</span> <span class="p">[]</span> <span class="o">?</span> <span class="kt">never</span> <span class="o">:</span> <span class="nx">T</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</code></pre></td></tr></table>
</div>
</div><p><code>Head</code> first determines whether <code>T extends []</code>, if so, <code>T</code> is a single-element set containing only the empty array and returns <code>never</code>; otherwise, <code>T</code> is not a single-element set of the empty array and may have the first element and returns <code>T[0]</code>.</p>
<p>Why is there only the <code>extends</code> keyword in the conditional generic, but not the <code>equals</code> keyword or the <code>==</code> operator? My insight is that in set operations, only the <strong>inclusion operation</strong> can produce a <code>yes</code> or <code>no</code> result, while the other operations on sets: intersection, union, complement, mapping, they all result in another set. In the context of sets, A is contained in B, which means A is a subset of B. Switch to the context of types, which means A is a subclass of B, which means A inherits from B.</p>
<blockquote>
<p>How can we tell that two types are identical? Just determine that they contain each other (inherit from each other).</p>
</blockquote>
<p>To perform some tests on <code>Head</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">type</span> <span class="nx">Head_Test1</span> <span class="o">=</span> <span class="nx">Head</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="kt">number</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>    <span class="c1">// =&gt; 1
</span><span class="c1"></span><span class="kr">type</span> <span class="nx">Head_Test2</span> <span class="o">=</span> <span class="nx">Head</span><span class="p">&lt;</span><span class="nt">string</span><span class="err">[]</span><span class="p">&gt;;</span>       <span class="c1">// =&gt; string
</span><span class="c1"></span><span class="kr">type</span> <span class="nx">Head_Test3</span> <span class="o">=</span> <span class="nx">Head</span><span class="p">&lt;</span><span class="nt">unknown</span><span class="p">&gt;;</span>        <span class="c1">// ts error
</span><span class="c1"></span><span class="kr">type</span> <span class="nx">Head_Test4</span> <span class="o">=</span> <span class="nx">Head</span><span class="o">&lt;</span><span class="p">[]</span><span class="o">&gt;</span><span class="p">;</span>             <span class="c1">// =&gt; never
</span></code></pre></td></tr></table>
</div>
</div><p>The results of the first three tests are intuitive. The fourth one, when we pass <strong>a single-element set containing the empty array</strong> to <code>Head</code>, yields a result of type <code>never</code>, indicating the empty set, and there is nothing wrong with that either.</p>
<p>Let&rsquo;s take another look at the second test: is the empty array an element of the <code>string[]</code> set, please? Of course it is. So, in a real-world <code>Head</code> mapping, to what elements is the empty array mapped?</p>
<p>In set theory, the premise of a mapping is that the mapping rules are valid for all elements in the source set. How should we understand <code>Head</code>?</p>
<p>My understanding is that there is a <strong><code>never</code> object</strong> in TS that <strong>can&rsquo;t be written out</strong> (not in JS), and a <strong><code>never</code> type</strong> that <strong>can be written out</strong> represents a single-element set containing a <code>never</code> object. Also, any type that can be written out in TS implicitly contains <code>never</code> objects, which makes any type that merges with a <code>never</code> type get itself, thus making the otherwise single-element set of <code>never</code> types on <strong>concept</strong> the empty set.</p>
<p>From this perspective, <code>Head&lt;string[]&gt;</code> makes sense: the empty array elements in the <code>string[]</code> set are mapped to <code>never</code>, while the other elements are mapped to <code>string</code>; since <code>string | never</code> is still <code>string</code>, it eventually returns <code>string</code>.</p>
<h2 id="generic-tail">Generic <code>Tail</code></h2>
<p>The third generic <code>Tail</code> extracts the type of the <strong>tail items</strong> of the tuple <code>T</code> (i.e., those remaining after the first item).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">type</span> <span class="nx">Tail</span><span class="p">&lt;</span><span class="nt">T</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[]</span><span class="p">&gt;</span> <span class="o">=</span> <span class="nx">T</span> <span class="kr">extends</span> <span class="p">[]</span> <span class="o">?</span> <span class="kt">never</span> <span class="o">:</span> <span class="nx">T</span> <span class="kr">extends</span> <span class="p">[</span><span class="kt">unknown</span><span class="p">,</span> <span class="p">...</span><span class="k">infer</span> <span class="nx">R</span><span class="p">]</span> <span class="o">?</span> <span class="nx">R</span> : <span class="kt">T</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>It&rsquo;s a bit complicated.</p>
<p>Let&rsquo;s start with a short version.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">type</span> <span class="nx">SimpleTail</span><span class="p">&lt;</span><span class="nt">T</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[]</span><span class="p">&gt;</span> <span class="o">=</span> <span class="nx">T</span> <span class="kr">extends</span> <span class="p">[</span><span class="kt">unknown</span><span class="p">,</span> <span class="p">...</span><span class="k">infer</span> <span class="nx">R</span><span class="p">]</span> <span class="o">?</span> <span class="nx">R</span> : <span class="kt">never</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p><code>SimpleTail</code> is formally very similar to JS code: it uses the residual argument operator to extract the remainder of the tuple excluding the first item. A simple test is no problem either.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">type</span> <span class="nx">SimpleTail_Test1</span> <span class="o">=</span> <span class="nx">SimpleTail</span><span class="o">&lt;</span><span class="p">[]</span><span class="o">&gt;</span><span class="p">;</span>                    <span class="c1">// =&gt; never
</span><span class="c1"></span><span class="kr">type</span> <span class="nx">SimpleTail_Test2</span> <span class="o">=</span> <span class="nx">SimpleTail</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="kt">string</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>        <span class="c1">// =&gt; [2, string]
</span><span class="c1"></span><span class="kr">type</span> <span class="nx">SimpleTail_Test3</span> <span class="o">=</span> <span class="nx">SimpleTail</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">...</span><span class="kt">string</span><span class="p">[]]</span><span class="o">&gt;</span><span class="p">;</span>   <span class="c1">// =&gt; [2, ...string[]]
</span></code></pre></td></tr></table>
</div>
</div><p>However, if you test it with <code>string[]</code>, you get <code>never</code>. That&rsquo;s not quite right.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">type</span> <span class="nx">SimpleTail_Test3</span> <span class="o">=</span> <span class="nx">SimpleTail</span><span class="p">&lt;</span><span class="nt">string</span><span class="err">[]</span><span class="p">&gt;;</span>              <span class="c1">// =&gt; never
</span></code></pre></td></tr></table>
</div>
</div><p>In the real world, almost all elements of a <code>string[]</code> set (except for the empty array object) are meaningful for the tail operation. In fact, if we generalize by giving some examples, we must conclude that the result of taking the last term of <code>string[]</code> <strong>is</strong> <code>string[]</code>. However, according to the implementation of <code>SimpleTail</code>: <code>string[]</code> is indeed not <code>[unknown, . . unknown[]]</code>, we can only return <code>never</code>.</p>
<p>Let&rsquo;s look at the formal version of <code>Tail</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">type</span> <span class="nx">Tail</span><span class="p">&lt;</span><span class="nt">T</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[]</span><span class="p">&gt;</span> <span class="o">=</span> <span class="nx">T</span> <span class="kr">extends</span> <span class="p">[]</span> <span class="o">?</span> <span class="kt">never</span> <span class="o">:</span> <span class="nx">T</span> <span class="kr">extends</span> <span class="p">[</span><span class="kt">unknown</span><span class="p">,</span> <span class="p">...</span><span class="k">infer</span> <span class="nx">R</span><span class="p">]</span> <span class="o">?</span> <span class="nx">R</span> : <span class="kt">T</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>Branch 1: If <code>T</code> is a subset of the empty array single-element set, we can conclude that <code>T</code> can only be the empty array single-element set or <code>never</code>, which returns <code>never</code>.</li>
<li>Branch 2: If <code>T</code> is a subset of &ldquo;the set consisting of all &ldquo;arrays with the first item&rdquo;&rdquo;, we can conclude that <code>T</code> cannot contain empty array elements, and extract the type of the last item in a form similar to that in <code>SimpleTail</code>.</li>
<li>Branch 3: If neither of the above is satisfied, we return <code>T</code> directly.</li>
</ol>
<p>Passing <code>string[]</code> to test this, we get the expected type: <code>string[]</code> by branching 3.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">type</span> <span class="nx">Tail_Test4</span> <span class="o">=</span> <span class="nx">Tail</span><span class="p">&lt;</span><span class="nt">string</span><span class="err">[]</span><span class="p">&gt;;</span>                           <span class="c1">// =&gt; string[]
</span></code></pre></td></tr></table>
</div>
</div><p>Are you really sure? If <code>T</code> does not satisfy branch 1 or branch 2, it must be a pure array type like <code>string[]</code> or <code>number[]</code>, and not <strong>anything else</strong>?</p>
<p>Let&rsquo;s summarize the <strong>writing</strong> of array (including tuple) types: (we don&rsquo;t care about the specific types of array items, we use <code>unknown</code> instead)</p>
<ol>
<li>empty arrays: <code>[]</code>.</li>
<li>pure arrays: <code>unknown[]</code>; 3.</li>
<li>tuple: <code>[unknownA, unknownB, unknownC]</code>.</li>
<li>a tuple with remaining terms: <code>[unknownA, unknownB, . . unknownC[]]</code> .</li>
</ol>
<p>After summarizing, we find that there are <strong>only</strong> 4 ways to write an array type, <strong>nothing</strong> else! The array types that can be <strong>written</strong> and the array types that can be <strong>calculated</strong> (returned by other generics) can all be grouped together in the end. These 4 ways of writing are the <strong>boundaries</strong> on how TS handles array types, in other words TS cannot produce array types that &ldquo;cannot be combined out with these 4 ways of writing&rdquo;.</p>
<p>Based on this knowledge, we are confident that only the second write method (pure array types) will make it to branch 3, and we can safely return direct <code>T</code> in branch 3.</p>
<p>Note that there is a catch here. Consider the case of passing in a merge set.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">type</span> <span class="nx">Tail_Test5</span> <span class="o">=</span> <span class="nx">Tail</span><span class="o">&lt;</span><span class="p">[]</span> <span class="o">|</span> <span class="kt">string</span><span class="p">[]</span> <span class="o">|</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>          <span class="c1">// string[] | [2, 3]
</span></code></pre></td></tr></table>
</div>
</div><p>According to set theory, the mapping of a concatenation should be done by mapping <strong>each</strong> of the individual sets that make up the concatenation, separately, and then taking the concatenation of <strong>multiple result sets</strong> as the final result.</p>
<p><code>Tail</code> does not disappoint us, it returns the expected type correctly. But this is conditional, the branch condition in the generic must satisfy the constraint <strong>Distribution condition type</strong>: i.e. the condition must be a generic argument <strong>directly</strong> <code>extends</code> some type (in the form <code>T extends SOMETYPE</code>), if we replace the first condition <code>T extends []</code> in the <code>Tail</code> implementation with <code>Length&lt;T&gt; extends 0</code>, the constraint on the type of the distribution condition fails and the proposition &ldquo;<code>T</code> can only be one of these 4 ways&rdquo; ceases to exist, and the building collapses.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">type</span> <span class="nx">BrokenTail</span><span class="p">&lt;</span><span class="nt">T</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[]</span><span class="p">&gt;</span> <span class="o">=</span> <span class="nx">Length</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;</span> <span class="kr">extends</span> <span class="mi">0</span> <span class="o">?</span> <span class="kt">never</span> <span class="o">:</span> <span class="nx">T</span> <span class="kr">extends</span> <span class="p">[</span><span class="kt">unknown</span><span class="p">,</span> <span class="p">...</span><span class="k">infer</span> <span class="nx">R</span><span class="p">]</span> <span class="o">?</span> <span class="nx">R</span> : <span class="kt">T</span><span class="p">;</span>

<span class="kr">type</span> <span class="nx">BrokenTail_Test6</span> <span class="o">=</span> <span class="nx">BrokenTail</span><span class="o">&lt;</span><span class="p">[]</span> <span class="o">|</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">|</span> <span class="kt">string</span><span class="p">[]</span><span class="o">&gt;</span><span class="p">;</span>  <span class="c1">// =&gt; [] | [3] | string[]
</span></code></pre></td></tr></table>
</div>
</div><p>Have you experienced a certain <strong>clumsiness</strong> of generic programming? The rules of set mapping (i.e., the semantics of generics) are based on <strong>elements within sets</strong>, but implementers of generics must answer the question &ldquo;what set is after the mapping&rdquo; based on the operations of the <strong>set itself</strong>. This needs to be summarized practically from a real-world perspective to guarantee the <strong>correctness</strong> and <strong>minimality</strong> of the mapping.</p>
<h2 id="types-of-conversion-functions">Types of conversion functions</h2>
<p>Currently, the type of the curry conversion function <code>curry</code> is defined as follows: takes an arbitrary function and returns <code>unknown</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">type</span> <span class="nx">Curry</span> <span class="o">=</span> <span class="p">(</span><span class="nx">toCurry</span>: <span class="kt">Function</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">unknown</span><span class="p">;</span>

<span class="kr">declare</span> <span class="kr">const</span> <span class="nx">curry</span>: <span class="kt">Curry</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>We want to replace <code>unknown</code> with a <strong>more refined type</strong> so that the user can get the correct type hint when using the result returned by <code>curry</code> (i.e. the curry function).</p>
<p>Obviously, exactly what this &ldquo;more refined type&rdquo; is depends on the function that is passed in when calling <code>curry</code>. We use <strong>generic constraints</strong> to extract the argument <code>P</code> and the return type <code>R</code> from the passed-in function.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">type</span> <span class="nx">Curry</span> <span class="o">=</span> <span class="p">&lt;</span><span class="nt">P</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[],</span> <span class="na">R</span><span class="p">&gt;(</span><span class="nx">toCurry</span><span class="o">:</span> <span class="p">(...</span><span class="nx">args</span>: <span class="kt">P</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">R</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">Curried</span><span class="p">&lt;</span><span class="nt">P</span><span class="err">,</span> <span class="na">R</span><span class="p">&gt;;</span>
</code></pre></td></tr></table>
</div>
</div><p>Then, pass <code>P</code> and <code>R</code> to the <code>Curried</code> generic type as the type of the curried function (i.e., the aforementioned &ldquo;more refined type&rdquo;).</p>
<blockquote>
<p>Note that <code>Curry</code> is not a generic mapping, but simply a function type with generic constraints.</p>
</blockquote>
<h2 id="generic-type-curriedv1">Generic type <code>CurriedV1</code></h2>
<p><code>CurriedV1</code> is the first version of the implementation of the <code>Curried</code> generic type, which supports the simplest form of currying (consuming one argument at a time).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">type</span> <span class="nx">CurriedV1</span><span class="p">&lt;</span><span class="nt">P</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[],</span> <span class="na">R</span><span class="p">&gt;</span> <span class="o">=</span> <span class="nx">P</span> <span class="kr">extends</span> <span class="p">[]</span> <span class="o">?</span> <span class="nx">R</span> <span class="o">:</span> <span class="p">(</span><span class="nx">arg</span>: <span class="kt">Head</span><span class="p">&lt;</span><span class="nt">P</span><span class="p">&gt;)</span> <span class="o">=&gt;</span> <span class="nx">CurriedV1</span><span class="p">&lt;</span><span class="nt">Tail</span><span class="err">&lt;</span><span class="na">P</span><span class="p">&gt;,</span> <span class="nx">R</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>A generic type can be called recursively, and <code>CurriedV1</code> is such that each time it calls itself recursively, the size of the tuple <code>P</code> is reduced by one until it becomes an empty array, ending the recursion.</p>
<p>Test it out, it&rsquo;s perfect.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">type</span> <span class="nx">CurriedV1_Test1</span> <span class="o">=</span> <span class="nx">CurriedV1</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">0</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// =&gt; (arg: 1) =&gt; (arg: 2) =&gt; (arg: 3) =&gt; 0
</span></code></pre></td></tr></table>
</div>
</div><p>You may ask: If you pass in an array type of infinite (unknown) length, like <code>number[]</code>, will TS get stuck in a dead loop? Let&rsquo;s try.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">type</span> <span class="nx">CurriedV1_Test2</span> <span class="o">=</span> <span class="nx">CurriedV1</span><span class="p">&lt;</span><span class="nt">number</span><span class="err">[],</span> <span class="na">0</span><span class="p">&gt;;</span> <span class="c1">// =&gt; (arg: number) =&gt; ...
</span></code></pre></td></tr></table>
</div>
</div><p>Instead of reporting an error or getting stuck in a dead loop, TS still maps a function type that can be called ad infinitum. So, we can conclude that progressive scaling down on recursion is not a necessary condition for generic recursion.</p>
<p>In fact, some <strong>inert</strong> mechanism of generics allows us to define types for things like <strong>loop reference objects</strong> in JS or <strong>functions that return themselves</strong>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">type</span> <span class="nx">Foo</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">foo</span>: <span class="kt">Foo</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;</span> <span class="p">};</span>
<span class="kr">declare</span> <span class="kr">const</span> <span class="nx">foo</span>: <span class="kt">Foo</span><span class="p">&lt;</span><span class="nt">number</span><span class="p">&gt;;</span>
<span class="nx">foo</span><span class="p">.</span><span class="nx">foo</span><span class="p">.</span><span class="nx">foo</span><span class="p">.</span><span class="nx">foo</span><span class="p">.</span><span class="nx">foo</span><span class="p">.</span><span class="nx">foo</span><span class="p">;</span>            <span class="c1">// =&gt; 属性 foo 可以无限取下去
</span><span class="c1"></span>
<span class="kr">type</span> <span class="nx">Bar</span><span class="p">&lt;</span><span class="nt">T</span> <span class="na">extends</span> <span class="err">()</span> <span class="err">=</span><span class="p">&gt;</span> <span class="kt">number</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">Bar</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;;</span>
<span class="kr">declare</span> <span class="kr">const</span> <span class="nx">bar</span>: <span class="kt">Bar</span><span class="o">&lt;</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>
<span class="nx">bar</span><span class="p">()()()()();</span>                      <span class="c1">// =&gt; 函数 bar 可以无限调用下去
</span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>At this point, most of the &ldquo;generalization from a collection perspective&rdquo; insights have been stated. Next, I&rsquo;ll speed things up a bit and finish up with the more advanced implementation of curried types.</p>
</blockquote>
<h2 id="curriedv2-allowing-indefinite-arguments">CurriedV2: Allowing Indefinite Arguments</h2>
<p>It would be easier to use if curried functions could take indefinite arguments (in the form of <code>curried(1)(2,3)(4)</code>). My implementation is.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">type</span> <span class="nx">Prepend</span><span class="p">&lt;</span><span class="nt">E</span><span class="err">,</span> <span class="na">T</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[]</span><span class="p">&gt;</span> <span class="o">=</span> <span class="p">[</span><span class="nx">E</span><span class="p">,</span> <span class="p">...</span><span class="nx">T</span><span class="p">];</span>

<span class="kr">type</span> <span class="nx">Drop</span><span class="p">&lt;</span><span class="nt">N</span> <span class="na">extends</span> <span class="na">number</span><span class="err">,</span> <span class="na">P</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[],</span> <span class="na">T</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[]</span> <span class="err">=</span> <span class="err">[]</span><span class="p">&gt;</span> <span class="o">=</span>
    <span class="nx">Length</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;</span> <span class="kr">extends</span> <span class="nx">N</span> <span class="o">?</span> <span class="nx">P</span> : <span class="kt">Drop</span><span class="p">&lt;</span><span class="nt">N</span><span class="err">,</span> <span class="na">Tail</span><span class="err">&lt;</span><span class="na">P</span><span class="p">&gt;,</span> <span class="nx">Prepend</span><span class="p">&lt;</span><span class="nt">unknown</span><span class="err">,</span> <span class="na">T</span><span class="p">&gt;</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kr">type</span> <span class="nx">PartialTuple</span><span class="p">&lt;</span><span class="nt">T</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[]</span><span class="p">&gt;</span> <span class="o">=</span> <span class="nx">Partial</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;</span> <span class="o">&amp;</span> <span class="kt">unknown</span><span class="p">[];</span>

<span class="kr">type</span> <span class="nx">CurriedV2</span><span class="p">&lt;</span><span class="nt">P</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[],</span> <span class="na">R</span><span class="p">&gt;</span> <span class="o">=</span>
    <span class="nx">Length</span><span class="p">&lt;</span><span class="nt">P</span><span class="p">&gt;</span> <span class="kr">extends</span> <span class="mi">0</span>
    <span class="o">?</span> <span class="nx">R</span>
    <span class="o">:</span> <span class="p">&lt;</span><span class="nt">T</span> <span class="na">extends</span> <span class="na">PartialTuple</span><span class="err">&lt;</span><span class="na">P</span><span class="p">&gt;</span><span class="o">&gt;</span><span class="p">(...</span><span class="nx">args</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">CurriedV2</span><span class="p">&lt;</span><span class="nt">Drop</span><span class="err">&lt;</span><span class="na">Length</span><span class="err">&lt;</span><span class="na">T</span><span class="p">&gt;,</span> <span class="nx">P</span><span class="o">&gt;</span><span class="p">,</span> <span class="nx">R</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kr">type</span> <span class="nx">Curry</span> <span class="o">=</span> <span class="p">&lt;</span><span class="nt">P</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[],</span> <span class="na">R</span><span class="p">&gt;(</span><span class="nx">fn</span><span class="o">:</span> <span class="p">(...</span><span class="nx">args</span>: <span class="kt">P</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">R</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">CurriedV2</span><span class="p">&lt;</span><span class="nt">P</span><span class="err">,</span> <span class="na">R</span><span class="p">&gt;;</span>

<span class="kr">declare</span> <span class="kr">const</span> <span class="nx">curry</span>: <span class="kt">Curry</span><span class="p">;</span>
<span class="kr">declare</span> <span class="kr">const</span> <span class="nx">toCurry</span><span class="o">:</span> <span class="p">(</span><span class="nx">a1</span>: <span class="kt">1</span><span class="p">,</span> <span class="nx">a2</span>: <span class="kt">2</span><span class="p">,</span> <span class="nx">a3</span>: <span class="kt">3</span><span class="p">,</span> <span class="nx">a4</span>: <span class="kt">4</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="p">;</span>

<span class="kr">const</span> <span class="nx">curried</span> <span class="o">=</span> <span class="nx">curry</span><span class="p">(</span><span class="nx">toCurry</span><span class="p">);</span>
<span class="nx">curried</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span> <span class="c1">// =&gt; 0
</span></code></pre></td></tr></table>
</div>
</div><h2 id="generic-prepend">Generic <code>Prepend</code></h2>
<p>The generic <code>Prepend</code> prefixes the tuple type with an item.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">type</span> <span class="nx">Prepend</span><span class="p">&lt;</span><span class="nt">E</span><span class="err">,</span> <span class="na">T</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[]</span><span class="p">&gt;</span> <span class="o">=</span> <span class="p">[</span><span class="nx">E</span><span class="p">,</span> <span class="p">...</span><span class="nx">T</span><span class="p">];</span>

<span class="kr">type</span> <span class="nx">Prepend_Test1</span> <span class="o">=</span> <span class="nx">Prepend</span><span class="p">&lt;</span><span class="nt">1</span><span class="err">,</span> <span class="err">[</span><span class="na">2</span><span class="err">]</span><span class="p">&gt;;</span>                   <span class="c1">// ==&gt; [1, 2]
</span><span class="c1"></span><span class="kr">type</span> <span class="nx">Prepend_Test2</span> <span class="o">=</span> <span class="nx">Prepend</span><span class="p">&lt;</span><span class="nt">1</span><span class="err">,</span> <span class="err">[</span><span class="na">2</span><span class="err">,</span> <span class="na">...3</span><span class="err">[]]</span><span class="p">&gt;;</span>           <span class="c1">// ==&gt; [1, 2, ...3[]]
</span><span class="c1"></span><span class="kr">type</span> <span class="nx">Prepend_Test3</span> <span class="o">=</span> <span class="nx">Prepend</span><span class="p">&lt;</span><span class="nt">1</span> <span class="err">|</span> <span class="na">2</span><span class="err">,</span> <span class="na">3</span><span class="err">[]</span><span class="p">&gt;;</span>               <span class="c1">// ==&gt; [1 | 2, ...3[]]
</span></code></pre></td></tr></table>
</div>
</div><p>Note that <code>Prepend</code> is not a conditional type and naturally does not satisfy the distribution condition type, so <code>Prepend_Test3</code> is <code>[1 | 2, . . 3[]]</code> instead of <code>[1, . . 3[]] | [2, . . 3[]]</code> . If you want the latter, you can put the implementation of <code>Prepend</code> inside the conditional type, as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">type</span> <span class="nx">DistributedPrepend</span><span class="p">&lt;</span><span class="nt">E</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">,</span> <span class="na">T</span> <span class="na">extends</span><span class="p">&gt;</span> <span class="o">=</span> <span class="nx">E</span> <span class="kr">extends</span> <span class="kt">unknown</span> <span class="o">?</span> <span class="p">[</span><span class="nx">E</span><span class="p">,</span> <span class="p">...</span><span class="nx">T</span><span class="p">]</span> <span class="o">:</span> <span class="kt">never</span><span class="p">;</span>

<span class="kr">type</span> <span class="nx">DistributedPrepend_Test1</span> <span class="o">=</span> <span class="nx">DistributedPrepend</span><span class="p">&lt;</span><span class="nt">1</span> <span class="err">|</span> <span class="na">2</span><span class="err">,</span> <span class="na">3</span><span class="err">[]</span><span class="p">&gt;;</span>    <span class="c1">// ==&gt; [1, ...3[]] | [2, ...3[]]
</span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>The subsequent discussion in this article assumes that all incoming types are non-discrete (i.e., non-concurrent in form) and does not discuss the issue of distributing conditional types.</p>
</blockquote>
<h2 id="the-generic-type-drop">The generic type <code>Drop</code></h2>
<p>The generic type <code>Drop</code> is responsible for deleting the <code>N</code> elements of the header from the tuple. <code>Drop</code> is also recursive, deleting one element at a time recursively, while placing an <code>unknown</code> into tuple <code>T</code>. When the length of the tuple <code>T</code> is equal to <code>N</code>, enough elements have been removed to return the remaining elements.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">type</span> <span class="nx">Drop</span><span class="p">&lt;</span><span class="nt">N</span> <span class="na">extends</span> <span class="na">number</span><span class="err">,</span> <span class="na">P</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[],</span> <span class="na">T</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[]</span> <span class="err">=</span> <span class="err">[]</span><span class="p">&gt;</span> <span class="o">=</span>
    <span class="nx">Length</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;</span> <span class="kr">extends</span> <span class="nx">N</span> <span class="o">?</span> <span class="nx">P</span> : <span class="kt">Drop</span><span class="p">&lt;</span><span class="nt">N</span><span class="err">,</span> <span class="na">Tail</span><span class="err">&lt;</span><span class="na">P</span><span class="p">&gt;,</span> <span class="nx">Prepend</span><span class="p">&lt;</span><span class="nt">unknown</span><span class="err">,</span> <span class="na">T</span><span class="p">&gt;</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>Simply tested with no problems.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">type</span> <span class="nx">Drop_Test1</span> <span class="o">=</span> <span class="nx">Drop</span><span class="p">&lt;</span><span class="nt">2</span><span class="err">,</span> <span class="err">[</span><span class="na">1</span><span class="err">,</span> <span class="na">2</span><span class="err">,</span> <span class="na">3</span><span class="err">,</span> <span class="na">4</span><span class="err">]</span><span class="p">&gt;;</span>    <span class="c1">// =&gt; [3, 4]
</span><span class="c1"></span><span class="kr">type</span> <span class="nx">Drop_Test2</span> <span class="o">=</span> <span class="nx">Drop</span><span class="p">&lt;</span><span class="nt">5</span><span class="err">,</span> <span class="err">[</span><span class="na">1</span><span class="err">,</span> <span class="na">2</span><span class="err">,</span> <span class="na">3</span><span class="err">,</span> <span class="na">4</span><span class="err">]</span><span class="p">&gt;;</span>    <span class="c1">// =&gt; never
</span><span class="c1"></span><span class="kr">type</span> <span class="nx">Drop_Test3</span> <span class="o">=</span> <span class="nx">Drop</span><span class="p">&lt;</span><span class="nt">5</span><span class="err">,</span> <span class="err">[</span><span class="na">1</span><span class="err">,</span> <span class="na">2</span><span class="err">,</span> <span class="na">...3</span><span class="err">[]]</span><span class="p">&gt;;</span>  <span class="c1">// =&gt; 3[]
</span></code></pre></td></tr></table>
</div>
</div><p>The key to <code>Drop</code> is that an empty array, the third generic parameter <code>T</code>, is used for counting.</p>
<blockquote>
<p>Interestingly, a similar mechanism can be used to add and subtract integers.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">type</span> <span class="nx">FromLength</span><span class="p">&lt;</span><span class="nt">N</span> <span class="na">extends</span> <span class="na">number</span><span class="err">,</span> <span class="na">P</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[]</span> <span class="err">=</span> <span class="err">[]</span><span class="p">&gt;</span> <span class="o">=</span> 
    <span class="nx">Length</span><span class="p">&lt;</span><span class="nt">P</span><span class="p">&gt;</span> <span class="kr">extends</span> <span class="nx">N</span> <span class="o">?</span> <span class="nx">P</span> : <span class="kt">FromLength</span><span class="p">&lt;</span><span class="nt">N</span><span class="err">,</span> <span class="na">Prepend</span><span class="err">&lt;</span><span class="na">unknown</span><span class="err">,</span> <span class="na">P</span><span class="p">&gt;</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kr">type</span> <span class="nx">Add</span><span class="p">&lt;</span><span class="nt">A</span> <span class="na">extends</span> <span class="na">number</span><span class="err">,</span> <span class="na">B</span> <span class="na">extends</span> <span class="na">number</span><span class="err">,</span> <span class="na">Res</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[]</span> <span class="err">=</span> <span class="na">FromLength</span><span class="err">&lt;</span><span class="na">A</span><span class="p">&gt;,</span> <span class="nx">Count</span> <span class="kr">extends</span> <span class="kt">unknown</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[]</span><span class="o">&gt;</span> <span class="o">=</span> 
    <span class="nx">Length</span><span class="p">&lt;</span><span class="nt">Count</span><span class="p">&gt;</span> <span class="kr">extends</span> <span class="nx">B</span> <span class="o">?</span> <span class="nx">Length</span><span class="p">&lt;</span><span class="nt">Res</span><span class="p">&gt;</span> <span class="o">:</span> <span class="nx">Add</span><span class="p">&lt;</span><span class="nt">A</span><span class="err">,</span> <span class="na">B</span><span class="err">,</span> <span class="na">Prepend</span><span class="err">&lt;</span><span class="na">unknown</span><span class="err">,</span> <span class="na">Res</span><span class="p">&gt;,</span> <span class="nx">Prepend</span><span class="p">&lt;</span><span class="nt">unknown</span><span class="err">,</span> <span class="na">Count</span><span class="p">&gt;</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kr">type</span> <span class="nx">Sub</span><span class="p">&lt;</span><span class="nt">A</span> <span class="na">extends</span> <span class="na">number</span><span class="err">,</span> <span class="na">B</span> <span class="na">extends</span> <span class="na">number</span><span class="err">,</span> <span class="na">Res</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[]</span> <span class="err">=</span> <span class="err">[],</span> <span class="na">Count</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[]</span> <span class="err">=</span> <span class="na">FromLength</span><span class="err">&lt;</span><span class="na">B</span><span class="p">&gt;</span><span class="o">&gt;</span> <span class="o">=</span> 
    <span class="nx">Length</span><span class="p">&lt;</span><span class="nt">Count</span><span class="p">&gt;</span> <span class="kr">extends</span> <span class="nx">A</span> <span class="o">?</span> <span class="nx">Length</span><span class="p">&lt;</span><span class="nt">Res</span><span class="p">&gt;</span> <span class="o">:</span> <span class="nx">Sub</span><span class="p">&lt;</span><span class="nt">A</span><span class="err">,</span> <span class="na">B</span><span class="err">,</span> <span class="na">Prepend</span><span class="err">&lt;</span><span class="na">unknown</span><span class="err">,</span> <span class="na">Res</span><span class="p">&gt;,</span> <span class="nx">Prepend</span><span class="p">&lt;</span><span class="nt">unknown</span><span class="err">,</span> <span class="na">Count</span><span class="p">&gt;</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kr">type</span> <span class="nx">Eight</span> <span class="o">=</span> <span class="nx">Add</span><span class="p">&lt;</span><span class="nt">3</span><span class="err">,</span> <span class="na">5</span><span class="p">&gt;;</span>     <span class="c1">// =&gt; 8
</span><span class="c1"></span><span class="kr">type</span> <span class="nx">Four</span> <span class="o">=</span> <span class="nx">Sub</span><span class="p">&lt;</span><span class="nt">9</span><span class="err">,</span> <span class="na">5</span><span class="p">&gt;;</span>      <span class="c1">// =&gt; 4
</span></code></pre></td></tr></table>
</div>
</div></blockquote>
<h2 id="the-generic-partialtuple">The generic <code>PartialTuple</code></h2>
<p>The story of the generic <code>PartialTuple</code> starts with the official TS generic <code>Partial</code>. We know that the <code>Partial</code> generic can make all properties of an object type optional. When applied to an array, it makes each item of the array optional, e.g. <code>Partial&lt;[number, string]&gt;</code> can be of type <strong>similar</strong> to <code>[number?, string?]</code>.</p>
<p>We expect CurriedV2 to support indefinite arguments, so we need to extract the &ldquo;first arbitrary term of a tuple&rdquo; type from the tuple of indefinite arguments: for example, if the indefinite arguments are of type [1, 2, 3], then the indefinite arguments can be [1], [1, 2] or [1, 2, 3]. However, the current type operations of TS do not allow for such a mapping rule as &ldquo;first arbitrary term of a tuple&rdquo;, and Partial is the closest implementation (minimal superset).</p>
<p>Why do we need <code>PartialTuple</code> again? Because the type converted by <code>Partial</code> is no longer a tuple: properties like <code>length</code>, <code>map</code>, etc. become optional, which makes objects like <code>{0: 'Hello'}</code> also in the set of <code>Partial&lt;[string]&gt;</code>. The <code>PartialTuple</code> excludes the elements that are not part of the tuple.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">type</span> <span class="nx">PartialTuple</span><span class="p">&lt;</span><span class="nt">T</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[]</span><span class="p">&gt;</span> <span class="o">=</span> <span class="nx">Partial</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;</span> <span class="o">&amp;</span> <span class="kt">unknown</span><span class="p">[];</span>
</code></pre></td></tr></table>
</div>
</div><p>The original uses <code>Partial</code> directly without reporting an error, which is a bug in TS: for <code>Partial</code> after passing in a tuple type, it is inconsistent in determining whether it is still a tuple or not under different conditions. I submitted <a href="https://github.com/microsoft/TypeScript/issues/47128">issue</a> and <a href="https://www.typescriptlang.org/play?ts=4.1.5#code/C4TwDgpgBAIgjAHgAoD4oF4pKhAHsCAOwBMBnKAV0IGtCB7Ad0IG0BdKAfigAoA6fgIYAuLAIBOwAJYCANshQBKDGgBudScSgjCEFRDEBuKAHpjOMWLpiAsACg7oSLABMyHPiJlKNekzZpMPkERJHEpWXkldFV1YiNTKFIKAGNkiFJSOzsEgBUAC2hgBjp3AQBbMBloUjy6ChlNACM6YDzElLSMiE0rKAAzAUkq4izbIA">Minimal Replication</a>.</p>
<h2 id="pan-type-curriedv2">Pan type <code>CurriedV2</code></h2>
<p><code>CurriedV2</code> is somewhat similar to <code>CurriedV1</code> in terms of framework.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">type</span> <span class="nx">CurriedV1</span><span class="p">&lt;</span><span class="nt">P</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[],</span> <span class="na">R</span><span class="p">&gt;</span> <span class="o">=</span> 
    <span class="nx">P</span> <span class="kr">extends</span> <span class="p">[]</span> <span class="o">?</span> <span class="nx">R</span> <span class="o">:</span> <span class="p">(</span><span class="nx">arg</span>: <span class="kt">Head</span><span class="p">&lt;</span><span class="nt">P</span><span class="p">&gt;)</span> <span class="o">=&gt;</span> <span class="nx">CurriedV1</span><span class="p">&lt;</span><span class="nt">Tail</span><span class="err">&lt;</span><span class="na">P</span><span class="p">&gt;,</span> <span class="nx">R</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kr">type</span> <span class="nx">CurriedV2</span><span class="p">&lt;</span><span class="nt">P</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[],</span> <span class="na">R</span><span class="p">&gt;</span> <span class="o">=</span>
    <span class="nx">P</span> <span class="kr">extends</span> <span class="p">[]</span> <span class="o">?</span> <span class="nx">R</span> <span class="o">:</span> <span class="p">&lt;</span><span class="nt">T</span> <span class="na">extends</span> <span class="na">PartialTuple</span><span class="err">&lt;</span><span class="na">P</span><span class="p">&gt;</span><span class="o">&gt;</span><span class="p">(...</span><span class="nx">args</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">CurriedV2</span><span class="p">&lt;</span><span class="nt">Drop</span><span class="err">&lt;</span><span class="na">Length</span><span class="err">&lt;</span><span class="na">T</span><span class="p">&gt;,</span> <span class="nx">P</span><span class="o">&gt;</span><span class="p">,</span> <span class="nx">R</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>The most important difference is that <code>CurriedV2</code> introduces a generic constraint for the Curried function, so that each time it is called, the number of incoming arguments can be dynamically extracted and the type that should be returned from this call can be calculated accordingly.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">type</span> <span class="nx">CurriedV1_Test1</span> <span class="o">=</span> <span class="nx">CurriedV1</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">0</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// =&gt; (arg: 1) =&gt; (arg: 2) =&gt; (arg: 3) =&gt; 0
</span><span class="c1"></span>
<span class="kr">type</span> <span class="nx">CurriedV2_Test1</span> <span class="o">=</span> <span class="nx">CurriedV2</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">0</span><span class="o">&gt;</span><span class="p">;</span>
<span class="c1">// =&gt; &lt;T extends PartialTuple&lt;[1, 2, 3]&gt;&gt;(...args: T) =&gt; CurriedV2&lt;Drop&lt;Length&lt;T&gt;, [1, 2, 3], []&gt;, 0&gt;
</span></code></pre></td></tr></table>
</div>
</div><p>As a simple test, we found that <code>CurriedV2_Test1</code> cannot give the type of the Curried function straightforwardly, because the type is obtained after each step of the call and can only be determined (based on the parameters) at the time of the call.</p>
<h2 id="curriedv3-support-for-remaining-arguments">CurriedV3: support for remaining arguments</h2>
<p>Some functions split their arguments into two parts: fixed arguments and residual arguments. For example, <code>toCurry</code>: after the first four fixed parameters, you can pass in any residual parameter of type <code>5</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">declare</span> <span class="kr">const</span> <span class="nx">toCurry</span><span class="o">:</span> <span class="p">(</span><span class="nx">a1</span>: <span class="kt">1</span><span class="p">,</span> <span class="nx">a2</span>: <span class="kt">2</span><span class="p">,</span> <span class="nx">a3</span>: <span class="kt">3</span><span class="p">,</span> <span class="nx">a4</span>: <span class="kt">4</span><span class="p">,</span> <span class="p">...</span><span class="nx">args</span>: <span class="kt">5</span><span class="p">[])</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">// 必须在最后一次调用时一次性传入所有剩余参数
</span><span class="c1"></span><span class="nx">curry</span><span class="p">(</span><span class="nx">toCurry</span><span class="p">)(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>It would undoubtedly be better if Curried could support such functions: that is the goal of <code>CurriedV3</code>. My implementation is.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">type</span> <span class="nx">CurriedV3</span><span class="p">&lt;</span><span class="nt">P</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[],</span> <span class="na">R</span><span class="p">&gt;</span> <span class="o">=</span>
    <span class="nx">P</span> <span class="kr">extends</span> <span class="p">[</span><span class="kt">unknown</span><span class="p">,</span> <span class="p">...</span><span class="kt">unknown</span><span class="p">[]]</span>
    <span class="o">?</span> <span class="p">&lt;</span><span class="nt">T</span> <span class="na">extends</span> <span class="na">PartialTuple</span><span class="err">&lt;</span><span class="na">P</span><span class="p">&gt;</span><span class="o">&gt;</span><span class="p">(...</span><span class="nx">args</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">CurryV3</span><span class="p">&lt;</span><span class="nt">Drop</span><span class="err">&lt;</span><span class="na">Length</span><span class="err">&lt;</span><span class="na">T</span><span class="p">&gt;,</span> <span class="nx">P</span><span class="o">&gt;</span><span class="p">,</span> <span class="nx">R</span><span class="o">&gt;</span>
    <span class="o">:</span> <span class="nx">R</span><span class="p">;</span>

<span class="kr">type</span> <span class="nx">Curry</span> <span class="o">=</span> <span class="p">&lt;</span><span class="nt">P</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[],</span> <span class="na">R</span><span class="p">&gt;(</span><span class="nx">fn</span><span class="o">:</span> <span class="p">(...</span><span class="nx">args</span>: <span class="kt">P</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">R</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">CurriedV3</span><span class="p">&lt;</span><span class="nt">P</span><span class="err">,</span> <span class="na">R</span><span class="p">&gt;;</span>

<span class="kr">declare</span> <span class="kr">const</span> <span class="nx">curry</span>: <span class="kt">Curry</span><span class="p">;</span>
<span class="kr">declare</span> <span class="kr">const</span> <span class="nx">toCurry</span><span class="o">:</span> <span class="p">(</span><span class="nx">a1</span>: <span class="kt">1</span><span class="p">,</span> <span class="nx">a2</span>: <span class="kt">2</span><span class="p">,</span> <span class="nx">a3</span>: <span class="kt">3</span><span class="p">,</span> <span class="nx">a4</span>: <span class="kt">4</span><span class="p">,</span> <span class="p">...</span><span class="nx">args</span>: <span class="kt">5</span><span class="p">[])</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="p">;</span>

<span class="kr">const</span> <span class="nx">curried</span> <span class="o">=</span> <span class="nx">curry</span><span class="p">(</span><span class="nx">toCurry</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">curried</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)(</span><span class="mi">4</span><span class="err">，</span><span class="mi">5</span><span class="err">，</span><span class="mi">5</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>The difference between <code>CurriedV3</code> and <code>CurriedV2</code> <strong>only</strong> is that the recursion ends under different conditions: <code>CurriedV3</code> determines that <code>P extends [unknown, . . unknown[]]</code> infers that <code>P</code> still contains a fixed term, and continues the recursion; not satisfying this condition means that there are only remaining arguments in <code>P</code>, and ends the recursion.</p>
<p>Thanks to the tight <code>Drop</code> and the <code>Tail</code> behind it &ndash; which handles both pure arrays and tuples with remaining items &ndash; the recursive part of <code>CurriedV3</code> is identical to <code>CurriedV2</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">type</span> <span class="nx">Drop_Test3</span> <span class="o">=</span> <span class="nx">Drop</span><span class="p">&lt;</span><span class="nt">5</span><span class="err">,</span> <span class="err">[</span><span class="na">1</span><span class="err">,</span> <span class="na">2</span><span class="err">,</span> <span class="na">...3</span><span class="err">[]]</span><span class="p">&gt;;</span>  <span class="c1">// =&gt; 3[]
</span><span class="c1"></span><span class="kr">type</span> <span class="nx">Tail_Test5</span> <span class="o">=</span> <span class="nx">Tail</span><span class="p">&lt;</span><span class="nt">1</span><span class="err">[]</span><span class="p">&gt;;</span>                <span class="c1">// =&gt; 1[]
</span></code></pre></td></tr></table>
</div>
</div><p>If <code>Drop</code> and <code>Tail</code> don&rsquo;t handle the more marginal aspects of the above well enough (e.g. returning <code>never</code> or <code>[]</code> directly), <code>CurriedV1</code> and <code>CurriedV2</code> don&rsquo;t suffer much, but the implementation of <code>CurriedV3</code> is not so easy.</p>
<h2 id="curriedv4-placeholder-support">CurriedV4: Placeholder support</h2>
<p>Placeholders in Curried can help us delay the timing of passing in parameters. For example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="c1">// 普通的调用
</span><span class="c1"></span><span class="nx">curried</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
<span class="c1">// 占位符调用
</span><span class="c1"></span><span class="nx">curried</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nx">__</span><span class="p">,</span> <span class="mi">3</span><span class="p">)(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
<span class="c1">// 甚至
</span><span class="c1"></span><span class="nx">curried</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nx">__</span><span class="p">,</span> <span class="mi">3</span><span class="p">)(</span><span class="nx">__</span><span class="p">,</span> <span class="mi">4</span><span class="p">)(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>This is the goal of <code>CurriedV4</code>. My implementation is.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">type</span> <span class="nx">Equal</span><span class="p">&lt;</span><span class="nt">X</span><span class="err">,</span> <span class="na">Y</span><span class="p">&gt;</span> <span class="o">=</span> <span class="nx">X</span> <span class="kr">extends</span> <span class="nx">Y</span> <span class="o">?</span> <span class="nx">Y</span> <span class="kr">extends</span> <span class="nx">X</span> <span class="o">?</span> <span class="kc">true</span> <span class="o">:</span> <span class="kc">false</span> <span class="o">:</span> <span class="kc">false</span><span class="p">;</span>

<span class="kr">type</span> <span class="nx">Item</span><span class="p">&lt;</span><span class="nt">T</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[]</span><span class="p">&gt;</span> <span class="o">=</span> <span class="nx">T</span> <span class="kr">extends</span> <span class="p">(</span><span class="k">infer</span> <span class="nx">R</span><span class="p">)[]</span> <span class="o">?</span> <span class="nx">R</span> : <span class="kt">never</span><span class="p">;</span>

<span class="kr">type</span> <span class="nx">PlaceholderTuple</span><span class="p">&lt;</span><span class="nt">T</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[],</span> <span class="na">M</span> <span class="na">extends</span> <span class="na">unknown</span><span class="p">&gt;</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="nx">P</span> <span class="k">in</span> <span class="k">keyof</span> <span class="nx">T</span><span class="p">]</span><span class="o">?:</span> <span class="nx">T</span><span class="p">[</span><span class="nx">P</span><span class="p">]</span> <span class="o">|</span> <span class="nx">M</span> <span class="p">}</span> <span class="o">&amp;</span> <span class="kt">unknown</span><span class="p">[];</span>

<span class="kr">type</span> <span class="nx">Reverse</span><span class="p">&lt;</span><span class="nt">T</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[],</span> <span class="na">R</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[]</span> <span class="err">=</span> <span class="err">[]</span><span class="p">&gt;</span> <span class="o">=</span>
    <span class="nx">Equal</span><span class="p">&lt;</span><span class="nt">Length</span><span class="err">&lt;</span><span class="na">T</span><span class="p">&gt;,</span> <span class="kt">number</span><span class="o">&gt;</span> <span class="kr">extends</span> <span class="kc">true</span>
    <span class="o">?</span> <span class="nx">Item</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;[]</span>
    <span class="o">:</span> <span class="nx">T</span> <span class="kr">extends</span> <span class="p">[</span><span class="kt">unknown</span><span class="p">,</span> <span class="p">...</span><span class="kt">unknown</span><span class="p">[]]</span>
    <span class="o">?</span> <span class="nx">Reverse</span><span class="p">&lt;</span><span class="nt">Tail</span><span class="err">&lt;</span><span class="na">T</span><span class="p">&gt;,</span> <span class="nx">Prepend</span><span class="p">&lt;</span><span class="nt">Head</span><span class="err">&lt;</span><span class="na">T</span><span class="p">&gt;,</span> <span class="nx">R</span><span class="o">&gt;&gt;</span>
    <span class="o">:</span> <span class="nx">R</span><span class="p">;</span>

<span class="kr">type</span> <span class="nx">Join</span><span class="p">&lt;</span><span class="nt">P</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[],</span> <span class="na">T</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[]</span><span class="p">&gt;</span> <span class="o">=</span> 
    <span class="nx">P</span> <span class="kr">extends</span> <span class="p">[</span><span class="kt">unknown</span><span class="p">,</span> <span class="p">...</span><span class="kt">unknown</span><span class="p">[]]</span> <span class="o">?</span> <span class="nx">Join</span><span class="p">&lt;</span><span class="nt">Tail</span><span class="err">&lt;</span><span class="na">P</span><span class="p">&gt;,</span> <span class="nx">Prepend</span><span class="p">&lt;</span><span class="nt">Head</span><span class="err">&lt;</span><span class="na">P</span><span class="p">&gt;,</span> <span class="nx">T</span><span class="o">&gt;&gt;</span> <span class="o">:</span> <span class="nx">T</span><span class="p">;</span>

<span class="kr">type</span> <span class="nx">Concat</span><span class="p">&lt;</span><span class="nt">P</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[],</span> <span class="na">T</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[]</span><span class="p">&gt;</span> <span class="o">=</span> <span class="nx">Join</span><span class="p">&lt;</span><span class="nt">Reverse</span><span class="err">&lt;</span><span class="na">P</span><span class="p">&gt;,</span> <span class="nx">T</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kr">type</span> <span class="nx">PlaceholderMatched</span><span class="p">&lt;</span><span class="nt">T</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[],</span> <span class="na">S</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[],</span> <span class="na">M</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">,</span> <span class="na">R</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[]</span> <span class="err">=</span> <span class="err">[]</span><span class="p">&gt;</span> <span class="o">=</span>
    <span class="nx">T</span> <span class="kr">extends</span> <span class="p">[</span><span class="kt">unknown</span><span class="p">,</span> <span class="p">...</span><span class="kt">unknown</span><span class="p">[]]</span>
    <span class="o">?</span> <span class="nx">PlaceholderMatched</span><span class="p">&lt;</span><span class="nt">Tail</span><span class="err">&lt;</span><span class="na">T</span><span class="p">&gt;,</span> <span class="nx">Tail</span><span class="p">&lt;</span><span class="nt">S</span><span class="p">&gt;,</span> <span class="nx">M</span><span class="p">,</span> <span class="nx">Head</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;</span> <span class="kr">extends</span> <span class="nx">M</span> <span class="o">?</span> <span class="nx">Prepend</span><span class="p">&lt;</span><span class="nt">Head</span><span class="err">&lt;</span><span class="na">S</span><span class="p">&gt;,</span> <span class="nx">R</span><span class="o">&gt;</span> <span class="o">:</span> <span class="nx">R</span><span class="o">&gt;</span>
    <span class="o">:</span> <span class="nx">Reverse</span><span class="p">&lt;</span><span class="nt">R</span><span class="p">&gt;;</span>

<span class="kr">type</span> <span class="nx">__</span> <span class="o">=</span> <span class="s1">&#39;__&#39;</span><span class="p">;</span>
<span class="kr">type</span> <span class="nx">CurriedV4</span><span class="p">&lt;</span><span class="nt">P</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[],</span> <span class="na">R</span><span class="p">&gt;</span> <span class="o">=</span>
    <span class="nx">P</span> <span class="kr">extends</span> <span class="p">[</span><span class="kt">unknown</span><span class="p">,</span> <span class="p">...</span><span class="kt">unknown</span><span class="p">[]]</span>
    <span class="o">?</span> <span class="p">&lt;</span><span class="nt">T</span> <span class="na">extends</span> <span class="na">PlaceholderTuple</span><span class="err">&lt;</span><span class="na">P</span><span class="err">,</span> <span class="na">__</span><span class="p">&gt;</span><span class="o">&gt;</span><span class="p">(...</span><span class="nx">args</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span>
        <span class="nx">CurriedV4</span><span class="p">&lt;</span><span class="nt">Concat</span><span class="err">&lt;</span><span class="na">PlaceholderMatched</span><span class="err">&lt;</span><span class="na">T</span><span class="err">,</span> <span class="na">P</span><span class="err">,</span> <span class="na">__</span><span class="p">&gt;,</span> <span class="nx">Drop</span><span class="p">&lt;</span><span class="nt">Length</span><span class="err">&lt;</span><span class="na">T</span><span class="p">&gt;,</span> <span class="nx">P</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="nx">R</span><span class="o">&gt;</span>
    <span class="o">:</span> <span class="nx">R</span><span class="p">;</span>

<span class="kr">type</span> <span class="nx">Curry</span> <span class="o">=</span> <span class="p">&lt;</span><span class="nt">P</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[],</span> <span class="na">R</span><span class="p">&gt;(</span><span class="nx">fn</span><span class="o">:</span> <span class="p">(...</span><span class="nx">args</span>: <span class="kt">P</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">R</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">CurriedV4</span><span class="p">&lt;</span><span class="nt">P</span><span class="err">,</span> <span class="na">R</span><span class="p">&gt;;</span>

<span class="kr">declare</span> <span class="kr">const</span> <span class="nx">curry</span>: <span class="kt">Curry</span><span class="p">;</span>
<span class="kr">declare</span> <span class="kr">const</span> <span class="nx">toCurry</span><span class="o">:</span> <span class="p">(</span><span class="nx">a1</span>: <span class="kt">1</span><span class="p">,</span> <span class="nx">a2</span>: <span class="kt">2</span><span class="p">,</span> <span class="nx">a3</span>: <span class="kt">3</span><span class="p">,</span> <span class="nx">a4</span>: <span class="kt">4</span><span class="p">,</span> <span class="p">...</span><span class="nx">args</span>: <span class="kt">5</span><span class="p">[])</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="p">;</span>
<span class="kr">declare</span> <span class="kr">const</span> <span class="nx">__</span>: <span class="kt">__</span><span class="p">;</span>

<span class="kr">const</span> <span class="nx">curried</span> <span class="o">=</span> <span class="nx">curry</span><span class="p">(</span><span class="nx">toCurry</span><span class="p">);</span>
<span class="nx">curried</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nx">__</span><span class="p">,</span> <span class="mi">3</span><span class="p">)(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>          <span class="c1">// =&gt; 0
</span><span class="c1"></span><span class="nx">curried</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nx">__</span><span class="p">,</span> <span class="mi">3</span><span class="p">)(</span><span class="nx">__</span><span class="p">,</span> <span class="mi">4</span><span class="p">)(</span><span class="mi">2</span><span class="p">);</span>            <span class="c1">// =&gt; 0
</span></code></pre></td></tr></table>
</div>
</div><h2 id="generic-equal">Generic <code>Equal</code></h2>
<p>The generic <code>Equal</code> determines whether two types are exactly equal (note that it is still a set operation, <code>true</code> and <code>false</code> denote a single-element set containing a Boolean value).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">type</span> <span class="nx">Equal</span><span class="p">&lt;</span><span class="nt">X</span><span class="err">,</span> <span class="na">Y</span><span class="p">&gt;</span> <span class="o">=</span> <span class="nx">X</span> <span class="kr">extends</span> <span class="nx">Y</span> <span class="o">?</span> <span class="nx">Y</span> <span class="kr">extends</span> <span class="nx">X</span> <span class="o">?</span> <span class="kc">true</span> <span class="o">:</span> <span class="kc">false</span> <span class="o">:</span> <span class="kc">false</span><span class="p">;</span>

<span class="kr">type</span> <span class="nx">Equal_Test1</span> <span class="o">=</span> <span class="nx">Equal</span><span class="p">&lt;</span><span class="nt">number</span><span class="err">,</span> <span class="na">1</span><span class="p">&gt;;</span>            <span class="c1">// =&gt; false
</span><span class="c1"></span><span class="kr">type</span> <span class="nx">Equal_Test2</span> <span class="o">=</span> <span class="nx">Equal</span><span class="p">&lt;</span><span class="nt">number</span><span class="err">,</span> <span class="na">number</span><span class="p">&gt;;</span>       <span class="c1">// =&gt; true
</span></code></pre></td></tr></table>
</div>
</div><h2 id="generic-item">Generic <code>Item</code></h2>
<p>The generic <code>Item</code> extracts the possible types of array items from the array type.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">type</span> <span class="nx">Item</span><span class="p">&lt;</span><span class="nt">T</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[]</span><span class="p">&gt;</span> <span class="o">=</span> <span class="nx">T</span> <span class="kr">extends</span> <span class="p">(</span><span class="k">infer</span> <span class="nx">R</span><span class="p">)[]</span> <span class="o">?</span> <span class="nx">R</span> : <span class="kt">never</span><span class="p">;</span>

<span class="kr">type</span> <span class="nx">Item_Test1</span> <span class="o">=</span> <span class="nx">Item</span><span class="p">&lt;</span><span class="nt">string</span><span class="err">[]</span><span class="p">&gt;;</span> <span class="c1">// =&gt; string
</span><span class="c1"></span><span class="kr">type</span> <span class="nx">Item_Test2</span> <span class="o">=</span> <span class="nx">Item</span><span class="o">&lt;</span><span class="p">[</span><span class="kt">string</span><span class="p">,</span> <span class="p">...</span><span class="mi">1</span><span class="p">[]]</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// =&gt; string | 1
</span></code></pre></td></tr></table>
</div>
</div><h2 id="the-generic-placeholdertuple">The generic <code>PlaceholderTuple</code></h2>
<p>The generic <code>PlaceholderTuple</code> is very similar to <code>PartialTuple</code> in that it not only makes each item of the tuple optional, but also makes each item of the incoming type <code>M</code> possible.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">type</span> <span class="nx">PlaceholderTuple</span><span class="p">&lt;</span><span class="nt">T</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[],</span> <span class="na">M</span> <span class="na">extends</span> <span class="na">unknown</span><span class="p">&gt;</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="nx">P</span> <span class="k">in</span> <span class="k">keyof</span> <span class="nx">T</span><span class="p">]</span><span class="o">?:</span> <span class="nx">T</span><span class="p">[</span><span class="nx">P</span><span class="p">]</span> <span class="o">|</span> <span class="nx">M</span> <span class="p">}</span> <span class="o">&amp;</span> <span class="kt">unknown</span><span class="p">[];</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="generic-reverse">Generic <code>Reverse</code></h2>
<p>The generic <code>Reverse</code> flips the head and tail of a tuple.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">type</span> <span class="nx">Reverse</span><span class="p">&lt;</span><span class="nt">T</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[],</span> <span class="na">R</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[]</span> <span class="err">=</span> <span class="err">[]</span><span class="p">&gt;</span> <span class="o">=</span>
    <span class="nx">Equal</span><span class="p">&lt;</span><span class="nt">Length</span><span class="err">&lt;</span><span class="na">T</span><span class="p">&gt;,</span> <span class="kt">number</span><span class="o">&gt;</span> <span class="kr">extends</span> <span class="kc">true</span>
    <span class="o">?</span> <span class="nx">Item</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;[]</span>
    <span class="o">:</span> <span class="nx">T</span> <span class="kr">extends</span> <span class="p">[</span><span class="kt">unknown</span><span class="p">,</span> <span class="p">...</span><span class="kt">unknown</span><span class="p">[]]</span>
    <span class="o">?</span> <span class="nx">Reverse</span><span class="p">&lt;</span><span class="nt">Tail</span><span class="err">&lt;</span><span class="na">T</span><span class="p">&gt;,</span> <span class="nx">Prepend</span><span class="p">&lt;</span><span class="nt">Head</span><span class="err">&lt;</span><span class="na">T</span><span class="p">&gt;,</span> <span class="nx">R</span><span class="o">&gt;&gt;</span>
    <span class="o">:</span> <span class="nx">R</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>The generic <code>Reverse</code> deserves a little expansion. Let&rsquo;s look at the core part first (starting with <code>T extends</code>): take the array type <code>T</code>, call itself recursively, and each time recursively take the head element of <code>T</code> and push it from the head into <code>R</code>. When <code>T</code> is exhausted, <code>R</code> is naturally the flipped array.</p>
<p>For fixed-length tuple types, this is fine. But what if you want to flip an array type that is not of fixed length?</p>
<p>By simple induction in the real world, we know that <code>Reverse&lt;string[]&gt;</code> should be <code>string[]</code> and the mapping is still perfect; for <code>Reverse&lt;[string, . . number[]]&gt;</code>, we can only map it to <code>Array&lt;string | number&gt;</code> &ndash; as we said before, generics often return broader types than we expect, and this is unavoidable.</p>
<p>The first two lines of the <code>Reverse</code> implementation (the non-core part) are used to handle the above two types of irregular-length arrays.</p>
<p>To test.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">type</span> <span class="nx">Reverse_Test1</span> <span class="o">=</span> <span class="nx">Reverse</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>                <span class="c1">// =&gt; [3, 2, 1]
</span><span class="c1"></span><span class="kr">type</span> <span class="nx">Reverse_Test2</span> <span class="o">=</span> <span class="nx">Reverse</span><span class="p">&lt;</span><span class="nt">unknown</span><span class="err">[]</span><span class="p">&gt;;</span>                <span class="c1">// =&gt; unknown[]
</span><span class="c1"></span><span class="kr">type</span> <span class="nx">Reverse_Test3</span> <span class="o">=</span> <span class="nx">Reverse</span><span class="o">&lt;</span><span class="p">[</span><span class="kt">string</span><span class="p">,</span> <span class="p">...</span><span class="kt">number</span><span class="p">[]]</span><span class="o">&gt;</span><span class="p">;</span>    <span class="c1">// =&gt; Array&lt;string | number&gt;
</span></code></pre></td></tr></table>
</div>
</div><h2 id="generic-join">Generic <code>Join</code></h2>
<p>The generic <code>Join</code> joins two tuple types &ldquo;head-to-head&rdquo;. Note that the first argument must be the tuple type of the fixed item.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">type</span> <span class="nx">Join</span><span class="p">&lt;</span><span class="nt">P</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[],</span> <span class="na">T</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[]</span><span class="p">&gt;</span> <span class="o">=</span> <span class="nx">P</span> <span class="kr">extends</span> <span class="p">[</span><span class="kt">unknown</span><span class="p">,</span> <span class="p">...</span><span class="kt">unknown</span><span class="p">[]]</span> <span class="o">?</span> <span class="nx">Join</span><span class="p">&lt;</span><span class="nt">Tail</span><span class="err">&lt;</span><span class="na">P</span><span class="p">&gt;,</span> <span class="nx">Prepend</span><span class="p">&lt;</span><span class="nt">Head</span><span class="err">&lt;</span><span class="na">P</span><span class="p">&gt;,</span> <span class="nx">T</span><span class="o">&gt;&gt;</span> <span class="o">:</span> <span class="nx">T</span><span class="p">;</span>

<span class="kr">type</span> <span class="nx">Join_Test1</span> <span class="o">=</span> <span class="nx">Join</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>         <span class="c1">// =&gt; [2, 1, 3, 4]
</span><span class="c1"></span><span class="kr">type</span> <span class="nx">Join_Test2</span> <span class="o">=</span> <span class="nx">Join</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">...</span><span class="mi">4</span><span class="p">[]]</span><span class="o">&gt;</span><span class="p">;</span>    <span class="c1">// =&gt; [2, 1, 3, ...4[]]
</span><span class="c1"></span><span class="kr">type</span> <span class="nx">Join_Test3</span> <span class="o">=</span> <span class="nx">Join</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">...</span><span class="mi">2</span><span class="p">[]],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>    <span class="c1">// =&gt; ts error
</span></code></pre></td></tr></table>
</div>
</div><h2 id="generic-concat">Generic <code>Concat</code></h2>
<p>The generic <code>Concat</code> concatenates two tuple types in order. Similarly, the first argument must be the tuple type of the fixed item.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">type</span> <span class="nx">Concat</span><span class="p">&lt;</span><span class="nt">P</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[],</span> <span class="na">T</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[]</span><span class="p">&gt;</span> <span class="o">=</span> <span class="nx">Join</span><span class="p">&lt;</span><span class="nt">Reverse</span><span class="err">&lt;</span><span class="na">P</span><span class="p">&gt;,</span> <span class="nx">T</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kr">type</span> <span class="nx">Concat_Test1</span> <span class="o">=</span> <span class="nx">Concat</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>         <span class="c1">// =&gt; [1, 2, 3, 4]
</span><span class="c1"></span><span class="kr">type</span> <span class="nx">Concat_Test2</span> <span class="o">=</span> <span class="nx">Concat</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">...</span><span class="mi">4</span><span class="p">[]]</span><span class="o">&gt;</span><span class="p">;</span>    <span class="c1">// =&gt; [1, 2, 3, ...4[]]
</span><span class="c1"></span><span class="kr">type</span> <span class="nx">Concat_Test3</span> <span class="o">=</span> <span class="nx">Concat</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">...</span><span class="mi">2</span><span class="p">[]],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>    <span class="c1">// =&gt; ts error
</span></code></pre></td></tr></table>
</div>
</div><h2 id="generic-placeholdermatched">Generic <code>PlaceholderMatched</code></h2>
<p>The generic <code>PlaceholderMatched</code> finds the items of type <code>M</code> in the tuple <code>T</code>, then extracts the items of the corresponding position from the tuple <code>S</code>, stores them in a new tuple <code>R</code> in order, and finally returns them.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">type</span> <span class="nx">PlaceholderMatched</span><span class="p">&lt;</span><span class="nt">T</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[],</span> <span class="na">S</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[],</span> <span class="na">M</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">,</span> <span class="na">R</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[]</span> <span class="err">=</span> <span class="err">[]</span><span class="p">&gt;</span> <span class="o">=</span>
    <span class="nx">T</span> <span class="kr">extends</span> <span class="p">[</span><span class="kt">unknown</span><span class="p">,</span> <span class="p">...</span><span class="kt">unknown</span><span class="p">[]]</span>
    <span class="o">?</span> <span class="nx">PlaceholderMatched</span><span class="p">&lt;</span><span class="nt">Tail</span><span class="err">&lt;</span><span class="na">T</span><span class="p">&gt;,</span> <span class="nx">Tail</span><span class="p">&lt;</span><span class="nt">S</span><span class="p">&gt;,</span> <span class="nx">M</span><span class="p">,</span> <span class="nx">Head</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;</span> <span class="kr">extends</span> <span class="nx">M</span> <span class="o">?</span> <span class="nx">Prepend</span><span class="p">&lt;</span><span class="nt">Head</span><span class="err">&lt;</span><span class="na">S</span><span class="p">&gt;,</span> <span class="nx">R</span><span class="o">&gt;</span> <span class="o">:</span> <span class="nx">R</span><span class="o">&gt;</span>
    <span class="o">:</span> <span class="nx">Reverse</span><span class="p">&lt;</span><span class="nt">R</span><span class="p">&gt;;</span>
</code></pre></td></tr></table>
</div>
</div><p>A bit of a mouthful. A quick look at the test shows exactly what <code>PlaceholderMatched</code> does.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">type</span> <span class="nx">__</span> <span class="o">=</span> <span class="s1">&#39;__&#39;</span><span class="p">;</span>
<span class="kr">type</span> <span class="nx">PlaceholderMatched_Test1</span> <span class="o">=</span> <span class="nx">PlaceholderMatched</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="nx">__</span><span class="p">,</span> <span class="nx">__</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="nx">__</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// =&gt; [2, 3]
</span></code></pre></td></tr></table>
</div>
</div><h2 id="the-generic-type-curriedv4">The generic type <code>CurriedV4</code></h2>
<p>Finally, the full body of the Curried function type, <code>CurriedV4</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">type</span> <span class="nx">__</span> <span class="o">=</span> <span class="s1">&#39;__&#39;</span><span class="p">;</span>

<span class="kr">type</span> <span class="nx">CurriedV4</span><span class="p">&lt;</span><span class="nt">P</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[],</span> <span class="na">R</span><span class="p">&gt;</span> <span class="o">=</span>
    <span class="nx">P</span> <span class="kr">extends</span> <span class="p">[</span><span class="kt">unknown</span><span class="p">,</span> <span class="p">...</span><span class="kt">unknown</span><span class="p">[]]</span>
    <span class="o">?</span> <span class="p">&lt;</span><span class="nt">T</span> <span class="na">extends</span> <span class="na">PlaceholderTuple</span><span class="err">&lt;</span><span class="na">P</span><span class="err">,</span> <span class="na">__</span><span class="p">&gt;</span><span class="o">&gt;</span><span class="p">(...</span><span class="nx">args</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span>
        <span class="nx">CurriedV4</span><span class="p">&lt;</span><span class="nt">Concat</span><span class="err">&lt;</span><span class="na">PlaceholderMatched</span><span class="err">&lt;</span><span class="na">T</span><span class="err">,</span> <span class="na">P</span><span class="err">,</span> <span class="na">__</span><span class="p">&gt;,</span> <span class="nx">Drop</span><span class="p">&lt;</span><span class="nt">Length</span><span class="err">&lt;</span><span class="na">T</span><span class="p">&gt;,</span> <span class="nx">P</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="nx">R</span><span class="o">&gt;</span>
    <span class="o">:</span> <span class="nx">R</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>The difference between <code>CurriedV4</code> and <code>CurriedV3</code> is in the recursive part. We use <code>PlaceholderTuple&lt;P, __&gt;</code> to constrain the entry of the curried function so that the caller can pass in the placeholder constant <code>__</code>.</p>
<p>In a single recursion, we extract the tuple type consisting of the <code>PlaceholderMatched&lt;T, P, __&gt;</code> and concatenate it with the remaining arguments after this call consumes them (i.e. <code>Drop&lt;Length&lt;T&gt;, P&gt;&gt;</code>) as the new argument <code>P</code> to be passed into the next recursion.</p>
<p>Test it out, perfect.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">type</span> <span class="nx">Curry</span> <span class="o">=</span> <span class="p">&lt;</span><span class="nt">P</span> <span class="na">extends</span> <span class="na">unknown</span><span class="err">[],</span> <span class="na">R</span><span class="p">&gt;(</span><span class="nx">fn</span><span class="o">:</span> <span class="p">(...</span><span class="nx">args</span>: <span class="kt">P</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">R</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">CurriedV4</span><span class="p">&lt;</span><span class="nt">P</span><span class="err">,</span> <span class="na">R</span><span class="p">&gt;;</span>

<span class="kr">declare</span> <span class="kr">const</span> <span class="nx">curry</span>: <span class="kt">Curry</span><span class="p">;</span>
<span class="kr">declare</span> <span class="kr">const</span> <span class="nx">toCurry</span><span class="o">:</span> <span class="p">(</span><span class="nx">a1</span>: <span class="kt">1</span><span class="p">,</span> <span class="nx">a2</span>: <span class="kt">2</span><span class="p">,</span> <span class="nx">a3</span>: <span class="kt">3</span><span class="p">,</span> <span class="nx">a4</span>: <span class="kt">4</span><span class="p">,</span> <span class="p">...</span><span class="nx">args</span>: <span class="kt">5</span><span class="p">[])</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="p">;</span>
<span class="kr">declare</span> <span class="kr">const</span> <span class="nx">__</span>: <span class="kt">__</span><span class="p">;</span>

<span class="kr">const</span> <span class="nx">curried</span> <span class="o">=</span> <span class="nx">curry</span><span class="p">(</span><span class="nx">toCurry</span><span class="p">);</span>

<span class="nx">curried</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nx">__</span><span class="p">,</span> <span class="mi">3</span><span class="p">)(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>          <span class="c1">// =&gt; 0
</span><span class="c1">// =&gt; CurriedV4&lt;[1, 2, 3, 4, ...5[]], 0&gt; =&gt; CurriedV4&lt;[2, 4, ...5[]], 0&gt;
</span><span class="c1"></span>
<span class="nx">curried</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nx">__</span><span class="p">,</span> <span class="mi">3</span><span class="p">)(</span><span class="nx">__</span><span class="p">,</span> <span class="mi">4</span><span class="p">)(</span><span class="mi">2</span><span class="p">);</span>            <span class="c1">// =&gt; 0
</span><span class="c1">// =&gt; CurriedV4&lt;[1, 2, 3, 4, ...5[]], 0&gt; =&gt; CurriedV4&lt;[2, 4, ...5[]], 0&gt; =&gt; CurriedV4&lt;[2, ...5[]], 0&gt;
</span></code></pre></td></tr></table>
</div>
</div><h2 id="summary">Summary</h2>
<p>Although the discussion of collections in this article has focused on the first half, what prompted me to think about it was actually the practice of a few more advanced scenarios that followed. I found that it seemed clearer to apply the insights from these practices to the very first few simple generic types to make a statement.</p>
<p>In the original article, the base generic at the beginning is not very tight, for example, the <code>Head</code> generic looks like this.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">type</span> <span class="nx">Head</span><span class="p">&lt;</span><span class="nt">T</span> <span class="na">extends</span> <span class="na">any</span><span class="err">[]</span><span class="p">&gt;</span> <span class="o">=</span> <span class="nx">T</span> <span class="kr">extends</span> <span class="p">[</span><span class="kt">any</span><span class="p">,</span> <span class="p">...</span><span class="kt">any</span><span class="p">[]]</span> <span class="o">?</span> <span class="nx">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">:</span> <span class="kt">never</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>This results in <code>Head&lt;string[]&gt;</code> returning <code>never</code>, which is clearly not what it looks like from a collection perspective.</p>
<p>Many of the base types in the original text had edge use cases that were not handled properly, so as the problem became more complex, the generic implementation became less and less controllable. Later the original authors started introducing <code>Cast</code> generic types to force back inaccurate types that were derived to the edge.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="kr">type</span> <span class="nx">Cast</span><span class="p">&lt;</span><span class="nt">X</span><span class="err">,</span> <span class="na">Y</span><span class="p">&gt;</span> <span class="o">=</span> <span class="nx">X</span> <span class="kr">extends</span> <span class="nx">Y</span> <span class="o">?</span> <span class="nx">X</span> : <span class="kt">Y</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>This led me to think about what these basic generic types <strong>should</strong> be implemented as. In repeated practice, I found that the code written by intuition was often not accurate enough, and for a moment, I realized that what I was missing was a set perspective; once I understood the essence of generic operations from a set perspective, I seemed to have a sense of clarity: what I could do and what I could not do, where I could compromise and where I could only give up, I could analyze them all with certainty.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/typescript/">typescript</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-03/useeffect-and-uselayouteffect/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">The difference between useEffect and useLayoutEffect</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-03/use-mock-to-test/">
            <span class="next-text nav-default">Using Mock and Interface for Golang Unit Testing</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
