<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Dissecting Smart Pointers Rc Weak and Arc - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="We know that rust ownership has three principles: For each value, there is an owner. A value can only have one owner at a time. When the owner leaves the scope, the corresponding value is automatically dropped. But sometimes a value is shared by multiple variables. Also it cannot be solved by reference, because there is no way to determine which variable ended up last and there is no way" /><meta name="keywords" content="rust, Smart Pointer, Rc Weak, Arc" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-03/smart-pointer-rc-weak-arc/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Dissecting Smart Pointers Rc Weak and Arc" />
<meta property="og:description" content="We know that rust ownership has three principles: For each value, there is an owner. A value can only have one owner at a time. When the owner leaves the scope, the corresponding value is automatically dropped. But sometimes a value is shared by multiple variables. Also it cannot be solved by reference, because there is no way to determine which variable ended up last and there is no way" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-03/smart-pointer-rc-weak-arc/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-03-08T14:59:56+08:00" />
<meta property="article:modified_time" content="2022-03-08T14:59:56+08:00" />

<meta itemprop="name" content="Dissecting Smart Pointers Rc Weak and Arc">
<meta itemprop="description" content="We know that rust ownership has three principles: For each value, there is an owner. A value can only have one owner at a time. When the owner leaves the scope, the corresponding value is automatically dropped. But sometimes a value is shared by multiple variables. Also it cannot be solved by reference, because there is no way to determine which variable ended up last and there is no way"><meta itemprop="datePublished" content="2022-03-08T14:59:56+08:00" />
<meta itemprop="dateModified" content="2022-03-08T14:59:56+08:00" />
<meta itemprop="wordCount" content="2038">
<meta itemprop="keywords" content="rust," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Dissecting Smart Pointers Rc Weak and Arc"/>
<meta name="twitter:description" content="We know that rust ownership has three principles: For each value, there is an owner. A value can only have one owner at a time. When the owner leaves the scope, the corresponding value is automatically dropped. But sometimes a value is shared by multiple variables. Also it cannot be solved by reference, because there is no way to determine which variable ended up last and there is no way"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Dissecting Smart Pointers Rc Weak and Arc</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-03-08 14:59:56 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 2038 words </span>
          <span class="more-meta"> 5 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#view-reference-count">View reference count</a></li>
        <li><a href="#circular-references">Circular references</a></li>
        <li><a href="#thread-safe-arc">Thread-safe Arc</a></li>
        <li><a href="#underlying-implementation">Underlying implementation</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/08/a834d88074fc4bd7b4bf46b669e03950.png" alt="rust"></p>
<p>We know that rust ownership has three principles:</p>
<ul>
<li>For each value, there is an owner.</li>
<li>A value can only have one owner at a time.</li>
<li>When the owner leaves the scope, the corresponding value is automatically dropped.</li>
</ul>
<p>But sometimes a value is shared by multiple variables. Also it cannot be solved by reference, because there is no way to determine which variable ended up last and there is no way to determine the lifecycle. So this is where the <code>Rc</code> reference count smart pointer comes in handy, <strong><code>Rc</code> shares ownership and adds one for each reference, and subtracts one when it leaves scope, and executes a destructor when the reference count is 0</strong>.</p>
<p><code>Rc</code> is not thread-safe, cross-threaded, you need to use <code>Arc</code>, where <code>A</code> is the atomic atom.</p>
<h2 id="view-reference-count">View reference count</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">rc</span>::<span class="n">Rc</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rc</span>::<span class="n">new</span><span class="p">(</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;https://mytechshares.com/&#34;</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;ref count is {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">Rc</span>::<span class="n">strong_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rc</span>::<span class="n">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;ref count is {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">Rc</span>::<span class="n">strong_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rc</span>::<span class="n">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;ref count is {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">Rc</span>::<span class="n">strong_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">));</span><span class="w">
</span><span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;ref count is {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">Rc</span>::<span class="n">strong_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;ref count is {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">Rc</span>::<span class="n">strong_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">));</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>strong_count</code> checks the reference count, the variable <code>c</code> is in inner lexical scope and prints the reference count before leaving the scope.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="w">    </span><span class="n">Finished</span><span class="w"> </span><span class="n">dev</span><span class="w"> </span><span class="p">[</span><span class="n">unoptimized</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">debuginfo</span><span class="p">]</span><span class="w"> </span><span class="n">target</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mf">0.03</span><span class="n">s</span><span class="w">
</span><span class="w">     </span><span class="n">Running</span><span class="w"> </span><span class="err">`</span><span class="n">target</span><span class="o">/</span><span class="n">debug</span><span class="o">/</span><span class="n">hello_cargo</span><span class="err">`</span><span class="w">
</span><span class="w"></span><span class="k">ref</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="w"></span><span class="k">ref</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="mi">2</span><span class="w">
</span><span class="w"></span><span class="k">ref</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="mi">3</span><span class="w">
</span><span class="w"></span><span class="k">ref</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="mi">3</span><span class="w">
</span><span class="w"></span><span class="k">ref</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="mi">2</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>Each time a reference is added, the count is added by one. In the inner statement block, the count is 3, but when left, the count is reduced to 2.</p>
<h2 id="circular-references">Circular references</h2>
<p>Anyone familiar with Garbage Collection knows that there are GC algorithms that rely on reference counting, such as the python implementation. For example, the Redis object is also implemented with rc. Since redis <code>rc</code> is not exposed to the user, as long as you pay attention to the direction of the reference when writing code, you won&rsquo;t write circular references, but rust <code>Rc</code> is unavoidable.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">rc</span>::<span class="n">Rc</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">cell</span>::<span class="n">RefCell</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Node</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">next</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">Drop</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Node</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;Dropping https://mytechshares.com 董泽润的技术笔记&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rc</span>::<span class="n">new</span><span class="p">(</span><span class="n">RefCell</span>::<span class="n">new</span><span class="p">(</span><span class="n">Node</span><span class="w"> </span><span class="p">{</span><span class="n">next</span>: <span class="nb">None</span><span class="p">}));</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">second</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rc</span>::<span class="n">new</span><span class="p">(</span><span class="n">RefCell</span>::<span class="n">new</span><span class="p">(</span><span class="n">Node</span><span class="w"> </span><span class="p">{</span><span class="n">next</span>: <span class="nb">None</span><span class="p">}));</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">third</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rc</span>::<span class="n">new</span><span class="p">(</span><span class="n">RefCell</span>::<span class="n">new</span><span class="p">(</span><span class="n">Node</span><span class="w"> </span><span class="p">{</span><span class="n">next</span>: <span class="nb">None</span><span class="p">}));</span><span class="w">
</span><span class="w">    </span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">).</span><span class="n">borrow_mut</span><span class="p">().</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">Rc</span>::<span class="n">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">second</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="p">(</span><span class="o">*</span><span class="n">second</span><span class="p">).</span><span class="n">borrow_mut</span><span class="p">().</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">Rc</span>::<span class="n">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">third</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="p">(</span><span class="o">*</span><span class="n">third</span><span class="p">).</span><span class="n">borrow_mut</span><span class="p">().</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">Rc</span>::<span class="n">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">first</span><span class="p">));</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>This is a representative of a circular chain table, a little bit around, the principle is first -&gt; second -&gt; third, while third -&gt; first, the code runs, and does not print <code>Dropping https://mytechshares.com 董泽润的技术笔记</code></p>
<p>The <code>RefCell</code> , <code>borrow_mut</code> are a bit hard to understand, I just learned rust when it has been difficult to understand. The next article will explain in detail. <strong>Simply put, <code>RefCell</code> , <code>Cell</code> provides a mechanism called <code>internal mutability</code>, because <code>Rc</code> shares the ownership of variables, so it requires that only reads and no modifications are allowed. Then the value inside <code>Rc</code> wraps around a layer of <code>RefCell</code> , <code>Cell</code> to avoid compiler checks and turn it into a runtime check, which is equivalent to opening a back door</strong> . This design pattern is used a lot in Rust.</p>
<p>So how do you fix this circular reference? The answer is the <code>Weak</code> pointer, which only increases the reference logic and does not share ownership, i.e. it does not increase the strong reference count.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">rc</span>::<span class="n">Rc</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">rc</span>::<span class="n">Weak</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">cell</span>::<span class="n">RefCell</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Node</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">next</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Rc</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">head</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Weak</span><span class="o">&lt;</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">Drop</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Node</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;Dropping https://mytechshares.com 董泽润的技术笔记&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rc</span>::<span class="n">new</span><span class="p">(</span><span class="n">RefCell</span>::<span class="n">new</span><span class="p">(</span><span class="n">Node</span><span class="w"> </span><span class="p">{</span><span class="n">next</span>: <span class="nb">None</span><span class="p">,</span><span class="w"> </span><span class="n">head</span>: <span class="nb">None</span><span class="p">}));</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">second</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rc</span>::<span class="n">new</span><span class="p">(</span><span class="n">RefCell</span>::<span class="n">new</span><span class="p">(</span><span class="n">Node</span><span class="w"> </span><span class="p">{</span><span class="n">next</span>: <span class="nb">None</span><span class="p">,</span><span class="w"> </span><span class="n">head</span>: <span class="nb">None</span><span class="p">}));</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">third</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rc</span>::<span class="n">new</span><span class="p">(</span><span class="n">RefCell</span>::<span class="n">new</span><span class="p">(</span><span class="n">Node</span><span class="w"> </span><span class="p">{</span><span class="n">next</span>: <span class="nb">None</span><span class="p">,</span><span class="w"> </span><span class="n">head</span>: <span class="nb">None</span><span class="p">}));</span><span class="w">
</span><span class="w">    </span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">).</span><span class="n">borrow_mut</span><span class="p">().</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">Rc</span>::<span class="n">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">second</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="p">(</span><span class="o">*</span><span class="n">second</span><span class="p">).</span><span class="n">borrow_mut</span><span class="p">().</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">Rc</span>::<span class="n">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">third</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="p">(</span><span class="o">*</span><span class="n">third</span><span class="p">).</span><span class="n">borrow_mut</span><span class="p">().</span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">Rc</span>::<span class="n">downgrade</span><span class="p">(</span><span class="o">&amp;</span><span class="n">first</span><span class="p">));</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>This is the fixed code, adding a <code>head</code> field, a pointer of type <code>Weak</code>, and generating a weak reference to first via <code>Rc::downgrade</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust">#<span class="w"> </span><span class="n">cargo</span><span class="w"> </span><span class="n">run</span><span class="w">
</span><span class="w">   </span><span class="n">Compiling</span><span class="w"> </span><span class="n">hello_cargo</span><span class="w"> </span><span class="n">v0</span><span class="p">.</span><span class="mf">1.0</span><span class="w"> </span><span class="p">(</span><span class="o">/</span><span class="n">root</span><span class="o">/</span><span class="n">zerun</span><span class="p">.</span><span class="n">dong</span><span class="o">/</span><span class="n">code</span><span class="o">/</span><span class="n">rusttest</span><span class="o">/</span><span class="n">hello_cargo</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="n">Finished</span><span class="w"> </span><span class="n">dev</span><span class="w"> </span><span class="p">[</span><span class="n">unoptimized</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">debuginfo</span><span class="p">]</span><span class="w"> </span><span class="n">target</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mf">2.63</span><span class="n">s</span><span class="w">
</span><span class="w">     </span><span class="n">Running</span><span class="w"> </span><span class="err">`</span><span class="n">target</span><span class="o">/</span><span class="n">debug</span><span class="o">/</span><span class="n">hello_cargo</span><span class="err">`</span><span class="w">
</span><span class="w"></span><span class="n">Dropping</span><span class="w"> </span><span class="n">https</span>:<span class="c1">//mytechshares.com 董泽润的技术笔记
</span><span class="c1"></span><span class="n">Dropping</span><span class="w"> </span><span class="n">https</span>:<span class="c1">//mytechshares.com 董泽润的技术笔记
</span><span class="c1"></span><span class="n">Dropping</span><span class="w"> </span><span class="n">https</span>:<span class="c1">//mytechshares.com 董泽润的技术笔记
</span></code></pre></td></tr></table>
</div>
</div><p>After running, we see that the Dropping message is printed three times, as expected. Also, since the object pointed to by the <code>Weak</code> pointer may be destructured, you can&rsquo;t dereference it directly, you have to pattern match and then upgrade.</p>
<h2 id="thread-safe-arc">Thread-safe Arc</h2>
<p>Let&rsquo;s look at an example of concurrent variable modification, from <a href="https://doc.rust-lang.org/book/ch16-03-shared-state.html#atomic-reference-counting-with-arct">the rust book official website</a>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">sync</span>::<span class="p">{</span><span class="n">Arc</span><span class="p">,</span><span class="w"> </span><span class="n">Mutex</span><span class="p">};</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">thread</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Arc</span>::<span class="n">new</span><span class="p">(</span><span class="n">Mutex</span>::<span class="n">new</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">handles</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[];</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="mi">10</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Arc</span>::<span class="n">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">counter</span><span class="p">);</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">handle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">thread</span>::<span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">counter</span><span class="p">.</span><span class="n">lock</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">            </span><span class="o">*</span><span class="n">num</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="p">});</span><span class="w">
</span><span class="w">        </span><span class="n">handles</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">handle</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">handles</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">handle</span><span class="p">.</span><span class="n">join</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;董泽润的技术笔记 Got Result: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">counter</span><span class="p">.</span><span class="n">lock</span><span class="p">().</span><span class="n">unwrap</span><span class="p">());</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>spawn opens 10 threads, concurrently adds one to counter, and prints it after the final run.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust">#<span class="w"> </span><span class="n">cargo</span><span class="w"> </span><span class="n">run</span><span class="w">
</span><span class="w">   </span><span class="n">Compiling</span><span class="w"> </span><span class="n">hello_cargo</span><span class="w"> </span><span class="n">v0</span><span class="p">.</span><span class="mf">1.0</span><span class="w"> </span><span class="p">(</span><span class="o">/</span><span class="n">root</span><span class="o">/</span><span class="n">zerun</span><span class="p">.</span><span class="n">dong</span><span class="o">/</span><span class="n">code</span><span class="o">/</span><span class="n">rusttest</span><span class="o">/</span><span class="n">hello_cargo</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="n">Finished</span><span class="w"> </span><span class="n">dev</span><span class="w"> </span><span class="p">[</span><span class="n">unoptimized</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">debuginfo</span><span class="p">]</span><span class="w"> </span><span class="n">target</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mf">3.72</span><span class="n">s</span><span class="w">
</span><span class="w">     </span><span class="n">Running</span><span class="w"> </span><span class="err">`</span><span class="n">target</span><span class="o">/</span><span class="n">debug</span><span class="o">/</span><span class="n">hello_cargo</span><span class="err">`</span><span class="w">
</span><span class="w"></span><span class="err">董泽润的技术笔记</span><span class="w">  </span><span class="n">Got</span><span class="w"> </span><span class="nb">Result</span>: <span class="mi">10</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>When I first learned it was really hard to understand, even concurrently modify variables are so troublesome, all kinds of <code>Arc</code> set <code>Mutex</code> , in fact, this is to achieve zero-cost runtime security, someone always have to do the GC side of the work.</p>
<p>And <strong>all kinds of wrapper does not prevent reading the source code, just ignore it and focus on the code logic, only when writing need to think carefully</strong>.</p>
<h2 id="underlying-implementation">Underlying implementation</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[stable(feature = </span><span class="s">&#34;rust1&#34;</span><span class="cp">, since = </span><span class="s">&#34;1.0.0&#34;</span><span class="cp">)]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Rc</span><span class="o">&lt;</span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">ptr</span>: <span class="nc">NonNull</span><span class="o">&lt;</span><span class="n">RcBox</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">phantom</span>: <span class="nc">PhantomData</span><span class="o">&lt;</span><span class="n">RcBox</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[repr(C)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">RcBox</span><span class="o">&lt;</span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">strong</span>: <span class="nc">Cell</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">weak</span>: <span class="nc">Cell</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">value</span>: <span class="nc">T</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>Rc</code> is a structure, two fields <code>ptr</code> , <code>phantom</code> members are <code>RcBox</code> type, note that there are <code>strong</code> , <code>weak</code> count fields and real data <code>value</code> fields, see again the <code>Cell</code> to achieve the internal variable</p>
<p><code>PhantomData</code> is a ghost data type, refer to nomicon documentation, the general scenario is.</p>
<blockquote>
<p>When writing non-safe code, we often encounter situations where a type or lifecycle is logically associated with a structure, but is not a member of any of its members. This is particularly common for lifecycles.</p>
</blockquote>
<blockquote>
<p>PhantomData does not consume storage space, it just simulates some type of data for static analysis. Doing so is less error-prone than explicitly telling the type system what variability you need, and also provides the information needed for drop checking.</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="n">Zero</span><span class="o">-</span><span class="n">sized</span><span class="w"> </span><span class="k">type</span> <span class="nc">used</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">mark</span><span class="w"> </span><span class="n">things</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="s">&#34;act like&#34;</span><span class="w"> </span><span class="n">they</span><span class="w"> </span><span class="n">own</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="err">`</span><span class="n">T</span><span class="err">`</span><span class="p">.</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="n">Adding</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="err">`</span><span class="n">PhantomData</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="err">`</span><span class="w"> </span><span class="n">field</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">your</span><span class="w"> </span><span class="k">type</span> <span class="nc">tells</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">compiler</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">your</span><span class="w">
</span><span class="w"></span><span class="k">type</span> <span class="nc">acts</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">though</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">stores</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="k">type</span> <span class="err">`</span><span class="n">T</span><span class="err">`</span><span class="p">,</span><span class="w"> </span><span class="n">even</span><span class="w"> </span><span class="n">though</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">doesn</span><span class="o">&#39;</span><span class="na">t</span><span class="w">
</span><span class="w"></span><span class="n">really</span><span class="p">.</span><span class="w"> </span><span class="n">This</span><span class="w"> </span><span class="n">information</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">used</span><span class="w"> </span><span class="n">when</span><span class="w"> </span><span class="n">computing</span><span class="w"> </span><span class="n">certain</span><span class="w"> </span><span class="n">safety</span><span class="w"> </span><span class="n">properties</span><span class="p">.</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>Simply put, <code>PhantomData</code> is a zero-length placeholder that tells the compiler that it looks like I own the T, but it doesn&rsquo;t belong to me, and also calls drop to release the T if it is destructured. Because of the phantom field, <code>Rc</code> does not own <code>RcBox</code>, <code>NonNull</code> tells the compiler that the pointer ptr must not be null and you can optimize it, and <code>Option&lt;Rc&lt;T&gt;&gt;</code> occupies the same size as <code>Rc&lt;T&gt;</code>, removing the flag field for whether it is null or not.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">value</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Rc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// There is an implicit weak pointer owned by all the strong
</span><span class="c1"></span><span class="w">    </span><span class="c1">// pointers, which ensures that the weak destructor never frees
</span><span class="c1"></span><span class="w">    </span><span class="c1">// the allocation while the strong destructor is running, even
</span><span class="c1"></span><span class="w">    </span><span class="c1">// if the weak pointer is stored inside the strong one.
</span><span class="c1"></span><span class="w">    </span><span class="bp">Self</span>::<span class="n">from_inner</span><span class="p">(</span><span class="w">
</span><span class="w">        </span><span class="nb">Box</span>::<span class="n">leak</span><span class="p">(</span><span class="k">box</span><span class="w"> </span><span class="n">RcBox</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">strong</span>: <span class="nc">Cell</span>::<span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">weak</span>: <span class="nc">Cell</span>::<span class="n">new</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="p">}).</span><span class="n">into</span><span class="p">(),</span><span class="w">
</span><span class="w">    </span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>From the initialization <code>Rc::new</code> code, we see that the initial strong, weak count is 1.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[stable(feature = </span><span class="s">&#34;rust1&#34;</span><span class="cp">, since = </span><span class="s">&#34;1.0.0&#34;</span><span class="cp">)]</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Clone</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Rc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="cp">#[inline]</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Rc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">inner</span><span class="p">().</span><span class="n">inc_strong</span><span class="p">();</span><span class="w">
</span><span class="w">        </span><span class="bp">Self</span>::<span class="n">from_inner</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">ptr</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Rc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="cp">#[inline(always)]</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">inner</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">RcBox</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// This unsafety is ok because while this Rc is alive we&#39;re guaranteed
</span><span class="c1"></span><span class="w">        </span><span class="c1">// that the inner pointer is valid.
</span><span class="c1"></span><span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">ptr</span><span class="p">.</span><span class="n">as_ref</span><span class="p">()</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">inc_strong</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">strong</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">strong</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">  </span><span class="c1">// We want to abort on overflow instead of dropping the value.
</span><span class="c1"></span><span class="w">  </span><span class="c1">// The reference count will never be zero when this is called;
</span><span class="c1"></span><span class="w">  </span><span class="c1">// nevertheless, we insert an abort here to hint LLVM at
</span><span class="c1"></span><span class="w">  </span><span class="c1">// an otherwise missed optimization.
</span><span class="c1"></span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="n">strong</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">strong</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kt">usize</span>::<span class="n">MAX</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">      </span><span class="n">abort</span><span class="p">();</span><span class="w">
</span><span class="w">  </span><span class="p">}</span><span class="w">
</span><span class="w">  </span><span class="bp">self</span><span class="p">.</span><span class="n">strong_ref</span><span class="p">().</span><span class="n">set</span><span class="p">(</span><span class="n">strong</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w"> 
</span></code></pre></td></tr></table>
</div>
</div><p><code>Rc::clone</code> does not copy the data, it only increases the strong ref count.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[stable(feature = </span><span class="s">&#34;rust1&#34;</span><span class="cp">, since = </span><span class="s">&#34;1.0.0&#34;</span><span class="cp">)]</span><span class="w">
</span><span class="w"></span><span class="k">unsafe</span><span class="w"> </span><span class="k">impl</span><span class="o">&lt;</span><span class="cp">#[may_dangle]</span><span class="w"> </span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Drop</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Rc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">inner</span><span class="p">().</span><span class="n">dec_strong</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">inner</span><span class="p">().</span><span class="n">strong</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="c1">// destroy the contained object
</span><span class="c1"></span><span class="w">                </span><span class="n">ptr</span>::<span class="n">drop_in_place</span><span class="p">(</span><span class="bp">Self</span>::<span class="n">get_mut_unchecked</span><span class="p">(</span><span class="bp">self</span><span class="p">));</span><span class="w">
</span><span class="w">
</span><span class="w">                </span><span class="c1">// remove the implicit &#34;strong weak&#34; pointer now that we&#39;ve
</span><span class="c1"></span><span class="w">                </span><span class="c1">// destroyed the contents.
</span><span class="c1"></span><span class="w">                </span><span class="bp">self</span><span class="p">.</span><span class="n">inner</span><span class="p">().</span><span class="n">dec_weak</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">inner</span><span class="p">().</span><span class="n">weak</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                    </span><span class="n">Global</span><span class="p">.</span><span class="n">deallocate</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">ptr</span><span class="p">.</span><span class="n">cast</span><span class="p">(),</span><span class="w"> </span><span class="n">Layout</span>::<span class="n">for_value</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">ptr</span><span class="p">.</span><span class="n">as_ref</span><span class="p">()));</span><span class="w">
</span><span class="w">                </span><span class="p">}</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>You can see that <code>drop</code> first does a count minus one operation, and if the strong ref count reaches 0, it starts to destruct and release the object. At the same time, if the weak ref count reaches 0, <code>RcBox</code> is released, which means that <code>RcBox</code> and <code>Value T</code> are released separately.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Arc</span><span class="o">&lt;</span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">ptr</span>: <span class="nc">NonNull</span><span class="o">&lt;</span><span class="n">ArcInner</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">phantom</span>: <span class="nc">PhantomData</span><span class="o">&lt;</span><span class="n">ArcInner</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">ArcInner</span><span class="o">&lt;</span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">strong</span>: <span class="nc">atomic</span>::<span class="n">AtomicUsize</span><span class="p">,</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// the value usize::MAX acts as a sentinel for temporarily &#34;locking&#34; the
</span><span class="c1"></span><span class="w">    </span><span class="c1">// ability to upgrade weak pointers or downgrade strong ones; this is used
</span><span class="c1"></span><span class="w">    </span><span class="c1">// to avoid races in `make_mut` and `get_mut`.
</span><span class="c1"></span><span class="w">    </span><span class="n">weak</span>: <span class="nc">atomic</span>::<span class="n">AtomicUsize</span><span class="p">,</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="n">data</span>: <span class="nc">T</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>And the count inside <code>Arc</code> is guaranteed atomic with atomic, so it is concurrent word full.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[stable(feature = </span><span class="s">&#34;rc_weak&#34;</span><span class="cp">, since = </span><span class="s">&#34;1.4.0&#34;</span><span class="cp">)]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Weak</span><span class="o">&lt;</span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="c1">// This is a `NonNull` to allow optimizing the size of this type in enums,
</span><span class="c1"></span><span class="w">    </span><span class="c1">// but it is not necessarily a valid pointer.
</span><span class="c1"></span><span class="w">    </span><span class="c1">// `Weak::new` sets this to `usize::MAX` so that it doesn’t need
</span><span class="c1"></span><span class="w">    </span><span class="c1">// to allocate space on the heap.  That&#39;s not a value a real pointer
</span><span class="c1"></span><span class="w">    </span><span class="c1">// will ever have because RcBox has alignment at least 2.
</span><span class="c1"></span><span class="w">    </span><span class="c1">// This is only possible when `T: Sized`; unsized `T` never dangle.
</span><span class="c1"></span><span class="w">    </span><span class="n">ptr</span>: <span class="nc">NonNull</span><span class="o">&lt;</span><span class="n">RcBox</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[stable(feature = </span><span class="s">&#34;rc_weak&#34;</span><span class="cp">, since = </span><span class="s">&#34;1.4.0&#34;</span><span class="cp">)]</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">downgrade</span><span class="p">(</span><span class="n">this</span>: <span class="kp">&amp;</span><span class="nc">Self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Weak</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">this</span><span class="p">.</span><span class="n">inner</span><span class="p">().</span><span class="n">inc_weak</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="c1">// Make sure we do not create a dangling Weak
</span><span class="c1"></span><span class="w">    </span><span class="fm">debug_assert!</span><span class="p">(</span><span class="o">!</span><span class="n">is_dangling</span><span class="p">(</span><span class="n">this</span><span class="p">.</span><span class="n">ptr</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">()));</span><span class="w">
</span><span class="w">    </span><span class="n">Weak</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">ptr</span>: <span class="nc">this</span><span class="p">.</span><span class="n">ptr</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="n">s</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><code>Rc::downgrade</code> generate <code>Weak</code> logic is also relatively simple, <code>inc_weak</code> add weak ref count weak reference count, and then return <code>Weak</code>.</p>
<p>There are many source implementations, it is a little difficult to understand, more google check, and then read the comments, interested in their own view.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/rust/">rust</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-03/rust-box/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">The Box Smart Pointer in Rust</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-03/rust-why-need-interior-mutability/">
            <span class="next-text nav-default">Why Rust Needs Internal Variability</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
