<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>String builder in C# - StringBuilder - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="In everyday development StringBuilder must be used by everyone, even a lot. After all, we all know the unwritten norm that StringBuilder&amp;rsquo;s performance is higher than direct string splicing when a large number of strings need to be constructed at high frequencies, because using &#43; or &#43;= directly will generate a new String instance, because String objects are immutable objects, which means that each time the string This means that" /><meta name="keywords" content="c#, Stringbuilder" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-03/csharp-stringbuilder/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="String builder in C# - StringBuilder" />
<meta property="og:description" content="In everyday development StringBuilder must be used by everyone, even a lot. After all, we all know the unwritten norm that StringBuilder&rsquo;s performance is higher than direct string splicing when a large number of strings need to be constructed at high frequencies, because using &#43; or &#43;= directly will generate a new String instance, because String objects are immutable objects, which means that each time the string This means that" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-03/csharp-stringbuilder/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-03-03T15:29:01+08:00" />
<meta property="article:modified_time" content="2022-03-03T15:29:01+08:00" />

<meta itemprop="name" content="String builder in C# - StringBuilder">
<meta itemprop="description" content="In everyday development StringBuilder must be used by everyone, even a lot. After all, we all know the unwritten norm that StringBuilder&rsquo;s performance is higher than direct string splicing when a large number of strings need to be constructed at high frequencies, because using &#43; or &#43;= directly will generate a new String instance, because String objects are immutable objects, which means that each time the string This means that"><meta itemprop="datePublished" content="2022-03-03T15:29:01+08:00" />
<meta itemprop="dateModified" content="2022-03-03T15:29:01+08:00" />
<meta itemprop="wordCount" content="7892">
<meta itemprop="keywords" content="c#," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="String builder in C# - StringBuilder"/>
<meta name="twitter:description" content="In everyday development StringBuilder must be used by everyone, even a lot. After all, we all know the unwritten norm that StringBuilder&rsquo;s performance is higher than direct string splicing when a large number of strings need to be constructed at high frequencies, because using &#43; or &#43;= directly will generate a new String instance, because String objects are immutable objects, which means that each time the string This means that"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">String builder in C# - StringBuilder</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-03-03 15:29:01 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 7892 words </span>
          <span class="more-meta"> 16 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#simple-example">Simple example</a></li>
        <li><a href="#source-code-exploration">Source Code Exploration</a>
          <ul>
            <li><a href="#start-with-the-construction">Start with the construction</a></li>
            <li><a href="#core-methods">Core Methods</a></li>
            <li><a href="#convert-to-string">Convert to String</a></li>
            <li><a href="#compare-to-java-implementation">Compare to java implementation</a></li>
          </ul>
        </li>
        <li><a href="#summary">Summary</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>In everyday development StringBuilder must be used by everyone, even a lot. After all, we all know the unwritten norm that StringBuilder&rsquo;s performance is higher than direct string splicing when a large number of strings need to be constructed at high frequencies, because using <code>+</code> or <code>+=</code> directly will generate a new <code>String</code> instance, because String objects are <code>immutable objects</code>, which means that each time the string This means that each time the content of a string is manipulated, a new instance of the string is created, which is very unfriendly to the large number of scenarios where string splicing is performed. Hence <code>StringBuilder</code> was born. Note that this does not mean that StringBuilder can be used for all string stitching scenarios, but rather that it is used <code>frequently</code> for stitching the same string object. Today we will look at the clever implementation of StringBuilder in c# and experience the way the underlying class library solves the problem.</p>
<blockquote>
<p>Note that immutability here means that the content of the string object itself is immutable, but the reference to the string variable can be changed.</p>
</blockquote>
<h2 id="simple-example">Simple example</h2>
<p>Let&rsquo;s take a simple example of the operation, in fact, the core operation is mainly <code>Append method</code> and <code>ToString method</code>, and the constructor of StringBuilder from the point of view of the source code. The first is the most commonly used way to get the results of various Append directly and then finally.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c#" data-lang="c#"><span class="n">StringBuilder</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="p">();</span>
<span class="n">builder</span><span class="p">.</span><span class="n">Append</span><span class="p">(</span><span class="s">&#34;我和我的祖国&#34;</span><span class="p">);</span>
<span class="n">builder</span><span class="p">.</span><span class="n">Append</span><span class="p">(</span><span class="sc">&#39;,&#39;</span><span class="p">);</span>
<span class="n">builder</span><span class="p">.</span><span class="n">Append</span><span class="p">(</span><span class="s">&#34;一刻也不能分割&#34;</span><span class="p">);</span>
<span class="n">builder</span><span class="p">.</span><span class="n">Append</span><span class="p">(</span><span class="sc">&#39;。&#39;</span><span class="p">);</span>
<span class="n">builder</span><span class="p">.</span><span class="n">Append</span><span class="p">(</span><span class="s">&#34;无论我走到哪里,都留下一首赞歌。&#34;</span><span class="p">);</span>
<span class="n">builder</span><span class="p">.</span><span class="n">Append</span><span class="p">(</span><span class="s">&#34;我歌唱每一座高山,我歌唱每一条河。&#34;</span><span class="p">);</span>
<span class="n">builder</span><span class="p">.</span><span class="n">Append</span><span class="p">(</span><span class="s">&#34;袅袅炊烟,小小村落,路上一道辙。&#34;</span><span class="p">);</span>
<span class="n">builder</span><span class="p">.</span><span class="n">Append</span><span class="p">(</span><span class="s">&#34;我永远紧依着你的心窝,你用你那母亲的脉搏,和我诉说。&#34;</span><span class="p">);</span>
<span class="kt">string</span> <span class="n">result</span> <span class="p">=</span> <span class="n">builder</span><span class="p">.</span><span class="n">ToString</span><span class="p">();</span>
<span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>StringBuilder also supports initializing some data through the constructor, and whether or not the initialization data is passed in the constructor means different initialization logic. For example, the following operations</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c#" data-lang="c#"><span class="n">StringBuilder</span> <span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="p">(</span><span class="s">&#34;我和我的祖国&#34;</span><span class="p">);</span>
<span class="c1">//或者是指定StringBuilder的容量，这样的话StringBuilder初始可承载字符串的长度是16
</span><span class="c1"></span><span class="n">builder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="p">(</span><span class="m">16</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>Because StringBuilder is a basic class library, it is simple to look at, simple to use, and everyone uses these operations all the time.</p>
<h2 id="source-code-exploration">Source Code Exploration</h2>
<p>Above we simply demonstrate the use of the StringBuilder, general similar StringBuilder or List, although I did not use the process can not pay attention to the length of the container itself has been to add elements, in fact, the internal logic of the implementation of these containers themselves contain some expansion-related logic. We mentioned above that the core of StringBuilder is mainly three operations, that is, through these three functions can present the way StringBuilder works and the principle.</p>
<ul>
<li>One is the <code>Constructor</code>, because the constructor contains some logic for initialization.</li>
<li>Next is the <code>Append</code> method, which is the core operation of StringBuilder for string splicing.</li>
<li>And finally, the <code>ToString</code> method, which converts the StringBuilder into a string, which is the operation we use to get the stitched string.</li>
</ul>
<p>Let&rsquo;s start with these three related methods to see the core implementation of StringBuilder, here I refer to the .net version <code>v6.0.2</code>.</p>
<h3 id="start-with-the-construction">Start with the construction</h3>
<p>As we mentioned above, the constructor of StringBuilder represents the initialization logic, which is roughly the default constructor, i.e. the default initialization logic and a part of the custom constructor logic, mainly the logic that determines the length of the StringBuilder container that can hold the string.</p>
<h4 id="parameterless-constructors">Parameterless constructors</h4>
<p>First, let&rsquo;s take a look at the implementation of the default unparametric constructor [<a href="https://github.com/dotnet/runtime/blob/v6.0.2/src/libraries/System.Private.CoreLib/src/System/Text/StringBuilder.cs#L77">Click to view source code 👈</a>]</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c#" data-lang="c#"><span class="c1">//可承载字符的最大容量,即可以拼接的字符串的长度
</span><span class="c1"></span><span class="k">internal</span> <span class="kt">int</span> <span class="n">m_MaxCapacity</span><span class="p">;</span>
<span class="c1">//承载【拼接字符串的char数组
</span><span class="c1"></span><span class="k">internal</span> <span class="kt">char</span><span class="p">[]</span> <span class="n">m_ChunkChars</span><span class="p">;</span>
<span class="c1">//默认的容量，即默认初始化m_ChunkChars的长度，也就是首次扩容触发的长度
</span><span class="c1"></span><span class="k">internal</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">DefaultCapacity</span> <span class="p">=</span> <span class="m">16</span><span class="p">;</span>
<span class="k">public</span> <span class="n">StringBuilder</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">m_MaxCapacity</span> <span class="p">=</span> <span class="kt">int</span><span class="p">.</span><span class="n">MaxValue</span><span class="p">;</span>
    <span class="n">m_ChunkChars</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">DefaultCapacity</span><span class="p">];</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>With the default parameterless constructor, we can learn two things</p>
<ul>
<li>The first is that the core StringBuilder container for storing strings is a <code>char[]</code> array.</li>
<li>The default container for <code>char[]</code> character arrays is declared to be 16, i.e. the expansion mechanism is triggered if the first StringBuilder holds more than 16 characters.</li>
</ul>
<h4 id="constructors-with-parameters">Constructors with parameters</h4>
<p>StringBuilder has several constructors with parameters, as follows</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c#" data-lang="c#"><span class="c1">//声明初始化容量，即首次扩容触发的长度条件
</span><span class="c1"></span><span class="k">public</span> <span class="n">StringBuilder</span><span class="p">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="p">)</span>
<span class="c1">//声明初始化容量，和最大容量即可以动态构建字符串的总长度
</span><span class="c1"></span><span class="k">public</span> <span class="n">StringBuilder</span><span class="p">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxCapacity</span><span class="p">)</span>
<span class="c1">//用给定字符串初始化
</span><span class="c1"></span><span class="k">public</span> <span class="n">StringBuilder</span><span class="p">(</span><span class="kt">string?</span> <span class="k">value</span><span class="p">)</span>
<span class="c1">//用给定字符串初始化，并声明容量
</span><span class="c1"></span><span class="k">public</span> <span class="n">StringBuilder</span><span class="p">(</span><span class="kt">string?</span> <span class="k">value</span><span class="p">,</span> <span class="kt">int</span> <span class="n">capacity</span><span class="p">)</span>
<span class="c1">//用一个字符串截取指定长度初始化，并声明最大容量
</span><span class="c1"></span><span class="k">public</span> <span class="n">StringBuilder</span><span class="p">(</span><span class="kt">string?</span> <span class="k">value</span><span class="p">,</span> <span class="kt">int</span> <span class="n">startIndex</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">capacity</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Although there are many constructors, but most of them are calling their own overloaded methods, the core constructor with parameters is actually two, let&rsquo;s look at them separately, the first is to specify the capacity of the initialization constructor [<a href="https://github.com/dotnet/runtime/blob/v6.0.2/src/libraries/System.Private.CoreLib/src/System/Text/StringBuilder.cs#L160">Click to view source code 👈</a>]</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c#" data-lang="c#"><span class="c1">//可承载字符的最大容量,即可以拼接的字符串的长度
</span><span class="c1"></span><span class="k">internal</span> <span class="kt">int</span> <span class="n">m_MaxCapacity</span><span class="p">;</span>
<span class="c1">//承载【拼接字符串的char数组
</span><span class="c1"></span><span class="k">internal</span> <span class="kt">char</span><span class="p">[]</span> <span class="n">m_ChunkChars</span><span class="p">;</span>
<span class="c1">//默认的容量，即默认初始化m_ChunkChars的长度，也就是首次扩容触发的长度
</span><span class="c1"></span><span class="k">internal</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">DefaultCapacity</span> <span class="p">=</span> <span class="m">16</span><span class="p">;</span>
<span class="k">public</span> <span class="n">StringBuilder</span><span class="p">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxCapacity</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//指定容量不能大于最大容量
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">capacity</span> <span class="p">&gt;</span> <span class="n">maxCapacity</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">ArgumentOutOfRangeException</span><span class="p">(</span><span class="n">nameof</span><span class="p">(</span><span class="n">capacity</span><span class="p">),</span> <span class="n">SR</span><span class="p">.</span><span class="n">ArgumentOutOfRange_Capacity</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">//最大容量不能小于1
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">maxCapacity</span> <span class="p">&lt;</span> <span class="m">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">ArgumentOutOfRangeException</span><span class="p">(</span><span class="n">nameof</span><span class="p">(</span><span class="n">maxCapacity</span><span class="p">),</span> <span class="n">SR</span><span class="p">.</span><span class="n">ArgumentOutOfRange_SmallMaxCapacity</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">//初始化容量不能小于0
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">capacity</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">ArgumentOutOfRangeException</span><span class="p">(</span><span class="n">nameof</span><span class="p">(</span><span class="n">capacity</span><span class="p">),</span> <span class="n">SR</span><span class="p">.</span><span class="n">Format</span><span class="p">(</span><span class="n">SR</span><span class="p">.</span><span class="n">ArgumentOutOfRange_MustBePositive</span><span class="p">,</span> <span class="n">nameof</span><span class="p">(</span><span class="n">capacity</span><span class="p">)));</span>
    <span class="p">}</span>
    <span class="c1">//如果指定容量等于0，则使用默认的容量
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">capacity</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">capacity</span> <span class="p">=</span> <span class="n">Math</span><span class="p">.</span><span class="n">Min</span><span class="p">(</span><span class="n">DefaultCapacity</span><span class="p">,</span> <span class="n">maxCapacity</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">//最大容量赋值
</span><span class="c1"></span>    <span class="n">m_MaxCapacity</span> <span class="p">=</span> <span class="n">maxCapacity</span><span class="p">;</span>
    <span class="c1">//分配指定容量的数组
</span><span class="c1"></span>    <span class="n">m_ChunkChars</span> <span class="p">=</span> <span class="n">GC</span><span class="p">.</span><span class="n">AllocateUninitializedArray</span><span class="p">&lt;</span><span class="kt">char</span><span class="p">&gt;(</span><span class="n">capacity</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The main thing is to judge and assign values to the maximum and initialized capacities, and if the initial and maximum capacities are formulated then the passed-in ones are the main ones. Next, let&rsquo;s look at the main operation to initialize StringBuilder according to the specified string [<a href="https://github.com/dotnet/runtime/blob/v6.0.2/src/libraries/System.Private.CoreLib/src/System/Text/StringBuilder.cs#L118">Click to view source code 👈</a>]</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c#" data-lang="c#"><span class="c1">//可承载字符的最大容量,即可以拼接的字符串的长度
</span><span class="c1"></span><span class="k">internal</span> <span class="kt">int</span> <span class="n">m_MaxCapacity</span><span class="p">;</span>
<span class="c1">//承载【拼接字符串的char数组
</span><span class="c1"></span><span class="k">internal</span> <span class="kt">char</span><span class="p">[]</span> <span class="n">m_ChunkChars</span><span class="p">;</span>
<span class="c1">//默认的容量，即默认初始化m_ChunkChars的长度，也就是首次扩容触发的长度
</span><span class="c1"></span><span class="k">internal</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">DefaultCapacity</span> <span class="p">=</span> <span class="m">16</span><span class="p">;</span>
<span class="c1">//当前m_ChunkChars字符数组中已经使用的长度
</span><span class="c1"></span><span class="k">internal</span> <span class="kt">int</span> <span class="n">m_ChunkLength</span><span class="p">;</span>
<span class="k">public</span> <span class="n">StringBuilder</span><span class="p">(</span><span class="kt">string?</span> <span class="k">value</span><span class="p">,</span> <span class="kt">int</span> <span class="n">startIndex</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">capacity</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">capacity</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">ArgumentOutOfRangeException</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">ArgumentOutOfRangeException</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">startIndex</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">ArgumentOutOfRangeException</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="c1">//初始化的字符串可以为null,如果为null则只用空字符串即&#34;&#34;
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="k">value</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">value</span> <span class="p">=</span> <span class="kt">string</span><span class="p">.</span><span class="n">Empty</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//基础长度判断,这个逻辑其实已经包含了针对字符串截取的起始位置和接要截取的长度进行判断了
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">startIndex</span> <span class="p">&gt;</span> <span class="k">value</span><span class="p">.</span><span class="n">Length</span> <span class="p">-</span> <span class="n">length</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">ArgumentOutOfRangeException</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="c1">//最大容量是int的最大值，即2^31-1
</span><span class="c1"></span>    <span class="n">m_MaxCapacity</span> <span class="p">=</span> <span class="kt">int</span><span class="p">.</span><span class="n">MaxValue</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">capacity</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">capacity</span> <span class="p">=</span> <span class="n">DefaultCapacity</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//虽然传递了默认容量,但是这里依然做了判断,在传递的默认容量和需要存储的字符串容量总取最大值
</span><span class="c1"></span>    <span class="n">capacity</span> <span class="p">=</span> <span class="n">Math</span><span class="p">.</span><span class="n">Max</span><span class="p">(</span><span class="n">capacity</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
    <span class="c1">//分配指定容量的数组
</span><span class="c1"></span>    <span class="n">m_ChunkChars</span> <span class="p">=</span> <span class="n">GC</span><span class="p">.</span><span class="n">AllocateUninitializedArray</span><span class="p">&lt;</span><span class="kt">char</span><span class="p">&gt;(</span><span class="n">capacity</span><span class="p">);</span>
    <span class="c1">//这里记录了m_ChunkChars固定长度的快中已经被使用的长度
</span><span class="c1"></span>    <span class="n">m_ChunkLength</span> <span class="p">=</span> <span class="n">length</span><span class="p">;</span>
    <span class="c1">//把传递的字符串指定位置指定长度(即截取操作)copy到m_ChunkChars中
</span><span class="c1"></span>    <span class="k">value</span><span class="p">.</span><span class="n">AsSpan</span><span class="p">(</span><span class="n">startIndex</span><span class="p">,</span> <span class="n">length</span><span class="p">).</span><span class="n">CopyTo</span><span class="p">(</span><span class="n">m_ChunkChars</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>This initialization operation mainly intercepts the specified length of the given string and stores it in ChunkChars for initializing StringBuilder, where the initialized capacity depends on whether the length that can be intercepted is greater than the specified capacity, and the essence is to be able to store the intercepted length of the string.</p>
<h4 id="summary-of-constructors">Summary of Constructors</h4>
<p>Through the logic of StringBuilder&rsquo;s constructor we can see that StringBuilder is essentially stored in <code>char[]</code>, the initialized length of this character array is 16, the main role of this length is the expansion mechanism, that is, the first time you need to expand the capacity is when the length of m_ChunkChars exceeds 16, at this time the original m_ChunkChars can no longer carry the string to be built when the expansion is triggered.</p>
<h3 id="core-methods">Core Methods</h3>
<p>We have seen the initialization code of StringBuilder above, through the initialization operation, we can understand the data structure of StringBuilder itself, but if we want to understand the expansion mechanism of StringBuilder, we need to start from its <code>Append method</code>, because only when Append has the opportunity to judge the original The length of the m_ChunkChars array is sufficient to store the appended string. There are many overloads for the Append method of StringBuilder, so we won&rsquo;t list them all here, but the essence is the same. So let&rsquo;s choose the most familiar and commonly used <code>Append(string? value)</code> method to explain, directly find the source code location [<a href="https://github.com/dotnet/runtime/blob/v6.0.2/src/libraries/System.Private.CoreLib/src/System/Text/StringBuilder.cs#L793%5D">Click to view source code 👈</a>]</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c#" data-lang="c#"><span class="c1">//承载【拼接字符串的char数组
</span><span class="c1"></span><span class="k">internal</span> <span class="kt">char</span><span class="p">[]</span> <span class="n">m_ChunkChars</span><span class="p">;</span>
<span class="c1">//当前m_ChunkChars字符数组中已经使用的长度
</span><span class="c1"></span><span class="k">internal</span> <span class="kt">int</span> <span class="n">m_ChunkLength</span><span class="p">;</span>
<span class="k">public</span> <span class="n">StringBuilder</span> <span class="n">Append</span><span class="p">(</span><span class="kt">string?</span> <span class="k">value</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">value</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 获取当前存储块
</span><span class="c1"></span>        <span class="kt">char</span><span class="p">[]</span> <span class="n">chunkChars</span> <span class="p">=</span> <span class="n">m_ChunkChars</span><span class="p">;</span>
        <span class="c1">// 获取当前块已使用的长度
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">chunkLength</span> <span class="p">=</span> <span class="n">m_ChunkLength</span><span class="p">;</span>
        <span class="c1">// 获取传进来的字符的长度
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">valueLen</span> <span class="p">=</span> <span class="k">value</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span>

        <span class="c1">//当前使用的长度 + 需要Append的长度 &lt; 当前块的长度 则不需要扩容
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(((</span><span class="kt">uint</span><span class="p">)</span><span class="n">chunkLength</span> <span class="p">+</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="n">valueLen</span><span class="p">)</span> <span class="p">&lt;</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="n">chunkChars</span><span class="p">.</span><span class="n">Length</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">//判断传进来的字符串长度是否&lt;=2
</span><span class="c1"></span>            <span class="c1">//如果小于2则只用直接访问位置的方式操作
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">valueLen</span> <span class="p">&lt;=</span> <span class="m">2</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="c1">//判断字符串长度&gt;0的场景
</span><span class="c1"></span>                <span class="k">if</span> <span class="p">(</span><span class="n">valueLen</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="c1">//m_ChunkChars的已使用长度其实就是可以Append新元素的起始位置
</span><span class="c1"></span>                    <span class="c1">//直接取value得第0个元素放入m_ChunkChars[可存储的起始位置]
</span><span class="c1"></span>                    <span class="n">chunkChars</span><span class="p">[</span><span class="n">chunkLength</span><span class="p">]</span> <span class="p">=</span> <span class="k">value</span><span class="p">[</span><span class="m">0</span><span class="p">];</span>
                <span class="p">}</span>
                <span class="c1">//其实是判断字符串长度==2的场景
</span><span class="c1"></span>                <span class="k">if</span> <span class="p">(</span><span class="n">valueLen</span> <span class="p">&gt;</span> <span class="m">1</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="c1">//因为上面已经取了value第0个元素放入了m_ChunkChars中
</span><span class="c1"></span>                    <span class="c1">//现在则取value得第1个元素继续放入chunkLength的下一位置
</span><span class="c1"></span>                    <span class="n">chunkChars</span><span class="p">[</span><span class="n">chunkLength</span> <span class="p">+</span> <span class="m">1</span><span class="p">]</span> <span class="p">=</span> <span class="k">value</span><span class="p">[</span><span class="m">1</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="c1">//如果value的长度大于2则通过操作内存去追加value
</span><span class="c1"></span>                <span class="c1">//获取m_ChunkChars的引用位置,偏移到m_ChunkLength的位置追加value
</span><span class="c1"></span>                <span class="n">Buffer</span><span class="p">.</span><span class="n">Memmove</span><span class="p">(</span>
                    <span class="k">ref</span> <span class="n">Unsafe</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="k">ref</span> <span class="n">MemoryMarshal</span><span class="p">.</span><span class="n">GetArrayDataReference</span><span class="p">(</span><span class="n">chunkChars</span><span class="p">),</span> <span class="n">chunkLength</span><span class="p">),</span>
                    <span class="k">ref</span> <span class="k">value</span><span class="p">.</span><span class="n">GetRawStringData</span><span class="p">(),</span>
                    <span class="p">(</span><span class="n">nuint</span><span class="p">)</span><span class="n">valueLen</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="c1">//更新以使用长度的值,新的使用长度是当前已使用长度+追加进来的字符串长度
</span><span class="c1"></span>            <span class="n">m_ChunkLength</span> <span class="p">=</span> <span class="n">chunkLength</span> <span class="p">+</span> <span class="n">valueLen</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="c1">//走到这里说明进入了扩容逻辑
</span><span class="c1"></span>            <span class="n">AppendHelper</span><span class="p">(</span><span class="k">value</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>This part of the logic mainly shows the logic when the expansion condition is not reached, which is essentially appending the Append string to the <code>m_ChunkChars</code> array, where <code>m_ChunkLength</code> represents the length of the current <code>m_ChunkChars</code> already used, and another meaning is that it represents the starting position of the next Append element is stored to the starting position of <code>m_ChunkLength</code>. And the logic needed for expansion goes to the <code>AppendHelper</code> method, let&rsquo;s look at the implementation of the AppendHelper method [<a href="https://github.com/dotnet/runtime/blob/v6.0.2/src/libraries/System.Private.CoreLib/src/System/Text/StringBuilder.cs#L836">Click to view source 👈</a>]</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c#" data-lang="c#"><span class="k">private</span> <span class="k">void</span> <span class="n">AppendHelper</span><span class="p">(</span><span class="kt">string</span> <span class="k">value</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">unsafe</span>
    <span class="p">{</span>
        <span class="c1">//防止垃圾收集器重新定位value变量。
</span><span class="c1"></span>        <span class="c1">//指针操作,string本身是不可变的char数组,所以它的指针是char* 
</span><span class="c1"></span>        <span class="k">fixed</span> <span class="p">(</span><span class="kt">char</span><span class="p">*</span> <span class="n">valueChars</span> <span class="p">=</span> <span class="k">value</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">//调用了另一个append
</span><span class="c1"></span>            <span class="n">Append</span><span class="p">(</span><span class="n">valueChars</span><span class="p">,</span> <span class="k">value</span><span class="p">.</span><span class="n">Length</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Here we get the value pointer passed in and call another overloaded Append method, but we can get a message from this code that this operation is non-thread safe. We continue to find another Append method [<a href="https://github.com/dotnet/runtime/blob/v6.0.2/src/libraries/System.Private.CoreLib/src/System/Text/StringBuilder.cs#L2095">click to view source code 👈</a>]</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="k">unsafe</span> <span class="n">StringBuilder</span> <span class="n">Append</span><span class="p">(</span><span class="kt">char</span><span class="p">*</span> <span class="k">value</span><span class="p">,</span> <span class="kt">int</span> <span class="n">valueCount</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// value必须有值
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">valueCount</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">ArgumentOutOfRangeException</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">//新的长度=StringBuilder的长度+需要追加的字符串长度
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">newLength</span> <span class="p">=</span> <span class="n">Length</span> <span class="p">+</span> <span class="n">valueCount</span><span class="p">;</span>
    <span class="c1">//新的长度不能大于最大容量
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">newLength</span> <span class="p">&gt;</span> <span class="n">m_MaxCapacity</span> <span class="p">||</span> <span class="n">newLength</span> <span class="p">&lt;</span> <span class="n">valueCount</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">ArgumentOutOfRangeException</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">// 新的起始位置=需要追加的长度+当前使用的长度
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">newIndex</span> <span class="p">=</span> <span class="n">valueCount</span> <span class="p">+</span> <span class="n">m_ChunkLength</span><span class="p">;</span>
    <span class="c1">// 判断当前m_ChunkChars的容量是否够用
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">newIndex</span> <span class="p">&lt;=</span> <span class="n">m_ChunkChars</span><span class="p">.</span><span class="n">Length</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">//够用的话则直接将追加的元素添加到m_ChunkChars中去
</span><span class="c1"></span>        <span class="k">new</span> <span class="n">ReadOnlySpan</span><span class="p">&lt;</span><span class="kt">char</span><span class="p">&gt;(</span><span class="k">value</span><span class="p">,</span> <span class="n">valueCount</span><span class="p">).</span><span class="n">CopyTo</span><span class="p">(</span><span class="n">m_ChunkChars</span><span class="p">.</span><span class="n">AsSpan</span><span class="p">(</span><span class="n">m_ChunkLength</span><span class="p">));</span>
        <span class="c1">//更新已使用的长度为新的长度
</span><span class="c1"></span>        <span class="n">m_ChunkLength</span> <span class="p">=</span> <span class="n">newIndex</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//当前m_ChunkChars不满足存储则需要扩容
</span><span class="c1"></span>    <span class="k">else</span>
    <span class="p">{</span>
        <span class="c1">// 判断当前存储块m_ChunkChars还有多少未存储的位置
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">firstLength</span> <span class="p">=</span> <span class="n">m_ChunkChars</span><span class="p">.</span><span class="n">Length</span> <span class="p">-</span> <span class="n">m_ChunkLength</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">firstLength</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">//把需要追加的value中的前firstLength位字符copy到m_ChunkChars中剩余的位置
</span><span class="c1"></span>            <span class="c1">//合理的利用存储空间,截取需要追加的value到m_ChunkChars剩余的位置
</span><span class="c1"></span>            <span class="k">new</span> <span class="n">ReadOnlySpan</span><span class="p">&lt;</span><span class="kt">char</span><span class="p">&gt;(</span><span class="k">value</span><span class="p">,</span> <span class="n">firstLength</span><span class="p">).</span><span class="n">CopyTo</span><span class="p">(</span><span class="n">m_ChunkChars</span><span class="p">.</span><span class="n">AsSpan</span><span class="p">(</span><span class="n">m_ChunkLength</span><span class="p">));</span>
            <span class="c1">//更新已使用的位置，这个时候当前存块m_ChunkChars已经存储满了
</span><span class="c1"></span>            <span class="n">m_ChunkLength</span> <span class="p">=</span> <span class="n">m_ChunkChars</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 获取value中未放入到m_ChunkChars(因为当前块已经放满)剩余部分起始位置
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">restLength</span> <span class="p">=</span> <span class="n">valueCount</span> <span class="p">-</span> <span class="n">firstLength</span><span class="p">;</span>
        <span class="c1">//扩展当前存储块即扩容操作
</span><span class="c1"></span>        <span class="n">ExpandByABlock</span><span class="p">(</span><span class="n">restLength</span><span class="p">);</span>
        <span class="c1">//判断新的存储块是否创建成功
</span><span class="c1"></span>        <span class="n">Debug</span><span class="p">.</span><span class="n">Assert</span><span class="p">(</span><span class="n">m_ChunkLength</span> <span class="p">==</span> <span class="m">0</span><span class="p">,</span> <span class="s">&#34;A new block was not created.&#34;</span><span class="p">);</span>
        <span class="c1">// 将value中未放入到m_ChunkChars的剩余部放入扩容后的m_ChunkChars中去
</span><span class="c1"></span>        <span class="k">new</span> <span class="n">ReadOnlySpan</span><span class="p">&lt;</span><span class="kt">char</span><span class="p">&gt;(</span><span class="k">value</span> <span class="p">+</span> <span class="n">firstLength</span><span class="p">,</span> <span class="n">restLength</span><span class="p">).</span><span class="n">CopyTo</span><span class="p">(</span><span class="n">m_ChunkChars</span><span class="p">);</span>
        <span class="c1">// 更新当前已使用长度
</span><span class="c1"></span>        <span class="n">m_ChunkLength</span> <span class="p">=</span> <span class="n">restLength</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//一些针对当前StringBuilder的校验操作,和相关逻辑无关不做详细介绍
</span><span class="c1"></span>    <span class="c1">//类似的Debug.Assert(m_ChunkOffset + m_ChunkChars.Length &gt;= m_ChunkOffset, &#34;The length of the string is greater than int.MaxValue.&#34;);
</span><span class="c1"></span>    <span class="n">AssertInvariants</span><span class="p">();</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The source code here deals with the length of a StringBuilder. Length represents the actual length of characters stored in the current StringBuilder object, which is defined as follows</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="kt">int</span> <span class="n">Length</span>
<span class="p">{</span>
    <span class="c1">//StringBuilder已存储的长度=块的偏移量+当前块使用的长度
</span><span class="c1"></span>    <span class="k">get</span> <span class="p">=&gt;</span> <span class="n">m_ChunkOffset</span> <span class="p">+</span> <span class="n">m_ChunkLength</span><span class="p">;</span>
    <span class="k">set</span>
    <span class="p">{</span>
        <span class="c1">//注意这里是有代码的只是我们暂时省略set逻辑
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The Append method in the source code above is actually another overloaded method, only <code>Append(string? value)</code> calls this logic, here you can clearly see that if the current storage block meets the storage, it is directly used. If the current storage location does not meet the storage, then the storage space will not be wasted, according to the available storage length of the current storage block to intercept the length of the string that needs to Append, into the remaining location of this storage block, the remaining characters that can not be stored will be stored in the expanded new storage block <code>m_ChunkChars</code>, this practice is to not waste storage space.</p>
<blockquote>
<p>This is very well thought out, even if the expansion happens, then the storage block of my current node must be filled, ensuring the maximum use of storage space.</p>
</blockquote>
<p>Through the Append source code above we can naturally see that the logic of expansion is naturally in the <code>ExpandByABlock</code> method [<a href="https://github.com/dotnet/runtime/blob/v6.0.2/src/libraries/System.Private.CoreLib/src/System/Text/StringBuilder.cs#L2372">Click to view source code 👈</a>]</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c#" data-lang="c#"><span class="c1">//当前StringBuilder实际存储的总长度
</span><span class="c1"></span><span class="k">public</span> <span class="kt">int</span> <span class="n">Length</span>
<span class="p">{</span>
    <span class="c1">//StringBuilder已存储的长度=块的偏移量+当前块使用的长度
</span><span class="c1"></span>    <span class="k">get</span> <span class="p">=&gt;</span> <span class="n">m_ChunkOffset</span> <span class="p">+</span> <span class="n">m_ChunkLength</span><span class="p">;</span>
    <span class="k">set</span>
    <span class="p">{</span>
        <span class="c1">//注意这里是有代码的只是我们暂时省略set逻辑
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">//当前StringBuilder的总容量
</span><span class="c1"></span><span class="k">public</span> <span class="kt">int</span> <span class="n">Capacity</span>
<span class="p">{</span>
    <span class="k">get</span> <span class="p">=&gt;</span> <span class="n">m_ChunkChars</span><span class="p">.</span><span class="n">Length</span> <span class="p">+</span> <span class="n">m_ChunkOffset</span><span class="p">;</span>
    <span class="k">set</span>
    <span class="p">{</span>
        <span class="c1">//注意这里是有代码的只是我们暂时省略set逻辑
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">//可承载字符的最大容量,即可以拼接的字符串的长度
</span><span class="c1"></span><span class="k">internal</span> <span class="kt">int</span> <span class="n">m_MaxCapacity</span><span class="p">;</span>
<span class="c1">//承载【拼接字符串的char数组
</span><span class="c1"></span><span class="k">internal</span> <span class="kt">char</span><span class="p">[]</span> <span class="n">m_ChunkChars</span><span class="p">;</span>
<span class="c1">//当前块的最大长度
</span><span class="c1"></span><span class="k">internal</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">MaxChunkSize</span> <span class="p">=</span> <span class="m">8000</span><span class="p">;</span>
<span class="c1">//当前m_ChunkChars字符数组中已经使用的长度
</span><span class="c1"></span><span class="k">internal</span> <span class="kt">int</span> <span class="n">m_ChunkLength</span><span class="p">;</span>
<span class="c1">//存储块的偏移量,用于计算总长度
</span><span class="c1"></span><span class="k">internal</span> <span class="kt">int</span> <span class="n">m_ChunkOffset</span><span class="p">;</span>
<span class="c1">//前一个存储块
</span><span class="c1"></span><span class="k">internal</span> <span class="n">StringBuilder</span><span class="p">?</span> <span class="n">m_ChunkPrevious</span><span class="p">;</span>
<span class="k">private</span> <span class="k">void</span> <span class="n">ExpandByABlock</span><span class="p">(</span><span class="kt">int</span> <span class="n">minBlockCharCount</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//当前块m_ChunkChars存储满才进行扩容操作
</span><span class="c1"></span>    <span class="n">Debug</span><span class="p">.</span><span class="n">Assert</span><span class="p">(</span><span class="n">Capacity</span> <span class="p">==</span> <span class="n">Length</span><span class="p">,</span> <span class="n">nameof</span><span class="p">(</span><span class="n">ExpandByABlock</span><span class="p">)</span> <span class="p">+</span> <span class="s">&#34; should only be called when there is no space left.&#34;</span><span class="p">);</span>
    <span class="c1">//minBlockCharCount指的是剩下的需要存储的长度
</span><span class="c1"></span>    <span class="n">Debug</span><span class="p">.</span><span class="n">Assert</span><span class="p">(</span><span class="n">minBlockCharCount</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">);</span>
    <span class="n">AssertInvariants</span><span class="p">();</span>

    <span class="c1">//StringBuilder的总长度不能大于StringBuilder的m_MaxCapacity
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">((</span><span class="n">minBlockCharCount</span> <span class="p">+</span> <span class="n">Length</span><span class="p">)</span> <span class="p">&gt;</span> <span class="n">m_MaxCapacity</span> <span class="p">||</span> <span class="n">minBlockCharCount</span> <span class="p">+</span> <span class="n">Length</span> <span class="p">&lt;</span> <span class="n">minBlockCharCount</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">ArgumentOutOfRangeException</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">//!!!需要扩容块的新长度=max(当前追加字符的剩余长度,min(当前StringBuilder长度,8000))
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">newBlockLength</span> <span class="p">=</span> <span class="n">Math</span><span class="p">.</span><span class="n">Max</span><span class="p">(</span><span class="n">minBlockCharCount</span><span class="p">,</span> <span class="n">Math</span><span class="p">.</span><span class="n">Min</span><span class="p">(</span><span class="n">Length</span><span class="p">,</span> <span class="n">MaxChunkSize</span><span class="p">));</span>

    <span class="c1">//判断长度是否越界
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">m_ChunkOffset</span> <span class="p">+</span> <span class="n">m_ChunkLength</span> <span class="p">+</span> <span class="n">newBlockLength</span> <span class="p">&lt;</span> <span class="n">newBlockLength</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">OutOfMemoryException</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">// 申请一个新的存块长度为newBlockLength
</span><span class="c1"></span>    <span class="kt">char</span><span class="p">[]</span> <span class="n">chunkChars</span> <span class="p">=</span> <span class="n">GC</span><span class="p">.</span><span class="n">AllocateUninitializedArray</span><span class="p">&lt;</span><span class="kt">char</span><span class="p">&gt;(</span><span class="n">newBlockLength</span><span class="p">);</span>

    <span class="c1">//!!!把当前StringBuilder中的存储块存放到一个新的StringBuilder实例中，当前实例的m_ChunkPrevious指向上一个StringBuilder
</span><span class="c1"></span>    <span class="c1">//这里可以看出来扩容的本质是构建节点为StringBuilder的链表
</span><span class="c1"></span>    <span class="n">m_ChunkPrevious</span> <span class="p">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="c1">//偏移量是每次扩容的时候去修改,它的长度就是记录了已使用块的长度,但是不包含当前StringBuilder的存储块
</span><span class="c1"></span>    <span class="c1">//可以理解为偏移量=长度-已经存放扩容块的长度
</span><span class="c1"></span>    <span class="n">m_ChunkOffset</span> <span class="p">+=</span> <span class="n">m_ChunkLength</span><span class="p">;</span>
    <span class="c1">//因为已经扩容了新的容器所以重置已使用长度
</span><span class="c1"></span>    <span class="n">m_ChunkLength</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
    <span class="c1">//把新的块重新赋值给当前存储块m_ChunkChars数组
</span><span class="c1"></span>    <span class="n">m_ChunkChars</span> <span class="p">=</span> <span class="n">chunkChars</span><span class="p">;</span>
    <span class="n">AssertInvariants</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>This code is the core operation of expansion, through this we can clearly understand the storage nature of StringBuilder</p>
<ul>
<li>First of all, the data of StringBuilder is stored in <code>m_ChunkChars array</code>, but the nature of expansion is a <code>one way chain</code> operation, StringBuilder itself contains <code>m_ChunkPrevious</code> which points to the data saved in the last expansion.</li>
<li>The actual length of the expansion is <code>max(the remaining length of the current appended characters, min(the current StringBuilder length, 8000))</code>, so we can know that the maximum size of a block of m_ChunkChars is <code>8000</code>.</li>
</ul>
<p>StringBuilder also contains a method to build an instance through StringBuilder. This constructor is used to build <code>one way chains</code> when expanding the capacity, and its implementation is also very simple</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c#" data-lang="c#"><span class="k">private</span> <span class="n">StringBuilder</span><span class="p">(</span><span class="n">StringBuilder</span> <span class="k">from</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">m_ChunkLength</span> <span class="p">=</span> <span class="k">from</span><span class="p">.</span><span class="n">m_ChunkLength</span><span class="p">;</span>
    <span class="n">m_ChunkOffset</span> <span class="p">=</span> <span class="k">from</span><span class="p">.</span><span class="n">m_ChunkOffset</span><span class="p">;</span>
    <span class="n">m_ChunkChars</span> <span class="p">=</span> <span class="k">from</span><span class="p">.</span><span class="n">m_ChunkChars</span><span class="p">;</span>
    <span class="n">m_ChunkPrevious</span> <span class="p">=</span> <span class="k">from</span><span class="p">.</span><span class="n">m_ChunkPrevious</span><span class="p">;</span>
    <span class="n">m_MaxCapacity</span> <span class="p">=</span> <span class="k">from</span><span class="p">.</span><span class="n">m_MaxCapacity</span><span class="p">;</span>
    <span class="n">AssertInvariants</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The purpose is to pass the various data related to the storage before the expansion to the new StringBuilder instance. Well, so far the core logic of Append is finished, let&rsquo;s roughly run through the core logic of <code>Append</code> Let&rsquo;s roughly list it, for example</p>
<ol>
<li>default m_ChunkChars[16], m_ChunkOffset=0, m_ChunkPrevious=null, Length=0</li>
<li>First expansion m_ChunkChars[16], m_ChunkOffset=16, m_ChunkPrevious=points to the original StringBuilder, m_ChunkLength=16</li>
<li>Second expansion of m_ChunkChars[32], m_ChunkOffset=32, m_ChunkPrevious=StringBuilder of m_ChunkChars[16] before expansion, m_ChunkLength=32</li>
<li>third expansion of m_ChunkChars[64], m_ChunkOffset=64, m_ChunkPrevious=StringBuilder of m_ChunkChars[64] before expansion, m_ChunkLength=64</li>
</ol>
<p>I have tried to draw a diagram. I wonder if I can help understand the data structure of StringBuilder. The chain table structure of StringBuilder is the current node pointing to the last StringBuilder, that is, the current instance of StringBuilder before expansion</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/03/e71d2a64afdf487ba32046b6320e0278.png" alt="c# stringbuilder"></p>
<blockquote>
<p>c# StringBuilder overall data structure is a one-way chain table, but each node of the chain table storage block is m_ChunkChars is <code>char[]</code> . The essence of expansion is to add a new node to the chain table, and the capacity of the new node storage block will increase with each expansion. Most of the cases encountered when using it are 16 for the first time, 16 for the second time, 32 for the third time, 64 for the fourth time, and so on.</p>
</blockquote>
<h3 id="convert-to-string">Convert to String</h3>
<p>From the above data structure of StringBuilder, we understand that StringBuilder is essentially a <code>unidirectional chain table</code>, which contains <code>m_ChunkPrevious</code> pointing to the previous StringBuilder instance, i.e. a chain table in reverse order. We finally get the result of the construction of the StringBuilder through the <code>ToString()</code> method of the StringBuilder to get a final result string, next we will look at the implementation of ToString [<a href="https://github.com/dotnet/runtime/blob/v6.0.2/src/libraries/System.Private.CoreLib/src/System/Text/StringBuilder.cs#L346">Click to view source code 👈</a>]</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//当前StringBuilder实际存储的总长度
</span><span class="c1"></span><span class="nx">public</span> <span class="kt">int</span> <span class="nx">Length</span>
<span class="p">{</span>
    <span class="c1">//StringBuilder已存储的长度=块的偏移量+当前块使用的长度
</span><span class="c1"></span>    <span class="nx">get</span> <span class="p">=&gt;</span> <span class="nx">m_ChunkOffset</span> <span class="o">+</span> <span class="nx">m_ChunkLength</span><span class="p">;</span>
    <span class="nx">set</span>
    <span class="p">{</span>
        <span class="c1">//注意这里是有代码的只是我们暂时省略set逻辑
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
<span class="nx">public</span> <span class="nx">override</span> <span class="kt">string</span> <span class="nf">ToString</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nf">AssertInvariants</span><span class="p">();</span>
    <span class="c1">//当前StringBuilder长度为0则直接返回空字符串
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">Length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="kt">string</span><span class="p">.</span><span class="nx">Empty</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//FastAllocateString函数负责分配长度为StringBuilder长度的字符串
</span><span class="c1"></span>    <span class="c1">//这个字符串就是ToString最终返回的结果,所以长度等于StringBuilder的长度
</span><span class="c1"></span>    <span class="kt">string</span> <span class="nx">result</span> <span class="p">=</span> <span class="kt">string</span><span class="p">.</span><span class="nf">FastAllocateString</span><span class="p">(</span><span class="nx">Length</span><span class="p">);</span>
    <span class="c1">//当前StringBuilder是遍历的第一个链表节点
</span><span class="c1"></span>    <span class="nx">StringBuilder</span><span class="err">?</span> <span class="nx">chunk</span> <span class="p">=</span> <span class="nx">this</span><span class="p">;</span>
    <span class="nx">do</span>
    <span class="p">{</span>
        <span class="c1">//当前使用长度必须大于0，也就是说当前块的m_ChunkChars必须使用过,才需要遍历当前节点
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="nx">chunk</span><span class="p">.</span><span class="nx">m_ChunkLength</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// 取出当前遍历的StringBuilder的相关数据
</span><span class="c1"></span>            <span class="c1">// 当前遍历StringBuilder的m_ChunkChars
</span><span class="c1"></span>            <span class="nx">char</span><span class="p">[]</span> <span class="nx">sourceArray</span> <span class="p">=</span> <span class="nx">chunk</span><span class="p">.</span><span class="nx">m_ChunkChars</span><span class="p">;</span>
            <span class="kt">int</span> <span class="nx">chunkOffset</span> <span class="p">=</span> <span class="nx">chunk</span><span class="p">.</span><span class="nx">m_ChunkOffset</span><span class="p">;</span>
            <span class="kt">int</span> <span class="nx">chunkLength</span> <span class="p">=</span> <span class="nx">chunk</span><span class="p">.</span><span class="nx">m_ChunkLength</span><span class="p">;</span>

            <span class="c1">// 检查是否越界
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">((</span><span class="kt">uint</span><span class="p">)(</span><span class="nx">chunkLength</span> <span class="o">+</span> <span class="nx">chunkOffset</span><span class="p">)</span> <span class="p">&gt;</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="nx">result</span><span class="p">.</span><span class="nx">Length</span> <span class="o">||</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="nx">chunkLength</span> <span class="p">&gt;</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span><span class="nx">sourceArray</span><span class="p">.</span><span class="nx">Length</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="nx">throw</span> <span class="nx">new</span> <span class="nf">ArgumentOutOfRangeException</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="c1">//把当前遍历项StringBuilder的m_ChunkChars逐步添加到result中当前结果的前端
</span><span class="c1"></span>            <span class="nx">Buffer</span><span class="p">.</span><span class="nf">Memmove</span><span class="p">(</span>
                <span class="nx">ref</span> <span class="nx">Unsafe</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">ref</span> <span class="nx">result</span><span class="p">.</span><span class="nf">GetRawStringData</span><span class="p">(),</span> <span class="nx">chunkOffset</span><span class="p">),</span>
                <span class="nx">ref</span> <span class="nx">MemoryMarshal</span><span class="p">.</span><span class="nf">GetArrayDataReference</span><span class="p">(</span><span class="nx">sourceArray</span><span class="p">),</span>
                <span class="p">(</span><span class="nx">nuint</span><span class="p">)</span><span class="nx">chunkLength</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">//获取当前StringBuilder的前一个节点,循环遍历链表操作
</span><span class="c1"></span>        <span class="nx">chunk</span> <span class="p">=</span> <span class="nx">chunk</span><span class="p">.</span><span class="nx">m_ChunkPrevious</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//如果m_ChunkPrevious==null则代表是第一个节点
</span><span class="c1"></span>    <span class="nf">while</span> <span class="p">(</span><span class="nx">chunk</span> <span class="o">!=</span> <span class="nx">null</span><span class="p">);</span>

    <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The essence of this ToString operation is an inverted-link traversal operation, each traversal gets the current StringBuilder&rsquo;s <code>m_ChunkPrevious character array</code> and after the data stitching is completed, it gets the last StringBuilder node of the current StringBuilder, i.e. <code>m_ ChunkPrevious</code>, the end condition is <code>m_ChunkPrevious==null</code> which means the node is the first node, and finally stitching into a string is returned. For example, our StringBuilder stores ``I can&rsquo;t be separated from my country, wherever I go, I leave a hymn. &lsquo;, then the traversal process for the ToString traversal StringBuilder is roughly as follows</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c#" data-lang="c#"><span class="c1">//初始化一个等于StringBuilder长度的字符串
</span><span class="c1"></span><span class="kt">string</span> <span class="n">result</span> <span class="p">=</span> <span class="s">&#34;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0&#34;</span><span class="p">;</span>
<span class="c1">//第一次遍历后
</span><span class="c1"></span><span class="n">result</span> <span class="p">=</span> <span class="s">&#34;\0\0\0\0\0\0\0\0\0\0\0\0\0\0无论我走到哪里都留下一首赞歌。&#34;</span><span class="p">;</span>
<span class="c1">//第二次遍历后
</span><span class="c1"></span><span class="n">result</span> <span class="p">=</span> <span class="s">&#34;\0\0\0\0\0\0\0一刻也不能分割,无论我走到哪里都留下一首赞歌。&#34;</span><span class="p">;</span>
<span class="c1">//第三次遍历后
</span><span class="c1"></span><span class="n">result</span> <span class="p">=</span> <span class="s">&#34;\0\0\0我的祖国一刻也不能分割,无论我走到哪里都留下一首赞歌。&#34;</span><span class="p">;</span>
<span class="c1">//第三次遍历后
</span><span class="c1"></span><span class="n">result</span> <span class="p">=</span> <span class="s">&#34;我和我的祖国一刻也不能分割,无论我走到哪里都留下一首赞歌。&#34;</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>After all, StringBuilder can only record the data of the last StringBuilder, so this is an operation that traverses the chain of StringBuilder in reverse order, each traversal is to add the data recorded in <code>m_ChunkPrevious</code> until <code>m_ChunkPrevious==null</code> then the traversal is completed and the result is returned directly.</p>
<blockquote>
<p>c# StringBuilder class ToString is essentially a reverse-order traversal of a one-way chain, each node of the chain is a StringBuilder instance, get the storage block inside <code>m_ChunkChars character array</code> to assemble, loop through all the nodes after the results are assembled into a string to return.</p>
</blockquote>
<h3 id="compare-to-java-implementation">Compare to java implementation</h3>
<p>We can see that the implementation of StringBuilder on C# is essentially a chain table. So and C# language similar to the Java implementation of the idea of whether the same, let&rsquo;s look at the general idea of the implementation of StringBuilder in Java how my local jdk version for <code>1.8.0_191</code>, the first is also the initialization logic</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c#" data-lang="c#"><span class="c1">//存储块也就是承载Append数据的容器
</span><span class="c1"></span><span class="kt">char</span><span class="p">[]</span> <span class="k">value</span><span class="p">;</span>
<span class="c1">//StringBuilder的总长度
</span><span class="c1"></span><span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
<span class="k">public</span> <span class="n">StringBuilder</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//默认的容量也是16
</span><span class="c1"></span>    <span class="n">super</span><span class="p">(</span><span class="m">16</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">public</span> <span class="n">StringBuilder</span><span class="p">(</span><span class="n">String</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//这个地方有差异如果通过指定字符串初始化StringBuilder
</span><span class="c1"></span>    <span class="c1">//则初始化的长度则是当前传递的str的长度+16
</span><span class="c1"></span>    <span class="n">super</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="p">+</span> <span class="m">16</span><span class="p">);</span>
    <span class="n">append</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// AbstractStringBuilder.java
</span><span class="c1"></span><span class="n">AbstractStringBuilder</span><span class="p">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">value</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">capacity</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Here you can see that the logic of the initialization capacity of java is a little different from c#, the default initialization length of c# depends on the length of the initialization string that can be stored mainly, while the implementation of java is in the <code>current length +16</code> length, that is, the length of this initialization 16 must be available anyway. So let&rsquo;s look at the source code for the implementation of <code>append</code> again.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c#" data-lang="c#"><span class="c1">// AbstractStringBuilder.java
</span><span class="c1"></span><span class="k">public</span> <span class="n">AbstractStringBuilder</span> <span class="n">append</span><span class="p">(</span><span class="n">String</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">str</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">appendNull</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="p">=</span> <span class="n">str</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
    <span class="c1">// 这里是扩容操作
</span><span class="c1"></span>    <span class="n">ensureCapacityInternal</span><span class="p">(</span><span class="n">count</span> <span class="p">+</span> <span class="n">len</span><span class="p">);</span>
    <span class="n">str</span><span class="p">.</span><span class="n">getChars</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="k">value</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
    <span class="c1">//每次append之后重新设置长度
</span><span class="c1"></span>    <span class="n">count</span> <span class="p">+=</span> <span class="n">len</span><span class="p">;</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
<span class="p">}</span> 
</code></pre></td></tr></table>
</div>
</div><p>The core is the method to expand ensureCapacityInternal, let&rsquo;s simply look at its implementation</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c#" data-lang="c#"><span class="k">private</span> <span class="k">void</span> <span class="n">ensureCapacityInternal</span><span class="p">(</span><span class="kt">int</span> <span class="n">minimumCapacity</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//当前需要的长度&gt;char[]的长度则需要扩容
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">minimumCapacity</span> <span class="p">-</span> <span class="k">value</span><span class="p">.</span><span class="n">length</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span>
        <span class="n">expandCapacity</span><span class="p">(</span><span class="n">minimumCapacity</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">void</span> <span class="n">expandCapacity</span><span class="p">(</span><span class="kt">int</span> <span class="n">minimumCapacity</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//新扩容的长度是当前块char[]的长度的2倍+2
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">newCapacity</span> <span class="p">=</span> <span class="k">value</span><span class="p">.</span><span class="n">length</span> <span class="p">*</span> <span class="m">2</span> <span class="p">+</span> <span class="m">2</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">newCapacity</span> <span class="p">-</span> <span class="n">minimumCapacity</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">)</span>
        <span class="n">newCapacity</span> <span class="p">=</span> <span class="n">minimumCapacity</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">newCapacity</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">minimumCapacity</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">OutOfMemoryError</span><span class="p">();</span>
        <span class="n">newCapacity</span> <span class="p">=</span> <span class="n">Integer</span><span class="p">.</span><span class="n">MAX_VALUE</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//把当前的char[]复制到新扩容的字符数组中
</span><span class="c1"></span>    <span class="k">value</span> <span class="p">=</span> <span class="n">Arrays</span><span class="p">.</span><span class="n">copyOf</span><span class="p">(</span><span class="k">value</span><span class="p">,</span> <span class="n">newCapacity</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Arrays.java copy的逻辑
</span><span class="c1"></span><span class="k">public</span> <span class="k">static</span> <span class="kt">char</span><span class="p">[]</span> <span class="n">copyOf</span><span class="p">(</span><span class="kt">char</span><span class="p">[]</span> <span class="n">original</span><span class="p">,</span> <span class="kt">int</span> <span class="n">newLength</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//声明一个新的数组，把original的数据copy到新的char数组中
</span><span class="c1"></span>    <span class="kt">char</span><span class="p">[]</span> <span class="n">copy</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">newLength</span><span class="p">];</span>
    <span class="n">System</span><span class="p">.</span><span class="n">arraycopy</span><span class="p">(</span><span class="n">original</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span>
                     <span class="n">Math</span><span class="p">.</span><span class="n">min</span><span class="p">(</span><span class="n">original</span><span class="p">.</span><span class="n">length</span><span class="p">,</span> <span class="n">newLength</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">copy</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The last thing to show is the operation to get the StringBuilder result, again the <code>toString</code> method, let&rsquo;s look at the implementation of this logic in java.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c#" data-lang="c#"><span class="n">@Override</span>
<span class="k">public</span> <span class="n">String</span> <span class="n">toString</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 这里创建了一个新的String对象返回，通过当前char[]初始化这个字符串
</span><span class="c1"></span>    <span class="k">return</span> <span class="k">new</span> <span class="n">String</span><span class="p">(</span><span class="k">value</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>By now the logic of StringBuilder in java is very clear to all of us.</p>
<ul>
<li>The real data of StringBuilder in c# is stored in <code>m_ChunkChars character array</code>, but the overall data structure is <code>one way chain table</code>, while in java it is completely <code>char[]</code> character array.</li>
<li>The initial length of StringBuilder in c# is the length that can hold the current initialized string, while the initialized length of java is the length of the current passed string + 16.</li>
<li>The expansion of StringBuilder in c# is to generate a new instance of StringBuilder with a capacity related to the length of the previous StringBuilder. java generates a new array of the length of the original <code>char[] array * 2 + 2</code> length.</li>
<li>The ToString implementation in c# iterates through the inverted chain to assemble a new string to return, while java initializes a new string with the <code>char[]</code> of the current StringBuilder to return.</li>
</ul>
<p>About the c# and java StringBuilder implementation is so different, in the end which implementation is better? There is no way to evaluate this, after all, each language&rsquo;s underlying class library implementation is well thought out and integrates many people&rsquo;s ideas. From the owner&rsquo;s point of view, the core function of StringBuilder itself lies in the construction process, so the performance of the construction process is very important, so the logic of similar array expansion and then copy is not as efficient as the way of a chain table. However, when it comes to the final ToString result, the advantage of the array is very obvious, after all, string is essentially a <code>char[] array</code>.</p>
<blockquote>
<p>For StringBuilder append is a frequent operation and most of the cases may be append operation many times, while ToString operation for StringBuilder is basically only once, that is when you get the result of StringBuilder construction. So the owner feels that improving the performance of append is the key.</p>
</blockquote>
<h2 id="summary">Summary</h2>
<p>In this article we have explained the general implementation of c# StringBuilder, and also compared the differences between c# and java regarding the implementation of StringBuilder, the main difference is that the underlying data structure implemented in c# is a <code>unidirectional chain table</code>, but the data of each node is stored in <code>char[]</code>, while the overall implementation of java is an <code>array</code>. is an <code>array</code>. This also provides us with a different way of thinking, and here we also summarize its implementation again.</p>
<ul>
<li>c# StringBuilder is essentially a <code>one way chain</code> operation, StringBuilder itself contains <code>m_ChunkPrevious</code> pointing to the data saved in the last expansion, the essence of the expansion is to add a new node to the chain.</li>
<li>The actual length of the expansion is <code>max(the remaining length of the current appended character, min(the current StringBuilder length, 8000))</code>, and the capacity of the new node storage block will be increased each time the expansion is done. Most of the cases encountered when using is the first time for 16, the second time for 16, three times for 32, four times for 64 and so on.</li>
<li>c# StringBuilder class ToString is the essence of inverted traversal of the one-way chain table, each traversal to obtain the current StringBuilder <code>m_ChunkPrevious array of characters</code> after the completion of data stitching, and then get <code>m_ChunkPrevious</code> pointed to the last StringBuilder instance, and finally the results are assembled into a string to return.</li>
<li>The main difference between the c# and java implementations of StringBuilder is that the overall underlying data structure of the c# implementation is a <code>unidirectional chain table</code>, but the data itself is stored in <code>char[]</code> in each StringBuilder instance, which is a bit like the redis <code>quicklist</code>. The overall approach is a <code>char[]</code> array of characters.</li>
</ul>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/c/">c#</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-03/jose/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Javascript Object Signing and Encryption</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-03/differences-bettween-time-and-datetime-in-python/">
            <span class="next-text nav-default">Python time processing standard library: time and datetime modules</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
