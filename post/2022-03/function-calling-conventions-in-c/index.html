<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Function calling conventions in C - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="This article focuses on function calling conventions in C. The assembly code is combined with real-time observation of stack changes to visualize the process of function calls. This article only discusses the situation in x86/64 architecture, Linux/GCC environment, but other environments should be similar in overall idea and need to deal with these issues." /><meta name="keywords" content="c, Function Calling Conventions" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-03/function-calling-conventions-in-c/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Function calling conventions in C" />
<meta property="og:description" content="This article focuses on function calling conventions in C. The assembly code is combined with real-time observation of stack changes to visualize the process of function calls. This article only discusses the situation in x86/64 architecture, Linux/GCC environment, but other environments should be similar in overall idea and need to deal with these issues." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-03/function-calling-conventions-in-c/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-03-24T10:35:03+08:00" />
<meta property="article:modified_time" content="2022-03-24T10:35:03+08:00" />

<meta itemprop="name" content="Function calling conventions in C">
<meta itemprop="description" content="This article focuses on function calling conventions in C. The assembly code is combined with real-time observation of stack changes to visualize the process of function calls. This article only discusses the situation in x86/64 architecture, Linux/GCC environment, but other environments should be similar in overall idea and need to deal with these issues."><meta itemprop="datePublished" content="2022-03-24T10:35:03+08:00" />
<meta itemprop="dateModified" content="2022-03-24T10:35:03+08:00" />
<meta itemprop="wordCount" content="2703">
<meta itemprop="keywords" content="c," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Function calling conventions in C"/>
<meta name="twitter:description" content="This article focuses on function calling conventions in C. The assembly code is combined with real-time observation of stack changes to visualize the process of function calls. This article only discusses the situation in x86/64 architecture, Linux/GCC environment, but other environments should be similar in overall idea and need to deal with these issues."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Function calling conventions in C</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-03-24 10:35:03 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 2703 words </span>
          <span class="more-meta"> 6 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#preface">Preface</a></li>
        <li><a href="#typical-stack-frame-structure">Typical stack frame structure</a></li>
        <li><a href="#caller-rules">Caller rules</a></li>
        <li><a href="#rules-for-callee">Rules for callee</a></li>
        <li><a href="#c-example">C example</a></li>
        <li><a href="#caller-section">Caller section</a></li>
        <li><a href="#the-called-part">The called part</a></li>
        <li><a href="#the-difference-on-x64">The difference on x64</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>This article focuses on function calling conventions in C. The assembly code is combined with real-time observation of stack changes to visualize the process of function calls. This article only discusses the situation in x86/64 architecture, Linux/GCC environment, but other environments should be similar in overall idea and need to deal with these issues.</p>
<h2 id="preface">Preface</h2>
<p>What is the Calling Convention?</p>
<p>It is mainly to facilitate the sharing of code and to simplify the way sub-functions are used. How are arguments and return values passed, how are stack frames created and destroyed, and what are the caller and callee responsible for? The calling convention specifies all of these, and as long as both the function definer and the caller follow this convention, then the interaction can be error-free; otherwise, inconsistent state can lead to fatal errors in the program.</p>
<p>The x86 C compiler usually uses the cdecl calling convention by default, and this is the de facto standard for the C language. There are of course a number of other calling conventions, which the reader can learn more about through the references at the end of this article.</p>
<h2 id="typical-stack-frame-structure">Typical stack frame structure</h2>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/4979a0e88db946a6bb663481764a0a4d.png" alt="Typical stack frame structure"></p>
<p>The figure above shows the structure of a typical stack frame during a call to a subfunction. The stack grows upwards from the high address below, one stack frame upwards for each nested layer of function calls. The return address can be seen as the dividing line for each stack frame, with the top part of it going to the callee and the bottom part of it going to the caller.</p>
<p>ESP and EBP indicate the current top-of-stack position and the base address of the current stack frame, respectively. EBP with appropriate offsets allows easy access to parameters and local variables, as well as fast frame closure.</p>
<p>The calling convention can be divided into two parts, the part that specifies the caller and the part that specifies the callee. They are described separately below.</p>
<h2 id="caller-rules">Caller rules</h2>
<p>When initiating a subfunction call, the caller needs to.</p>
<ol>
<li>first need to save the values of certain registers before calling the subfunction. These registers are designed to be saved by the caller, so that the called function is allowed to modify them. If the caller relies on the values of these registers after the subfunction returns, it must save the values of these registers on the stack before calling the subfunction, and restore them off the stack after the subfunction returns. The registers saved by the caller are EAX, ECX, EDX2;</li>
<li>then, the caller needs to call the sub-function parameters on the stack, the stacking order is from right to left, so the first parameter at the top of the stack (low address)3;</li>
<li>use the <code>call</code> instruction to call the sub-function, this instruction will return the address (that is, the address of the next instruction of the current function) on the stack, and then jump to the sub-function to start execution;</li>
</ol>
<p>We&rsquo;ll look at the callee rules later. For now, let&rsquo;s assume that the subfunction has returned, so the stack has normally reverted to the situation before the <code>call</code> instruction was called. The caller can get the return value of the subfunction from the EAX register. To fully restore the state before the subfunction call, you also need to.</p>
<ol>
<li>remove the arguments from the stack;</li>
<li>restoring the contents of the caller&rsquo;s saved registers that were previously stacked out of the stack (in the reverse order of the stack entry). The caller can assume that the other registers have not been modified by the subfunction;</li>
</ol>
<h2 id="rules-for-callee">Rules for callee</h2>
<p>The sub-function at the beginning needs to.</p>
<ol>
<li>stack the value of EBP, and then copy the value of ESP to EBP. You can think of this as an open frame operation, first saving the base address of the previous stack frame, then setting the base address of the current stack frame (i.e. the value of the stack pointer when the subfunction first starts execution), the parameters and local variables have a fixed offset from EBP, so they can be accessed through EBP2;</li>
<li>next, allocate the stack space for local variables, which can be achieved by decreasing the value of ESP3;</li>
<li>then you need to add the values of the registers saved by the callee to the stack (if they are used in subfunctions). The registers saved by the transferee include EBX, EDI and ESI;</li>
</ol>
<p>After executing these 3 steps, the actual function body is executed. When the function body is about to return at the end of execution, it needs to.</p>
<ol>
<li>put the return value in EAX</li>
<li>put the values of the registers saved by the caller on the stack (in the opposite order of the stack entry)</li>
<li>release the stack space of local variables, this can be done by increasing the value of ESP, or better yet, restoring the value of EBP to ESP.</li>
<li>then restore the EBP of the previous stack frame and take it off the stack</li>
<li>Finally, execute the <code>ret</code> instruction to return. This instruction will return the previously stacked return address out of the stack, and then jump to this return address to continue execution.</li>
</ol>
<h2 id="c-example">C example</h2>
<p>Let&rsquo;s take a practical look at this with a simple example as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">fa</span> <span class="o">=</span> <span class="mh">0x10</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">fb</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">;</span>
    <span class="n">fa</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">fb</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">fa</span> <span class="o">+</span> <span class="n">fb</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>After we compile it, we use objdump to disassemble.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># 内核版本 2.6.8-2-686-smp</span>
<span class="c1"># gcc版本 3.3.5</span>
$ gcc -g -O0 test.c
$ objdump -Sd a.out &gt; a.s
<span class="c1"># 如果只想编译的话，可以直接</span>
<span class="c1"># gcc -S test.c</span>
</code></pre></td></tr></table>
</div>
</div><p>Next we will visualize the process of calling a function, i.e., the foo function above, in conjunction with the assembly code and the stack in real time.</p>
<h2 id="caller-section">Caller section</h2>
<p>First, let&rsquo;s look at the first part of the main function</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
 <span class="mi">804837</span><span class="nl">c</span><span class="p">:</span>   <span class="mi">55</span>                      <span class="n">push</span>   <span class="o">%</span><span class="n">ebp</span>
 <span class="mi">804837</span><span class="nl">d</span><span class="p">:</span>   <span class="mi">89</span> <span class="n">e5</span>                   <span class="n">mov</span>    <span class="o">%</span><span class="n">esp</span><span class="p">,</span><span class="o">%</span><span class="n">ebp</span>
 <span class="mf">804837f</span><span class="o">:</span>   <span class="mi">83</span> <span class="n">ec</span> <span class="mi">18</span>                <span class="n">sub</span>    <span class="err">$</span><span class="mh">0x18</span><span class="p">,</span><span class="o">%</span><span class="n">esp</span>
 <span class="mi">8048382</span><span class="o">:</span>   <span class="mi">83</span> <span class="n">e4</span> <span class="n">f0</span>                <span class="n">and</span>    <span class="err">$</span><span class="mh">0xfffffff0</span><span class="p">,</span><span class="o">%</span><span class="n">esp</span>
 <span class="mi">8048385</span><span class="o">:</span>   <span class="n">b8</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mo">00</span>          <span class="n">mov</span>    <span class="err">$</span><span class="mh">0x0</span><span class="p">,</span><span class="o">%</span><span class="n">eax</span>
 <span class="mi">804838</span><span class="nl">a</span><span class="p">:</span>   <span class="mi">29</span> <span class="n">c4</span>                   <span class="n">sub</span>    <span class="o">%</span><span class="n">eax</span><span class="p">,</span><span class="o">%</span><span class="n">esp</span>

</code></pre></td></tr></table>
</div>
</div><ol>
<li>the first two instructions are the open frame operation of main function</li>
<li>the next <code>sub $0x18, %esp</code> allocates the stack space, here more space is allocated, including the space for local variables and arguments when calling subfunctions, and there is still room to spare.</li>
<li>the next <code>and $0xfffff0,%esp</code>, is to align esp 16 bytes.</li>
<li>The next two instructions have no real impact, not sure what the purpose is, guess it is also some compiler behavior.</li>
<li><code>movl $0x0,0xfffffffc(%ebp)</code> assigns the first local variable (i.e. ret) to 0.</li>
</ol>
<p>The next part is the part related to the call to the foo function, when the stack is as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/3c7659ed670f4b9f996a2e9a3120ae86.png" alt="stack"></p>
<p>At this point EBP points to the base address of the main function stack frame, and ESP points to the top of the stack location. Since our program is very simple and the registers saved by the caller are not used later, the step of saving registers is omitted here. Since the stack space of the parameters has been allocated at the beginning, the next step is to directly assign the value to the corresponding position of the formal reference on the stack.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/f1be18aaf91b4911bf523e6952234fa8.png" alt="stack"></p>
<p>The parameters are passed in right-to-left order, so the second parameter is passed first and the value at the ESP+4 position is assigned a value of 2.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/8cb1e88a03b34db4a7766be37c25eaf1.png" alt="stack"></p>
<p>Then the first argument is passed, and the value of the ESP position is assigned to 1. Once the argument is passed, the <code>call</code> instruction is executed to enter the scope of the subfunction foo.</p>
<p>Let&rsquo;s skip ahead and assume that the foo function has now returned and look at the last few instructions. The return value is now stored in EAX.</p>
<ol>
<li><code>mov %eax,0xfffffffc(%ebp)</code> assigns the return value to the local variable ret</li>
<li>then the main function returns, so the return value should be put into EAX. (Because we compile with -O0, this step seems a bit redundant)</li>
<li>next to the parameters out of the stack, this operation is not performed separately, but merged into the <code>leave</code> instruction</li>
<li><code>leave</code> instruction, equivalent to <code>mov esp,ebp; pop ebp</code>. It directly closes the current stack frame and clears all the parameters and local variables. As we can see from this example, the compiler does not foolishly perform stack-in and stack-out operations on every function call. In fact, it does some optimization by allocating enough stack space at the beginning to store the local variables and the arguments of the subfunctions to be called later, and then releasing the stack space at the end of the off frame.</li>
<li>If the registers saved by the caller are stacked, the corresponding out-stack operation should be performed here to restore the values of the corresponding registers. Not in our case.</li>
</ol>
<h2 id="the-called-part">The called part</h2>
<p>Now let&rsquo;s look at the part of the callee foo function. After executing the <code>call</code> instruction in the main function, the stack looks like this.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/592499f82c7d4e7d9d7dfc9bcb07766f.png" alt="stack"></p>
<p>At this point, the return address is already on the stack, and EBP is still the base address of the previous main function.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/60e7d0e410a24d5c9c7acaddb8a46063.png" alt="stack"></p>
<p>First you need to create the stack frame of the foo function, put the EBP on the stack, and save the base address of the main function stack frame.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/5410cf40a14a4d23b7e208d690245b38.png" alt="stack"></p>
<p>Immediately after letting EBP point to the current ESP location, EBP becomes the base address of the foo function stack frame. You can then access the form reference and local variables by adding certain offsets to the EBP.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/3f512b277ab34456909c31962717bfca.png" alt="stack"></p>
<p>The next instruction allocates the stack space for local variables, and since there are two int-type local variables, esp is subtracted by 8 here.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/44f88c94661c4d9aa0cc5a2ca0fcde2b.png" alt="stack"></p>
<p>Normally, if the foo function uses the registers saved by the callee, you need to perform a stack operation here now to save the values of the corresponding registers. Since our program is relatively simple, we don&rsquo;t have this process.</p>
<p>Next, assign the EBP-4 location to 0x10, which corresponds to <code>int fa = 0x10;</code> in the C code</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/268004f0ea6d49ddb9181090fd1df312.png" alt="stack"></p>
<p>Similarly, assign the EBP-8 location to 0x20, which corresponds to <code>int fb = 0x10;</code> in the C code.</p>
<p>The next execution assigns the value of the formal parameter a to fa, first assigning the EBP+8 location of the formal parameter a to the EAX register.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/6bd0124c54f64dae86876939ca93276e.png" alt="stack"></p>
<p>Then the value of the EAX register is assigned to the EBP-4 position.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/e3c73773770a45528450c02b73b3132d.png" alt="stack"></p>
<p>The next step is to assign the value of the formal parameter b to fb, which performs a similar operation, with a little transit through the register EAX.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/98884b94dff44873b0cf7abf59bee25d.png" alt="stack"></p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/b68cc87131dd4e59b2cf200ffd2c7a7e.png" alt="stack"></p>
<p>Next, perform the operation of adding fa and fb, first put the value of EBP-8 into EAX, because of the -O0 relationship this step again seems a little redundant, then EBP-4 value added to EAX, after the execution of EAX becomes 3.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/6d7ff099a4f1469aadfc3e55e8cf9b85.png" alt="stack"></p>
<p>Here the function body has been executed, but there is still some after work to be done.</p>
<ol>
<li>the return value is already in EAX at this point.</li>
<li>if there are registers saved by the caller on the stack, here you need to perform the corresponding out-stack operation to restore.</li>
<li>Next, you need to release the stack space of the local variable, and then restore the EBP of the previous stack frame to get it off the stack. These two steps are combined in the <code>leave</code> instruction. After executing <code>leave</code>, the stack looks like this. The top of the stack is the return address, and the EBP has been restored to the base address of the main function.</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/a0db2538688449c49c345ea33d14d32c.png" alt="stack"></p>
<p>After the last <code>ret</code> instruction is executed, the return address comes out of the stack, the stack reverts to the situation before the execution of the <code>call</code> instruction, and the program jumps to the return address to continue executing the subsequent code of the main function.</p>
<h2 id="the-difference-on-x64">The difference on x64</h2>
<p>On x64, not only is the number of registers extended to 64 bits, but there are also more registers available. Linux uses the System V AMD64 ABI calling convention on x64, the main elements of which are as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt">%rax     %eax    返回值
%rbx     %ebx    被调用者保存
%rcx     %ecx    第四个参数
%rdx     %edx    第三个参数，128位返回值
%rsi     %esi    第二个参数
%rdi     %edi    第一个参数
%rbp     %ebp    基址指针，被调用者保存
%rsp     %esp    堆栈指针，被调用者保存
%r8      %r8d    第五个参数
%r9      %r9d    第六个参数
%r10     %r10d   调用者保存
%r11     %r11d   调用者保存
%r12     %r12d   被调用者保存
%r13     %r13d   被调用者保存
%r14     %r14d   被调用者保存
%r15     %r15d   被调用者保存
xmm0-7           前8个浮点参数
xmm0-1           浮点返回值
</code></pre></td></tr></table>
</div>
</div><p>The RDI, RSI, RDX, RCX, R8, R9 registers are used to pass the first 6 integer or pointer parameters respectively, and XMM0-7 are used to pass the first 8 floating point parameters. If there are additional parameters, then they are still passed through the stack.</p>
<p>Return values up to 64 bits are passed through RAX, and those up to 128 bits are passed through RAX and RDX. Floating point return values use XMM0 and XMM1.</p>
<p>The registers RBX, RBP, RSP, and R12-R15 are saved by the caller, and the rest are saved by the caller.</p>
<p>Another point worth mentioning is that for leaf-node functions, a 128-byte space (red-zone) is reserved below the stack pointer of the function, which can be used by the compiler to save local variables, thus eliminating some instructions at the beginning.</p>
<p>Let&rsquo;s recompile the previous example code in x64 environment and see the difference</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="c1">// 内核版本 5.4.0-91-generic
</span><span class="c1">// gcc版本 7.5.0
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
 <span class="mi">628</span><span class="o">:</span>   <span class="mi">55</span>                      <span class="n">push</span>   <span class="o">%</span><span class="n">rbp</span>
 <span class="mi">629</span><span class="o">:</span>   <span class="mi">48</span> <span class="mi">89</span> <span class="n">e5</span>                <span class="n">mov</span>    <span class="o">%</span><span class="n">rsp</span><span class="p">,</span><span class="o">%</span><span class="n">rbp</span>
 <span class="mi">62</span><span class="nl">c</span><span class="p">:</span>   <span class="mi">48</span> <span class="mi">83</span> <span class="n">ec</span> <span class="mi">10</span>             <span class="n">sub</span>    <span class="err">$</span><span class="mh">0x10</span><span class="p">,</span><span class="o">%</span><span class="n">rsp</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="mi">630</span><span class="o">:</span>   <span class="n">c7</span> <span class="mi">45</span> <span class="n">fc</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mo">00</span>    <span class="n">movl</span>   <span class="err">$</span><span class="mh">0x0</span><span class="p">,</span><span class="o">-</span><span class="mh">0x4</span><span class="p">(</span><span class="o">%</span><span class="n">rbp</span><span class="p">)</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
 <span class="mi">637</span><span class="o">:</span>   <span class="n">be</span> <span class="mo">02</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mo">00</span>          <span class="n">mov</span>    <span class="err">$</span><span class="mh">0x2</span><span class="p">,</span><span class="o">%</span><span class="n">esi</span>
 <span class="mi">63</span><span class="nl">c</span><span class="p">:</span>   <span class="n">bf</span> <span class="mo">01</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mo">00</span>          <span class="n">mov</span>    <span class="err">$</span><span class="mh">0x1</span><span class="p">,</span><span class="o">%</span><span class="n">edi</span>
 <span class="mi">641</span><span class="o">:</span>   <span class="n">e8</span> <span class="n">b4</span> <span class="n">ff</span> <span class="n">ff</span> <span class="n">ff</span>          <span class="n">callq</span>  <span class="mf">5f</span><span class="n">a</span> <span class="o">&lt;</span><span class="n">foo</span><span class="o">&gt;</span>
 <span class="mi">646</span><span class="o">:</span>   <span class="mi">89</span> <span class="mi">45</span> <span class="n">fc</span>                <span class="n">mov</span>    <span class="o">%</span><span class="n">eax</span><span class="p">,</span><span class="o">-</span><span class="mh">0x4</span><span class="p">(</span><span class="o">%</span><span class="n">rbp</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
 <span class="mi">649</span><span class="o">:</span>   <span class="mi">8</span><span class="n">b</span> <span class="mi">45</span> <span class="n">fc</span>                <span class="n">mov</span>    <span class="o">-</span><span class="mh">0x4</span><span class="p">(</span><span class="o">%</span><span class="n">rbp</span><span class="p">),</span><span class="o">%</span><span class="n">eax</span>
<span class="p">}</span>
 <span class="mi">64</span><span class="nl">c</span><span class="p">:</span>   <span class="n">c9</span>                      <span class="n">leaveq</span>
 <span class="mi">64</span><span class="nl">d</span><span class="p">:</span>   <span class="n">c3</span>                      <span class="n">retq</span>
 <span class="mi">64</span><span class="nl">e</span><span class="p">:</span>   <span class="mi">66</span> <span class="mi">90</span>                   <span class="n">xchg</span>   <span class="o">%</span><span class="n">ax</span><span class="p">,</span><span class="o">%</span><span class="n">ax</span>
</code></pre></td></tr></table>
</div>
</div><p>You can see that the two parameters are not passed through the stack, but through the edi and esi registers, respectively.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
 <span class="mf">5f</span><span class="nl">a</span><span class="p">:</span>   <span class="mi">55</span>                      <span class="n">push</span>   <span class="o">%</span><span class="n">rbp</span>
 <span class="mf">5f</span><span class="nl">b</span><span class="p">:</span>   <span class="mi">48</span> <span class="mi">89</span> <span class="n">e5</span>                <span class="n">mov</span>    <span class="o">%</span><span class="n">rsp</span><span class="p">,</span><span class="o">%</span><span class="n">rbp</span>
 <span class="mf">5f</span><span class="nl">e</span><span class="p">:</span>   <span class="mi">89</span> <span class="mi">7</span><span class="n">d</span> <span class="n">ec</span>                <span class="n">mov</span>    <span class="o">%</span><span class="n">edi</span><span class="p">,</span><span class="o">-</span><span class="mh">0x14</span><span class="p">(</span><span class="o">%</span><span class="n">rbp</span><span class="p">)</span>
 <span class="mi">601</span><span class="o">:</span>   <span class="mi">89</span> <span class="mi">75</span> <span class="n">e8</span>                <span class="n">mov</span>    <span class="o">%</span><span class="n">esi</span><span class="p">,</span><span class="o">-</span><span class="mh">0x18</span><span class="p">(</span><span class="o">%</span><span class="n">rbp</span><span class="p">)</span>
    <span class="kt">int</span> <span class="n">fa</span> <span class="o">=</span> <span class="mh">0x10</span><span class="p">;</span>
 <span class="mi">604</span><span class="o">:</span>   <span class="n">c7</span> <span class="mi">45</span> <span class="n">f8</span> <span class="mi">10</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mo">00</span>    <span class="n">movl</span>   <span class="err">$</span><span class="mh">0x10</span><span class="p">,</span><span class="o">-</span><span class="mh">0x8</span><span class="p">(</span><span class="o">%</span><span class="n">rbp</span><span class="p">)</span>
    <span class="kt">int</span> <span class="n">fb</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">;</span>
 <span class="mi">60</span><span class="nl">b</span><span class="p">:</span>   <span class="n">c7</span> <span class="mi">45</span> <span class="n">fc</span> <span class="mi">20</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mo">00</span>    <span class="n">movl</span>   <span class="err">$</span><span class="mh">0x20</span><span class="p">,</span><span class="o">-</span><span class="mh">0x4</span><span class="p">(</span><span class="o">%</span><span class="n">rbp</span><span class="p">)</span>
    <span class="n">fa</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
 <span class="mi">612</span><span class="o">:</span>   <span class="mi">8</span><span class="n">b</span> <span class="mi">45</span> <span class="n">ec</span>                <span class="n">mov</span>    <span class="o">-</span><span class="mh">0x14</span><span class="p">(</span><span class="o">%</span><span class="n">rbp</span><span class="p">),</span><span class="o">%</span><span class="n">eax</span>
 <span class="mi">615</span><span class="o">:</span>   <span class="mi">89</span> <span class="mi">45</span> <span class="n">f8</span>                <span class="n">mov</span>    <span class="o">%</span><span class="n">eax</span><span class="p">,</span><span class="o">-</span><span class="mh">0x8</span><span class="p">(</span><span class="o">%</span><span class="n">rbp</span><span class="p">)</span>
    <span class="n">fb</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
 <span class="mi">618</span><span class="o">:</span>   <span class="mi">8</span><span class="n">b</span> <span class="mi">45</span> <span class="n">e8</span>                <span class="n">mov</span>    <span class="o">-</span><span class="mh">0x18</span><span class="p">(</span><span class="o">%</span><span class="n">rbp</span><span class="p">),</span><span class="o">%</span><span class="n">eax</span>
 <span class="mi">61</span><span class="nl">b</span><span class="p">:</span>   <span class="mi">89</span> <span class="mi">45</span> <span class="n">fc</span>                <span class="n">mov</span>    <span class="o">%</span><span class="n">eax</span><span class="p">,</span><span class="o">-</span><span class="mh">0x4</span><span class="p">(</span><span class="o">%</span><span class="n">rbp</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fa</span> <span class="o">+</span> <span class="n">fb</span><span class="p">;</span>
 <span class="mi">61</span><span class="nl">e</span><span class="p">:</span>   <span class="mi">8</span><span class="n">b</span> <span class="mi">55</span> <span class="n">f8</span>                <span class="n">mov</span>    <span class="o">-</span><span class="mh">0x8</span><span class="p">(</span><span class="o">%</span><span class="n">rbp</span><span class="p">),</span><span class="o">%</span><span class="n">edx</span>
 <span class="mi">621</span><span class="o">:</span>   <span class="mi">8</span><span class="n">b</span> <span class="mi">45</span> <span class="n">fc</span>                <span class="n">mov</span>    <span class="o">-</span><span class="mh">0x4</span><span class="p">(</span><span class="o">%</span><span class="n">rbp</span><span class="p">),</span><span class="o">%</span><span class="n">eax</span>
 <span class="mi">624</span><span class="o">:</span>   <span class="mo">01</span> <span class="n">d0</span>                   <span class="n">add</span>    <span class="o">%</span><span class="n">edx</span><span class="p">,</span><span class="o">%</span><span class="n">eax</span>
<span class="p">}</span>
 <span class="mi">626</span><span class="o">:</span>   <span class="mi">5</span><span class="n">d</span>                      <span class="n">pop</span>    <span class="o">%</span><span class="n">rbp</span>
 <span class="mi">627</span><span class="o">:</span>   <span class="n">c3</span>                      <span class="n">retq</span>
</code></pre></td></tr></table>
</div>
</div><p>Let&rsquo;s take a look at the foo function again and notice that it does not allocate stack space for local variables inside it, but assigns them directly via rbp. This is because the foo function is the leaf node function we mentioned earlier, it does not call any other function, so it can use the red-zone space directly.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/c/">c</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-03/cryptography-ssl/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Cryptography fundamentals and SSL/TLS protocols</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-03/openssl-cve-2022-0778/">
            <span class="next-text nav-default">OpenSSL CVE-2022-0778 Vulnerability Recurrence and Illegal Certificate Construction</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
