<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Getting Started with Kubernetes - A Knowledge Base - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Start with an introduction to k8s knowledge points and common terms.
Master The Master node, the brain of k8s, is the control node of the cluster and is responsible for the management and control of the cluster. All other Nodes register themselves with the Master and report all information about themselves on a regular basis. The following four processes run on the Master node.
 Api Server: The service process that provides the HTTP Rest interface; the only entry point for all resource add, delete, and check operations; the entry point for cluster control, kubectl is directly responsible for the Api Server." /><meta name="keywords" content="kubernetes, Knowledge Base" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-03/kubernetes-knowledge-base/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Getting Started with Kubernetes - A Knowledge Base" />
<meta property="og:description" content="Start with an introduction to k8s knowledge points and common terms.
Master The Master node, the brain of k8s, is the control node of the cluster and is responsible for the management and control of the cluster. All other Nodes register themselves with the Master and report all information about themselves on a regular basis. The following four processes run on the Master node.
 Api Server: The service process that provides the HTTP Rest interface; the only entry point for all resource add, delete, and check operations; the entry point for cluster control, kubectl is directly responsible for the Api Server." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-03/kubernetes-knowledge-base/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-03-12T11:08:29+08:00" />
<meta property="article:modified_time" content="2022-03-12T11:08:29+08:00" />

<meta itemprop="name" content="Getting Started with Kubernetes - A Knowledge Base">
<meta itemprop="description" content="Start with an introduction to k8s knowledge points and common terms.
Master The Master node, the brain of k8s, is the control node of the cluster and is responsible for the management and control of the cluster. All other Nodes register themselves with the Master and report all information about themselves on a regular basis. The following four processes run on the Master node.
 Api Server: The service process that provides the HTTP Rest interface; the only entry point for all resource add, delete, and check operations; the entry point for cluster control, kubectl is directly responsible for the Api Server."><meta itemprop="datePublished" content="2022-03-12T11:08:29+08:00" />
<meta itemprop="dateModified" content="2022-03-12T11:08:29+08:00" />
<meta itemprop="wordCount" content="1615">
<meta itemprop="keywords" content="kubernetes," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Getting Started with Kubernetes - A Knowledge Base"/>
<meta name="twitter:description" content="Start with an introduction to k8s knowledge points and common terms.
Master The Master node, the brain of k8s, is the control node of the cluster and is responsible for the management and control of the cluster. All other Nodes register themselves with the Master and report all information about themselves on a regular basis. The following four processes run on the Master node.
 Api Server: The service process that provides the HTTP Rest interface; the only entry point for all resource add, delete, and check operations; the entry point for cluster control, kubectl is directly responsible for the Api Server."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Getting Started with Kubernetes - A Knowledge Base</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-03-12 11:08:29 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 1615 words </span>
          <span class="more-meta"> 8 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#master">Master</a></li>
        <li><a href="#node">Node</a></li>
        <li><a href="#namespace">Namespace</a></li>
        <li><a href="#pods">Pods</a></li>
        <li><a href="#volume">Volume</a>
          <ul>
            <li><a href="#types">Types</a></li>
          </ul>
        </li>
        <li><a href="#deployment">Deployment</a></li>
        <li><a href="#label">Label</a></li>
        <li><a href="#annotation">Annotation</a></li>
        <li><a href="#replica-set">Replica Set</a></li>
        <li><a href="#service">Service</a>
          <ul>
            <li><a href="#load-balancing">Load balancing</a></li>
            <li><a href="#clusterip">ClusterIP</a></li>
            <li><a href="#service-discovery">Service Discovery</a></li>
            <li><a href="#external-system-access-service">External System Access Service</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>Start with an introduction to k8s knowledge points and common terms.</p>
<h2 id="master">Master</h2>
<p>The Master node, the brain of k8s, is the control node of the cluster and is responsible for the management and control of the cluster. All other Nodes register themselves with the Master and report all information about themselves on a regular basis. The following four processes run on the Master node.</p>
<ul>
<li>Api Server: The service process that provides the HTTP Rest interface; the only entry point for all resource add, delete, and check operations; the entry point for cluster control, <code>kubectl</code> is directly responsible for the Api Server.</li>
<li>Controller Manager : The automated control center for all resource objects.</li>
<li>Scheduler: responsible for resource scheduling, mainly scheduling Pods to the specified Node.</li>
<li>etc Server : All the data of resource objects are stored in etcd.</li>
</ul>
<h2 id="node">Node</h2>
<p>If a Node does not report information for more than a specified period of time, it will be judged as out-of-connection by the Master, and the status of the Node will be marked as unavailable, and then the Master will trigger the automatic process of &ldquo;workload transfer&rdquo;. There are three main processes running on the Node.</p>
<ul>
<li>kubelet: responsible for creating, starting and stopping containers corresponding to Pods; works closely with Master nodes to achieve the basic functions of cluster management; Node reports information to Master through kubelet.</li>
<li>kube-proxy: implements the communication and load balancing mechanism of the Service.</li>
<li>Docker Engine: responsible for the creation and management of local containers.</li>
</ul>
<h2 id="namespace">Namespace</h2>
<p>Namespace is used to implement multi-tenant resource isolation. By assigning the resource objects inside the cluster to different Namespace. When creating a resource object, you can specify which Namespace it belongs to.</p>
<h2 id="pods">Pods</h2>
<p>Pods are the smallest scheduling unit of k8s.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/12/8cfb986baf2e401dbbf7ba8383cc11f8.png" alt="k8s pod"></p>
<p>As shown in the figure above, Pods are composed of one container, called a container group. The containers that make up a Pod are divided into Pause containers and individual business containers. The state of the Pause container represents the state of the entire Pod, and since the Pause container does not die easily, this ensures the judgment of the Pod&rsquo;s state as a whole; while all business containers share the IP and Volume of the Pause, which solves the problem of communication and sharing of resources among the closely connected business containers. kubelet scheduling.</p>
<p>Pods have unique IPs, and k8s uses the Endpoint (pod_ip + containerPort) as the external communication address for a service process in a Pod. The Endpoint of a Pod has the same lifecycle as the Pod, and when the Pod is destroyed, the corresponding Endpoint is also destroyed.</p>
<p>There are two types of Pods.</p>
<ul>
<li>Normal Pods, which are stored in etcd and are dispatched to a Node for binding, and are instantiated into a set of containers and started by a kubelet in the Node after dispatch.</li>
<li>Static Pods, which are stored in a specific file on a specific Node and are started and run only in that Node.</li>
</ul>
<h2 id="volume">Volume</h2>
<p>is defined on a Pod and is mounted to a specific file directory by multiple containers within a Pod. Note that Volume has the same lifecycle as Pod.</p>
<p>Role: Multiple containers in a Pod share files; let the container&rsquo;s data write to the host&rsquo;s disk; write files to network storage; centralized definition and management of container configuration files.</p>
<h3 id="types">Types</h3>
<ul>
<li>emptyDir: Created when a Pod is assigned to a Node without specifying a directory file on the host. when a Pod is removed, the data on emptyDir is permanently deleted.</li>
<li>hostPath: Mounts a file or directory on the host on the Pod. Pods with the same configuration on different Nodes may have inconsistent access results to directories and files on the Volume because the directories and files on the host are different; if resource quota management is used, k8s cannot include the resources used by hostPath on the host in the management.
<ul>
<li>Usage: Log files generated by containers need to be saved permanently; need to access the Docker engine on the host, define hostPath as the host /var/lib/docker directory.</li>
</ul>
</li>
<li>Other: such as gcePersistentDisk, awsElasticBlockStore, etc., are permanent disks provided by specific cloud services. pods are not deleted when they end, they are only unmounted. The Pods are not deleted at the end of the day, they are only uninstalled. You need to install specific virtual machines and persistent disks as required to use them.</li>
</ul>
<h2 id="deployment">Deployment</h2>
<p>Used to better solve the Pod orchestration problem, which uses ReplicaSet internally to achieve the purpose.</p>
<p>Usage scenarios.</p>
<ul>
<li>Generating RS and completing the process of creating a copy of the Pod.</li>
<li>Checking if the deployment action is complete.</li>
<li>Updating Deployment to create a new Pod.</li>
<li>Rollback.</li>
<li>Hanging or recovery.</li>
</ul>
<p>Description of the number of Pods</p>
<ul>
<li>DESIRED: Desired value for the number of Pod replicas</li>
<li>CURRENT: The current number of replicas</li>
<li>UP_TO_DATE: The number of Pod copies of the latest version</li>
<li>AVAILABLE: Number of Pod copies currently available in the cluster</li>
</ul>
<h2 id="label">Label</h2>
<p>Definition form: key=value. We mainly use Label Selector to query and filter the resource objects of certain labels.</p>
<p>Usage scenarios.</p>
<ul>
<li>kube-controller filtering Pods to be monitored</li>
<li>kube-proxy process builds a routing table for Service requests to Pods.</li>
<li>kube-scheduler process to implement Pod directed scheduling</li>
</ul>
<h2 id="annotation">Annotation</h2>
<p>Definition form: key=value</p>
<p>Difference from Label.</p>
<ul>
<li>Label has strict naming rules</li>
<li>Label defines metadata and is used in Label Selector; Annotation is additional information arbitrarily defined by the user</li>
</ul>
<p>Usage Scenarios.</p>
<ul>
<li>build information, release information, Docker image information, etc.</li>
<li>Addresses of log repositories, monitoring repositories, analysis repositories, and other repositories</li>
<li>Program debugging tool information</li>
<li>Contact information for the team</li>
</ul>
<h2 id="replica-set">Replica Set</h2>
<p>Replica Set(RS) is an upgraded version of Replication Controller(RC). The only difference between the two is the support for selectors; ReplicaSet supports set-based selector requirements as described in the labels user guide, while Replication Controller only supports equality-based selector requirements.</p>
<p>We generally use Deployment to define RSs, and rarely create them directly, thus forming a complete orchestration mechanism for creating, deleting, and updating Pods.</p>
<p>What can be defined in RS are: the expected number of replicas (Replicas) for Pods; Label Selector for filtering target Pods; and template for creating new Pods when the number of Pod replicas is less than the expected number.</p>
<p>The Master&rsquo;s Controller Manager periodically patrols the system for currently live target Pods to ensure that the number of target Pod instances is equal to the desired value. Deleting RSs does not affect Pods and supports collection-based Label Selector; it enables Pod scaling up and scaling down by changing the number of Pod copies in RSs; it enables rolling upgrade of Pods by changing the mirror version in Pod templates in RSs.</p>
<h2 id="service">Service</h2>
<p>Definition: microservice in a microservice architecture.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/12/34823ebb56f7489580b59d6643d114a7.png" alt="k8s service"></p>
<p>Service defines an access entry address for a service through which clients access the cluster instance behind it. service is interfaced with the back-end Pod copy cluster through Label Selector. service communicates with each other via TCP/IP.</p>
<h3 id="load-balancing">Load balancing</h3>
<p>The kube-proxy process is an intelligent load balancer that forwards requests for the Service to the back-end Pods. all copies of the Pods are grouped together, providing an external service port to which the Endpoint list of these Pods is added to the forwarding list. Clients access this service through the external IP + service port of the load balancing.</p>
<h3 id="clusterip">ClusterIP</h3>
<p>A Service has a globally unique virtual IP, called ClusterIP, and each Service becomes a communication node with a globally unique IP. Unlike a Pod, the Endpoint of a Pod changes when the Pod is destroyed, but the ClusterIP does not change during the lifetime of the Service. And as long as a DNS domain name mapping is done with the Name of the Service and the ClusterIP of the Service, service discovery can be realized.</p>
<p>The Service generally defines a targetPort, which is the exposed port of the container providing the service. The specific business process provides TCP/IP access on the targetPort in the container; and the port property of the Service defines the virtual interface of the Service.</p>
<h3 id="service-discovery">Service Discovery</h3>
<p>before: Each Service generates some corresponding Linux environment variables that are automatically injected when the Pod container is started.</p>
<p>now: The DNS system is introduced by means of an Add-On value-added package, which is implemented by using the service name as the DNS domain name.</p>
<h3 id="external-system-access-service">External System Access Service</h3>
<p>There are three types of IPs in k8s.</p>
<ul>
<li>Node IPThe IP address of the physical NIC of each node in the cluster; all servers belonging to this network communicate directly with each other over this network; nodes outside the cluster must communicate over the Node IP when accessing the cluster.</li>
<li>Pod IPDocker Engine assigned based on the IP address segment of the docker0 bridge; virtual Layer 2 network; containers of different Pods communicate with each other through the virtual Layer 2 network where the Pod IP is located.</li>
<li>Cluster IP
<ul>
<li>Service-only: IP addresses are managed and assigned by kuber.</li>
<li>Cannot be pinged: because there is no physical network object to respond to.</li>
<li>Cluster IP can only be combined with Service Port to form a specific communication port: separate Cluster IP does not have a TCP/IP communication base; belongs to the closed space of the kuber cluster; nodes outside the cluster need some additional operations if they need access.</li>
<li>Communication between the Node IP network, Pod IP network and Cluster IP network is a programmatic routing rule of kuber&rsquo;s own making.</li>
</ul>
</li>
</ul>
<p>The method of accessing the Service by external systems in k8s is mainly through NodePort, which is implemented by opening a corresponding TCP listening port on each Node for the Service that needs to provide external access. At this point, external systems can access the service by using the IP + NodePort of any of the Nodes.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/kubernetes/">kubernetes</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-03/js-mapping-tables/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">JavaScript Data Processing - Mapping Tables</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-03/django-signaling-mechanism/">
            <span class="next-text nav-default">Django&#39;s signaling mechanism</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
