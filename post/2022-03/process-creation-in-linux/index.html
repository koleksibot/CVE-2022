<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Process creation in Linux - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="This article explains in detail the creation of processes in Linux." /><meta name="keywords" content="linux, Process" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-03/process-creation-in-linux/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Process creation in Linux" />
<meta property="og:description" content="This article explains in detail the creation of processes in Linux." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-03/process-creation-in-linux/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-03-28T09:33:43+08:00" />
<meta property="article:modified_time" content="2022-03-28T09:33:43+08:00" />

<meta itemprop="name" content="Process creation in Linux">
<meta itemprop="description" content="This article explains in detail the creation of processes in Linux."><meta itemprop="datePublished" content="2022-03-28T09:33:43+08:00" />
<meta itemprop="dateModified" content="2022-03-28T09:33:43+08:00" />
<meta itemprop="wordCount" content="4278">
<meta itemprop="keywords" content="linux," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Process creation in Linux"/>
<meta name="twitter:description" content="This article explains in detail the creation of processes in Linux."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Process creation in Linux</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-03-28 09:33:43 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 4278 words </span>
          <span class="more-meta"> 9 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#what-is-a-process">What is a process</a></li>
        <li><a href="#definition-and-background">Definition and Background</a></li>
        <li><a href="#process-descriptors">Process Descriptors</a></li>
        <li><a href="#process-0">Process 0</a></li>
        <li><a href="#fork-and-system-calls">fork and system calls</a></li>
        <li><a href="#summary">Summary</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>Regardless of the field, building is often much more difficult than destroying. Building a building may take years, while destroying it may be a matter of seconds. At the root of this, because construction is an entropy-reducing process, there must be an input of energy from outside the system. One type of problem in creation that seems even more special is the problem of origins. How did the first life come into being? How did mankind originate? Questions such as these have never ceased to be explored by mankind.</p>
<p>Today we are going to explore the topic of process creation in Linux. Most of you probably know about fork, and you know that processes are divided like a cell division. So are you aware of the following: what do you need to prepare in order to split it? What exactly is divided and what is inherited by the so-called division? How is the genetic material passed on? How does the first process come about?</p>
<p>Let&rsquo;s explore these questions together!</p>
<h2 id="what-is-a-process">What is a process</h2>
<h2 id="definition-and-background">Definition and Background</h2>
<p>Before discussing any issue we need to define it clearly, otherwise the discussion will seem pointless. Similarly, since we are talking about processes, we need to know what a process is first.</p>
<p>This is how processes are usually defined in books: A process is an instance of program execution. You can think of a process as a collection of data structures that describe how far a process has been executed.</p>
<p>This is a simple definition, but it doesn&rsquo;t help us much to understand the underlying layers. Processes are actually a concept that followed the multi-channel programming of operating systems. Early computers did not support multitasking and could only have one program running, but this was too inefficient. So from Intel 80286/80386 onwards, CPUs started to support protected mode, and operating systems started to support multitasking with it. In the era of single-channel programs CPU and memory are yours, you can use them as you like. But not in the era of multi-channel programs, because system resources (CPU, memory, etc.) need to be shared, and the whole system is in chaos if not managed accordingly.</p>
<p>So, the concept of process was abstracted, which takes on the role of an entity that allocates system resources (CPU time, memory, etc.) and provides isolation and protection for access to shared resources.</p>
<p>Processes are like humans, they are created, have their own life cycle and may be in several different states. Similarly, there are kinship and non-kinship relationships between processes.</p>
<h2 id="process-descriptors">Process Descriptors</h2>
<p>In order to manage processes, the kernel must provide a clear description of the process state. This is where the process descriptor comes in. task_struct is a very complex structure that contains all the information related to a process. Even in the early days of Linux 0.11, it already contained so many fields: the most basic process state information, memory-related information, file system-related information, local descriptor table ldt, and task state segment tss. Where ldt holds the descriptors of the code and data segments of the process, and tss is used to record the CPU register information used when the process switches.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">task_struct</span> <span class="p">{</span>
<span class="cm">/* these are hardcoded - don&#39;t touch */</span>
    <span class="kt">long</span> <span class="n">state</span><span class="p">;</span> <span class="cm">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span>
    <span class="kt">long</span> <span class="n">counter</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">priority</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">signal</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">sigaction</span> <span class="n">sigaction</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
    <span class="kt">long</span> <span class="n">blocked</span><span class="p">;</span>   <span class="cm">/* bitmap of masked signals */</span>
<span class="cm">/* various fields */</span>
    <span class="kt">int</span> <span class="n">exit_code</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_code</span><span class="p">,</span><span class="n">end_code</span><span class="p">,</span><span class="n">end_data</span><span class="p">,</span><span class="n">brk</span><span class="p">,</span><span class="n">start_stack</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">pid</span><span class="p">,</span><span class="n">father</span><span class="p">,</span><span class="n">pgrp</span><span class="p">,</span><span class="n">session</span><span class="p">,</span><span class="n">leader</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">uid</span><span class="p">,</span><span class="n">euid</span><span class="p">,</span><span class="n">suid</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">gid</span><span class="p">,</span><span class="n">egid</span><span class="p">,</span><span class="n">sgid</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">alarm</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">utime</span><span class="p">,</span><span class="n">stime</span><span class="p">,</span><span class="n">cutime</span><span class="p">,</span><span class="n">cstime</span><span class="p">,</span><span class="n">start_time</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">used_math</span><span class="p">;</span>
<span class="cm">/* file system info */</span>
    <span class="kt">int</span> <span class="n">tty</span><span class="p">;</span>        <span class="cm">/* -1 if no tty, so it must be signed */</span>
    <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">umask</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">m_inode</span> <span class="o">*</span> <span class="n">pwd</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">m_inode</span> <span class="o">*</span> <span class="n">root</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">m_inode</span> <span class="o">*</span> <span class="n">executable</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">close_on_exec</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span> <span class="n">filp</span><span class="p">[</span><span class="n">NR_OPEN</span><span class="p">];</span>
<span class="cm">/* ldt for this task 0 - zero 1 - cs 2 - ds&amp;ss */</span>
    <span class="k">struct</span> <span class="n">desc_struct</span> <span class="n">ldt</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="cm">/* tss for this task */</span>
    <span class="k">struct</span> <span class="n">tss_struct</span> <span class="n">tss</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>The structure of <code>tss_struct</code> is as follows, you can see that most of it is register information.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">tss_struct</span> <span class="p">{</span>
    <span class="kt">long</span>    <span class="n">back_link</span><span class="p">;</span>  <span class="cm">/* 16 high bits zero */</span>
    <span class="kt">long</span>    <span class="n">esp0</span><span class="p">;</span>
    <span class="kt">long</span>    <span class="n">ss0</span><span class="p">;</span>        <span class="cm">/* 16 high bits zero */</span>
    <span class="kt">long</span>    <span class="n">esp1</span><span class="p">;</span>
    <span class="kt">long</span>    <span class="n">ss1</span><span class="p">;</span>        <span class="cm">/* 16 high bits zero */</span>
    <span class="kt">long</span>    <span class="n">esp2</span><span class="p">;</span>
    <span class="kt">long</span>    <span class="n">ss2</span><span class="p">;</span>        <span class="cm">/* 16 high bits zero */</span>
    <span class="kt">long</span>    <span class="n">cr3</span><span class="p">;</span>
    <span class="kt">long</span>    <span class="n">eip</span><span class="p">;</span>
    <span class="kt">long</span>    <span class="n">eflags</span><span class="p">;</span>
    <span class="kt">long</span>    <span class="n">eax</span><span class="p">,</span><span class="n">ecx</span><span class="p">,</span><span class="n">edx</span><span class="p">,</span><span class="n">ebx</span><span class="p">;</span>
    <span class="kt">long</span>    <span class="n">esp</span><span class="p">;</span>
    <span class="kt">long</span>    <span class="n">ebp</span><span class="p">;</span>
    <span class="kt">long</span>    <span class="n">esi</span><span class="p">;</span>
    <span class="kt">long</span>    <span class="n">edi</span><span class="p">;</span>
    <span class="kt">long</span>    <span class="n">es</span><span class="p">;</span>     <span class="cm">/* 16 high bits zero */</span>
    <span class="kt">long</span>    <span class="n">cs</span><span class="p">;</span>     <span class="cm">/* 16 high bits zero */</span>
    <span class="kt">long</span>    <span class="n">ss</span><span class="p">;</span>     <span class="cm">/* 16 high bits zero */</span>
    <span class="kt">long</span>    <span class="n">ds</span><span class="p">;</span>     <span class="cm">/* 16 high bits zero */</span>
    <span class="kt">long</span>    <span class="n">fs</span><span class="p">;</span>     <span class="cm">/* 16 high bits zero */</span>
    <span class="kt">long</span>    <span class="n">gs</span><span class="p">;</span>     <span class="cm">/* 16 high bits zero */</span>
    <span class="kt">long</span>    <span class="n">ldt</span><span class="p">;</span>        <span class="cm">/* 16 high bits zero */</span>
    <span class="kt">long</span>    <span class="n">trace_bitmap</span><span class="p">;</span>   <span class="cm">/* bits: trace 0, bitmap 16-31 */</span>
    <span class="k">struct</span> <span class="n">i387_struct</span> <span class="n">i387</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>Note: The code and narrative in this article are based on Linux 0.11</p>
</blockquote>
<h2 id="process-0">Process 0</h2>
<p>Process 0 is like Adam, the ancestor of all processes, and Linus is like God, who pre-set the data structure of process 0 statically and then breathed on it during the kernel initialization phase, and process 0 came to life.</p>
<p>As you can see below, the task_struct of process 0 is pre-set in the static variable init_task with the INIT_TASK macro. From here I can see that the page where task_struct is located is also the kernel stack, and the stack pointer starts at the end of the page.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="k">union</span> <span class="n">task_union</span> <span class="n">init_task</span> <span class="o">=</span> <span class="p">{</span><span class="n">INIT_TASK</span><span class="p">,};</span>

<span class="k">union</span> <span class="n">task_union</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">task_struct</span> <span class="n">task</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">stack</span><span class="p">[</span><span class="n">PAGE_SIZE</span><span class="p">];</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>The macro INIT_TASK pre-sets the fields of the task_struct structure, including ldt and tss. You can understand the meaning of each initial value in conjunction with the previous fields of the task_struct. We mention a few special ones here</p>
<ul>
<li>ldt is a local descriptor table LDT, <code>0x9f, 0xc0fa00</code> and <code>0x9f, 0xc0f200</code> represent the code segment and data segment descriptors of process 0 respectively, with base address 0x0, limit 640K, G=1, D=1, DPL=3, P=1, and TYPE 0x0a and 0x02 respectively. The code segment and data segment of the kernel.</li>
<li>tss is the task status segment
<ul>
<li>The value of the second field, <code>PAGE_SIZE+(long)&amp;init_task</code>, indicates the kernel stack pointer esp0, which points to the end of the page where init_task is located.</li>
<li>The subsequent ss is initialized to 0x10, indicating that it is a kernel data stack segment selector.</li>
<li><code>(long)&amp;pg_dir</code> initializes cr3 to the address where the page directory is located</li>
<li>The next 10 registers are initialized to 0, including eip and esp in user state</li>
<li>All 6 segment registers are initialized to 0x17, indicating the user state data segment selector</li>
<li><code>_LDT(0)</code> indicates the LDT selector for process 0</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-h" data-lang="h"><span class="cp">#define INIT_TASK \
</span><span class="cp"></span><span class="cm">/* state etc */</span><span class="cp"> { 0,15,15, \
</span><span class="cp"></span><span class="cm">/* signals */</span><span class="cp">   0,{{},},0, \
</span><span class="cp"></span><span class="cm">/* ec,brk... */</span><span class="cp"> 0,0,0,0,0,0, \
</span><span class="cp"></span><span class="cm">/* pid etc.. */</span><span class="cp"> 0,-1,0,0,0, \
</span><span class="cp"></span><span class="cm">/* uid etc */</span><span class="cp">   0,0,0,0,0,0, \
</span><span class="cp"></span><span class="cm">/* alarm */</span><span class="cp"> 0,0,0,0,0,0, \
</span><span class="cp"></span><span class="cm">/* math */</span><span class="cp">  0, \
</span><span class="cp"></span><span class="cm">/* fs info */</span><span class="cp">   -1,0022,NULL,NULL,NULL,0, \
</span><span class="cp"></span><span class="cm">/* filp */</span><span class="cp">  {NULL,}, \
</span><span class="cp">    { \
</span><span class="cp">        {0,0}, \
</span><span class="cp"></span><span class="cm">/* ldt */</span><span class="cp">   {0x9f,0xc0fa00}, \
</span><span class="cp">        {0x9f,0xc0f200}, \
</span><span class="cp">    }, \
</span><span class="cp"></span><span class="cm">/*tss*/</span><span class="cp"> {0,PAGE_SIZE+(long)&amp;init_task,0x10,0,0,0,0,(long)&amp;pg_dir,\
</span><span class="cp">     0,0,0,0,0,0,0,0, \
</span><span class="cp">     0,0,0x17,0x17,0x17,0x17,0x17,0x17, \
</span><span class="cp">     _LDT(0),0x80000000, \
</span><span class="cp">        {} \
</span><span class="cp">    }, \
</span><span class="cp">}
</span></code></pre></td></tr></table>
</div>
</div><p>You can see that most of the process information has been set statically, but it is still a dead process 0. Let&rsquo;s see how the kernel gives it a breath of air to bring it back to life.</p>
<p>The following is the kernel main function. Note that the main function is not the entry point for the kernel program, but rather the system bootloader, followed by the main function after the system enters protected mode and completes some initialization. At the beginning the system uses a temporary stack, after entering protected mode the stack segment is set to the kernel data segment (0x10) and esp points to the end of the user_stack array, which is still used when the system first enters main.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// ...
</span><span class="c1"></span>    <span class="n">sched_init</span><span class="p">();</span>
    <span class="n">sti</span><span class="p">();</span>
    <span class="n">move_to_user_mode</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fork</span><span class="p">())</span> <span class="p">{</span>      <span class="cm">/* we count on this going ok */</span>
        <span class="n">init</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(;;)</span> <span class="n">pause</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Part of the initialization of process 0 is done in the <code>sched_init()</code> function. First, the TSS and LDT descriptor entries for process 0 are set in the global descriptor table GDT, and then loaded into the tr and ldtr registers respectively. This is the only time the kernel loads the LDT descriptor explicitly, and later the LDT descriptor of the process will be loaded automatically by the CPU according to the LDT selector in the TSS when the process switches.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="c1">// 设置进程0的TSS和LDT描述符到GDT中
</span><span class="c1"></span><span class="n">set_tss_desc</span><span class="p">(</span><span class="n">gdt</span><span class="o">+</span><span class="n">FIRST_TSS_ENTRY</span><span class="p">,</span><span class="o">&amp;</span><span class="p">(</span><span class="n">init_task</span><span class="p">.</span><span class="n">task</span><span class="p">.</span><span class="n">tss</span><span class="p">));</span>
<span class="n">set_ldt_desc</span><span class="p">(</span><span class="n">gdt</span><span class="o">+</span><span class="n">FIRST_LDT_ENTRY</span><span class="p">,</span><span class="o">&amp;</span><span class="p">(</span><span class="n">init_task</span><span class="p">.</span><span class="n">task</span><span class="p">.</span><span class="n">ldt</span><span class="p">));</span>
<span class="c1">// 加载进程0的TSS到tr寄存器，LDT到ldtr寄存器
</span><span class="c1"></span><span class="n">ltr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">lldt</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>The next <code>move_to_user_mode()</code> is the final exhalation. It accomplishes two important historical tasks: moving from the kernel state to the user state, and process process 0. The interrupt process is simulated manually by pressing specific values into the stack.</p>
<ul>
<li>Press in the user state stack segment selector, 0x17 for the data stack segment of the user state local table (previously ss was 0x10)</li>
<li>Press in the user state stack pointer, which inherits the esp before executing <code>move_to_user_mode</code></li>
<li>Pressing into the status register</li>
<li>Press in the user state code segment selector, 0x0f means the code segment in the user state local table (previously cs was 0x08)</li>
<li>Press in the offset address, which is the location marked 1 below</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-h" data-lang="h"><span class="cp">#define move_to_user_mode() \
</span><span class="cp">__asm__ (&#34;movl %%esp,%%eax\n\t&#34; \
</span><span class="cp">    &#34;pushl $0x17\n\t&#34; \
</span><span class="cp">    &#34;pushl %%eax\n\t&#34; \
</span><span class="cp">    &#34;pushfl\n\t&#34; \
</span><span class="cp">    &#34;pushl $0x0f\n\t&#34; \
</span><span class="cp">    &#34;pushl $1f\n\t&#34; \
</span><span class="cp">    &#34;iret\n&#34; \
</span><span class="cp">    &#34;1:\tmovl $0x17,%%eax\n\t&#34; \
</span><span class="cp">    &#34;movw %%ax,%%ds\n\t&#34; \
</span><span class="cp">    &#34;movw %%ax,%%es\n\t&#34; \
</span><span class="cp">    &#34;movw %%ax,%%fs\n\t&#34; \
</span><span class="cp">    &#34;movw %%ax,%%gs&#34; \
</span><span class="cp">    :::&#34;ax&#34;)
</span></code></pre></td></tr></table>
</div>
</div><p>Finally, by executing <code>iret</code>, the system moves from the kernel state to the user state and process 0 comes to life. Its kernel stack is set statically in the init_task structure, and the user stack segment and code segment are also set statically in the ldt of init_task, whose base address is 0, so it still points to the kernel code segment and data segment, but the privilege level becomes the user level. The user state stack pointer inherits the previous esp, so it still points to the original location. eip is manually set to the location of the next instruction in <code>iret</code>. So after <code>iret</code>, the execution of the code continues.</p>
<p>The task of process 0 is simple: fork process 1, and then it goes into a dead loop. Process 0 runs when there is no other process to run on the system, so it is also called idle process.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fork</span><span class="p">())</span> <span class="p">{</span>      <span class="cm">/* we count on this going ok */</span>
    <span class="n">init</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">for</span><span class="p">(;;)</span> <span class="n">pause</span><span class="p">();</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="fork-and-system-calls">fork and system calls</h2>
<p>Process 1 has a slightly special status, it is forked from process 0, so its code and data segments are the same as those of process 0. As for all subsequent processes, they are all children of process 1, because they are all exec&rsquo;d by process 1 after fork, so their code and data segments are no longer kernel code and data segments.</p>
<p>Next, let&rsquo;s explore how fork is divided into two, starting with the fork system call definition.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kr">inline</span> <span class="n">_syscall0</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="n">fork</span><span class="p">)</span>

</code></pre></td></tr></table>
</div>
</div><p><code>_syscall0</code> is a macro, and the kernel defines several such macros, where the number that follows it indicates the number of arguments.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-h" data-lang="h"><span class="cp">#define _syscall0(type,name) \
</span><span class="cp">...
</span><span class="cp">#define _syscall1(type,name,atype,a) \
</span><span class="cp">...
</span><span class="cp">#define _syscall2(type,name,atype,a,btype,b) \
</span><span class="cp">...
</span><span class="cp">#define _syscall3(type,name,atype,a,btype,b,ctype,c) \
</span></code></pre></td></tr></table>
</div>
</div><p>Let&rsquo;s look at the specific definition of <code>_syscall0</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-h" data-lang="h"><span class="cp">#define _syscall0(type,name) \
</span><span class="cp">type name(void) \
</span><span class="cp">{ \
</span><span class="cp">long __res; \
</span><span class="cp">__asm__ volatile (&#34;int $0x80&#34; \
</span><span class="cp">    : &#34;=a&#34; (__res) \
</span><span class="cp">    : &#34;0&#34; (__NR_##name)); \
</span><span class="cp">if (__res &gt;= 0) \
</span><span class="cp">    return (type) __res; \
</span><span class="cp">errno = -__res; \
</span><span class="cp">return -1; \
</span><span class="cp">}
</span></code></pre></td></tr></table>
</div>
</div><p>These macros are actually embedded assembly functions, with only one <code>int $0x80</code> instruction, where 0x80 is the interrupt number of the system call. There is 1 output parameter and input parameter respectively. The local variable <code>__res</code> is bound to the eax register as an output parameter and is used to receive the return value. The input parameter <code>__NR_fork</code> is the system call number, each system call has a separate number, also bound to register eax.</p>
<p>After the <code>int</code> instruction is executed, the CPU goes to the IDT to find the corresponding interrupt descriptor. Since the system call is implemented as a system gate (a trapdoor with a privilege level DPL of 3), it can be called in the user state, and the selector of the segment where the interrupt routine is located and the in-segment offset can be found in the gate descriptor to jump there. For the system call, it is a jump to the following <code>system_call:</code>.</p>
<p>This way the process enters the kernel space through the system call, and the interrupt process of the CPU triggered by the <code>int</code> instruction automatically puts the user state original stack segment ss, stack pointer esp, status register eflags, original user code segment cs, and original user code eip on the stack (note: the stack here is the kernel stack). So why does the CPU stack these registers? Because it has to remember the way back. Just as a function call needs to stack the return address, so does an interrupt need to stack the return address. In addition, the kernel state and the user state use separate stacks, so the user state stack segment register ss and the stack pointer esp also need to be stacked. So when you first enter the kernel space, the kernel stack pointer is located at esp0 in the following figure.</p>
<p>This code at the beginning of <code>systen_call</code> is common to all system calls. It first eax whether the system call number in eax is out of range, if it is normal, it will stack the segment registers and general registers, and then reset ds and es to kernel data segment and fs to user data segment. Finally, the corresponding processing function is called through the system call number lookup table.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-h" data-lang="h"><span class="nl">system_call</span><span class="p">:</span>
    <span class="n">cmpl</span> <span class="err">$</span><span class="n">nr_system_calls</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">%</span><span class="n">eax</span>
    <span class="n">ja</span> <span class="n">bad_sys_call</span>
    <span class="n">push</span> <span class="o">%</span><span class="n">ds</span>
    <span class="n">push</span> <span class="o">%</span><span class="n">es</span>
    <span class="n">push</span> <span class="o">%</span><span class="n">fs</span>
    <span class="n">pushl</span> <span class="o">%</span><span class="n">edx</span>
    <span class="n">pushl</span> <span class="o">%</span><span class="n">ecx</span>      <span class="err">#</span> <span class="n">push</span> <span class="o">%</span><span class="n">ebx</span><span class="p">,</span><span class="o">%</span><span class="n">ecx</span><span class="p">,</span><span class="o">%</span><span class="n">edx</span> <span class="n">as</span> <span class="n">parameters</span>
    <span class="n">pushl</span> <span class="o">%</span><span class="n">ebx</span>      <span class="err">#</span> <span class="n">to</span> <span class="n">the</span> <span class="n">system</span> <span class="n">call</span>
    <span class="n">movl</span> <span class="err">$</span><span class="mh">0x10</span><span class="p">,</span><span class="o">%</span><span class="n">edx</span>     <span class="err">#</span> <span class="n">set</span> <span class="n">up</span> <span class="n">ds</span><span class="p">,</span><span class="n">es</span> <span class="n">to</span> <span class="n">kernel</span> <span class="n">space</span>
    <span class="n">mov</span> <span class="o">%</span><span class="n">dx</span><span class="p">,</span><span class="o">%</span><span class="n">ds</span>
    <span class="n">mov</span> <span class="o">%</span><span class="n">dx</span><span class="p">,</span><span class="o">%</span><span class="n">es</span>
    <span class="n">movl</span> <span class="err">$</span><span class="mh">0x17</span><span class="p">,</span><span class="o">%</span><span class="n">edx</span>     <span class="err">#</span> <span class="n">fs</span> <span class="n">points</span> <span class="n">to</span> <span class="n">local</span> <span class="n">data</span> <span class="n">space</span>
    <span class="n">mov</span> <span class="o">%</span><span class="n">dx</span><span class="p">,</span><span class="o">%</span><span class="n">fs</span>
    <span class="n">call</span> <span class="n">sys_call_table</span><span class="p">(,</span><span class="o">%</span><span class="n">eax</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>fork system call kernel stack situation.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt">HIGH  +----------------------+
      |          |  prev ss  |
      +----------------------+
      |       prev esp       |
      +----------------------+
      |        eflags        |
      +----------------------+
      |          |  prev cs  |
      +----------------------+
      |       prev eip       |&lt;-- esp0
      +----------------------+
      |          |     ds    |
      +----------------------+
      |          |     es    |
      +----------------------+
      |          |     fs    |
      +----------------------+
      |         edx          |
      +----------------------+
      |         ecx          |
      +----------------------+
      |         ebx          |
      +----------------------+
      |         eip1         |&lt;-- esp1
      +----------------------+
      |          |     gs    |
      +----------------------+
      |         esi          |
      +----------------------+
      |         edi          |
      +----------------------+
      |         ebp          |
      +----------------------+
      |         eax          | nr
      +----------------------+
      |         eip2         |&lt;-- esp2
LOW   +----------------------+    
</code></pre></td></tr></table>
</div>
</div><p>For the fork system call, it goes to <code>sys_fork</code>, where the kernel stack pointer is at esp1. The <code>find_empty_process</code> function just gets a free process number (note that it is not a pid), and if there are no more free ones it jumps directly to the marker 1 and returns. Then all the remaining programmable registers are also put on the stack, and finally the new process number is put on the stack.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-h" data-lang="h"><span class="nl">sys_fork</span><span class="p">:</span>
    <span class="n">call</span> <span class="n">find_empty_process</span>
    <span class="n">testl</span> <span class="o">%</span><span class="n">eax</span><span class="p">,</span><span class="o">%</span><span class="n">eax</span>
    <span class="n">js</span> <span class="mf">1f</span>
    <span class="n">push</span> <span class="o">%</span><span class="n">gs</span>
    <span class="n">pushl</span> <span class="o">%</span><span class="n">esi</span>
    <span class="n">pushl</span> <span class="o">%</span><span class="n">edi</span>
    <span class="n">pushl</span> <span class="o">%</span><span class="n">ebp</span>
    <span class="n">pushl</span> <span class="o">%</span><span class="n">eax</span>
    <span class="n">call</span> <span class="n">copy_process</span>
    <span class="n">addl</span> <span class="err">$</span><span class="mi">20</span><span class="p">,</span><span class="o">%</span><span class="n">esp</span>
<span class="mi">1</span><span class="o">:</span>  <span class="n">ret</span>
</code></pre></td></tr></table>
</div>
</div><p>Next, the core function <code>copy_process</code> is called, and the kernel stack pointer is located at esp2 when you first enter the function. This function has many arguments, which are actually registers from the previous stack. Because the call convention in C on x86 is to stack arguments from right to left, the last nr on the stack is the first argument. The reason why so many arguments are needed is that the parent process needs to pass on the values of all these registers to the child process, while most of the rest of the information can be obtained through the process descriptor. The function first allocates a free page as the task_struct structure for the new process, and then saves the pointer to the task array.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">copy_process</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">,</span><span class="kt">long</span> <span class="n">ebp</span><span class="p">,</span><span class="kt">long</span> <span class="n">edi</span><span class="p">,</span><span class="kt">long</span> <span class="n">esi</span><span class="p">,</span><span class="kt">long</span> <span class="n">gs</span><span class="p">,</span><span class="kt">long</span> <span class="n">none</span><span class="p">,</span>
        <span class="kt">long</span> <span class="n">ebx</span><span class="p">,</span><span class="kt">long</span> <span class="n">ecx</span><span class="p">,</span><span class="kt">long</span> <span class="n">edx</span><span class="p">,</span>
        <span class="kt">long</span> <span class="n">fs</span><span class="p">,</span><span class="kt">long</span> <span class="n">es</span><span class="p">,</span><span class="kt">long</span> <span class="n">ds</span><span class="p">,</span>
        <span class="kt">long</span> <span class="n">eip</span><span class="p">,</span><span class="kt">long</span> <span class="n">cs</span><span class="p">,</span><span class="kt">long</span> <span class="n">eflags</span><span class="p">,</span><span class="kt">long</span> <span class="n">esp</span><span class="p">,</span><span class="kt">long</span> <span class="n">ss</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">f</span><span class="p">;</span>

    <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">)</span> <span class="n">get_free_page</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
    <span class="n">task</span><span class="p">[</span><span class="n">nr</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>The next step is to initialize the process descriptor of the child process p. The first line below copies the process descriptor of the parent process directly to the child process, so the fields that are not additionally modified later are by default the same as the parent process. But after all, the child process is a separate process and needs to modify the necessary fields, such as pid, parent process, time slice, signal, timer, time, etc.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-h" data-lang="h"><span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">*</span><span class="n">current</span><span class="p">;</span>  <span class="cm">/* NOTE! this doesn&#39;t copy the supervisor stack */</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">;</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">=</span> <span class="n">last_pid</span><span class="p">;</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">father</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">counter</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">priority</span><span class="p">;</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">signal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">alarm</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">leader</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>      <span class="cm">/* process leadership doesn&#39;t inherit */</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">utime</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">stime</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">cutime</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">cstime</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">start_time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>The next step is to initialize the tss of the child process, noting that the kernel stack is pointing to the end of the page where task_struct is located, <code>p-&gt;tss.esp0 = PAGE_SIZE + (long) p;</code> . The kernel stack segment selector ss0 is 0x10, which is the kernel data segment. The rest of the register values are copied from the parent process, except for the eax register. You can see that the eax of the child process is assigned to 0. As a comparison, the eax of the parent process (i.e., the last return value) is last_pid. The eax value here is actually the final return value of the fork function, which is why fork returns 0 for the child process and the pid of the child process for the parent process.</p>
<p><code>p-&gt;tss.ldt = _LDT(nr)</code> is to set the LDT selector of the new process so that the process can find its LDT when it switches.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-h" data-lang="h"><span class="n">p</span><span class="o">-&gt;</span><span class="n">tss</span><span class="p">.</span><span class="n">back_link</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">tss</span><span class="p">.</span><span class="n">esp0</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">+</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">p</span><span class="p">;</span> <span class="cm">/* 内核堆栈指针 */</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">tss</span><span class="p">.</span><span class="n">ss0</span> <span class="o">=</span> <span class="mh">0x10</span><span class="p">;</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">tss</span><span class="p">.</span><span class="n">eip</span> <span class="o">=</span> <span class="n">eip</span><span class="p">;</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">tss</span><span class="p">.</span><span class="n">eflags</span> <span class="o">=</span> <span class="n">eflags</span><span class="p">;</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">tss</span><span class="p">.</span><span class="n">eax</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>     <span class="cm">/* 新进程的返回值是0 */</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">tss</span><span class="p">.</span><span class="n">ecx</span> <span class="o">=</span> <span class="n">ecx</span><span class="p">;</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">tss</span><span class="p">.</span><span class="n">edx</span> <span class="o">=</span> <span class="n">edx</span><span class="p">;</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">tss</span><span class="p">.</span><span class="n">ebx</span> <span class="o">=</span> <span class="n">ebx</span><span class="p">;</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">tss</span><span class="p">.</span><span class="n">esp</span> <span class="o">=</span> <span class="n">esp</span><span class="p">;</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">tss</span><span class="p">.</span><span class="n">ebp</span> <span class="o">=</span> <span class="n">ebp</span><span class="p">;</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">tss</span><span class="p">.</span><span class="n">esi</span> <span class="o">=</span> <span class="n">esi</span><span class="p">;</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">tss</span><span class="p">.</span><span class="n">edi</span> <span class="o">=</span> <span class="n">edi</span><span class="p">;</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">tss</span><span class="p">.</span><span class="n">es</span> <span class="o">=</span> <span class="n">es</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">tss</span><span class="p">.</span><span class="n">cs</span> <span class="o">=</span> <span class="n">cs</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">tss</span><span class="p">.</span><span class="n">ss</span> <span class="o">=</span> <span class="n">ss</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">tss</span><span class="p">.</span><span class="n">ds</span> <span class="o">=</span> <span class="n">ds</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">tss</span><span class="p">.</span><span class="n">fs</span> <span class="o">=</span> <span class="n">fs</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">tss</span><span class="p">.</span><span class="n">gs</span> <span class="o">=</span> <span class="n">gs</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">tss</span><span class="p">.</span><span class="n">ldt</span> <span class="o">=</span> <span class="n">_LDT</span><span class="p">(</span><span class="n">nr</span><span class="p">);</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">tss</span><span class="p">.</span><span class="n">trace_bitmap</span> <span class="o">=</span> <span class="mh">0x80000000</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">last_task_used_math</span> <span class="o">==</span> <span class="n">current</span><span class="p">)</span>
    <span class="n">__asm__</span><span class="p">(</span><span class="s">&#34;clts ; fnsave %0&#34;</span><span class="o">::</span><span class="s">&#34;m&#34;</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">tss</span><span class="p">.</span><span class="n">i387</span><span class="p">));</span>

</code></pre></td></tr></table>
</div>
</div><p>The next <code>copy_mem()</code> function starts copying the memory.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="n">copy_mem</span><span class="p">(</span><span class="n">nr</span><span class="p">,</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">task</span><span class="p">[</span><span class="n">nr</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">free_page</span><span class="p">((</span><span class="kt">long</span><span class="p">)</span> <span class="n">p</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Let&rsquo;s take a look at its concrete implementation, we can see that it does not copy the memory pages directly, but the page table, and only the page table of the data segment is copied. (Because all processes in Linux 0.11 share the page directory, and the base address of the code segment and data segment in Linux 0.11 is the same, and the length of the data segment is not less than that of the code segment, so only the data segment needs to be copied here.)</p>
<p>(Linux 0.11 supports up to 64 processes at the same time, and the linear base address of each process is obtained according to its process number * 64MB, i.e. <code>nr * 0x4000000</code> in the above code.)</p>
<p>Before just set the ldt selector in tss, the LDT table is still a copy of the parent process. The user code segment and data segment descriptors are not updated, but are set here with the new base address.</p>
<p>This is only the first piece of the <strong>write time copy</strong> puzzle, not the complete write time copy mechanism, so I won&rsquo;t expand on it here for space reasons. (Perhaps a separate article can be written later)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">copy_mem</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">,</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old_data_base</span><span class="p">,</span><span class="n">new_data_base</span><span class="p">,</span><span class="n">data_limit</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old_code_base</span><span class="p">,</span><span class="n">new_code_base</span><span class="p">,</span><span class="n">code_limit</span><span class="p">;</span>

    <span class="n">code_limit</span><span class="o">=</span><span class="n">get_limit</span><span class="p">(</span><span class="mh">0x0f</span><span class="p">);</span>
    <span class="n">data_limit</span><span class="o">=</span><span class="n">get_limit</span><span class="p">(</span><span class="mh">0x17</span><span class="p">);</span>
    <span class="n">old_code_base</span> <span class="o">=</span> <span class="n">get_base</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">ldt</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="n">old_data_base</span> <span class="o">=</span> <span class="n">get_base</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">ldt</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">old_data_base</span> <span class="o">!=</span> <span class="n">old_code_base</span><span class="p">)</span>
        <span class="n">panic</span><span class="p">(</span><span class="s">&#34;We don&#39;t support separate I&amp;D&#34;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">data_limit</span> <span class="o">&lt;</span> <span class="n">code_limit</span><span class="p">)</span>
        <span class="n">panic</span><span class="p">(</span><span class="s">&#34;Bad data_limit&#34;</span><span class="p">);</span>
    <span class="n">new_data_base</span> <span class="o">=</span> <span class="n">new_code_base</span> <span class="o">=</span> <span class="n">nr</span> <span class="o">*</span> <span class="mh">0x4000000</span><span class="p">;</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">start_code</span> <span class="o">=</span> <span class="n">new_code_base</span><span class="p">;</span>
    <span class="n">set_base</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ldt</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">new_code_base</span><span class="p">);</span>
    <span class="n">set_base</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ldt</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">new_data_base</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">copy_page_tables</span><span class="p">(</span><span class="n">old_data_base</span><span class="p">,</span><span class="n">new_data_base</span><span class="p">,</span><span class="n">data_limit</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">printk</span><span class="p">(</span><span class="s">&#34;free_page_tables: from copy_mem</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
        <span class="n">free_page_tables</span><span class="p">(</span><span class="n">new_data_base</span><span class="p">,</span><span class="n">data_limit</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Let&rsquo;s go ahead and finish the rest of the <code>copy_process()</code> function first.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">NR_OPEN</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">f</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">filp</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        <span class="n">f</span><span class="o">-&gt;</span><span class="n">f_count</span><span class="o">++</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">pwd</span><span class="p">)</span>
    <span class="n">current</span><span class="o">-&gt;</span><span class="n">pwd</span><span class="o">-&gt;</span><span class="n">i_count</span><span class="o">++</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">)</span>
    <span class="n">current</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">i_count</span><span class="o">++</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">executable</span><span class="p">)</span>
    <span class="n">current</span><span class="o">-&gt;</span><span class="n">executable</span><span class="o">-&gt;</span><span class="n">i_count</span><span class="o">++</span><span class="p">;</span>
<span class="n">set_tss_desc</span><span class="p">(</span><span class="n">gdt</span><span class="o">+</span><span class="p">(</span><span class="n">nr</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">FIRST_TSS_ENTRY</span><span class="p">,</span><span class="o">&amp;</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">tss</span><span class="p">));</span>
<span class="n">set_ldt_desc</span><span class="p">(</span><span class="n">gdt</span><span class="o">+</span><span class="p">(</span><span class="n">nr</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">FIRST_LDT_ENTRY</span><span class="p">,</span><span class="o">&amp;</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ldt</span><span class="p">));</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">TASK_RUNNING</span><span class="p">;</span>    <span class="cm">/* do this last, just in case */</span>
<span class="k">return</span> <span class="n">last_pid</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>The next step is to add the reference count, all files opened by the process, and the three i-nodes pwd, root, and executable. Then the TSS and LDT descriptor entries of the child process are set in GDT. Finally, change the process state to runnable and return the pid of the child process.</p>
<p>The preceding is the process of system call in, and the next is a process of system call return, note that the eax on the stack here is the return value of fork. After the execution of the specific system call processing function to this may occur scheduling behavior, so fork after the parent process and the child process in the end which first run is not certain.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt">pushl %eax
movl current,%eax
cmpl $0,state(%eax)     # state
jne reschedule
cmpl $0,counter(%eax)       # counter
je reschedule
</code></pre></td></tr></table>
</div>
</div><p>If the system call is made from the user state, the process will also be signaled, which is not the focus of our attention today and will not be expanded here. Finally, all registers from the previous stack are restored, and <code>iret</code> returns to user space to continue execution. At this point, the kernel stack is restored to its original clean state, and cs/eip/ss/esp is restored to the state before the <code>int</code> instruction was executed, and the process continues to execute after the user state <code>fork()</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt">ret_from_sys_call:
    movl current,%eax       # task[0] cannot have signals
    cmpl task,%eax
    je 3f
    cmpw $0x0f,CS(%esp)     # was old code segment supervisor ?
    jne 3f
    cmpw $0x17,OLDSS(%esp)      # was stack segment = 0x17 ?
    jne 3f
    movl signal(%eax),%ebx
    movl blocked(%eax),%ecx
    notl %ecx
    andl %ebx,%ecx
    bsfl %ecx,%ecx
    je 3f
    btrl %ecx,%ebx
    movl %ebx,signal(%eax)
    incl %ecx
    pushl %ecx
    call do_signal
    popl %eax
3:  popl %eax
    popl %ebx
    popl %ecx
    popl %edx
    pop %fs
    pop %es
    pop %ds
    iret
</code></pre></td></tr></table>
</div>
</div><h2 id="summary">Summary</h2>
<p>To briefly review, the process creation is mainly to initialize the process descriptor structure, including the ldt and tss in it. memory copy, because it is a copy-on-write only copies the page table (Linux 0.11 all processes are shared page directory). Also set the LDT and TSS descriptors of the process in the GDT global descriptor table.</p>
<p>Process 0 is special as the ancestor of all processes, its process descriptor structure is set statically, then its LDT and TSS descriptors are set in the GDT during the initialization phase and tr and ldtr are loaded manually. finally it is transferred to the user state by manually simulating the interrupt process and setting its stack pointer and eip pointer.</p>
<p>The subsequent process creation is done by forking, and most of the information in the process descriptor is copied directly from the parent process. To keep the state consistent with the parent process, all programmable registers are passed as arguments to <code>copy_process</code>, although there are some differences between the child process and the parent process as an independent process, notably the kernel stack pointer, the local descriptor table LDT, and the return value eax.</p>
<p>The initial questions that were raised should all be answered now.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/linux/">linux</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-03/the-comparison-of-the-go-community-leading-kakfa-clients/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">A brief comparison of mainstream Kafka clients in the Go community</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-03/clickhouse-cloud-native/">
            <span class="next-text nav-default">Clickhouse deployment and use in cloud-native scenarios</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
