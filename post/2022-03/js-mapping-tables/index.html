<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>JavaScript Data Processing - Mapping Tables - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="The common data collections in JavaScript are lists (Array) and mapping tables (Plain Object). This article talks about mapping tables. Due to the dynamic nature of JavaScript, the object itself is a mapping table, and the &amp;ldquo;attribute name ⇒ attribute value&amp;rdquo; of an object is the &amp;ldquo;key ⇒ value&amp;rdquo; in the mapping table. To make it easier to use the object as a mapping table, JavaScript even allows property names" /><meta name="keywords" content="javascript, Mapping Tables" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-03/js-mapping-tables/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="JavaScript Data Processing - Mapping Tables" />
<meta property="og:description" content="The common data collections in JavaScript are lists (Array) and mapping tables (Plain Object). This article talks about mapping tables. Due to the dynamic nature of JavaScript, the object itself is a mapping table, and the &ldquo;attribute name ⇒ attribute value&rdquo; of an object is the &ldquo;key ⇒ value&rdquo; in the mapping table. To make it easier to use the object as a mapping table, JavaScript even allows property names" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-03/js-mapping-tables/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-03-12T11:12:51+08:00" />
<meta property="article:modified_time" content="2022-03-12T11:12:51+08:00" />

<meta itemprop="name" content="JavaScript Data Processing - Mapping Tables">
<meta itemprop="description" content="The common data collections in JavaScript are lists (Array) and mapping tables (Plain Object). This article talks about mapping tables. Due to the dynamic nature of JavaScript, the object itself is a mapping table, and the &ldquo;attribute name ⇒ attribute value&rdquo; of an object is the &ldquo;key ⇒ value&rdquo; in the mapping table. To make it easier to use the object as a mapping table, JavaScript even allows property names"><meta itemprop="datePublished" content="2022-03-12T11:12:51+08:00" />
<meta itemprop="dateModified" content="2022-03-12T11:12:51+08:00" />
<meta itemprop="wordCount" content="2984">
<meta itemprop="keywords" content="javascript," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="JavaScript Data Processing - Mapping Tables"/>
<meta name="twitter:description" content="The common data collections in JavaScript are lists (Array) and mapping tables (Plain Object). This article talks about mapping tables. Due to the dynamic nature of JavaScript, the object itself is a mapping table, and the &ldquo;attribute name ⇒ attribute value&rdquo; of an object is the &ldquo;key ⇒ value&rdquo; in the mapping table. To make it easier to use the object as a mapping table, JavaScript even allows property names"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">JavaScript Data Processing - Mapping Tables</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-03-12 11:12:51 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 2984 words </span>
          <span class="more-meta"> 6 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#i-crud">I. CRUD</a></li>
        <li><a href="#ii-lists-in-mapping-tables">II. Lists in mapping tables</a></li>
        <li><a href="#iii-iterative-mapping-table">III. Iterative mapping table</a></li>
        <li><a href="#iv-from-lists-to-mapping-tables">IV. From Lists to Mapping Tables</a></li>
        <li><a href="#v-a-small-use-case">V. A small use case</a></li>
        <li><a href="#vi-mapping-table-splitting">VI. Mapping table splitting</a></li>
        <li><a href="#vii-merge-mapping-table">VII. Merge mapping table</a></li>
        <li><a href="#viii-map-class">VIII. Map Class</a></li>
        <li><a href="#summary">Summary</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>The common data collections in JavaScript are lists (Array) and mapping tables (Plain Object). This article talks about mapping tables.</p>
<p>Due to the dynamic nature of JavaScript, the object itself is a mapping table, and the &ldquo;attribute name ⇒ attribute value&rdquo; of an object is the &ldquo;key ⇒ value&rdquo; in the mapping table. To make it easier to use the object as a mapping table, JavaScript even allows property names that are not identifiers &ndash; any string can be used as a property name. Of course, non-identifier property names can only be accessed using [], not the . sign.</p>
<p>Using [] to access object properties fits better with the mapping table access form, so when using an object as a mapping table, it is common to use [] to access the table elements. In this case, the content of [] is called the &ldquo;key&rdquo; and the access operation is to access the &ldquo;value&rdquo;. Therefore, the basic structure of a mapping table element is called a &ldquo;key-value pair&rdquo;. In JavaScript objects, keys are allowed to have</p>
<p>In JavaScript objects, there are three types of keys allowed: number, string, and symbol.</p>
<p>Keys of type number are mainly used as array indexes, and arrays can be considered as special mapping tables, where the keys are usually consecutive natural numbers. However, during mapping table access, the number type keys are converted to string type for use.</p>
<p>Symbol-type keys are less frequently used, and are generally used as a specification for special Symbol keys, such as Symbol.iterator. symbol-type keys are usually used for stricter access control, and elements with the key type symbol type.</p>
<h2 id="i-crud">I. CRUD</h2>
<p>Create object mapping tables directly using { } to define Object Literal on the line, basic skills, no need to elaborate. However, it should be noted that { } is also used in JavaScript to encapsulate blocks of code, so using Object Literal in an expression often requires wrapping it in a pair of parentheses, like this: ({ }). This is especially important when using arrow function expressions that return an object directly.</p>
<p>The [] operator is used for adding, changing, and checking mapping table elements.</p>
<p>If you want to determine whether an attribute exists, some people have the habit of using ! !map[key], or map[key] === undefined. If you want to determine exactly whether a key exists, you should use the in operator.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">k1</span><span class="o">:</span> <span class="kc">undefined</span> <span class="p">};</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">[</span><span class="s2">&#34;k1&#34;</span><span class="p">]</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">);</span>  <span class="c1">// false
</span><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;k1&#34;</span> <span class="k">in</span> <span class="nx">a</span><span class="p">);</span>              <span class="c1">// true
</span><span class="c1"></span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">[</span><span class="s2">&#34;k2&#34;</span><span class="p">]</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">);</span>  <span class="c1">// false
</span><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;k2&#34;</span> <span class="k">in</span> <span class="nx">a</span><span class="p">);</span>              <span class="c1">// false
</span></code></pre></td></tr></table>
</div>
</div><p>Similarly, to delete a key, instead of changing its value to undefined or null, the delete operator is used.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">k1</span><span class="o">:</span> <span class="s2">&#34;v1&#34;</span><span class="p">,</span> <span class="nx">k2</span><span class="o">:</span> <span class="s2">&#34;v2&#34;</span><span class="p">,</span> <span class="nx">k3</span><span class="o">:</span> <span class="s2">&#34;v3&#34;</span> <span class="p">};</span>

<span class="nx">a</span><span class="p">[</span><span class="s2">&#34;k1&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
<span class="k">delete</span> <span class="nx">a</span><span class="p">[</span><span class="s2">&#34;k2&#34;</span><span class="p">];</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">dir</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="c1">// { k1: undefined, k3: &#39;v3&#39; }
</span></code></pre></td></tr></table>
</div>
</div><p>The k2 attribute of a no longer exists after using the delete a[&ldquo;k2&rdquo;] operation.</p>
<blockquote>
<p>Note</p>
<blockquote>
<p>In the above two examples, ESLint may report a violation of the dot-notation rule because k1, k2, and k3 are all legal identifiers. In this case, you can either turn off this rule or use . symbolic access (the team decides how to handle this).</p>
</blockquote>
</blockquote>
<h2 id="ii-lists-in-mapping-tables">II. Lists in mapping tables</h2>
<p>A mapping table can be viewed as a list of key-value pairs, so a mapping table can be converted into a list of key-value pairs for processing.</p>
<p>A key-value pair is generally called a key value pair or entry in English, and is described by <code>Map.Entry&lt;K, V&gt;</code> in Java; <code>KeyValuePair&lt;TKey, TValue&gt;</code> in C#; JavaScript is more straightforward, using an array of only two elements to represent a key-value pair, such as [&ldquo;key&rdquo; , &ldquo;value&rdquo;].</p>
<p>In JavaScript, you can use Object.entries(it) to get a list of key-value pairs formed by [key, value].</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">b</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">c</span><span class="o">:</span> <span class="mi">3</span> <span class="p">};</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">entries</span><span class="p">(</span><span class="nx">obj</span><span class="p">));</span>
<span class="c1">// [ [ &#39;a&#39;, 1 ], [ &#39;b&#39;, 2 ], [ &#39;c&#39;, 3 ] ]
</span></code></pre></td></tr></table>
</div>
</div><p>In addition to entry lists, mapping tables can also separate keys and values to get a separate list of keys, or a list of values. To get a list of keys for an object, use the Object.keys(obj) static method; accordingly, to get a list of values use the Object.values(obj) static method.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">b</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">c</span><span class="o">:</span> <span class="mi">3</span> <span class="p">};</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">obj</span><span class="p">));</span>      <span class="c1">// [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39; ]
</span><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">values</span><span class="p">(</span><span class="nx">obj</span><span class="p">));</span>    <span class="c1">// [ 1, 2, 3 ]
</span></code></pre></td></tr></table>
</div>
</div><h2 id="iii-iterative-mapping-table">III. Iterative mapping table</h2>
<p>Since a mapping table can be viewed as a list of key-value pairs or a list of keys or values that can be obtained individually, there are more ways to iterate through a mapping table.</p>
<p>The most basic way is to use a for loop. Note, however, that since mapping tables usually do not have ordinal numbers (index numbers), they cannot be traversed by a normal for(;;;) loop, but rather by using for each. Interestingly, however, for&hellip; .in can be used to iterate through all the keys of a mapping table; however, using for&hellip; .of on a mapping table will error out because the object &ldquo;is not iterable&rdquo;.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">b</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">c</span><span class="o">:</span> <span class="mi">3</span> <span class="p">};</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">key</span> <span class="k">in</span> <span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`</span><span class="si">${</span><span class="nx">key</span><span class="si">}</span><span class="sb"> = </span><span class="si">${</span><span class="nx">obj</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>   <span class="c1">// 拿到 key 之后通过 obj[key] 来取值
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">// a = 1
</span><span class="c1">// b = 2
</span><span class="c1">// c = 3
</span></code></pre></td></tr></table>
</div>
</div><p>Since the mapping table can get the key set and value set separately, it is more flexible to handle the traversal. But usually we usually use both keys and values, so in practice, it is more common to iterate over all entries of the mapping table.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nb">Object</span><span class="p">.</span><span class="nx">entries</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">forEach</span><span class="p">(([</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">])</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`</span><span class="si">${</span><span class="nx">key</span><span class="si">}</span><span class="sb"> = </span><span class="si">${</span><span class="nx">value</span><span class="si">}</span><span class="sb">`</span><span class="p">));</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="iv-from-lists-to-mapping-tables">IV. From Lists to Mapping Tables</h2>
<p>The previous two subsections were all about how to convert a mapping table into a list. In turn, what about generating a mapping table from a list?</p>
<p>To generate a mapping table from a list, the most basic operation is to generate an empty mapping table, and then iterate through the list, from each element to get the &ldquo;key&rdquo; and &ldquo;value&rdquo; to add them to the mapping table, such as the following example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">items</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">{</span> <span class="nx">name</span><span class="o">:</span> <span class="s2">&#34;size&#34;</span><span class="p">,</span> <span class="nx">value</span><span class="o">:</span> <span class="s2">&#34;XL&#34;</span> <span class="p">},</span>
    <span class="p">{</span> <span class="nx">name</span><span class="o">:</span> <span class="s2">&#34;color&#34;</span><span class="p">,</span> <span class="nx">value</span><span class="o">:</span> <span class="s2">&#34;中国蓝&#34;</span> <span class="p">},</span>
    <span class="p">{</span> <span class="nx">name</span><span class="o">:</span> <span class="s2">&#34;material&#34;</span><span class="p">,</span> <span class="nx">value</span><span class="o">:</span> <span class="s2">&#34;涤纶&#34;</span> <span class="p">}</span>
<span class="p">];</span>

<span class="kd">function</span> <span class="nx">toObject</span><span class="p">(</span><span class="nx">specs</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">specs</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">spec</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="nx">obj</span><span class="p">[</span><span class="nx">spec</span><span class="p">.</span><span class="nx">name</span><span class="p">]</span> <span class="o">=</span> <span class="nx">spec</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
        <span class="k">return</span> <span class="nx">obj</span><span class="p">;</span>
    <span class="p">},</span> <span class="p">{});</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">toObject</span><span class="p">(</span><span class="nx">items</span><span class="p">));</span>
<span class="c1">// { size: &#39;XL&#39;, color: &#39;中国蓝&#39;, material: &#39;涤纶&#39; }
</span></code></pre></td></tr></table>
</div>
</div><p>This is the usual operation. Notice that Object also provides a fromEntries() static method, so if we prepare a list of key-value pairs, we can use Object.fromEntries() to quickly get the corresponding object.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">toObject</span><span class="p">(</span><span class="nx">specs</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">fromEntries</span><span class="p">(</span>
        <span class="nx">specs</span><span class="p">.</span><span class="nx">map</span><span class="p">(({</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">value</span> <span class="p">})</span> <span class="p">=&gt;</span> <span class="p">[</span><span class="nx">name</span><span class="p">,</span> <span class="nx">value</span><span class="p">])</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="v-a-small-use-case">V. A small use case</h2>
<p>During data processing, lists and mapped tables often need to be converted to each other to achieve more readable code or better performance. Two key methods of conversion have been covered earlier in this article.</p>
<ul>
<li>
<p>Object.entries() converts a mapped table into a list of key-value pairs</p>
</li>
<li>
<p>Object.fromEntries() generates a mapping table from a list of key-value pairs</p>
</li>
</ul>
<p>In which cases might these conversions be used? There are many application scenarios, for example, here is a more classic case.</p>
<p>asks the question.</p>
<p>Got all the nodes of a tree from the backend, and the parent relationship between the nodes is described by the parentId field. Now what should I do if I want to build it into a tree structure? Sample data.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="p">[</span>
 <span class="p">{</span> <span class="nt">&#34;id&#34;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nt">&#34;parentId&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nt">&#34;label&#34;</span><span class="p">:</span> <span class="s2">&#34;第 1 章&#34;</span> <span class="p">},</span>
 <span class="p">{</span> <span class="nt">&#34;id&#34;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nt">&#34;parentId&#34;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nt">&#34;label&#34;</span><span class="p">:</span> <span class="s2">&#34;第 1.1 节&#34;</span> <span class="p">},</span>
 <span class="p">{</span> <span class="nt">&#34;id&#34;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="nt">&#34;parentId&#34;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nt">&#34;label&#34;</span><span class="p">:</span> <span class="s2">&#34;第 1.2 节&#34;</span> <span class="p">},</span>
 <span class="p">{</span> <span class="nt">&#34;id&#34;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="nt">&#34;parentId&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nt">&#34;label&#34;</span><span class="p">:</span> <span class="s2">&#34;第 2 章&#34;</span> <span class="p">},</span>
 <span class="p">{</span> <span class="nt">&#34;id&#34;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="nt">&#34;parentId&#34;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="nt">&#34;label&#34;</span><span class="p">:</span> <span class="s2">&#34;第 2.1 节&#34;</span> <span class="p">},</span>
 <span class="p">{</span> <span class="nt">&#34;id&#34;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="nt">&#34;parentId&#34;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="nt">&#34;label&#34;</span><span class="p">:</span> <span class="s2">&#34;第 2.2 节&#34;</span> <span class="p">},</span>
 <span class="p">{</span> <span class="nt">&#34;id&#34;</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span> <span class="nt">&#34;parentId&#34;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="nt">&#34;label&#34;</span><span class="p">:</span> <span class="s2">&#34;第 2.1.1 点&#34;</span> <span class="p">},</span>
 <span class="p">{</span> <span class="nt">&#34;id&#34;</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="nt">&#34;parentId&#34;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="nt">&#34;label&#34;</span><span class="p">:</span> <span class="s2">&#34;第 2.1.2 点&#34;</span> <span class="p">}</span>
<span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p>The general idea is to first build an empty tree (imaginary root), then read the list of nodes in order, and for each node read, find the correct parent (or root) node from the tree and insert it. This idea is not complicated, but in practice, we encounter two problems</p>
<ol>
<li>finding a node in the generated tree itself is a complex process, whether by recursion through depth traversal or by queueing through breadth traversal, which requires writing relatively complex algorithms and is time consuming.</li>
<li>for the list of all node order, if you can not guarantee that the child node after the parent node, the complexity of processing will greatly increase.</li>
</ol>
<p>To solve the above two problems is not difficult, just need to first iterate through all nodes, generate a [id =&gt; node] mapping table is good to do. Assuming that the data is referenced by the variable nodes, the mapping table can be generated with the following code.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">nodeMap</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">fromEntries</span><span class="p">(</span>
    <span class="nx">nodes</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">node</span> <span class="p">=&gt;</span> <span class="p">[</span><span class="nx">node</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="nx">node</span><span class="p">])</span>
<span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>Without going into the details of the process, interested readers can read: Generating Trees from Lists (JavaScript/TypeScript).</p>
<h2 id="vi-mapping-table-splitting">VI. Mapping table splitting</h2>
<p>The mapping table itself does not support splitting, but we can select some key-value pairs from it according to certain rules to form a new mapping table for the purpose of splitting. This process is Object.entries() ⇒ filter() ⇒ Object.fromEntries(). For example, if you want to exclude all properties with underscore prefixes from a configuration object.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">options</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">_t1</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">_t2</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">_t3</span><span class="o">:</span> <span class="mi">3</span><span class="p">,</span> <span class="nx">name</span><span class="o">:</span> <span class="s2">&#34;James&#34;</span><span class="p">,</span> <span class="nx">title</span><span class="o">:</span> <span class="s2">&#34;Programmer&#34;</span> <span class="p">};</span>

<span class="kr">const</span> <span class="nx">newOptions</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">fromEntries</span><span class="p">(</span>
    <span class="nb">Object</span><span class="p">.</span><span class="nx">entries</span><span class="p">(</span><span class="nx">options</span><span class="p">).</span><span class="nx">filter</span><span class="p">(([</span><span class="nx">key</span><span class="p">])</span> <span class="p">=&gt;</span> <span class="o">!</span><span class="nx">key</span><span class="p">.</span><span class="nx">startsWith</span><span class="p">(</span><span class="s2">&#34;_&#34;</span><span class="p">))</span>
<span class="p">);</span>
<span class="c1">// { name: &#39;James&#39;, title: &#39;Programmer&#39; }
</span></code></pre></td></tr></table>
</div>
</div><p>However, it is more straightforward to use delete when you know exactly which elements you want to get rid of.</p>
<p>Here is another example.</p>
<p>Ask the question.</p>
<p>The problem is that a lot of code applying this asynchronous operation will take some time to complete the migration, and in the meantime, the old interface still needs to be executed correctly. During this time, the old interface still needs to be executed correctly.</p>
<p>For compatibility during the migration, this code needs to take the success and fail objects out of the parameter object, remove them from the original parameter object, and give the processed parameter object to the new business logic. The operation to remove the success and fail entries can be done with delete.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">async</span> <span class="kd">function</span> <span class="nx">asyncDoIt</span><span class="p">(</span><span class="nx">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">success</span> <span class="o">=</span> <span class="nx">options</span><span class="p">.</span><span class="nx">success</span><span class="p">;</span>
    <span class="kr">const</span> <span class="nx">fail</span> <span class="o">=</span> <span class="nx">options</span><span class="p">.</span><span class="nx">fail</span><span class="p">;</span>
    <span class="k">delete</span> <span class="nx">options</span><span class="p">.</span><span class="nx">success</span><span class="p">;</span>
    <span class="k">delete</span> <span class="nx">options</span><span class="p">.</span><span class="nx">fail</span><span class="p">;</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="kr">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">callNewProcess</span><span class="p">(</span><span class="nx">options</span><span class="p">);</span>
        <span class="nx">success</span><span class="o">?</span><span class="p">.(</span><span class="nx">result</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">fail</span><span class="o">?</span><span class="p">.(</span><span class="nx">e</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>This is a moderate approach, taking 4 lines of code to handle two special entries, the first two of which can easily be simplified by using destructuring.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="p">{</span> <span class="nx">success</span><span class="p">,</span> <span class="nx">fail</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">options</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>But did you notice that the last two sentences can also be merged in?</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="p">{</span> <span class="nx">success</span><span class="p">,</span> <span class="nx">fail</span><span class="p">,</span> <span class="p">...</span><span class="nx">opts</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">options</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>The opts we get here are the option list excluding the success and failure entries!</p>
<p>Further, we can use the deconstruction argument syntax to move the deconstruction process to the argument list. Here is the modified asyncDoIt.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">async</span> <span class="kd">function</span> <span class="nx">asyncDoIt</span><span class="p">({</span> <span class="nx">success</span><span class="p">,</span> <span class="nx">fail</span><span class="p">,</span> <span class="p">...</span><span class="nx">options</span> <span class="p">}</span> <span class="o">=</span> <span class="p">{})</span> <span class="p">{</span>
    <span class="c1">// TODO try { ... } catch (e) { ... }
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Using the deconstructed split mapping table makes the code look very clean, and such a way of defining functions can be copied to the arrow functions as processing functions during chained data processing. In this way, splitting data is solved by hand when defining parameters, and the code as a whole will look very concise and clear.</p>
<h2 id="vii-merge-mapping-table">VII. Merge mapping table</h2>
<p>To merge mapping tables, the basic operation must be to add them in a loop, which is not recommended.</p>
<p>Since the new features of JavaScript provide a more convenient way to do this, why not use them? There are basically only two new features.</p>
<ul>
<li>
<p>Object.assign()</p>
</li>
<li>
<p>expand operator</p>
</li>
</ul>
<p>The syntax and interface descriptions can be found on MDN, but here are some examples.</p>
<p>Ask the question</p>
<p>There is a function whose arguments are a list of options, and in order to facilitate the use of the caller does not need to provide all the options, the options not provided all use the default option values. But it is too tedious to determine one by one, is there a simpler way?</p>
<p>Yes, of course there is! Use Object.assign() ah.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">defaultOptions</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">b</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">c</span><span class="o">:</span> <span class="mi">3</span><span class="p">,</span> <span class="nx">d</span><span class="o">:</span> <span class="mi">4</span>
<span class="p">};</span>

<span class="kd">function</span> <span class="nx">doSomthing</span><span class="p">(</span><span class="nx">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">options</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">({},</span> <span class="nx">defaultOptions</span><span class="p">,</span> <span class="nx">options</span><span class="p">);</span>
    <span class="c1">// TODO 使用 options
</span><span class="c1"></span><span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>Once you know it, you will find that it is still very simple to use. But simple is simple, but there are still some pitfalls.</p>
<p>The first argument of Object.assign() must be given an empty mapping table, otherwise defaultOptions will be modified, because Object.assign() will merge the entries of each argument into its first argument (mapping table).</p>
<p>To avoid accidental modification of defaultOptions, you can &ldquo;freeze&rdquo; it.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">defaultOptions</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">freeze</span><span class="p">({</span>
<span class="c1">//                     ^^^^^^^^^^^^^^
</span><span class="c1"></span>    <span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">b</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">c</span><span class="o">:</span> <span class="mi">3</span><span class="p">,</span> <span class="nx">d</span><span class="o">:</span> <span class="mi">4</span>
<span class="p">});</span>
</code></pre></td></tr></table>
</div>
</div><p>In this way, Object.assign(defaultOptions, &hellip;) will report an error.</p>
<p>Alternatively, this can be achieved by using the expand operator.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">options</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span><span class="nx">defaultOptions</span><span class="p">,</span> <span class="p">...</span><span class="nx">options</span> <span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>An even bigger advantage of using the expand operator is that it is easy to add a single entry, unlike Object.assign() where you have to wrap the entry into a mapping table.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">fetchSomething</span><span class="p">(</span><span class="nx">url</span><span class="p">,</span> <span class="nx">options</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">options</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">...</span><span class="nx">defaultOptions</span><span class="p">,</span>
        <span class="p">...</span><span class="nx">options</span><span class="p">,</span>
        <span class="nx">url</span><span class="p">,</span>        <span class="c1">// 键和变量同名时可以简写
</span><span class="c1"></span>        <span class="nx">more</span><span class="o">:</span> <span class="s2">&#34;hi&#34;</span>  <span class="c1">// 普通的 Object Literal 属性写法
</span><span class="c1"></span>    <span class="p">};</span>
    <span class="c1">// TODO 使用 options
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>After all the talk, there is still a big hole in the merge process above, I don&rsquo;t know if you found it? &ndash; The above is talking about merging mapping tables, not merging objects. Although a mapping table is an object, the entry of a mapping table is a simple key-value pair relationship; unlike an object, which has a hierarchy and depth of properties.</p>
<p>For example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">t1</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">a</span><span class="o">:</span> <span class="p">{</span> <span class="nx">x</span><span class="o">:</span> <span class="mi">1</span> <span class="p">}</span> <span class="p">};</span>
<span class="kr">const</span> <span class="nx">t2</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">a</span><span class="o">:</span> <span class="p">{</span> <span class="nx">y</span><span class="o">:</span> <span class="mi">2</span> <span class="p">}</span> <span class="p">};</span>
<span class="kr">const</span> <span class="nx">r</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">({},</span> <span class="nx">t1</span><span class="p">,</span> <span class="nx">t2</span><span class="p">);</span>    <span class="c1">// { a: { y: 2 } }
</span></code></pre></td></tr></table>
</div>
</div><p>The result is { a: { y: 2} } instead of { a: { x: 1, y: 2 } }. The former is the result of a shallow merge, where the entries of the mapping table are merged; the latter is the result of a deep merge, where multiple layers of properties of the object are merged.</p>
<p>It&rsquo;s a lot of work to write a deep merge by hand, but Lodash provides the <code>_.merge()</code> method, so you can use it off the shelf. <code>_.merge()</code> may not work as expected when merging arrays, in this case use <code>_.mergeWith()</code> to customize the array merge, there is a ready-made example in the documentation.</p>
<h2 id="viii-map-class">VIII. Map Class</h2>
<p>JavaScript also provides a specialized Map class, which, in contrast to Plain Object, allows arbitrary types of &ldquo;keys&rdquo;, not limited to string.</p>
<p>All the operations mentioned above have corresponding methods in Map. Without going into detail, a brief description is sufficient.</p>
<ul>
<li>add/modify, using the set() method.</li>
<li>get() method to get the value by key.</li>
<li>delete by key, using the delete() method, and a clear() method that clears the map table directly.</li>
<li>has() access to determine if a key-value pair exists.</li>
<li>size property to get the number of entries, unlike Plain Object which needs Object.entries(map).length to get it.</li>
<li>entries(), keys() and values() methods are used to get a list of entries, keys and values, but the result is not an array, but an Iterator.</li>
<li>There is also a forEach() method used to iterate directly, and the handler does not receive the entire entry (i.e., ([k, v])), but a separated (value, key, map).</li>
</ul>
<h2 id="summary">Summary</h2>
<p>Are you using objects or mapping tables in JavaScript? To be honest, it&rsquo;s not really easy to say. As a mapping table, the methods mentioned above are sufficient, but as an object, JavaScript provides more tools and methods, so check the Object API and Reflect API.</p>
<p>By mastering how to manipulate lists and mapping tables, you can basically solve various JavaScript data processing problems that you encounter on a daily basis. Data conversion, data grouping, group expansion, and tree data &hellip;&hellip; are just a few of the things you can do. In general, the native JavaScript API is sufficient, but if you encounter more complex situations (such as grouping), you may want to check the Lodash API, which is a professional data processing tool after all.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/javascript/">javascript</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-03/spark-on-kubernetes-or-yarn/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Spark on Kubernetes vs. Spark on Yarn Incomplete Comparison Analysis</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-03/kubernetes-knowledge-base/">
            <span class="next-text nav-default">Getting Started with Kubernetes - A Knowledge Base</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
