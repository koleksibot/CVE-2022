<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Git rebase Usage Details and How it Works - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="I had no idea about the use of git rebase -i, but once I needed to merge multiple commits, I almost lost all my commits, but luckily I was able to recover them later. So let&amp;rsquo;s document the process of learning the rebase command. Understanding the Rebase Command The documentation for the git rebase command is Reapply commits on top of another base tip, which literally means reapply commits on" /><meta name="keywords" content="git, Rebase, Intro" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-03/git-rebase-intro/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Git rebase Usage Details and How it Works" />
<meta property="og:description" content="I had no idea about the use of git rebase -i, but once I needed to merge multiple commits, I almost lost all my commits, but luckily I was able to recover them later. So let&rsquo;s document the process of learning the rebase command. Understanding the Rebase Command The documentation for the git rebase command is Reapply commits on top of another base tip, which literally means reapply commits on" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-03/git-rebase-intro/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-03-03T10:27:47+08:00" />
<meta property="article:modified_time" content="2022-03-03T10:27:47+08:00" />

<meta itemprop="name" content="Git rebase Usage Details and How it Works">
<meta itemprop="description" content="I had no idea about the use of git rebase -i, but once I needed to merge multiple commits, I almost lost all my commits, but luckily I was able to recover them later. So let&rsquo;s document the process of learning the rebase command. Understanding the Rebase Command The documentation for the git rebase command is Reapply commits on top of another base tip, which literally means reapply commits on"><meta itemprop="datePublished" content="2022-03-03T10:27:47+08:00" />
<meta itemprop="dateModified" content="2022-03-03T10:27:47+08:00" />
<meta itemprop="wordCount" content="4065">
<meta itemprop="keywords" content="git," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Git rebase Usage Details and How it Works"/>
<meta name="twitter:description" content="I had no idea about the use of git rebase -i, but once I needed to merge multiple commits, I almost lost all my commits, but luckily I was able to recover them later. So let&rsquo;s document the process of learning the rebase command. Understanding the Rebase Command The documentation for the git rebase command is Reapply commits on top of another base tip, which literally means reapply commits on"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Git rebase Usage Details and How it Works</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-03-03 10:27:47 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 4065 words </span>
          <span class="more-meta"> 9 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#understanding-the-rebase-command">Understanding the Rebase Command</a></li>
        <li><a href="#main-uses">Main Uses</a>
          <ul>
            <li><a href="#the-difference-between-rebase-and-merge">The difference between rebase and merge</a></li>
            <li><a href="#why-keep-the-commit-history-tidy">Why keep the commit history tidy</a></li>
            <li><a href="#other-ways-to-rewrite-the-commit-history">Other ways to rewrite the commit history</a></li>
          </ul>
        </li>
        <li><a href="#rewriting-the-commit-history-using-rebases-interactive-mode">Rewriting the commit history using rebase&rsquo;s interactive mode</a>
          <ul>
            <li><a href="#the-difference-between-the-two-modes">The difference between the two modes</a></li>
            <li><a href="#more-than-just-branches">More than just branches</a></li>
            <li><a href="#rewriting-commit-history">Rewriting commit history</a></li>
          </ul>
        </li>
        <li><a href="#advanced-uses-of-rebase">Advanced Uses of Rebase</a>
          <ul>
            <li><a href="#rebase-before-merging">Rebase before merging</a></li>
            <li><a href="#rebase-to-other-branch">rebase to other branch</a></li>
            <li><a href="#running-git-pull-with-a-rebase-policy">Running <code>git pull</code> with a rebase policy</a></li>
          </ul>
        </li>
        <li><a href="#potential-drawbacks-and-objections">Potential drawbacks and objections</a></li>
        <li><a href="#retrieving-lost-commits">Retrieving lost commits</a>
          <ul>
            <li><a href="#the-git-reflog-command">The <code>git reflog</code> command</a></li>
            <li><a href="#restoring-commit-history">Restoring Commit History</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>I had no idea about the use of <code>git rebase -i</code>, but once I needed to merge multiple commits, I almost lost all my commits, but luckily I was able to recover them later. So let&rsquo;s document the process of learning the <code>rebase</code> command.</p>
<h2 id="understanding-the-rebase-command">Understanding the Rebase Command</h2>
<p>The documentation for the <code>git rebase</code> command is <code>Reapply commits on top of another base tip</code>, which literally means <code>reapply commits on top of another base tip</code>, which sounds a bit abstract. Put another way, it means &ldquo;change the base of a branch from one commit to another, making it look like a branch was created from another commit&rdquo;, as shown below.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/03/9d44a2844c324fc288666c03b4165339.png" alt="git rebase"></p>
<p>Suppose we create a <code>Feature</code> branch for new feature development from commit A of <code>Master</code>, where A is the base of <code>Feature</code>. Then <code>Matser</code> adds two commits B and C, and <code>Feature</code> adds two commits D and E. Now we need to integrate the two new commits from <code>Master</code> into the <code>Feature</code> branch for some reason, such as new feature development relying on commits B and C. To keep the commit history tidy, we can switch to the <code>Feature</code> branch to perform a <code>rebase</code> operation.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">git rebase master
</code></pre></td></tr></table>
</div>
</div><p>The process of <code>rebase</code> is to first find the most recent common ancestor commit A of both branches (i.e., the current branch <code>Feature</code> and the target base branch <code>Master</code> of the <code>rebase</code> operation), then compare the previous commits (D and E) of the current branch with respect to the ancestor commit, extract the corresponding changes and save them to a temporary file, then point the current branch to the commit C pointed to by the target base <code>Master</code>, and finally use this as the new base to apply the changes saved to the temporary file in order.</p>
<p>You can also read the above as changing the base of the <code>Feature</code> branch from commit A to commit C. It looks like you created the branch from commit C and committed D and E. But in reality, it just &ldquo;looks&rdquo; like Git internally copies commits D and E, creates new commits D' and E', and applies them to a specific base (A→B→C). Although the new <code>Feature</code> branch looks the same as before, it&rsquo;s made up of completely new commits.</p>
<p>The essence of the <code>rebase</code> operation is to discard some existing commits and create some new ones accordingly that are the same but actually different.</p>
<h2 id="main-uses">Main Uses</h2>
<p><code>rebase</code> is typically used to rewrite the commit history. The following usage scenario is very common in most Git workflows.</p>
<ul>
<li>We pull a <code>feature</code> branch from a <code>master</code> branch to do feature development locally</li>
<li>The remote <code>master</code> branch merges in some new commits later</li>
<li>We want to integrate the latest changes from <code>master</code> in the <code>feature</code> branch</li>
</ul>
<h3 id="the-difference-between-rebase-and-merge">The difference between rebase and merge</h3>
<p>The above scenario can also be accomplished using <code>merge</code>, but using <code>rebase</code> allows us to keep a linear and more tidy commit history. Suppose we have the following branches.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">  D---E feature
 /
A---B---C master
</code></pre></td></tr></table>
</div>
</div><p>Now we will integrate commits B and C from the <code>master</code> branch into the <code>feature</code> branch using <code>merge</code> and <code>rebase</code> respectively, and add a new commit F to the <code>feature</code> branch, then merge the <code>feature</code> branch into <code>master</code>, and finally compare the difference between the commit histories created by the two methods.</p>
<h4 id="using-merge">Using <code>merge</code></h4>
<ol>
<li>
<p>switch to the <code>feature</code> branch: <code>git checkout feature</code>.</p>
</li>
<li>
<p>merge updates from the <code>master</code> branch: <code>git merge master</code>.</p>
</li>
<li>
<p>Add a commit to F: <code>git add . &amp;&amp; git commit -m &quot;commit F&quot;</code>.</p>
</li>
<li>
<p>Cut back to the <code>master</code> branch and perform a fast-forward merge: <code>git chekcout master &amp;&amp; git merge feature</code>.Execute the process as shown below.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/03/38c45469e5534896af5969df794b0e28.gif" alt="git merge"></p>
</li>
</ol>
<p>We will get the following submission history.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">* 6fa5484 (HEAD -&gt; master, feature) commit F
*   875906b Merge branch &#39;master&#39; into feature
|\  
| | 5b05585 commit E
| | f5b0fc0 commit D
* * d017dff commit C
* * 9df916f commit B
|/  
* cb932a6 commit A
</code></pre></td></tr></table>
</div>
</div><h4 id="using-rebase">Using <code>rebase</code></h4>
<p>The steps are basically the same as using <code>merge</code>, the only difference is that the command in step 2 is replaced with: <code>git rebase master</code>.</p>
<p>The execution process is shown in the following diagram.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/03/3e70390e54f3452b9227b4ea7dcaec5e.gif" alt="rebase"></p>
<p>We will get the following submission history.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">* 74199ce (HEAD -&gt; master, feature) commit F
* e7c7111 commit E
* d9623b0 commit D
* 73deeed commit C
* c50221f commit B
* ef13725 commit A
</code></pre></td></tr></table>
</div>
</div><p>You can see that the commit history formed using the <code>rebase</code> method is completely linear, and also looks neater with one less <code>merge</code> commit than the <code>merge</code> method.</p>
<h3 id="why-keep-the-commit-history-tidy">Why keep the commit history tidy</h3>
<p>What are the benefits of a neater looking commit history?</p>
<ol>
<li>to satisfy some developers' cleanliness.</li>
<li>When you need to go back in the commit history for some bug, it is easier to locate the commit from which the bug was introduced. This is especially true if you need to troubleshoot hundreds of commits with <code>git bisect</code>, or if you have a large feature branch that needs to pull frequent updates from a remote master branch.</li>
</ol>
<p>Using <code>rebase</code> to consolidate remote changes into the local repository is a better option. Pulling remote changes with <code>merge</code> results in a redundant <code>merge</code> commit every time you want to get an update on your project. The result of using <code>rebase</code> is more in line with our intent: I want to build on other people&rsquo;s completed work to make my changes.</p>
<h3 id="other-ways-to-rewrite-the-commit-history">Other ways to rewrite the commit history</h3>
<p>When we just want to modify the most recent commit, it is easier to use <code>git commit --amend</code>.</p>
<p>It works for the following scenarios.</p>
<ul>
<li>We&rsquo;ve just finished a commit, but haven&rsquo;t pushed it to the public branch yet.</li>
<li>Suddenly we realize that we left some small loose ends on the last commit, like a comment we forgot to delete or a tiny typo that we can fix very quickly but don&rsquo;t want to add a separate commit.</li>
<li>Or we just feel that the commit message of the last commit is not written well enough and we want to make some changes.</li>
</ul>
<p>At this point we can add the new changes (or skip them) and use the <code>git commit --amend</code> command to execute the commit, which will bring us to a new editor window where we can make changes to the commit message of the previous commit, save it, and then apply those changes to the previous commit.</p>
<p>If we have already pushed the last commit to a remote branch and the push is now rejected with an error, we can use <code>git push --force</code> to force the push if we want to make sure the branch is not a public branch.</p>
<p>Note that like <code>rebase</code>, Git doesn&rsquo;t actually modify and replace the previous commit internally, but rather creates a new commit and redirects to it.</p>
<h2 id="rewriting-the-commit-history-using-rebases-interactive-mode">Rewriting the commit history using rebase&rsquo;s interactive mode</h2>
<p>The <code>git rebase</code> command has two modes, standard and interactive. The previous examples we used the default standard mode, add the <code>-i</code> or <code>-interactive</code> option to the end of the command to use the interactive mode.</p>
<h3 id="the-difference-between-the-two-modes">The difference between the two modes</h3>
<p>As we mentioned earlier, <code>rebase</code> is &ldquo;reapplying commits on top of another base&rdquo;, and during the reapplication process, these commits are recreated and can naturally be modified. In the standard mode of <code>rebase</code>, commits from the current working branch are applied directly to the top of the incoming branch, while in the interactive mode, we are allowed to merge, reorder, and delete commits via the editor and specific command rules before reapplying them.</p>
<p>The most common usage scenarios for the two differ as a result.</p>
<ol>
<li>standard mode is often used to integrate the latest changes from other branches in the current branch.</li>
<li>Interaction mode is often used to edit the commit history of the current branch, such as merging multiple small commits into one large commit.</li>
</ol>
<h3 id="more-than-just-branches">More than just branches</h3>
<p>While our previous examples all performed rebase operations between two different branches, the rebase command is in fact not limited to branches.</p>
<p>Any commit reference can be treated as a valid <code>rebase</code> base object, including a commit ID, branch name, tag name, or a relative reference like <code>HEAD~1</code>.</p>
<p>Naturally, if we execute <code>rebase</code> on a historical commit of the current branch, the result will be that all commits after this commit will be reapplied to the current branch, which in interactive mode allows us to make changes to those commits.</p>
<h3 id="rewriting-commit-history">Rewriting commit history</h3>
<p>Finally, as mentioned earlier, if we execute <code>rebase</code> in interactive mode on a commit of the current branch, we are (indirectly) rewriting all commits after this one. This is described in more detail in the following example.</p>
<p>Suppose we have the following commits in the <code>feature</code> branch.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">74199cebdd34d107bb67b6da5533a2e405f4c330 <span class="o">(</span>HEAD -&gt; feature<span class="o">)</span> commit F
e7c7111d807c1d5209b97a9c75b09da5cd2810d4 commit E
d9623b0ef9d722b4a83d58a334e1ce85545ea524 commit D
73deeedaa944ef459b17d42601677c2fcc4c4703 commit C
c50221f93a39f3474ac59228d69732402556c93b commit B
ef1372522cdad136ce7e6dc3e02aab4d6ad73f79 commit A
</code></pre></td></tr></table>
</div>
</div><p>The next action we will perform is.</p>
<ul>
<li>merge B and C into a new commit and keep only the commit information of the original commit C</li>
<li>Delete commit D</li>
<li>Move commit E after commit F and rename it (i.e., change the commit information) to commit H</li>
<li>Add a new file change to commit F and rename it commit G</li>
</ul>
<p>Since the commits we need to modify are B→C→D→E, we need to use commit A as the new &ldquo;base&rdquo; and all commits after commit A will be reapplied.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">git rebase -i ef1372522cdad136ce7e6dc3e02aab4d6ad73f79 <span class="c1"># 参数是提交 A 的 ID</span>
</code></pre></td></tr></table>
</div>
</div><p>You will then be taken to the following editor screen.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">pick c50221f commit B
pick 73deeed commit C
pick d9623b0 commit D
pick e7c7111 commit E
pick 74199ce commit F

<span class="c1"># 变基 ef13725..74199ce 到 ef13725（5 个提交）</span>
<span class="c1">#</span>
<span class="c1"># 命令:</span>
<span class="c1"># p, pick &lt;提交&gt; = 使用提交</span>
<span class="c1"># r, reword &lt;提交&gt; = 使用提交，但修改提交说明</span>
<span class="c1"># e, edit &lt;提交&gt; = 使用提交，进入 shell 以便进行提交修补</span>
<span class="c1"># s, squash &lt;提交&gt; = 使用提交，但融合到前一个提交</span>
<span class="c1"># f, fixup &lt;提交&gt; = 类似于 &#34;squash&#34;，但丢弃提交说明日志</span>
<span class="c1"># x, exec &lt;命令&gt; = 使用 shell 运行命令（此行剩余部分）</span>
<span class="c1"># b, break = 在此处停止（使用 &#39;git rebase --continue&#39; 继续变基）</span>
<span class="c1"># d, drop &lt;提交&gt; = 删除提交</span>
......
</code></pre></td></tr></table>
</div>
</div><p>(Note that the commit messages after the commit ID above only serve a descriptive purpose, and modifying them here will have no effect.)</p>
<p>The specific commands are explained in considerable detail in the editor comments, so let&rsquo;s proceed directly as follows.</p>
<ol>
<li>
<p>make the following changes to commits B and C.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">pick c50221f commit B
f 73deeed commit C
</code></pre></td></tr></table>
</div>
</div><p>Since commit B is the first of these commits, we cannot execute the <code>squash</code> or <code>fixup</code> commands on it (there is no previous commit), and we do not need to execute the <code>reword</code> command on commit B to modify its commit information, because we will be allowed to modify the fused commit information later when we fuse commit C into commit B.</p>
<p>Note that commits in this interface are displayed in top-down order, so changing the command for commit C to <code>s (or squash)</code> or <code>f (or fixup)</code> will fuse it to the previous commit B (above), the difference between the two commands being whether or not the commit information for C is retained.</p>
</li>
<li>
<p>Delete the submission D.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">d d9623b0 commit D
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>Move commit E to after commit F and modify its commit information.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">pick 74199ce commit F
r e7c7111 commit E
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>Add a new document change to commit F.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">e 74199ce commit F
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>Save and then exit.</p>
</li>
</ol>
<p>The commands that we modify or retain for each commit are then executed in order from top to bottom.</p>
<ol>
<li>
<p>The <code>pick</code> command for commit B will be executed automatically, so no interaction is required.</p>
</li>
<li>
<p>Next, execute the <code>squash</code> command for commit C. This brings us to a new editor screen that allows us to modify the commit information after merging B and C.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># 这是一个 2 个提交的组合。</span>
<span class="c1"># 这是第一个提交说明：</span>

commit B

<span class="c1"># 这是提交说明 #2：</span>

commit C
......
</code></pre></td></tr></table>
</div>
</div><p>We delete the line <code>commit B</code> and save it to exit. Subsequent commits will use <code>commit C</code> as the commit message.</p>
</li>
<li>
<p>the <code>drop</code> operation for commit D will also be executed automatically without any interactive steps.</p>
</li>
<li>
<p>Conflicts may occur during the execution of <code>rebase</code>, where <code>rebase</code> is temporarily suspended and we need to edit the conflicting files to merge the conflicts manually. After resolving the conflict, you can mark it as resolved with <code>git add/rm &lt;conflicted_files&gt;</code> and then run <code>git rebase --continue</code> to continue with the <code>rebase</code> step, or you can run <code>git rebase --abort</code> to abort the <code>rebase</code> operation and revert to the to the state before the operation.</p>
</li>
<li>
<p>Since we moved up commit F, we will then perform an <code>edit</code> operation on F. This will enter a new shell session.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">停止在 74199ce... commit F
您现在可以修补这个提交，使用

git commit --amend 

当您对变更感到满意，执行

git rebase --continue
</code></pre></td></tr></table>
</div>
</div><p>We add a new code file and run <code>git commit --amend</code> to merge it into the current previous commit (i.e. F), then change its commit information to <code>commit G</code> in the editor screen, and finally run <code>git rebase--continue</code> to continue the <code>rebase</code> operation.</p>
</li>
<li>
<p>Finally, perform a <code>reword</code> operation on commit E and change its commit information to <code>commit H</code> in the editor screen.</p>
</li>
</ol>
<p>Done! Finally, let&rsquo;s confirm the commit history after <code>rebase</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">64710dc88ef4fbe8fe7aac206ec2e3ef12e7bca9 <span class="o">(</span>HEAD -&gt; feature<span class="o">)</span> commit H
8ab4506a672dac5c1a55db34779a185f045d7dd3 commit G
1e186f890710291aab5b508a4999134044f6f846 commit C
ef1372522cdad136ce7e6dc3e02aab4d6ad73f79 commit A
</code></pre></td></tr></table>
</div>
</div><p>This is exactly as expected, and you can see that all the commit IDs after commit A have changed, which confirms what we said earlier about Git re-creating these commits.</p>
<h2 id="advanced-uses-of-rebase">Advanced Uses of Rebase</h2>
<h3 id="rebase-before-merging">Rebase before merging</h3>
<p>Another common scenario for using <code>rebase</code> is to execute <code>rebase</code> before pushing to a remote for merging, typically to ensure a tidy commit history.</p>
<p>We first develop in our own feature branch, and when development is complete, we need to <code>rebase</code> the current feature branch to the latest master branch to resolve any potential conflicts before committing changes to the remote. In this case, the maintainer of the master branch of the remote repository no longer needs to integrate and create an additional <code>merge</code> commit, but only needs to perform a fast-forward merge. This results in a completely linear commit history, even in cases where multiple branches are developed in parallel.</p>
<h3 id="rebase-to-other-branch">rebase to other branch</h3>
<p>We can use <code>rebase</code> to compare two branches, take out the corresponding changes, and apply them to the other branch. For example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">    F---G patch
   /
  D---E feature
 /
A---B---C master
</code></pre></td></tr></table>
</div>
</div><p>Suppose we created a branch <code>patch</code> based on commit D of the <code>feature</code> branch and added commits F and G. Now we want to merge the changes made by <code>patch</code> into <code>master</code> and publish it, but we don&rsquo;t want to merge <code>feature</code> yet, in which case we can use the <code>-onto &lt;branch&gt;</code> option of <code>rebase</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">git rebase —onto master feature patch
</code></pre></td></tr></table>
</div>
</div><p>This will take the <code>patch</code> branch, compare the changes it made based on <code>feature</code>, and then reapply those changes to the <code>master</code> branch, making <code>patch</code> look like it made the changes directly based on <code>master</code>. The executed <code>patch</code> looks like this.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">A---B---C---F<span class="s1">&#39;---G&#39;</span> patch
</code></pre></td></tr></table>
</div>
</div><p>We can then switch to the <code>master</code> branch and perform a fast-forward merge on <code>patch</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">git checkout master
git merge patch
</code></pre></td></tr></table>
</div>
</div><h3 id="running-git-pull-with-a-rebase-policy">Running <code>git pull</code> with a rebase policy</h3>
<p>If you run <code>git pull</code> directly after a recent release of Git, you will get the following message.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">warning: 不建议在没有为偏离分支指定合并策略时执行 pull 操作。 您可以在执行下一次 pull 操作之前执行下面一条命令来抑制本消息：

  git config pull.rebase <span class="nb">false</span>  <span class="c1"># 合并（缺省策略）</span>
  git config pull.rebase <span class="nb">true</span>   <span class="c1"># 变基</span>
  git config pull.ff only       <span class="c1"># 仅快进</span>

......
</code></pre></td></tr></table>
</div>
</div><p>It turns out that <code>git pull</code> can also be merged with <code>rebase</code>, because <code>git pull</code> is actually equivalent to <code>git fetch</code> + <code>git merge</code>, and we can replace <code>git merge</code> with <code>git rebase</code> in the second step to merge the changes fetched by <code>fetch</code>, again to avoid additional <code>merge</code> commits and maintain a linear commit history.</p>
<p>We can think of the <code>Matser</code> branch in the comparison example as a remote branch and the <code>Feature</code> branch as a local branch, and when we do a local <code>git pull</code>, we are actually pulling changes from <code>Master</code> and merging them into the <code>Feature</code> branch. If both branches have different commits, the default <code>git merge</code> method will generate a separate merge commit to consolidate those commits; using <code>git rebase</code> is equivalent to re-creating the local branch based on the latest commits from the remote branch and then reapplying the local commits.</p>
<p>There are several ways to use this.</p>
<ul>
<li>Add a specific option each time you run the pull command: <code>git pull --rebase</code>.</li>
<li>Set a configuration entry for the current repository: <code>git config pull.rebase true</code>, and add the <code>-global</code> option to <code>git config</code> to make it effective for all repositories.</li>
</ul>
<h2 id="potential-drawbacks-and-objections">Potential drawbacks and objections</h2>
<p>From the above scenario <code>rebase</code> is very powerful, but we also need to realize that it is not foolproof and even a bit dangerous for newbies, who may find that a commit is missing from <code>git log</code> or get stuck in a step of <code>rebase</code> and don&rsquo;t know how to recover.</p>
<p>We&rsquo;ve mentioned above that <code>rebase</code> has the advantage of keeping a neat linear commit history, but it&rsquo;s also important to realize that it has the potential disadvantages of.</p>
<ul>
<li>If it involves commits that have already been pushed, you need to force a push in order to push the commits after the local <code>rebase</code> to the remote. So never run <code>rebase</code> on a public branch (i.e. one that other people are working on), or else someone else running <code>git pull</code> later will merge a confusing local commit history, and pushing further back to the remote branch will mess up the remote commit history (see <a href="https://www.daolf.com/posts/git-series-part-2/">Rebase and the golden rule explained</a>), which in more severe cases may pose a risk to your safety.</li>
<li>Unfriendly to newcomers, who are likely to &ldquo;lose&rdquo; some commits by mistake in interactive mode (but can actually retrieve them).</li>
<li>If you frequently use <code>rebase</code> to integrate master branch updates, one potential consequence is that you will encounter more and more conflicts that need to be merged. While you can handle these conflicts in the <code>rebase</code> process, this is not a long-term solution, and it is more advisable to merge into the master branch frequently and then create a new feature branch, rather than using a long-standing feature branch.</li>
</ul>
<p>There are also some arguments that we should try to avoid rewriting the commit history.</p>
<blockquote>
<p>There is a view that the commit history of a repository is a record of what actually happened. It is a document that is specific to the history and has value in itself, and cannot be changed indiscriminately. From this perspective, changing the commit history is blasphemy; you are using a lie to hide what actually happened. What if the commit history generated by the merge is a mess? Since that is what happened, the traces should be preserved for future generations to access.</p>
</blockquote>
<p>As well, frequent use of <code>rebase</code> may make it more difficult to locate bugs from the commit history, as described in <a href="https://medium.com/@fredrikmorken/why-you-should-stop-using-git-rebase-5552bee4fed1">Why you should stop using Git rebase</a>.</p>
<h2 id="retrieving-lost-commits">Retrieving lost commits</h2>
<p>Doing a <code>rebase</code> in interactive mode and executing a command like <code>squash</code> or <code>drop</code> on a commit will delete the commit directly from the branch&rsquo;s <code>git log</code>. If you accidentally make a mistake, you&rsquo;ll break out in a cold sweat thinking that these commits are gone for good.</p>
<p>But these commits aren&rsquo;t really deleted. As mentioned above, Git doesn&rsquo;t modify (or delete) the original commits, but rather it re-creates a new batch of commits and points the top of the current branch to the new commits. So we can use <code>git reflog</code> to find and redirect to the original commits to restore them, which undoes the entire <code>rebase</code>. Thanks to Git, it doesn&rsquo;t really lose any commits even if you do something like <code>rebase</code> or <code>commit --amend</code> that rewrites the commit history.</p>
<h3 id="the-git-reflog-command">The <code>git reflog</code> command</h3>
<p>reflogs is a mechanism that Git uses to keep track of updates to the top of the local repository branch. It keeps track of all the commits that the top of the branch has ever pointed to, so reflogs allows us to find and switch to a commit that is not currently referenced by any branch or tag.</p>
<p>Whenever the top of a branch is updated for any reason (by switching branches, pulling new changes, rewriting history, or adding new commits), a new record will be added to reflogs. In this way, every commit we have created locally must be logged in reflogs. Even after the commit history is rewritten, reflogs will contain information about the old state of the branch and allow us to revert to that state if needed.</p>
<p>Note that reflogs is not kept forever, it has an expiration time of 90 days.</p>
<h3 id="restoring-commit-history">Restoring Commit History</h3>
<p>Let&rsquo;s continue from the previous example. Suppose we want to restore the commit history of <code>feature</code> branch A→B→C→D→E→F before <code>rebase</code>, but at this point there are no more commits in <code>git log</code> for the last 5 commits, so we need to look for them in reflogs, and run <code>git reflog</code> with the following result:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">64710dc <span class="o">(</span>HEAD -&gt; feature<span class="o">)</span> HEAD@<span class="o">{</span>0<span class="o">}</span>: rebase <span class="o">(</span><span class="k">continue</span><span class="o">)</span> <span class="o">(</span>finish<span class="o">)</span>: returning to refs/heads/feature
64710dc <span class="o">(</span>HEAD -&gt; feature<span class="o">)</span> HEAD@<span class="o">{</span>1<span class="o">}</span>: rebase <span class="o">(</span><span class="k">continue</span><span class="o">)</span>: commit H
8ab4506 HEAD@<span class="o">{</span>2<span class="o">}</span>: rebase <span class="o">(</span><span class="k">continue</span><span class="o">)</span>: commit G
1e186f8 HEAD@<span class="o">{</span>3<span class="o">}</span>: rebase <span class="o">(</span>squash<span class="o">)</span>: commit C
c50221f HEAD@<span class="o">{</span>4<span class="o">}</span>: rebase <span class="o">(</span>start<span class="o">)</span>: checkout ef1372522cdad136ce7e6dc3e02aab4d6ad73f79
74199ce HEAD@<span class="o">{</span>5<span class="o">}</span>: checkout: moving from master to feature
......
</code></pre></td></tr></table>
</div>
</div><p>The <code>reflogs</code> document the entire process of switching branches and doing a <code>rebase</code>, and continuing down the list, we find the commit F that disappeared from the <code>git log</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">74199ce HEAD@<span class="o">{</span>15<span class="o">}</span>: commit: commit F
</code></pre></td></tr></table>
</div>
</div><p>Next, we redirect the top of the <code>feature</code> branch to the original commit F via <code>git reset</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># 我们想将工作区中的文件也一并还原，因此使用了--hard选项   </span>
$ git reset --hard 74199ce                                      
HEAD 现在位于 74199ce commit F
</code></pre></td></tr></table>
</div>
</div><p>Run <code>git log</code> again and you&rsquo;ll see that everything is back to where it was before.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">74199cebdd34d107bb67b6da5533a2e405f4c330 <span class="o">(</span>HEAD -&gt; feature<span class="o">)</span> commit F
e7c7111d807c1d5209b97a9c75b09da5cd2810d4 commit E
d9623b0ef9d722b4a83d58a334e1ce85545ea524 commit D
73deeedaa944ef459b17d42601677c2fcc4c4703 commit C
c50221f93a39f3474ac59228d69732402556c93b commit B
ef1372522cdad136ce7e6dc3e02aab4d6ad73f79 commit A
</code></pre></td></tr></table>
</div>
</div>
    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/git/">git</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-03/building-multi-architecture-images-with-docker-buildx/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">How to use docker buildx to build multi-architecture Go images</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-03/git-merge-intro/">
            <span class="next-text nav-default">A deeper understanding of git merge operations</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
