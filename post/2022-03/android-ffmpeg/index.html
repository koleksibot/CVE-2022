<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Android FFmpeg video decoding process and practical analysis - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="This article firstly introduces the main process and basic principle of decoding video with FFmpeg as the topic; secondly, it also describes the simple applications related to FFmpeg video decoding, including how to play video in a certain timeline order based on the original FFmpeg video decoding, and how to add the logic of seek when playing video. Besides, the article focuses on the details that may be easily missed" /><meta name="keywords" content="android, ffmpeg" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-03/android-ffmpeg/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Android FFmpeg video decoding process and practical analysis" />
<meta property="og:description" content="This article firstly introduces the main process and basic principle of decoding video with FFmpeg as the topic; secondly, it also describes the simple applications related to FFmpeg video decoding, including how to play video in a certain timeline order based on the original FFmpeg video decoding, and how to add the logic of seek when playing video. Besides, the article focuses on the details that may be easily missed" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-03/android-ffmpeg/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-03-08T09:31:31+08:00" />
<meta property="article:modified_time" content="2022-03-08T09:31:31+08:00" />

<meta itemprop="name" content="Android FFmpeg video decoding process and practical analysis">
<meta itemprop="description" content="This article firstly introduces the main process and basic principle of decoding video with FFmpeg as the topic; secondly, it also describes the simple applications related to FFmpeg video decoding, including how to play video in a certain timeline order based on the original FFmpeg video decoding, and how to add the logic of seek when playing video. Besides, the article focuses on the details that may be easily missed"><meta itemprop="datePublished" content="2022-03-08T09:31:31+08:00" />
<meta itemprop="dateModified" content="2022-03-08T09:31:31+08:00" />
<meta itemprop="wordCount" content="6794">
<meta itemprop="keywords" content="android,ffmpeg," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Android FFmpeg video decoding process and practical analysis"/>
<meta name="twitter:description" content="This article firstly introduces the main process and basic principle of decoding video with FFmpeg as the topic; secondly, it also describes the simple applications related to FFmpeg video decoding, including how to play video in a certain timeline order based on the original FFmpeg video decoding, and how to add the logic of seek when playing video. Besides, the article focuses on the details that may be easily missed"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Android FFmpeg video decoding process and practical analysis</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-03-08 09:31:31 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 6794 words </span>
          <span class="more-meta"> 14 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#preface">Preface</a>
          <ul>
            <li><a href="#ffmpeg">FFmpeg</a></li>
            <li><a href="#ffmpeg-six-common-function-modules">FFmpeg six common function modules</a></li>
            <li><a href="#introduction-to-video-decoding-basics">Introduction to video decoding basics</a></li>
          </ul>
        </li>
        <li><a href="#1-preparation-before-importing-ffmpeg">1. Preparation before importing FFmpeg</a>
          <ul>
            <li><a href="#11-ffmpeg-so-library-compilation">1.1 FFmpeg so library compilation</a></li>
            <li><a href="#12-introducing-ffmpegs-so-library-in-android">1.2 Introducing FFmpeg&rsquo;s so library in Android</a></li>
          </ul>
        </li>
        <li><a href="#2-principles-and-details-of-ffmpeg-decoding-video">2. Principles and details of FFmpeg decoding video</a>
          <ul>
            <li><a href="#21-main-flow">2.1 Main flow</a></li>
            <li><a href="#22-fundamentals">2.2 Fundamentals</a></li>
            <li><a href="#23-simple-application">2.3 Simple application</a></li>
            <li><a href="#24-details-of-the-decoding-process">2.4 Details of the decoding process</a></li>
            <li><a href="#25-wrapping-decoder-videodecoder-in-upper-layer">2.5 Wrapping decoder VideoDecoder in upper layer</a></li>
          </ul>
        </li>
        <li><a href="#3-insights">3. Insights</a></li>
        <li><a href="#4-appendix">4. Appendix</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>This article firstly introduces the main process and basic principle of decoding video with FFmpeg as the topic; secondly, it also describes the simple applications related to FFmpeg video decoding, including how to play video in a certain timeline order based on the original FFmpeg video decoding, and how to add the logic of seek when playing video. Besides, the article focuses on the details that may be easily missed when decoding video, and finally, it briefly explains how to package a VideoDecoder with basic video decoding functions.</p>
<h2 id="preface">Preface</h2>
<h3 id="ffmpeg">FFmpeg</h3>
<p>FFmpeg is a set of open source computer programs that can be used to record, convert and stream digital audio and video. It generates libraries for processing and manipulating multimedia data, including the advanced audio and video decoding library <code>libavcodec</code> and the audio and video format conversion library <code>libavformat</code>.</p>
<h3 id="ffmpeg-six-common-function-modules">FFmpeg six common function modules</h3>
<ul>
<li>libavformat: encapsulation and decapsulation libraries for multimedia files or protocols, such as mp4, flv and other file encapsulation formats, rtmp, rtsp and other network protocol encapsulation formats.</li>
<li>libavcodec: core library for audio and video decoding.</li>
<li>libavfilter: audio/video and subtitle filter library.</li>
<li>libswscale: image format conversion library.</li>
<li>libswresample: audio resampling library.</li>
<li>libavutil: tool library</li>
</ul>
<h3 id="introduction-to-video-decoding-basics">Introduction to video decoding basics</h3>
<ol>
<li>
<p>Demultiplexing (Demux): Demultiplexing can also be called decapsulation. There is a concept called encapsulation format here, and encapsulation format refers to the combined format of audio and video, commonly known as mp4, flv, mkv, etc. In layman&rsquo;s terms, encapsulation is the product of combining audio streams, video streams, subtitle streams and other accessories into a package according to certain rules. Decapsulation plays the opposite role of encapsulation, breaking a streaming file into audio data and video data. At this point, the split data is compressed and encoded, and the common video compression data formats are h264.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/08/51a55e676e2948389386d1783e63464c.png" alt="Demultiplexing"></p>
</li>
<li>
<p>Decode: Simply speaking, it is to decompress the compressed encoded data into raw video pixel data, commonly used raw video pixel data formats are yuv.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/08/a8743a3c8cb74dfaa7303292343e318f.png" alt="Decode"></p>
</li>
<li>
<p>Color Space Convert: Normally, for image displays, it is used to display images through the RGB model, but using the YUV model can save bandwidth when transferring image data. Therefore, it is necessary to convert the data in yuv pixel format to rgb pixel format before rendering when displaying the image.</p>
</li>
<li>
<p>Render: The data of each video frame that has been decoded and color space converted earlier is sent to the graphics card to be drawn on the screen.</p>
</li>
</ol>
<h2 id="1-preparation-before-importing-ffmpeg">1. Preparation before importing FFmpeg</h2>
<h3 id="11-ffmpeg-so-library-compilation">1.1 FFmpeg so library compilation</h3>
<ul>
<li>
<p>Download the source library from the FFmpeg official website and extract it.</p>
</li>
<li>
<p>Download the NDK library and extract it.</p>
</li>
<li>
<p>configure the unpacked FFmpeg source code library directory, modify the highlighted parameters to the following, the main purpose is to generate the format of the name-version.so file that can be used by Android.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># ······</span>
<span class="c1"># build settings</span>
<span class="nv">SHFLAGS</span><span class="o">=</span><span class="s1">&#39;-shared -Wl,-soname,$$(@F)&#39;</span>
<span class="nv">LIBPREF</span><span class="o">=</span><span class="s2">&#34;lib&#34;</span>
<span class="nv">LIBSUF</span><span class="o">=</span><span class="s2">&#34;.a&#34;</span>
<span class="nv">FULLNAME</span><span class="o">=</span><span class="s1">&#39;$(NAME)$(BUILDSUF)&#39;</span>
<span class="nv">LIBNAME</span><span class="o">=</span><span class="s1">&#39;$(LIBPREF)$(FULLNAME)$(LIBSUF)&#39;</span>
<span class="nv">SLIBPREF</span><span class="o">=</span><span class="s2">&#34;lib&#34;</span>
<span class="nv">SLIBSUF</span><span class="o">=</span><span class="s2">&#34;.so&#34;</span>
<span class="nv">SLIBNAME</span><span class="o">=</span><span class="s1">&#39;$(SLIBPREF)$(FULLNAME)$(SLIBSUF)&#39;</span>
<span class="nv">SLIBNAME_WITH_VERSION</span><span class="o">=</span><span class="s1">&#39;$(SLIBNAME).$(LIBVERSION)&#39;</span>

<span class="c1"># 已修改配置</span>
<span class="nv">SLIBNAME_WITH_MAJOR</span><span class="o">=</span><span class="s1">&#39;$(SLIBNAME)$(FULLNAME)-$(LIBMAJOR)$(SLIBSUF)&#39;</span>
<span class="nv">LIB_INSTALL_EXTRA_CMD</span><span class="o">=</span><span class="s1">&#39;$$(RANLIB)&#34;$(LIBDIR)/$(LIBNAME)&#34;&#39;</span>
<span class="nv">SLIB_INSTALL_NAME</span><span class="o">=</span><span class="s1">&#39;$(SLIBNAME_WITH_MAJOR)&#39;</span>
<span class="nv">SLIB_INSTALL_LINKS</span><span class="o">=</span><span class="s1">&#39;$(SLIBNAME)&#39;</span>
<span class="c1"># ······</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>Create a new script file <code>build_android_arm_v8a.sh</code> in the FFmpeg repository directory, configure the path to the NDK in the file, and enter the rest of the following.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># 清空上次的编译</span>
make clean
<span class="c1"># 这里先配置你的 NDK 路径</span>
<span class="nb">export</span> <span class="nv">NDK</span><span class="o">=</span>/Users/bytedance/Library/Android/sdk/ndk/21.4.7075529
<span class="nv">TOOLCHAIN</span><span class="o">=</span><span class="nv">$NDK</span>/toolchains/llvm/prebuilt/darwin-x86_64


<span class="k">function</span> build_android
<span class="o">{</span>

./configure <span class="se">\
</span><span class="se"></span>--prefix<span class="o">=</span><span class="nv">$PREFIX</span> <span class="se">\
</span><span class="se"></span>--disable-postproc <span class="se">\
</span><span class="se"></span>--disable-debug <span class="se">\
</span><span class="se"></span>--disable-doc <span class="se">\
</span><span class="se"></span>--enable-FFmpeg <span class="se">\
</span><span class="se"></span>--disable-doc <span class="se">\
</span><span class="se"></span>--disable-symver <span class="se">\
</span><span class="se"></span>--disable-static <span class="se">\
</span><span class="se"></span>--enable-shared <span class="se">\
</span><span class="se"></span>--cross-prefix<span class="o">=</span><span class="nv">$CROSS_PREFIX</span> <span class="se">\
</span><span class="se"></span>--target-os<span class="o">=</span>android <span class="se">\
</span><span class="se"></span>--arch<span class="o">=</span><span class="nv">$ARCH</span> <span class="se">\
</span><span class="se"></span>--cpu<span class="o">=</span><span class="nv">$CPU</span> <span class="se">\
</span><span class="se"></span>--cc<span class="o">=</span><span class="nv">$CC</span> <span class="se">\
</span><span class="se"></span>--cxx<span class="o">=</span><span class="nv">$CXX</span> <span class="se">\
</span><span class="se"></span>--enable-cross-compile <span class="se">\
</span><span class="se"></span>--sysroot<span class="o">=</span><span class="nv">$SYSROOT</span> <span class="se">\
</span><span class="se"></span>--extra-cflags<span class="o">=</span><span class="s2">&#34;-Os -fpic </span><span class="nv">$OPTIMIZE_CFLAGS</span><span class="s2">&#34;</span> <span class="se">\
</span><span class="se"></span>--extra-ldflags<span class="o">=</span><span class="s2">&#34;</span><span class="nv">$ADDI_LDFLAGS</span><span class="s2">&#34;</span>

make clean
make -j16
make install

<span class="nb">echo</span> <span class="s2">&#34;============================ build android arm64-v8a success ==========================&#34;</span>

<span class="o">}</span>

<span class="c1"># arm64-v8a</span>
<span class="nv">ARCH</span><span class="o">=</span>arm64
<span class="nv">CPU</span><span class="o">=</span>armv8-a
<span class="nv">API</span><span class="o">=</span><span class="m">21</span>
<span class="nv">CC</span><span class="o">=</span><span class="nv">$TOOLCHAIN</span>/bin/aarch64-linux-android<span class="nv">$API</span>-clang
<span class="nv">CXX</span><span class="o">=</span><span class="nv">$TOOLCHAIN</span>/bin/aarch64-linux-android<span class="nv">$API</span>-clang++
<span class="nv">SYSROOT</span><span class="o">=</span><span class="nv">$NDK</span>/toolchains/llvm/prebuilt/darwin-x86_64/sysroot
<span class="nv">CROSS_PREFIX</span><span class="o">=</span><span class="nv">$TOOLCHAIN</span>/bin/aarch64-linux-android-
<span class="nv">PREFIX</span><span class="o">=</span><span class="k">$(</span><span class="nb">pwd</span><span class="k">)</span>/android/<span class="nv">$CPU</span>
<span class="nv">OPTIMIZE_CFLAGS</span><span class="o">=</span><span class="s2">&#34;-march=</span><span class="nv">$CPU</span><span class="s2">&#34;</span>

<span class="nb">echo</span> <span class="nv">$CC</span>

build_android
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>Set permissions for all files in the NDK folder <code>chmod 777 -R NDK</code>.</p>
</li>
<li>
<p>Execute the script <code>. /build_android_arm_v8a.sh</code> to start compiling FFmpeg. The compiled file will be in the <code>android</code> directory under FFmpeg, and multiple .so files will appear.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/08/c7fbe129d19f42a98f08341baa80f428.png" alt="android compiling FFmpeg"></p>
</li>
<li>
<p>To build arm-v7a, just copy and modify the above script to the following <code>build_android_arm_v7a.sh</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#armv7-a</span>
<span class="nv">ARCH</span><span class="o">=</span>arm
<span class="nv">CPU</span><span class="o">=</span>armv7-a
<span class="nv">API</span><span class="o">=</span><span class="m">21</span>
<span class="nv">CC</span><span class="o">=</span><span class="nv">$TOOLCHAIN</span>/bin/armv7a-linux-androideabi<span class="nv">$API</span>-clang
<span class="nv">CXX</span><span class="o">=</span><span class="nv">$TOOLCHAIN</span>/bin/armv7a-linux-androideabi<span class="nv">$API</span>-clang++
<span class="nv">SYSROOT</span><span class="o">=</span><span class="nv">$NDK</span>/toolchains/llvm/prebuilt/darwin-x86_64/sysroot
<span class="nv">CROSS_PREFIX</span><span class="o">=</span><span class="nv">$TOOLCHAIN</span>/bin/arm-linux-androideabi-
<span class="nv">PREFIX</span><span class="o">=</span><span class="k">$(</span><span class="nb">pwd</span><span class="k">)</span>/android/<span class="nv">$CPU</span>
<span class="nv">OPTIMIZE_CFLAGS</span><span class="o">=</span><span class="s2">&#34;-mfloat-abi=softfp -mfpu=vfp -marm -march=</span><span class="nv">$CPU</span><span class="s2"> &#34;</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="12-introducing-ffmpegs-so-library-in-android">1.2 Introducing FFmpeg&rsquo;s so library in Android</h3>
<ul>
<li>
<p>NDK environment, CMake build tool, LLDB (C/C++ code debugging tool).</p>
</li>
<li>
<p>New C++ module, which usually generates the following important files: <code>CMakeLists.txt</code>, <code>native-lib.cpp</code>, <code>MainActivity</code>.</p>
</li>
<li>
<p>Next, under the <code>jniLibs</code> directory, create the <code>arm64-v8a</code> directory and paste the compiled .so file into it; then paste the compiled . h header file (FFmpeg&rsquo;s exposed interface) into <code>include</code> in the <code>cpp</code> directory. The .so dynamic library directory and .h header directory above are explicitly declared and linked in <code>CMakeLists.txt</code>.</p>
</li>
<li>
<p>The top-level <code>MainActivity</code> where the C/C++ code compiled libraries are loaded: <code>native-lib</code>. <code>native-lib</code> is added to the library named &ldquo;ffmpeg&rdquo; in <code>CMakeLists.txt</code>, so the input in <code>System.loadLibrary()</code> is &ldquo;ffmpeg&rdquo;.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">MainActivity</span> <span class="o">:</span> <span class="n">AppCompatActivity</span><span class="o">()</span> <span class="o">{</span>

    <span class="n">override</span> <span class="n">fun</span> <span class="nf">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">:</span> <span class="n">Bundle</span><span class="o">?)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">)</span>
        <span class="n">setContentView</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">layout</span><span class="o">.</span><span class="na">activity_main</span><span class="o">)</span>

        <span class="c1">// Example of a call to a native method
</span><span class="c1"></span>        <span class="n">sample_text</span><span class="o">.</span><span class="na">text</span> <span class="o">=</span> <span class="n">stringFromJNI</span><span class="o">()</span>
    <span class="o">}</span>

    <span class="c1">// 声明一个外部引用的方法，此方法和 C/C++ 层的代码是对应的。
</span><span class="c1"></span>    <span class="n">external</span> <span class="n">fun</span> <span class="nf">stringFromJNI</span><span class="o">():</span> <span class="n">String</span>

    <span class="n">companion</span> <span class="n">object</span> <span class="o">{</span>

        <span class="c1">// 在 init{} 中加载 C/C++ 编译成的 library：ffmpeg
</span><span class="c1"></span>        <span class="c1">// library 名称的定义和添加在 CMakeLists.txt 中完成
</span><span class="c1"></span>        <span class="n">init</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">loadLibrary</span><span class="o">(</span><span class="s">&#34;ffmpeg&#34;</span><span class="o">)</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><code>native-lib.cpp</code> is a C++ interface file where the external methods declared in the Java layer are implemented.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;jni.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">extern</span> <span class="s">&#34;C&#34;</span> <span class="n">JNIEXPORT</span> <span class="n">jstring</span> <span class="n">JNICALL</span>
<span class="n">Java_com_bytedance_example_MainActivity_stringFromJNI</span><span class="p">(</span>
        <span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span>
        <span class="n">jobject</span> <span class="cm">/* this */</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">hello</span> <span class="o">=</span> <span class="s">&#34;Hello from C++&#34;</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">NewStringUTF</span><span class="p">(</span><span class="n">hello</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><code>CMakeLists.txt</code> is a build script to configure the build information for the so library <code>native-lib</code> that can be compiled.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># For more information about using CMake with Android Studio, read the</span>
<span class="c1"># documentation: https://d.android.com/studio/projects/add-native-code.html</span>

<span class="c1"># Sets the minimum version of CMake required to build the native library.</span>

cmake_minimum_required<span class="o">(</span>VERSION 3.10.2<span class="o">)</span>

<span class="c1"># Declares and names the project.</span>

project<span class="o">(</span><span class="s2">&#34;ffmpeg&#34;</span><span class="o">)</span>

<span class="c1"># Creates and names a library, sets it as either STATIC</span>
<span class="c1"># or SHARED, and provides the relative paths to its source code.</span>
<span class="c1"># You can define multiple libraries, and CMake builds them for you.</span>
<span class="c1"># Gradle automatically packages shared libraries with your APK.</span>

<span class="c1"># 定义 so 库和头文件所在目录，方便后面使用</span>
set<span class="o">(</span>FFmpeg_lib_dir <span class="si">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="si">}</span>/../jniLibs/<span class="si">${</span><span class="nv">ANDROID_ABI</span><span class="si">}</span><span class="o">)</span>
set<span class="o">(</span>FFmpeg_head_dir <span class="si">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="si">}</span>/FFmpeg<span class="o">)</span>

<span class="c1"># 添加头文件目录</span>
include_directories<span class="o">(</span>
        FFmpeg/include
<span class="o">)</span>

add_library<span class="o">(</span> <span class="c1"># Sets the name of the library.</span>
        ffmmpeg

        <span class="c1"># Sets the library as a shared library.</span>
        SHARED

        <span class="c1"># Provides a relative path to your source file(s).</span>
        native-lib.cpp
        <span class="o">)</span>

<span class="c1"># Searches for a specified prebuilt library and stores the path as a</span>
<span class="c1"># variable. Because CMake includes system libraries in the search path by</span>
<span class="c1"># default, you only need to specify the name of the public NDK library</span>
<span class="c1"># you want to add. CMake verifies that the library exists before</span>
<span class="c1"># completing its build.</span>

<span class="c1"># 添加FFmpeg相关的so库</span>
add_library<span class="o">(</span> avutil
        SHARED
        IMPORTED <span class="o">)</span>
set_target_properties<span class="o">(</span> avutil
        PROPERTIES IMPORTED_LOCATION
        <span class="si">${</span><span class="nv">FFmpeg_lib_dir</span><span class="si">}</span>/libavutil.so <span class="o">)</span>
add_library<span class="o">(</span> swresample
        SHARED
        IMPORTED <span class="o">)</span>
set_target_properties<span class="o">(</span> swresample
        PROPERTIES IMPORTED_LOCATION
        <span class="si">${</span><span class="nv">FFmpeg_lib_dir</span><span class="si">}</span>/libswresample.so <span class="o">)</span>

add_library<span class="o">(</span> avcodec
        SHARED
        IMPORTED <span class="o">)</span>
set_target_properties<span class="o">(</span> avcodec
        PROPERTIES IMPORTED_LOCATION
        <span class="si">${</span><span class="nv">FFmpeg_lib_dir</span><span class="si">}</span>/libavcodec.so <span class="o">)</span>


find_library<span class="o">(</span> <span class="c1"># Sets the name of the path variable.</span>
        log-lib

        <span class="c1"># Specifies the name of the NDK library that</span>
        <span class="c1"># you want CMake to locate.</span>
        log<span class="o">)</span>

<span class="c1"># Specifies libraries CMake should link to your target library. You</span>
<span class="c1"># can link multiple libraries, such as libraries you define in this</span>
<span class="c1"># build script, prebuilt third-party libraries, or system libraries.</span>

target_link_libraries<span class="o">(</span> <span class="c1"># Specifies the target library.</span>
        audioffmmpeg

        <span class="c1"># 把前面添加进来的 FFmpeg.so 库都链接到目标库 native-lib 上</span>
        avutil
        swresample
        avcodec

        -landroid

        <span class="c1"># Links the target library to the log library</span>
        <span class="c1"># included in the NDK.</span>
        <span class="si">${</span><span class="nv">log</span><span class="p">-lib</span><span class="si">}</span><span class="o">)</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>The above operation will introduce FFmpeg into the Android project.</p>
</li>
</ul>
<h2 id="2-principles-and-details-of-ffmpeg-decoding-video">2. Principles and details of FFmpeg decoding video</h2>
<h3 id="21-main-flow">2.1 Main flow</h3>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/08/204874d9272c4e149807c8f3c7e8e457.png" alt="FFmpeg decoding video  Main flow"></p>
<h3 id="22-fundamentals">2.2 Fundamentals</h3>
<h4 id="221-common-ffmpeg-interfaces">2.2.1 Common ffmpeg interfaces</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="c1">// 1 分配 AVFormatContext
</span><span class="c1"></span><span class="n">avformat_alloc_context</span><span class="p">();</span>
<span class="c1">// 2 打开文件输入流
</span><span class="c1"></span><span class="n">avformat_open_input</span><span class="p">(</span><span class="n">AVFormatContext</span> <span class="o">**</span><span class="n">ps</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">url</span><span class="p">,</span>
                        <span class="k">const</span> <span class="n">AVInputFormat</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="n">AVDictionary</span> <span class="o">**</span><span class="n">options</span><span class="p">);</span>
<span class="c1">// 3 提取输入文件中的数据流信息
</span><span class="c1"></span><span class="n">avformat_find_stream_info</span><span class="p">(</span><span class="n">AVFormatContext</span> <span class="o">*</span><span class="n">ic</span><span class="p">,</span> <span class="n">AVDictionary</span> <span class="o">**</span><span class="n">options</span><span class="p">);</span>
<span class="c1">// 4 分配编解码上下文
</span><span class="c1"></span><span class="n">avcodec_alloc_context3</span><span class="p">(</span><span class="k">const</span> <span class="n">AVCodec</span> <span class="o">*</span><span class="n">codec</span><span class="p">);</span>
<span class="c1">// 5 基于与数据流相关的编解码参数来填充编解码器上下文
</span><span class="c1"></span><span class="n">avcodec_parameters_to_context</span><span class="p">(</span><span class="n">AVCodecContext</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span>
                                  <span class="k">const</span> <span class="n">AVCodecParameters</span> <span class="o">*</span><span class="n">par</span><span class="p">);</span>
<span class="c1">// 6 查找对应已注册的编解码器
</span><span class="c1"></span><span class="n">avcodec_find_decoder</span><span class="p">(</span><span class="k">enum</span> <span class="n">AVCodecID</span> <span class="n">id</span><span class="p">);</span>
<span class="c1">// 7 打开编解码器
</span><span class="c1"></span><span class="n">avcodec_open2</span><span class="p">(</span><span class="n">AVCodecContext</span> <span class="o">*</span><span class="n">avctx</span><span class="p">,</span> <span class="k">const</span> <span class="n">AVCodec</span> <span class="o">*</span><span class="n">codec</span><span class="p">,</span> <span class="n">AVDictionary</span> <span class="o">**</span><span class="n">options</span><span class="p">);</span>
<span class="c1">// 8 不停地从码流中提取压缩帧数据，获取的是一帧视频的压缩数据
</span><span class="c1"></span><span class="n">av_read_frame</span><span class="p">(</span><span class="n">AVFormatContext</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">AVPacket</span> <span class="o">*</span><span class="n">pkt</span><span class="p">);</span>
<span class="c1">// 9 发送原生的压缩数据输入到解码器（compressed data）
</span><span class="c1"></span><span class="n">avcodec_send_packet</span><span class="p">(</span><span class="n">AVCodecContext</span> <span class="o">*</span><span class="n">avctx</span><span class="p">,</span> <span class="k">const</span> <span class="n">AVPacket</span> <span class="o">*</span><span class="n">avpkt</span><span class="p">);</span>
<span class="c1">// 10 接收解码器输出的解码数据
</span><span class="c1"></span><span class="n">avcodec_receive_frame</span><span class="p">(</span><span class="n">AVCodecContext</span> <span class="o">*</span><span class="n">avctx</span><span class="p">,</span> <span class="n">AVFrame</span> <span class="o">*</span><span class="n">frame</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="222-overall-idea-of-video-decoding">2.2.2 Overall idea of video decoding</h4>
<ul>
<li>
<p>First of all, register <code>libavformat</code> and register all codecs, multiplex/demultiplex groups, protocols, etc. It is the first function called in all FFmpeg-based applications, and only when this function is called can you use FFmpeg&rsquo;s functions properly. Also, in the latest versions of FFmpeg it is now possible to use this line of code without it.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">av_register_all<span class="o">()</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>Open the video file and extract the data stream information from the file.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">auto</span> <span class="n">av_format_context</span> <span class="o">=</span> <span class="n">avformat_alloc_context</span><span class="p">();</span>
<span class="n">avformat_open_input</span><span class="p">(</span><span class="o">&amp;</span><span class="n">av_format_context</span><span class="p">,</span> <span class="n">path_</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">nullptr</span><span class="p">,</span> <span class="n">nullptr</span><span class="p">);</span>
<span class="n">avformat_find_stream_info</span><span class="p">(</span><span class="n">av_format_context</span><span class="p">,</span> <span class="n">nullptr</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>Then get the subscript of the video media stream in order to find the video media stream in the file.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="n">video_stream_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">av_format_context</span><span class="o">-&gt;</span><span class="n">nb_streams</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 匹配找到视频媒体流的下标，
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">av_format_context</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">codecpar</span><span class="o">-&gt;</span><span class="n">codec_type</span> <span class="o">==</span> <span class="n">AVMEDIA_TYPE_VIDEO</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">video_stream_index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">LOGD</span><span class="p">(</span><span class="n">TAG</span><span class="p">,</span> <span class="s">&#34;find video stream index = %d&#34;</span><span class="p">,</span> <span class="n">video_stream_index</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>obtaining the video media stream, obtaining the decoder context, obtaining the decoder context, configuring the parameter values of the decoder context, and opening the decoder.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// 获取视频媒体流
</span><span class="c1"></span><span class="k">auto</span> <span class="n">stream</span> <span class="o">=</span> <span class="n">av_format_context</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">video_stream_index</span><span class="p">];</span>
<span class="c1">// 找到已注册的解码器
</span><span class="c1"></span><span class="k">auto</span> <span class="n">codec</span> <span class="o">=</span> <span class="n">avcodec_find_decoder</span><span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">codecpar</span><span class="o">-&gt;</span><span class="n">codec_id</span><span class="p">);</span>
<span class="c1">// 获取解码器上下文
</span><span class="c1"></span><span class="n">AVCodecContext</span><span class="o">*</span> <span class="n">codec_ctx</span> <span class="o">=</span> <span class="n">avcodec_alloc_context3</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
<span class="c1">// 将视频媒体流的参数配置到解码器上下文
</span><span class="c1"></span><span class="k">auto</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">avcodec_parameters_to_context</span><span class="p">(</span><span class="n">codec_ctx</span><span class="p">,</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">codecpar</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 打开解码器
</span><span class="c1"></span>    <span class="n">avcodec_open2</span><span class="p">(</span><span class="n">codec_ctx</span><span class="p">,</span> <span class="n">codec</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">);</span>
    <span class="c1">// ······
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>Calculate the memory size needed for the required buffer by specifying the pixel format, image width, and image height, and allocate the set buffer; and since it is an up-screen drawing, we need to use <code>ANativeWindow</code> and set the properties of this drawing window using <code>ANativeWindow_setBuffersGeometry</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">video_width_</span> <span class="o">=</span> <span class="n">codec_ctx</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">;</span>
<span class="n">video_height_</span> <span class="o">=</span> <span class="n">codec_ctx</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">buffer_size</span> <span class="o">=</span> <span class="n">av_image_get_buffer_size</span><span class="p">(</span><span class="n">AV_PIX_FMT_RGBA</span><span class="p">,</span>
                                        <span class="n">video_width_</span><span class="p">,</span> <span class="n">video_height_</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="c1">// 输出 buffer
</span><span class="c1"></span><span class="n">out_buffer_</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span> <span class="n">av_malloc</span><span class="p">(</span><span class="n">buffer_size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint8_t</span><span class="p">));</span>
<span class="c1">// 通过设置宽高来限制缓冲区中的像素数量，而非显示屏幕的尺寸。
</span><span class="c1">// 如果缓冲区与显示的屏幕尺寸不相符，则实际显示的可能会是拉伸，或者被压缩的图像
</span><span class="c1"></span><span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">ANativeWindow_setBuffersGeometry</span><span class="p">(</span><span class="n">native_window_</span><span class="p">,</span> <span class="n">video_width_</span><span class="p">,</span>
                                            <span class="n">video_height_</span><span class="p">,</span> <span class="n">WINDOW_FORMAT_RGBA_8888</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>Allocate memory space to an AVFrame in the pixel format RGBA to hold the frame data after conversion to RGBA; set the rgba_frame buffer to be associated with out_buffer_.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="n">rgba_frame</span> <span class="o">=</span> <span class="n">av_frame_alloc</span><span class="p">();</span>
<span class="n">av_image_fill_arrays</span><span class="p">(</span><span class="n">rgba_frame</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">rgba_frame</span><span class="o">-&gt;</span><span class="n">linesize</span><span class="p">,</span>
                    <span class="n">out_buffer_</span><span class="p">,</span>
                    <span class="n">AV_PIX_FMT_RGBA</span><span class="p">,</span>
                    <span class="n">video_width_</span><span class="p">,</span> <span class="n">video_height_</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>Get <code>SwsContext</code>, which is used when calling sws_scale() for image format conversion and image scaling. yuv420p to rgba conversion may fail to return the correct height value when calling sws_scale, because of the flags when calling sws_getContext, you need to change SWS _BICUBIC to SWS_FULL_CHR_H_INT | SWS_ACCURATE_RND.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">SwsContext</span><span class="o">*</span> <span class="n">data_convert_context</span> <span class="o">=</span> <span class="n">sws_getContext</span><span class="p">(</span>
                    <span class="n">video_width_</span><span class="p">,</span> <span class="n">video_height_</span><span class="p">,</span> <span class="n">codec_ctx</span><span class="o">-&gt;</span><span class="n">pix_fmt</span><span class="p">,</span>
                    <span class="n">video_width_</span><span class="p">,</span> <span class="n">video_height_</span><span class="p">,</span> <span class="n">AV_PIX_FMT_RGBA</span><span class="p">,</span>
                    <span class="n">SWS_BICUBIC</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>Allocate memory space to <code>AVFrame</code> for storing raw data, pointing to raw frame data, and to <code>AVPacket</code> for storing pre-decoded video data.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">av_frame_alloc</span><span class="p">();</span>
<span class="k">auto</span> <span class="n">packet</span> <span class="o">=</span> <span class="n">av_packet_alloc</span><span class="p">();</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>Loop through the compressed frame data from the video stream and start decoding.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">ret</span> <span class="o">=</span> <span class="n">av_read_frame</span><span class="p">(</span><span class="n">av_format_context</span><span class="p">,</span> <span class="n">packet</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Decode</span><span class="p">(</span><span class="n">codec_ctx</span><span class="p">,</span> <span class="n">packet</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">lock</span><span class="p">,</span> <span class="n">data_convert_context</span><span class="p">,</span> <span class="n">rgba_frame</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>Send the <code>packet</code> with the native compressed data as input to the decoder in the <code>Decode()</code> function.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cm">/* send the packet with the compressed data to the decoder */</span>
<span class="n">ret</span> <span class="o">=</span> <span class="n">avcodec_send_packet</span><span class="p">(</span><span class="n">codec_ctx</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>The decoder returns the decoded frame data to the specified <code>frame</code>, and the <code>pts</code> of the decoded <code>frame</code> can subsequently be converted to timestamps and drawn to the playback screen frame by frame in the display order of the timeline.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">while</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_stop_</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 返回解码后的数据到 frame
</span><span class="c1"></span>    <span class="n">ret</span> <span class="o">=</span> <span class="n">avcodec_receive_frame</span><span class="p">(</span><span class="n">codec_ctx</span><span class="p">,</span> <span class="n">frame</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">AVERROR</span><span class="p">(</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="o">||</span> <span class="n">ret</span> <span class="o">==</span> <span class="n">AVERROR_EOF</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 拿到当前解码后的 frame，对其 pts 换算成时间戳，以便于跟传入的指定时间戳进行比
</span><span class="c1"></span>    <span class="k">auto</span> <span class="n">decode_time_ms</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">pts</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">/</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">time_base</span><span class="p">.</span><span class="n">den</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">decode_time_ms</span> <span class="o">&gt;=</span> <span class="n">time_ms_</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">last_decode_time_ms_</span> <span class="o">=</span> <span class="n">decode_time_ms</span><span class="p">;</span>
        <span class="n">is_seeking_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="c1">// ······
</span><span class="c1"></span>        <span class="c1">// 图片数据格式转换
</span><span class="c1"></span>        <span class="c1">// ······
</span><span class="c1"></span>        <span class="c1">// 把转换后的数据绘制到屏幕上
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="n">av_packet_unref</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>Before drawing the screen, we have to convert the image data format, here we have to use the <code>SwsContext</code> obtained earlier.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// 图片数据格式转换
</span><span class="c1"></span><span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">sws_scale</span><span class="p">(</span>
        <span class="n">sws_context</span><span class="p">,</span>
        <span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="k">const</span><span class="o">*</span><span class="p">)</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">linesize</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span> <span class="n">video_height_</span><span class="p">,</span>
        <span class="n">rgba_frame</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">rgba_frame</span><span class="o">-&gt;</span><span class="n">linesize</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">LOGE</span><span class="p">(</span><span class="n">TAG</span><span class="p">,</span> <span class="s">&#34;Player Error : data convert fail&#34;</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>Because it is an up-screen drawing, <code>ANativeWindow</code> and <code>ANativeWindow_Buffer</code> are used. Before drawing the screen, the next drawing <code>surface</code> of the locked window is used to draw, then the data of the frame to be displayed is written to the buffer, and finally the drawing <code>surface</code> of the unlocked window is used to post the data from the buffer to the screen display.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// 播放
</span><span class="c1"></span><span class="n">result</span> <span class="o">=</span> <span class="n">ANativeWindow_lock</span><span class="p">(</span><span class="n">native_window_</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">window_buffer_</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">LOGE</span><span class="p">(</span><span class="n">TAG</span><span class="p">,</span> <span class="s">&#34;Player Error : Can not lock native window&#34;</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// 将图像绘制到界面上
</span><span class="c1"></span>    <span class="c1">// 注意 : 这里 rgba_frame 一行的像素和 window_buffer 一行的像素长度可能不一致
</span><span class="c1"></span>    <span class="c1">// 需要转换好 否则可能花屏
</span><span class="c1"></span>    <span class="k">auto</span> <span class="n">bits</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span> <span class="n">window_buffer_</span><span class="p">.</span><span class="n">bits</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="n">video_height_</span><span class="p">;</span> <span class="n">h</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">bits</span> <span class="o">+</span> <span class="n">h</span> <span class="o">*</span> <span class="n">window_buffer_</span><span class="p">.</span><span class="n">stride</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span>
            <span class="n">out_buffer_</span> <span class="o">+</span> <span class="n">h</span> <span class="o">*</span> <span class="n">rgba_frame</span><span class="o">-&gt;</span><span class="n">linesize</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">rgba_frame</span><span class="o">-&gt;</span><span class="n">linesize</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="n">ANativeWindow_unlockAndPost</span><span class="p">(</span><span class="n">native_window_</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>The above is the main decoding process. Besides, because C++ needs to release resources and memory space by itself when using them, it also needs to call the release interface to release resources after decoding to avoid memory leakage.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">sws_freeContext</span><span class="p">(</span><span class="n">data_convert_context</span><span class="p">);</span>
<span class="n">av_free</span><span class="p">(</span><span class="n">out_buffer_</span><span class="p">);</span>
<span class="n">av_frame_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rgba_frame</span><span class="p">);</span>
<span class="n">av_frame_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">frame</span><span class="p">);</span>
<span class="n">av_packet_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packet</span><span class="p">);</span>

<span class="n">avcodec_close</span><span class="p">(</span><span class="n">codec_ctx</span><span class="p">);</span>
<span class="n">avcodec_free_context</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec_ctx</span><span class="p">);</span>

<span class="n">avformat_close_input</span><span class="p">(</span><span class="o">&amp;</span><span class="n">av_format_context</span><span class="p">);</span>
<span class="n">avformat_free_context</span><span class="p">(</span><span class="n">av_format_context</span><span class="p">);</span>
<span class="n">ANativeWindow_release</span><span class="p">(</span><span class="n">native_window_</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="23-simple-application">2.3 Simple application</h3>
<p>In order to better understand the process of video decoding, a video decoder <code>VideoDecoder</code> is encapsulated here, and the decoder will initially have the following functions.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">VideoDecoder</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">path</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="kt">long</span> <span class="n">timestamp</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">on_decode_frame</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">Prepare</span><span class="p">(</span><span class="n">ANativeWindow</span><span class="o">*</span> <span class="n">window</span><span class="p">);</span>

<span class="kt">bool</span> <span class="nf">DecodeFrame</span><span class="p">(</span><span class="kt">long</span> <span class="n">time_ms</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">Release</span><span class="p">();</span>
</code></pre></td></tr></table>
</div>
</div><p>In this video decoder, the decoded frame data will be returned after the specified timestamp is input. The more important one is the DecodeFrame(long time_ms) function, which can be called by the user to pass in the timestamp of the specified frame and then decode the corresponding frame data. In addition, a synchronization lock can be added to separate the decoding thread from the using thread.</p>
<h4 id="231-adding-synchronization-lock-to-realize-video-playback">2.3.1 Adding synchronization lock to realize video playback</h4>
<p>If the video is only to be decoded, there is no need to use synchronous waiting.</p>
<p>However, if the video is to be played, a lock is needed to wait for each decoded and drawn frame, because the video needs to be decoded and drawn separately and in a certain timeline order and speed.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">condition_.wait<span class="o">(</span>lock<span class="o">)</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>Wake up the synchronization lock when the upper layer calls the <code>DecodeFrame</code> function to pass in the decoded timestamp and let the decoded drawing loop continue to execute.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">bool</span> <span class="n">VideoDecoder</span><span class="o">::</span><span class="n">DecodeFrame</span><span class="p">(</span><span class="kt">long</span> <span class="n">time_ms</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ······
</span><span class="c1"></span>    <span class="n">time_ms_</span> <span class="o">=</span> <span class="n">time_ms</span><span class="p">;</span>
    <span class="n">condition_</span><span class="p">.</span><span class="n">notify_all</span><span class="p">();</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="232-add-seek_frame-during-playback">2.3.2 Add seek_frame during playback</h4>
<p>Under normal playback, the video is decoded and played frame by frame; however, if the progress bar is dragged to the specified seek point, it may not be very efficient if the video is still decoded to the seek point frame by frame from the beginning to the end. At this time, we need to check the timestamp of seek point within certain rules, and seek to the specified timestamp directly if the condition is met.</p>
<h5 id="av_seek_frame-in-ffmpeg">av_seek_frame in FFmpeg</h5>
<ul>
<li>
<p><code>av_seek_frame</code> can locate keyframes and non-keyframes, depending on the selected <code>flag</code> value. Since the decoding of video depends on keyframes, we generally need to locate keyframes; the</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">av_seek_frame</span><span class="p">(</span><span class="n">AVFormatContext</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">stream_index</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">timestamp</span><span class="p">,</span>
                <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>The <code>flag</code> in <code>av_seek_frame</code> is used to specify the relationship between the sought I-frame and the incoming timestamp. When seeking a timestamp that has already passed, the timestamp will not necessarily be at the exact location of the I-frame, but since decoding depends on the I-frame, an I-frame near this timestamp needs to be found first, where <code>flag</code> indicates whether to seek to an I-frame before or after the current timestamp.</p>
</li>
<li>
<p><code>flag</code> has four options.</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>flag option</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>AVSEEK_FLAG_BACKWARD</td>
<td>The first Flag is the nearest keyframe before seek to the requested timestamp. Normally, seek is in ms units, and if the specified ms timestamp is not a keyframe (most likely), it will automatically seek back to the nearest keyframe. Although this flag positioning is not very precise, it is a good way to deal with the mosaic problem, because the BACKWARD approach will seek back to the keyframe and locate the keyframe.</td>
</tr>
<tr>
<td>AVSEEK_FLAG_BYTE</td>
<td>The second flag is to seek to the corresponding position (in bytes) in the file, exactly the same as AVSEEK_FLAG_FRAME, but with a different search algorithm.</td>
</tr>
<tr>
<td>AVSEEK_FLAG_ANY</td>
<td>The third Flag is to seek to any frame, not necessarily a keyframe, so it may appear as a mosaic, but the progress is exactly the same as hand-sliding.</td>
</tr>
<tr>
<td>AVSEEK_FLAG_FRAME</td>
<td>The fourth Flag is the timestamp of seek corresponding to the frame number, which can be interpreted as going backward to find the nearest keyframe, the opposite direction of BACKWARD.</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p><code>flag</code> may contain more than one of these values at the same time. For example <code>AVSEEK_FLAG_BACKWARD | AVSEEK_FLAG_BYTE</code>.</p>
</li>
<li>
<p><code>FRAME</code> and <code>BACKWARD</code> are to project the target position of seek by the interval between frames, which is suitable for fast forward and fast reverse; <code>BYTE</code> is suitable for large slide.</p>
</li>
</ul>
<h5 id="scenarios-for--seek">Scenarios for  seek</h5>
<ul>
<li>
<p>If the timestamp passed in when decoding is in the forward direction and is a certain distance beyond the previous frame, then seek is required, the &ldquo;certain distance&rdquo; here is estimated through several experiments, not always the 1000ms used in the following code.</p>
</li>
<li>
<p>if the direction is backward and less than the last decoding timestamp, but the distance from the last decoding timestamp is larger (e.g. more than 50ms), seek to the last keyframe.</p>
</li>
<li>
<p>The bool variable <code>is_seeking_</code> is used to prevent other operations from interfering with the current seeking operation, in order to control that only one seek operation is currently in progress.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_seeking_</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">time_ms_</span> <span class="o">&gt;</span> <span class="n">last_decode_time_ms_</span> <span class="o">+</span> <span class="mi">1000</span> <span class="o">||</span>
                    <span class="n">time_ms_</span> <span class="o">&lt;</span> <span class="n">last_decode_time_ms_</span> <span class="o">-</span> <span class="mi">50</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">is_seeking_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="c1">// seek 时传入的是指定帧带有 time_base 的时间戳，因此要用 times_ms 进行推算
</span><span class="c1"></span>    <span class="n">LOGD</span><span class="p">(</span><span class="n">TAG</span><span class="p">,</span> <span class="s">&#34;seek frame time_ms_ = %ld， last_decode_time_ms_ = %ld&#34;</span><span class="p">,</span> <span class="n">time_ms_</span><span class="p">,</span>
        <span class="n">last_decode_time_ms_</span><span class="p">);</span>
    <span class="n">av_seek_frame</span><span class="p">(</span><span class="n">av_format_context</span><span class="p">,</span>
                <span class="n">video_stream_index</span><span class="p">,</span>
                <span class="n">time_ms_</span> <span class="o">*</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">time_base</span><span class="p">.</span><span class="n">den</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">,</span>
                <span class="n">AVSEEK_FLAG_BACKWARD</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h5 id="insert-seek-logic">insert seek logic</h5>
<p>Since we have to check if seek before decoding, we have to insert the logic of seek before the <code>av_read_frame</code> function (which returns the next frame of the video media stream), use <code>av_seek_frame</code> to reach the specified I-frame when the seek condition is met, and then continue decoding to the destination timestamp position after <code>av_read_frame</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp">
<span class="c1">// 是否进行 seek 的逻辑写在这
</span><span class="c1">// 接下来是读取视频流的下一帧
</span><span class="c1"></span><span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">av_read_frame</span><span class="p">(</span><span class="n">av_format_context</span><span class="p">,</span> <span class="n">packet</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="24-details-of-the-decoding-process">2.4 Details of the decoding process</h3>
<h4 id="241-conditions-for-seek-during-decodeframe">2.4.1 Conditions for seek during DecodeFrame</h4>
<p>When using the <code>av_seek_frame</code> function, you need to specify the correct <code>flag</code> and also agree on the conditions for the seek operation, otherwise the video may appear as a splash screen (mosaic).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_seeking_</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">time_ms_</span> <span class="o">&gt;</span> <span class="n">last_decode_time_ms_</span> <span class="o">+</span> <span class="mi">1000</span> <span class="o">||</span>
                     <span class="n">time_ms_</span> <span class="o">&lt;</span> <span class="n">last_decode_time_ms_</span> <span class="o">-</span> <span class="mi">50</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">is_seeking_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">av_seek_frame</span><span class="p">(</span><span class="err">···</span><span class="p">,</span><span class="err">···</span><span class="p">,</span><span class="err">···</span><span class="p">,</span><span class="n">AVSEEK_FLAG_BACKWARD</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="242-reducing-the-number-of-decodes">2.4.2 Reducing the number of decodes</h4>
<p>When decoding video, there are conditions under which it is possible to decode frame data without passing in a timestamp. For example.</p>
<ol>
<li>
<p>the current decoding timestamp does not need to be decoded if it is in the forward direction and is the same as the previous decoding timestamp or the same as the timestamp currently being decoded.</p>
</li>
<li>
<p>if the current decoding timestamp is not greater than the previous decoding timestamp and the distance between it and the previous decoding timestamp is small (e.g. not more than 50ms), decoding is not required.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">bool</span> <span class="n">VideoDecoder</span><span class="o">::</span><span class="n">DecodeFrame</span><span class="p">(</span><span class="kt">long</span> <span class="n">time_ms</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">LOGD</span><span class="p">(</span><span class="n">TAG</span><span class="p">,</span> <span class="s">&#34;DecodeFrame time_ms = %ld&#34;</span><span class="p">,</span> <span class="n">time_ms</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">last_decode_time_ms_</span> <span class="o">==</span> <span class="n">time_ms</span> <span class="o">||</span> <span class="n">time_ms_</span> <span class="o">==</span> <span class="n">time_ms</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">LOGD</span><span class="p">(</span><span class="n">TAG</span><span class="p">,</span> <span class="s">&#34;DecodeFrame last_decode_time_ms_ == time_ms&#34;</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">time_ms</span> <span class="o">&lt;=</span> <span class="n">last_decode_time_ms_</span> <span class="o">&amp;&amp;</span>
        <span class="n">time_ms</span> <span class="o">+</span> <span class="mi">50</span> <span class="o">&gt;=</span> <span class="n">last_decode_time_ms_</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">time_ms_</span> <span class="o">=</span> <span class="n">time_ms</span><span class="p">;</span>
    <span class="n">condition_</span><span class="p">.</span><span class="n">notify_all</span><span class="p">();</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ol>
<p>With the above constraints, some unnecessary decoding operations will be reduced.</p>
<h4 id="243-using-pts-of-avframe">2.4.3 Using pts of AVFrame</h4>
<ol>
<li>
<p><code>AVPacket</code> stores the data before decoding (encoded data: H264/AAC, etc.), and saves the data after decapsulation and before decoding, which is still compressed data; <code>AVFrame</code> stores the data after decoding (pixel data: YUV/RGB/PCM, etc.).</p>
</li>
<li>
<p>There is a difference in the meaning of <code>pts</code> of <code>AVPacket</code> and <code>pts</code> of <code>AVFrame</code>. The former indicates when this decompressed packet is displayed, the latter indicates when the frame data is displayed.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// AVPacket 的 pts
</span><span class="c1"></span><span class="cm">/**
</span><span class="cm">    * Presentation timestamp in AVStream-&gt;time_base units; the time at which
</span><span class="cm">    * the decompressed packet will be presented to the user.
</span><span class="cm">    * Can be AV_NOPTS_VALUE if it is not stored in the file.
</span><span class="cm">    * pts MUST be larger or equal to dts as presentation cannot happen before
</span><span class="cm">    * decompression, unless one wants to view hex dumps. Some formats misuse
</span><span class="cm">    * the terms dts and pts/cts to mean something different. Such timestamps
</span><span class="cm">    * must be converted to true pts/dts before they are stored in AVPacket.
</span><span class="cm">    */</span>
<span class="kt">int64_t</span> <span class="n">pts</span><span class="p">;</span>

<span class="c1">// AVFrame 的 pts
</span><span class="c1"></span><span class="cm">/**
</span><span class="cm">    * Presentation timestamp in time_base units (time when frame should be shown to user).
</span><span class="cm">    */</span>
<span class="kt">int64_t</span> <span class="n">pts</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>Whether or not the currently decoded frame data is drawn to the screen depends on the result of comparing the incoming decoding timestamp with the timestamp of the decoded frame returned by the current decoder. <code>pts</code> of <code>AVPacket</code> may not be used here, it is probably not an incremental timestamp.</p>
</li>
<li>
<p>frame drawing is required provided that the specified decoding timestamp passed in is not greater than the converted timestamp of the pts of the currently decoded frame.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="n">decode_time_ms</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">pts</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">/</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">time_base</span><span class="p">.</span><span class="n">den</span><span class="p">;</span>
<span class="n">LOGD</span><span class="p">(</span><span class="n">TAG</span><span class="p">,</span> <span class="s">&#34;decode_time_ms = %ld&#34;</span><span class="p">,</span> <span class="n">decode_time_ms</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">decode_time_ms</span> <span class="o">&gt;=</span> <span class="n">time_ms_</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">last_decode_time_ms_</span> <span class="o">=</span> <span class="n">decode_time_ms</span><span class="p">;</span>
    <span class="n">is_seeking</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="c1">// 画面绘制
</span><span class="c1"></span>    <span class="c1">// ····
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ol>
<h4 id="244-decoding-the-last-frame-when-the-video-has-no-more-data">2.4.4 Decoding the last frame when the video has no more data</h4>
<p>Use <code>av_read_frame(av_format_context, packet)</code> to return the next frame of the video media stream to <code>AVPacket</code>. If the function returns an int value of 0 it is <code>Success</code>, if it is less than 0 it is <code>Error</code> or <code>EOF</code>.</p>
<p>So if the value returned when playing video is less than 0, call the <code>avcodec_flush_buffers</code> function to reset the state of the decoder, flush the contents of the buffer, and then seek to the current incoming timestamp to finish the post-decoding callback and let the sync lock wait.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// 读取码流中的音频若干帧或者视频一帧，
</span><span class="c1">// 这里是读取视频一帧（完整的一帧），获取的是一帧视频的压缩数据，接下来才能对其进行解码
</span><span class="c1"></span><span class="n">ret</span> <span class="o">=</span> <span class="n">av_read_frame</span><span class="p">(</span><span class="n">av_format_context</span><span class="p">,</span> <span class="n">packet</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">avcodec_flush_buffers</span><span class="p">(</span><span class="n">codec_ctx</span><span class="p">);</span>
    <span class="n">av_seek_frame</span><span class="p">(</span><span class="n">av_format_context</span><span class="p">,</span> <span class="n">video_stream_index</span><span class="p">,</span>
                  <span class="n">time_ms_</span> <span class="o">*</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">time_base</span><span class="p">.</span><span class="n">den</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">AVSEEK_FLAG_BACKWARD</span><span class="p">);</span>
    <span class="n">LOGD</span><span class="p">(</span><span class="n">TAG</span><span class="p">,</span> <span class="s">&#34;ret &lt; 0, condition_.wait(lock)&#34;</span><span class="p">);</span>
    <span class="c1">// 防止解最后一帧时视频已经没有数据
</span><span class="c1"></span>    <span class="n">on_decode_frame_</span><span class="p">(</span><span class="n">last_decode_time_ms_</span><span class="p">);</span>
    <span class="n">condition_</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="25-wrapping-decoder-videodecoder-in-upper-layer">2.5 Wrapping decoder VideoDecoder in upper layer</h3>
<p>If you want to encapsulate a <code>VideoDecoder</code> in the upper layer, you just need to expose the interface of the C++ layer <code>VideoDecoder</code> in <code>native-lib.cpp</code>, and then the upper layer calls the C++ interface by JNI.</p>
<p>For example, if the upper layer wants to pass in the specified decoding timestamp for decoding, write a <code>deocodeFrame</code> method, and then pass the timestamp to the <code>nativeDecodeFrame</code> of the C++ layer for decoding, and the implementation of the <code>nativeDecodeFrame</code> method is written in <code>native-lib.cpp</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// FFmpegVideoDecoder.kt
</span><span class="c1"></span><span class="k">class</span> <span class="nf">FFmpegVideoDecoder</span><span class="p">(</span>
    <span class="nl">path</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span>
    <span class="n">val</span> <span class="nl">onDecodeFrame</span><span class="p">:</span> <span class="p">(</span><span class="nl">timestamp</span><span class="p">:</span> <span class="n">Long</span><span class="p">,</span> <span class="nl">texture</span><span class="p">:</span> <span class="n">SurfaceTexture</span><span class="p">,</span> <span class="nl">needRender</span><span class="p">:</span> <span class="n">Boolean</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Unit</span>
<span class="p">){</span>
    <span class="c1">// 抽第 timeMs 帧，根据 sync 是否同步等待
</span><span class="c1"></span>    <span class="n">fun</span> <span class="n">decodeFrame</span><span class="p">(</span><span class="nl">timeMS</span><span class="p">:</span> <span class="n">Long</span><span class="p">,</span> <span class="nl">sync</span><span class="p">:</span> <span class="n">Boolean</span> <span class="o">=</span> <span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 若当前不需要抽帧时不进行等待
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">nativeDecodeFrame</span><span class="p">(</span><span class="n">decoderPtr</span><span class="p">,</span> <span class="n">timeMS</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">sync</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// ······
</span><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// ······
</span><span class="c1"></span>        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="n">external</span> <span class="n">fun</span> <span class="n">nativeDecodeFrame</span><span class="p">(</span><span class="nl">decoder</span><span class="p">:</span> <span class="n">Long</span><span class="p">,</span> <span class="nl">timeMS</span><span class="p">:</span> <span class="n">Long</span><span class="p">)</span><span class="o">:</span> <span class="n">Boolean</span>

    <span class="n">companion</span> <span class="n">object</span> <span class="p">{</span>
        <span class="k">const</span> <span class="n">val</span> <span class="n">TAG</span> <span class="o">=</span> <span class="s">&#34;FFmpegVideoDecoder&#34;</span>

        <span class="n">init</span> <span class="p">{</span>
            <span class="n">System</span><span class="p">.</span><span class="n">loadLibrary</span><span class="p">(</span><span class="s">&#34;ffmmpeg&#34;</span><span class="p">)</span>

        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Then the interface <code>DecodeFrame</code> of the C++ layer <code>VideoDecoder</code> is called in <code>native-lib.cpp</code>, thus establishing the connection between the upper layer and the C++ base layer by means of JNI.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// native-lib.cpp
</span><span class="c1"></span><span class="k">extern</span> <span class="s">&#34;C&#34;</span>
<span class="n">JNIEXPORT</span> <span class="n">jboolean</span> <span class="n">JNICALL</span>
<span class="n">Java_com_example_decoder_video_FFmpegVideoDecoder_nativeDecodeFrame</span><span class="p">(</span><span class="n">JNIEnv</span><span class="o">*</span> <span class="n">env</span><span class="p">,</span>
                                                               <span class="n">jobject</span> <span class="n">thiz</span><span class="p">,</span>
                                                               <span class="n">jlong</span> <span class="n">decoder</span><span class="p">,</span>
                                                               <span class="n">jlong</span> <span class="n">time_ms</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">videoDecoder</span> <span class="o">=</span> <span class="p">(</span><span class="n">codec</span><span class="o">::</span><span class="n">VideoDecoder</span><span class="o">*</span><span class="p">)</span><span class="n">decoder</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">videoDecoder</span><span class="o">-&gt;</span><span class="n">DecodeFrame</span><span class="p">(</span><span class="n">time_ms</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="3-insights">3. Insights</h2>
<blockquote>
<p>Technical experience</p>
</blockquote>
<ul>
<li>
<p>FFmpeg is compiled and combined with Android to realize video decoding and playback, which is convenient.</p>
</li>
<li>
<p>Since the specific decoding process is implemented with C++ layer, it will be difficult to learn, so it is better to have some C++ foundation.</p>
</li>
</ul>
<h2 id="4-appendix">4. Appendix</h2>
<blockquote>
<p>C++ wrapped VideoDecoder</p>
</blockquote>
<ul>
<li>
<p><code>VideoDecoder.h</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-h" data-lang="h"><span class="cp">#include</span> <span class="cpf">&lt;jni.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;android/native_window.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;android/native_window_jni.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;time.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">extern</span> <span class="s">&#34;C&#34;</span> <span class="p">{</span>
<span class="cp">#include</span> <span class="cpf">&lt;libavformat/avformat.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;libavcodec/avcodec.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;libswresample/swresample.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;libswscale/swscale.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="p">}</span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cm">/*
</span><span class="cm">* VideoDecoder 可用于解码某个音视频文件（比如.mp4）中视频媒体流的数据。
</span><span class="cm">* Java 层传入指定文件的路径后，可以按一定 fps 循环传入指定的时间戳进行解码（抽帧），这一实现由 C++ 提供的 DecodeFrame 来完成。
</span><span class="cm">* 在每次解码结束时，将解码某一帧的时间戳回调给上层的解码器，以供其他操作使用。
</span><span class="cm">*/</span>
<span class="n">namespace</span> <span class="n">codec</span> <span class="p">{</span>
<span class="n">class</span> <span class="n">VideoDecoder</span> <span class="p">{</span>

<span class="nl">private</span><span class="p">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">path_</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">time_ms_</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">last_decode_time_ms_</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">is_seeking_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">ANativeWindow</span><span class="o">*</span> <span class="n">native_window_</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
    <span class="n">ANativeWindow_Buffer</span> <span class="n">window_buffer_</span><span class="p">{};</span><span class="err">、</span>
    <span class="c1">// 视频宽高属性
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">video_width_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">video_height_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">out_buffer_</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
    <span class="c1">// on_decode_frame 用于将抽取指定帧的时间戳回调给上层解码器，以供上层解码器进行其他操作。
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="kt">long</span> <span class="n">timestamp</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">on_decode_frame_</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">is_stop_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

    <span class="c1">// 会与在循环同步时用的锁 &#34;std::unique_lock&lt;std::mutex&gt;&#34; 配合使用
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">work_queue_mtx</span><span class="p">;</span>
    <span class="c1">// 真正在进行同步等待和唤醒的属性
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">condition_</span><span class="p">;</span>
    <span class="c1">// 解码器真正进行解码的函数
</span><span class="c1"></span>    <span class="kt">void</span> <span class="nf">Decode</span><span class="p">(</span><span class="n">AVCodecContext</span><span class="o">*</span> <span class="n">codec_ctx</span><span class="p">,</span> <span class="n">AVPacket</span><span class="o">*</span> <span class="n">pkt</span><span class="p">,</span> <span class="n">AVFrame</span><span class="o">*</span> <span class="n">frame</span><span class="p">,</span> <span class="n">AVStream</span><span class="o">*</span> <span class="n">stream</span><span class="p">,</span>
                <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;&amp;</span> <span class="n">lock</span><span class="p">,</span> <span class="n">SwsContext</span><span class="o">*</span> <span class="n">sws_context</span><span class="p">,</span> <span class="n">AVFrame</span><span class="o">*</span> <span class="n">pFrame</span><span class="p">);</span>

<span class="nl">public</span><span class="p">:</span>
    <span class="c1">// 新建解码器时要传入媒体文件路径和一个解码后的回调 on_decode_frame。
</span><span class="c1"></span>    <span class="n">VideoDecoder</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">path</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="kt">long</span> <span class="n">timestamp</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">on_decode_frame</span><span class="p">);</span>
    <span class="c1">// 在 JNI 层将上层传入的 Surface 包装后新建一个 ANativeWindow 传入，在后面解码后绘制帧数据时需要用到
</span><span class="c1"></span>    <span class="kt">void</span> <span class="nf">Prepare</span><span class="p">(</span><span class="n">ANativeWindow</span><span class="o">*</span> <span class="n">window</span><span class="p">);</span>
    <span class="c1">// 抽取指定时间戳的视频帧，可由上层调用
</span><span class="c1"></span>    <span class="kt">bool</span> <span class="nf">DecodeFrame</span><span class="p">(</span><span class="kt">long</span> <span class="n">time_ms</span><span class="p">);</span>
    <span class="c1">// 释放解码器资源
</span><span class="c1"></span>    <span class="kt">void</span> <span class="nf">Release</span><span class="p">();</span>
    <span class="c1">// 获取当前系统毫秒时间
</span><span class="c1"></span>    <span class="k">static</span> <span class="kt">int64_t</span> <span class="nf">GetCurrentMilliTime</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="p">};</span>

<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><code>VideoDecoder.cpp</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span><span class="lnt">222
</span><span class="lnt">223
</span><span class="lnt">224
</span><span class="lnt">225
</span><span class="lnt">226
</span><span class="lnt">227
</span><span class="lnt">228
</span><span class="lnt">229
</span><span class="lnt">230
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&#34;VideoDecoder.h&#34;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&#34;../log/Logger.h&#34;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">extern</span> <span class="s">&#34;C&#34;</span> <span class="p">{</span>
<span class="cp">#include</span> <span class="cpf">&lt;libavutil/imgutils.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="p">}</span>

<span class="cp">#define TAG &#34;VideoDecoder&#34;
</span><span class="cp"></span><span class="k">namespace</span> <span class="n">codec</span> <span class="p">{</span>

<span class="n">VideoDecoder</span><span class="o">::</span><span class="n">VideoDecoder</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">path</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="kt">long</span> <span class="n">timestamp</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">on_decode_frame</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">on_decode_frame_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">on_decode_frame</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">path_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">VideoDecoder</span><span class="o">::</span><span class="n">Decode</span><span class="p">(</span><span class="n">AVCodecContext</span><span class="o">*</span> <span class="n">codec_ctx</span><span class="p">,</span> <span class="n">AVPacket</span><span class="o">*</span> <span class="n">pkt</span><span class="p">,</span> <span class="n">AVFrame</span><span class="o">*</span> <span class="n">frame</span><span class="p">,</span> <span class="n">AVStream</span><span class="o">*</span> <span class="n">stream</span><span class="p">,</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;&amp;</span> <span class="n">lock</span><span class="p">,</span> <span class="n">SwsContext</span><span class="o">*</span> <span class="n">sws_context</span><span class="p">,</span>
                    <span class="n">AVFrame</span><span class="o">*</span> <span class="n">rgba_frame</span><span class="p">)</span> <span class="p">{</span>

    <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
    <span class="cm">/* send the packet with the compressed data to the decoder */</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">avcodec_send_packet</span><span class="p">(</span><span class="n">codec_ctx</span><span class="p">,</span> <span class="n">pkt</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">AVERROR</span><span class="p">(</span><span class="n">EAGAIN</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">LOGE</span><span class="p">(</span><span class="n">TAG</span><span class="p">,</span>
            <span class="s">&#34;Decode: Receive_frame and send_packet both returned EAGAIN, which is an API violation.&#34;</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// read all the output frames (infile general there may be any number of them
</span><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_stop_</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 对于frame, avcodec_receive_frame内部每次都先调用
</span><span class="c1"></span>        <span class="n">ret</span> <span class="o">=</span> <span class="n">avcodec_receive_frame</span><span class="p">(</span><span class="n">codec_ctx</span><span class="p">,</span> <span class="n">frame</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">AVERROR</span><span class="p">(</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="o">||</span> <span class="n">ret</span> <span class="o">==</span> <span class="n">AVERROR_EOF</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="kt">int64_t</span> <span class="n">startTime</span> <span class="o">=</span> <span class="n">GetCurrentMilliTime</span><span class="p">();</span>
        <span class="n">LOGD</span><span class="p">(</span><span class="n">TAG</span><span class="p">,</span> <span class="s">&#34;decodeStartTime: %ld&#34;</span><span class="p">,</span> <span class="n">startTime</span><span class="p">);</span>
        <span class="c1">// 换算当前解码的frame时间戳
</span><span class="c1"></span>        <span class="k">auto</span> <span class="n">decode_time_ms</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">pts</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">/</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">time_base</span><span class="p">.</span><span class="n">den</span><span class="p">;</span>
        <span class="n">LOGD</span><span class="p">(</span><span class="n">TAG</span><span class="p">,</span> <span class="s">&#34;decode_time_ms = %ld&#34;</span><span class="p">,</span> <span class="n">decode_time_ms</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">decode_time_ms</span> <span class="o">&gt;=</span> <span class="n">time_ms_</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">LOGD</span><span class="p">(</span><span class="n">TAG</span><span class="p">,</span> <span class="s">&#34;decode decode_time_ms = %ld, time_ms_ = %ld&#34;</span><span class="p">,</span> <span class="n">decode_time_ms</span><span class="p">,</span> <span class="n">time_ms_</span><span class="p">);</span>
            <span class="n">last_decode_time_ms_</span> <span class="o">=</span> <span class="n">decode_time_ms</span><span class="p">;</span>
            <span class="n">is_seeking_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

            <span class="c1">// 数据格式转换
</span><span class="c1"></span>            <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">sws_scale</span><span class="p">(</span>
                    <span class="n">sws_context</span><span class="p">,</span>
                    <span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="k">const</span><span class="o">*</span><span class="p">)</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">linesize</span><span class="p">,</span>
                    <span class="mi">0</span><span class="p">,</span> <span class="n">video_height_</span><span class="p">,</span>
                    <span class="n">rgba_frame</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">rgba_frame</span><span class="o">-&gt;</span><span class="n">linesize</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">LOGE</span><span class="p">(</span><span class="n">TAG</span><span class="p">,</span> <span class="s">&#34;Player Error : data convert fail&#34;</span><span class="p">);</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// 播放
</span><span class="c1"></span>            <span class="n">result</span> <span class="o">=</span> <span class="n">ANativeWindow_lock</span><span class="p">(</span><span class="n">native_window_</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">window_buffer_</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">LOGE</span><span class="p">(</span><span class="n">TAG</span><span class="p">,</span> <span class="s">&#34;Player Error : Can not lock native window&#34;</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="c1">// 将图像绘制到界面上
</span><span class="c1"></span>                <span class="k">auto</span> <span class="n">bits</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span> <span class="n">window_buffer_</span><span class="p">.</span><span class="n">bits</span><span class="p">;</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="n">video_height_</span><span class="p">;</span> <span class="n">h</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">memcpy</span><span class="p">(</span><span class="n">bits</span> <span class="o">+</span> <span class="n">h</span> <span class="o">*</span> <span class="n">window_buffer_</span><span class="p">.</span><span class="n">stride</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span>
                        <span class="n">out_buffer_</span> <span class="o">+</span> <span class="n">h</span> <span class="o">*</span> <span class="n">rgba_frame</span><span class="o">-&gt;</span><span class="n">linesize</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                        <span class="n">rgba_frame</span><span class="o">-&gt;</span><span class="n">linesize</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
                <span class="p">}</span>
                <span class="n">ANativeWindow_unlockAndPost</span><span class="p">(</span><span class="n">native_window_</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">on_decode_frame_</span><span class="p">(</span><span class="n">decode_time_ms</span><span class="p">);</span>
            <span class="kt">int64_t</span> <span class="n">endTime</span> <span class="o">=</span> <span class="n">GetCurrentMilliTime</span><span class="p">();</span>
            <span class="n">LOGD</span><span class="p">(</span><span class="n">TAG</span><span class="p">,</span> <span class="s">&#34;decodeEndTime - decodeStartTime: %ld&#34;</span><span class="p">,</span> <span class="n">endTime</span> <span class="o">-</span> <span class="n">startTime</span><span class="p">);</span>
            <span class="n">LOGD</span><span class="p">(</span><span class="n">TAG</span><span class="p">,</span> <span class="s">&#34;finish decode frame&#34;</span><span class="p">);</span>
            <span class="n">condition_</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">// 主要作用是清理AVPacket中的所有空间数据，清理完毕后进行初始化操作，并且将 data 与 size 置为0，方便下次调用。
</span><span class="c1"></span>        <span class="c1">// 释放 packet 引用
</span><span class="c1"></span>        <span class="n">av_packet_unref</span><span class="p">(</span><span class="n">pkt</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">VideoDecoder</span><span class="o">::</span><span class="n">Prepare</span><span class="p">(</span><span class="n">ANativeWindow</span><span class="o">*</span> <span class="n">window</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">native_window_</span> <span class="o">=</span> <span class="n">window</span><span class="p">;</span>
    <span class="n">av_register_all</span><span class="p">();</span>
    <span class="k">auto</span> <span class="n">av_format_context</span> <span class="o">=</span> <span class="n">avformat_alloc_context</span><span class="p">();</span>
    <span class="n">avformat_open_input</span><span class="p">(</span><span class="o">&amp;</span><span class="n">av_format_context</span><span class="p">,</span> <span class="n">path_</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="k">nullptr</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">);</span>
    <span class="n">avformat_find_stream_info</span><span class="p">(</span><span class="n">av_format_context</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">video_stream_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">av_format_context</span><span class="o">-&gt;</span><span class="n">nb_streams</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 找到视频媒体流的下标
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">av_format_context</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">codecpar</span><span class="o">-&gt;</span><span class="n">codec_type</span> <span class="o">==</span> <span class="n">AVMEDIA_TYPE_VIDEO</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">video_stream_index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="n">LOGD</span><span class="p">(</span><span class="n">TAG</span><span class="p">,</span> <span class="s">&#34;find video stream index = %d&#34;</span><span class="p">,</span> <span class="n">video_stream_index</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// run once
</span><span class="c1"></span>    <span class="k">do</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">video_stream_index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">codec</span><span class="o">::</span><span class="n">LOGE</span><span class="p">(</span><span class="n">TAG</span><span class="p">,</span> <span class="s">&#34;Player Error : Can not find video stream&#34;</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">work_queue_mtx</span><span class="p">);</span>

        <span class="c1">// 获取视频媒体流
</span><span class="c1"></span>        <span class="k">auto</span> <span class="n">stream</span> <span class="o">=</span> <span class="n">av_format_context</span><span class="o">-&gt;</span><span class="n">streams</span><span class="p">[</span><span class="n">video_stream_index</span><span class="p">];</span>
        <span class="c1">// 找到已注册的解码器
</span><span class="c1"></span>        <span class="k">auto</span> <span class="n">codec</span> <span class="o">=</span> <span class="n">avcodec_find_decoder</span><span class="p">(</span><span class="n">stream</span><span class="o">-&gt;</span><span class="n">codecpar</span><span class="o">-&gt;</span><span class="n">codec_id</span><span class="p">);</span>
        <span class="c1">// 获取解码器上下文
</span><span class="c1"></span>        <span class="n">AVCodecContext</span><span class="o">*</span> <span class="n">codec_ctx</span> <span class="o">=</span> <span class="n">avcodec_alloc_context3</span><span class="p">(</span><span class="n">codec</span><span class="p">);</span>
        <span class="k">auto</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">avcodec_parameters_to_context</span><span class="p">(</span><span class="n">codec_ctx</span><span class="p">,</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">codecpar</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 打开
</span><span class="c1"></span>            <span class="n">avcodec_open2</span><span class="p">(</span><span class="n">codec_ctx</span><span class="p">,</span> <span class="n">codec</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">);</span>
            <span class="c1">// 解码器打开后才有宽高的值
</span><span class="c1"></span>            <span class="n">video_width_</span> <span class="o">=</span> <span class="n">codec_ctx</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">;</span>
            <span class="n">video_height_</span> <span class="o">=</span> <span class="n">codec_ctx</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">;</span>

            <span class="n">AVFrame</span><span class="o">*</span> <span class="n">rgba_frame</span> <span class="o">=</span> <span class="n">av_frame_alloc</span><span class="p">();</span>
            <span class="kt">int</span> <span class="n">buffer_size</span> <span class="o">=</span> <span class="n">av_image_get_buffer_size</span><span class="p">(</span><span class="n">AV_PIX_FMT_RGBA</span><span class="p">,</span> <span class="n">video_width_</span><span class="p">,</span> <span class="n">video_height_</span><span class="p">,</span>
                                                    <span class="mi">1</span><span class="p">);</span>
            <span class="c1">// 分配内存空间给输出 buffer
</span><span class="c1"></span>            <span class="n">out_buffer_</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span> <span class="n">av_malloc</span><span class="p">(</span><span class="n">buffer_size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint8_t</span><span class="p">));</span>
            <span class="n">av_image_fill_arrays</span><span class="p">(</span><span class="n">rgba_frame</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">rgba_frame</span><span class="o">-&gt;</span><span class="n">linesize</span><span class="p">,</span> <span class="n">out_buffer_</span><span class="p">,</span>
                                <span class="n">AV_PIX_FMT_RGBA</span><span class="p">,</span>
                                <span class="n">video_width_</span><span class="p">,</span> <span class="n">video_height_</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

            <span class="c1">// 通过设置宽高限制缓冲区中的像素数量，而非屏幕的物理显示尺寸。
</span><span class="c1"></span>            <span class="c1">// 如果缓冲区与物理屏幕的显示尺寸不相符，则实际显示可能会是拉伸，或者被压缩的图像
</span><span class="c1"></span>            <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">ANativeWindow_setBuffersGeometry</span><span class="p">(</span><span class="n">native_window_</span><span class="p">,</span> <span class="n">video_width_</span><span class="p">,</span>
                                                        <span class="n">video_height_</span><span class="p">,</span> <span class="n">WINDOW_FORMAT_RGBA_8888</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">LOGE</span><span class="p">(</span><span class="n">TAG</span><span class="p">,</span> <span class="s">&#34;Player Error : Can not set native window buffer&#34;</span><span class="p">);</span>
                <span class="n">avcodec_close</span><span class="p">(</span><span class="n">codec_ctx</span><span class="p">);</span>
                <span class="n">avcodec_free_context</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec_ctx</span><span class="p">);</span>
                <span class="n">av_free</span><span class="p">(</span><span class="n">out_buffer_</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">auto</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">av_frame_alloc</span><span class="p">();</span>
            <span class="k">auto</span> <span class="n">packet</span> <span class="o">=</span> <span class="n">av_packet_alloc</span><span class="p">();</span>

            <span class="k">struct</span> <span class="nc">SwsContext</span><span class="o">*</span> <span class="n">data_convert_context</span> <span class="o">=</span> <span class="n">sws_getContext</span><span class="p">(</span>
                    <span class="n">video_width_</span><span class="p">,</span> <span class="n">video_height_</span><span class="p">,</span> <span class="n">codec_ctx</span><span class="o">-&gt;</span><span class="n">pix_fmt</span><span class="p">,</span>
                    <span class="n">video_width_</span><span class="p">,</span> <span class="n">video_height_</span><span class="p">,</span> <span class="n">AV_PIX_FMT_RGBA</span><span class="p">,</span>
                    <span class="n">SWS_BICUBIC</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">);</span>
            <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">is_stop_</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">LOGD</span><span class="p">(</span><span class="n">TAG</span><span class="p">,</span> <span class="s">&#34;front seek time_ms_ = %ld, last_decode_time_ms_ = %ld&#34;</span><span class="p">,</span> <span class="n">time_ms_</span><span class="p">,</span>
                    <span class="n">last_decode_time_ms_</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_seeking_</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">time_ms_</span> <span class="o">&gt;</span> <span class="n">last_decode_time_ms_</span> <span class="o">+</span> <span class="mi">1000</span> <span class="o">||</span>
                                    <span class="n">time_ms_</span> <span class="o">&lt;</span> <span class="n">last_decode_time_ms_</span> <span class="o">-</span> <span class="mi">50</span><span class="p">))</span> <span class="p">{</span>
                    <span class="n">is_seeking_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                    <span class="n">LOGD</span><span class="p">(</span><span class="n">TAG</span><span class="p">,</span> <span class="s">&#34;seek frame time_ms_ = %ld， last_decode_time_ms_ = %ld&#34;</span><span class="p">,</span> <span class="n">time_ms_</span><span class="p">,</span>
                        <span class="n">last_decode_time_ms_</span><span class="p">);</span>
                    <span class="c1">// 传进去的是指定帧带有 time_base 的时间戳，所以是要将原来的 times_ms 按照上面获取时的计算方式反推算出时间戳
</span><span class="c1"></span>                    <span class="n">av_seek_frame</span><span class="p">(</span><span class="n">av_format_context</span><span class="p">,</span> <span class="n">video_stream_index</span><span class="p">,</span>
                                <span class="n">time_ms_</span> <span class="o">*</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">time_base</span><span class="p">.</span><span class="n">den</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">AVSEEK_FLAG_BACKWARD</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="c1">// 读取视频一帧（完整的一帧），获取的是一帧视频的压缩数据，接下来才能对其进行解码
</span><span class="c1"></span>                <span class="n">ret</span> <span class="o">=</span> <span class="n">av_read_frame</span><span class="p">(</span><span class="n">av_format_context</span><span class="p">,</span> <span class="n">packet</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">avcodec_flush_buffers</span><span class="p">(</span><span class="n">codec_ctx</span><span class="p">);</span>
                    <span class="n">av_seek_frame</span><span class="p">(</span><span class="n">av_format_context</span><span class="p">,</span> <span class="n">video_stream_index</span><span class="p">,</span>
                                <span class="n">time_ms_</span> <span class="o">*</span> <span class="n">stream</span><span class="o">-&gt;</span><span class="n">time_base</span><span class="p">.</span><span class="n">den</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">AVSEEK_FLAG_BACKWARD</span><span class="p">);</span>
                    <span class="n">LOGD</span><span class="p">(</span><span class="n">TAG</span><span class="p">,</span> <span class="s">&#34;ret &lt; 0, condition_.wait(lock)&#34;</span><span class="p">);</span>
                    <span class="c1">// 防止解码最后一帧时视频已经没有数据
</span><span class="c1"></span>                    <span class="n">on_decode_frame_</span><span class="p">(</span><span class="n">last_decode_time_ms_</span><span class="p">);</span>
                    <span class="n">condition_</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">Decode</span><span class="p">(</span><span class="n">codec_ctx</span><span class="p">,</span> <span class="n">packet</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">lock</span><span class="p">,</span> <span class="n">data_convert_context</span><span class="p">,</span>
                        <span class="n">rgba_frame</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="c1">// 释放资源
</span><span class="c1"></span>            <span class="n">sws_freeContext</span><span class="p">(</span><span class="n">data_convert_context</span><span class="p">);</span>
            <span class="n">av_free</span><span class="p">(</span><span class="n">out_buffer_</span><span class="p">);</span>
            <span class="n">av_frame_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rgba_frame</span><span class="p">);</span>
            <span class="n">av_frame_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">frame</span><span class="p">);</span>
            <span class="n">av_packet_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packet</span><span class="p">);</span>

        <span class="p">}</span>
        <span class="n">avcodec_close</span><span class="p">(</span><span class="n">codec_ctx</span><span class="p">);</span>
        <span class="n">avcodec_free_context</span><span class="p">(</span><span class="o">&amp;</span><span class="n">codec_ctx</span><span class="p">);</span>

    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="nb">false</span><span class="p">);</span>
    <span class="n">avformat_close_input</span><span class="p">(</span><span class="o">&amp;</span><span class="n">av_format_context</span><span class="p">);</span>
    <span class="n">avformat_free_context</span><span class="p">(</span><span class="n">av_format_context</span><span class="p">);</span>
    <span class="n">ANativeWindow_release</span><span class="p">(</span><span class="n">native_window_</span><span class="p">);</span>
    <span class="k">delete</span> <span class="k">this</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">VideoDecoder</span><span class="o">::</span><span class="n">DecodeFrame</span><span class="p">(</span><span class="kt">long</span> <span class="n">time_ms</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">LOGD</span><span class="p">(</span><span class="n">TAG</span><span class="p">,</span> <span class="s">&#34;DecodeFrame time_ms = %ld&#34;</span><span class="p">,</span> <span class="n">time_ms</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">last_decode_time_ms_</span> <span class="o">==</span> <span class="n">time_ms</span> <span class="o">||</span> <span class="n">time_ms_</span> <span class="o">==</span> <span class="n">time_ms</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">LOGD</span><span class="p">(</span><span class="n">TAG</span><span class="p">,</span> <span class="s">&#34;DecodeFrame last_decode_time_ms_ == time_ms&#34;</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">last_decode_time_ms_</span> <span class="o">&gt;=</span> <span class="n">time_ms</span> <span class="o">&amp;&amp;</span> <span class="n">last_decode_time_ms_</span> <span class="o">&lt;=</span> <span class="n">time_ms</span> <span class="o">+</span> <span class="mi">50</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">time_ms_</span> <span class="o">=</span> <span class="n">time_ms</span><span class="p">;</span>
    <span class="n">condition_</span><span class="p">.</span><span class="n">notify_all</span><span class="p">();</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">VideoDecoder</span><span class="o">::</span><span class="n">Release</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">is_stop_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">condition_</span><span class="p">.</span><span class="n">notify_all</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**
</span><span class="cm">* 获取当前的毫秒级时间
</span><span class="cm">*/</span>
<span class="kt">int64_t</span> <span class="n">VideoDecoder</span><span class="o">::</span><span class="n">GetCurrentMilliTime</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">timeval</span> <span class="n">tv</span><span class="p">{};</span>
    <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tv</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">tv</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">*</span> <span class="mf">1000.0</span> <span class="o">+</span> <span class="n">tv</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">/</span> <span class="mf">1000.0</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ul>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/android/">android</a>
          <a href="/tags/ffmpeg/">ffmpeg</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-03/go-ctx-best-practice/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Go Context Best Practices</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-03/jib-docker/">
            <span class="next-text nav-default">Jib builds Docker images efficiently</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
