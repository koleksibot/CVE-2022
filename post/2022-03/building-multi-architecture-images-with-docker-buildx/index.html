<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>How to use docker buildx to build multi-architecture Go images - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Running applications on different operating systems and processor architectures is a common scenario, so it is a common practice to build separate distributions for different platforms. This is not easy to achieve when the platform we use to develop the application is different from the target platform for deployment. For example, developing an application on an x86 architecture and deploying it to a machine on an ARM platform usually requires preparing the ARM platform infrastructure for development and compilation." /><meta name="keywords" content="Docker Buildx, Multi Architecture, image, golang" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-03/building-multi-architecture-images-with-docker-buildx/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="How to use docker buildx to build multi-architecture Go images" />
<meta property="og:description" content="Running applications on different operating systems and processor architectures is a common scenario, so it is a common practice to build separate distributions for different platforms. This is not easy to achieve when the platform we use to develop the application is different from the target platform for deployment. For example, developing an application on an x86 architecture and deploying it to a machine on an ARM platform usually requires preparing the ARM platform infrastructure for development and compilation." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-03/building-multi-architecture-images-with-docker-buildx/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-03-03T10:49:37+08:00" />
<meta property="article:modified_time" content="2022-03-03T10:49:37+08:00" />

<meta itemprop="name" content="How to use docker buildx to build multi-architecture Go images">
<meta itemprop="description" content="Running applications on different operating systems and processor architectures is a common scenario, so it is a common practice to build separate distributions for different platforms. This is not easy to achieve when the platform we use to develop the application is different from the target platform for deployment. For example, developing an application on an x86 architecture and deploying it to a machine on an ARM platform usually requires preparing the ARM platform infrastructure for development and compilation."><meta itemprop="datePublished" content="2022-03-03T10:49:37+08:00" />
<meta itemprop="dateModified" content="2022-03-03T10:49:37+08:00" />
<meta itemprop="wordCount" content="2592">
<meta itemprop="keywords" content="golang,docker," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="How to use docker buildx to build multi-architecture Go images"/>
<meta name="twitter:description" content="Running applications on different operating systems and processor architectures is a common scenario, so it is a common practice to build separate distributions for different platforms. This is not easy to achieve when the platform we use to develop the application is different from the target platform for deployment. For example, developing an application on an x86 architecture and deploying it to a machine on an ARM platform usually requires preparing the ARM platform infrastructure for development and compilation."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">How to use docker buildx to build multi-architecture Go images</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-03-03 10:49:37 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 2592 words </span>
          <span class="more-meta"> 13 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#prerequisites">Prerequisites</a></li>
        <li><a href="#docker-buildx">docker buildx</a>
          <ul>
            <li><a href="#enabling-buildx">Enabling Buildx</a></li>
            <li><a href="#builder-instances">builder instances</a></li>
            <li><a href="#build-drivers">Build drivers</a></li>
          </ul>
        </li>
        <li><a href="#build-multiple-architectures-at-once-go-image-practice">Build multiple architectures at once Go image practice</a>
          <ul>
            <li><a href="#source-code-and-dockerfile">Source code and Dockerfile</a></li>
            <li><a href="#executing-a-cross-platform-build">Executing a cross-platform build</a></li>
            <li><a href="#validate-the-build-results">Validate the build results</a></li>
          </ul>
        </li>
        <li><a href="#how-to-cross-compile-golangs-cgo-projects">How to cross-compile Golang&rsquo;s CGO projects</a>
          <ul>
            <li><a href="#preparing-the-cross-compilation-environment-and-dependencies">Preparing the cross-compilation environment and dependencies</a></li>
            <li><a href="#cross-compiling-cgo-examples">Cross-compiling CGO examples</a></li>
          </ul>
        </li>
        <li><a href="#summary">Summary</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>Running applications on different operating systems and processor architectures is a common scenario, so it is a common practice to build separate distributions for different platforms. This is not easy to achieve when the platform we use to develop the application is different from the target platform for deployment. For example, developing an application on an x86 architecture and deploying it to a machine on an ARM platform usually requires preparing the ARM platform infrastructure for development and compilation.</p>
<p>Distributing images for multiple deployments in a single build dramatically improves the efficiency of application delivery, and for scenarios where applications need to be deployed across platforms, building images across platforms with docker buildx is a fast and efficient solution.</p>
<h2 id="prerequisites">Prerequisites</h2>
<p>Most mirror hosting platforms support multi-platform mirrors, which means that a single tag in a mirror repository can contain multiple mirrors from different platforms. Take the <code>python</code> image repository of <code>docker hub</code> for example, the <code>3.9.6</code> tag contains 10 images for different systems and architectures (platform = system + architecture).</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/03/bb554f45360d404a80fa68243035259e.png" alt="docker hub"></p>
<p>When pulling an image with cross-platform support via <code>docker pull</code> or <code>docker run</code>, <code>docker</code> will automatically select the image that matches the current running platform. Thanks to this feature, when distributing mirrors cross-platform, we don&rsquo;t need to do anything about the consumption of the mirrors, we only need to care about the production of the mirrors, i.e. how to build cross-platform mirrors.</p>
<h2 id="docker-buildx">docker buildx</h2>
<p>The default <code>docker build</code> command cannot do cross-platform build tasks, we need to extend its functionality by installing the <code>buildx</code> plugin for the <code>docker</code> command line. <code>buildx</code> can use the additional features of build images provided by <a href="https://github.com/moby/buildkit">Moby BuildKit</a> to create multiple builder instances, perform build tasks in parallel on multiple nodes, and build across platforms.</p>
<h3 id="enabling-buildx">Enabling Buildx</h3>
<p>Docker Desktop for macOS or Windows, and <code>docker</code> for Linux distributions installed via the <code>deb</code> or <code>rpm</code> packages have <code>buildx</code> built in and do not need to be installed separately.</p>
<p>If your <code>docker</code> does not have the <code>buildx</code> command, you can download the binary package to install it.</p>
<ol>
<li>First, find the binary for your platform from the release page of the <a href="https://github.com/docker/buildx/releases/latest">Docker buildx</a> project.</li>
<li>Download the binaries locally and rename them to <code>docker-buildx</code> and move them to docker&rsquo;s plugins directory <code>~/.docker/cli-plugins</code>.</li>
<li>Grant executable permissions to the binaries.</li>
</ol>
<p>If the local <code>docker</code> version is higher than 19.03, it is easier to build and install it directly locally with the following command.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">$ <span class="nb">export</span> <span class="nv">DOCKER_BUILDKIT</span><span class="o">=</span><span class="m">1</span>
$ docker build --platform<span class="o">=</span><span class="nb">local</span> -o . git://github.com/docker/buildx
$ mkdir -p ~/.docker/cli-plugins
$ mv buildx ~/.docker/cli-plugins/docker-buildx
</code></pre></td></tr></table>
</div>
</div><p>Building with <code>buildx</code> is done as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">docker buildx build .
</code></pre></td></tr></table>
</div>
</div><p><code>buildx</code> and <code>docker build</code> commands are basically the same experience, and also support <code>build</code> common options such as <code>-t</code>, <code>-f</code>, etc.</p>
<h3 id="builder-instances">builder instances</h3>
<p><code>docker buildx</code> manages the build configuration and nodes through the builder instance object. The command line sends the build task to the builder instance, which in turn assigns it to a qualified node for execution. We can create multiple builder instances based on the same <code>docker</code> service application and make them available to different projects to isolate the configuration of each project, or create a builder instance for a set of remote <code>docker</code> nodes to form a build array and quickly switch between arrays.</p>
<p>A builder instance can be created using the <code>docker buildx create</code> command, which will create a new builder instance for the node with the currently used docker service. To use a remote node, you can specify the remote port with the <code>DOCKER_HOST</code> environment variable when creating the example or switch to the remote node&rsquo;s <code>docker context</code> in advance. The following creates a new builder instance with a remote node and specifies its driver, target platform, and instance name via command line options.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">$ <span class="nb">export</span> <span class="nv">DOCKER_HOST</span><span class="o">=</span>tcp://10.10.150.66:2375
$ docker buildx create --driver docker-container --platform linux/amd64,linux/arm64 --name remote-builder
remote-builder
</code></pre></td></tr></table>
</div>
</div><p><code>docker buildx ls</code> will list all available builder instances and the nodes in the instance.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">$ docker buildx ls
NAME/NODE         DRIVER/ENDPOINT         STATUS   PLATFORMS
remote-builder    docker-container                 
  remote-builder0 tcp://10.10.150.66:2375 inactive linux/amd64*, linux/arm64*
default *         docker                           
  default         default                 running  linux/amd64, linux/386
</code></pre></td></tr></table>
</div>
</div><p>After an instance is created, you can continue to add new nodes to it by using the <code>-append &lt;node&gt;</code> option of the <code>docker buildx create</code> command to add nodes to the builder instance specified by the <code>-name &lt;builder&gt;</code> option.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">$ docker buildx create --name default --append remote-builder0
</code></pre></td></tr></table>
</div>
</div><p>The <code>docker buildx inspect</code>, <code>docker buildx stop</code> and <code>docker buildx rm</code> commands are used to manage the lifecycle of an instance.</p>
<p><code>docker buildx use &lt;builder&gt;</code> will switch to the specified builder instance.</p>
<h3 id="build-drivers">Build drivers</h3>
<p>The buildx instance performs build tasks in two ways, the two execution methods are referred to as using different <code>drivers</code>.</p>
<ul>
<li><code>docker</code> driver: executes builds using the BuildKit library integrated in the Docker service application.</li>
<li><code>docker-container</code> driver: starts a container containing BuildKit and executes the build in the container.</li>
</ul>
<p>The <code>docker</code> driver cannot use a small number of <code>buildx</code> features (such as building multiple platform images at the same time in a single run), and there is also a difference in the default output format of the images: the <code>docker</code> driver outputs the build results directly to the <code>docker</code> image directory (usually <code>/var/lib/ overlay2</code>), and the output images can be listed by executing the <code>docker images</code> command, while <code>docker container</code> requires the <code>--output</code> option to specify the output format as a mirror or other format.</p>
<p>In order to build images for multiple platforms at once, we will use the <code>docker container</code>-driven builder instance below.</p>
<p>Cross-platform build strategies for ## buildx</p>
<p>Depending on the build node and target language, <code>buildx</code> supports the following three cross-platform build strategies.</p>
<ol>
<li>create a lightweight virtual machine via QEMU&rsquo;s user-state mode and build the image in the virtual machine system.</li>
<li>add multiple nodes of different target platforms to a builder instance and build the corresponding platform image from the native nodes.</li>
<li>build and cross-compile to different target architectures in phases.</li>
</ol>
<p>While QEMU is typically used to emulate a full operating system, it can also run in user state mode: register a binary conversion handler with <code>binfmt_misc</code> on the host system and dynamically translate the binary file at runtime, converting system calls from the target CPU architecture to the current system&rsquo;s CPU architecture as needed. The end result is like running the target CPU architecture&rsquo;s binaries in a virtual machine. qemu support is built into Docker Desktop, and other platforms that meet the requirements to run it can be installed in the following way.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">$ docker run --privileged --rm tonistiigi/binfmt --install all
</code></pre></td></tr></table>
</div>
</div><p>This approach does not require any changes to the existing Dockerfile and is cheap to implement, but obviously not very efficient.</p>
<p>Adding native nodes from different system architectures to the builder instance can bring better support for cross-platform compilation and is more efficient, but requires sufficient infrastructure support.</p>
<p>If the build project uses a programming language that supports cross-compilation (e.g. C and Go), you can take advantage of the staged build feature provided by Dockerfile: first compile the binaries of the target architecture in the same architecture as the build node, and then copy these binaries to another image of the target architecture. A concrete example is implemented below using Go. This approach does not require additional hardware and yields better performance, but is only possible with specific programming languages.</p>
<h2 id="build-multiple-architectures-at-once-go-image-practice">Build multiple architectures at once Go image practice</h2>
<h3 id="source-code-and-dockerfile">Source code and Dockerfile</h3>
<p>The following will be a simple Go project as an example, assuming that the sample program file <code>main.go</code> reads as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;runtime&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Hello world!&#34;</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Running in [%s] architecture.\n&#34;</span><span class="p">,</span> <span class="nx">runtime</span><span class="p">.</span><span class="nx">GOARCH</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The Dockerfile that defines the build process is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="k">FROM</span><span class="s"> --platform=$BUILDPLATFORM golang:1.14 as builder</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="k">ARG</span> TARGETARCH<span class="err">
</span><span class="err">
</span><span class="err"></span><span class="k">WORKDIR</span><span class="s"> /app</span><span class="err">
</span><span class="err"></span><span class="k">COPY</span> main.go /app/main.go<span class="err">
</span><span class="err"></span><span class="k">RUN</span> <span class="nv">GOOS</span><span class="o">=</span>linux <span class="nv">GOARCH</span><span class="o">=</span><span class="nv">$TARGETARCH</span> go build -a -o output/main main.go<span class="err">
</span><span class="err">
</span><span class="err"></span><span class="k">FROM</span><span class="s"> alpine:latest</span><span class="err">
</span><span class="err"></span><span class="k">WORKDIR</span><span class="s"> /root</span><span class="err">
</span><span class="err"></span><span class="k">COPY</span> --from<span class="o">=</span>builder /app/output/main .<span class="err">
</span><span class="err"></span><span class="k">CMD</span> /root/main<span class="err">
</span></code></pre></td></tr></table>
</div>
</div><p>The build process is divided into two phases.</p>
<ul>
<li>In one phase, we pull a <code>golang</code> image for the same platform as the current build node and compile it into a binary for the target architecture using Go&rsquo;s cross-compilation features.</li>
<li>Then pull the <code>alpine</code> image for the target platform and copy the compilation results from the previous phase into the image.</li>
</ul>
<h3 id="executing-a-cross-platform-build">Executing a cross-platform build</h3>
<p>When executing the build command, in addition to specifying the image name, the other two important options are to specify the target platform and the output format.</p>
<p>The <code>-docker buildx build</code> specifies the target platform for the build via the <code>-platform</code> option, and the FROM command in Dockerfile without the <code>-platform</code> flag will pull the base image with the target platform, and the resulting image will belong to the target platform. In addition, the value of this option can be used in Dockerfile with the <code>BUILDPLATFORM</code>, <code>TARGETPLATFORM</code>, <code>BUILDARCH</code> and <code>TARGETARCH</code> parameters. When using the <code>docker-container</code> driver, this option accepts multiple comma-separated values as input to specify multiple target platforms at the same time, and the build results for all platforms are combined into a single list of images as output, so they cannot be directly output as local <code>docker images</code> images.</p>
<p><code>docker buildx build</code> supports rich output behavior. The <code>--output=[PATH,-,type=TYPE[,KEY=VALUE]</code> option allows you to specify the output type and path of the build result.</p>
<ul>
<li>local: the build result will be written to the local path specified by <code>dest</code> in file system format, such as <code>--output type=local,dest=. /output</code>.</li>
<li>tar: the build result will be written to the local path specified by <code>dest</code> after packing.</li>
<li>oci: The build result is written to the local path specified by <code>dest</code> in OCI standard image format.</li>
<li>docker: The build result is written to the local path specified by <code>dest</code> in Docker standard image format or loaded into <code>docker</code>&rsquo;s image repository. This option is not available when multiple target platforms are specified at the same time.</li>
<li>image: Export as an image or list of images, and support the <code>push=true</code> option to push directly to a remote repository, which can be used when specifying multiple target platforms.</li>
<li>registry: a compact representation of <code>type=image,push=true</code>.</li>
</ul>
<p>For this example, we execute the following <code>docker buildx build</code> command.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">$ docker buildx build --platform linux/amd64,linux/arm64,linux/arm -t registry.cn-hangzhou.aliyuncs.com/waynerv/arch-demo -o <span class="nv">type</span><span class="o">=</span>registry .
</code></pre></td></tr></table>
</div>
</div><p>This command will build <code>linux/amd64</code>, <code>linux/arm64</code> and <code>linux/arm</code> images in the current directory and push the output directly to the remote Aliyun image repository.</p>
<p>The build process can be broken down as follows.</p>
<ol>
<li><code>docker</code> transfers the build context to the builder instance. 2.</li>
<li>builder builds images for each target platform specified by the <code>-platform</code> option on the command line, including pulling the base image and performing the build steps. 3.</li>
<li>export the build results, and the image file layer is pushed to the remote repository. 4.</li>
<li>Generate a manifest JSON file and push it to the remote repository as a mirror tag.</li>
</ol>
<h3 id="validate-the-build-results">Validate the build results</h3>
<p>After running you can probe the images that have been pushed to the remote repository with <code>docker buildx imagetools</code> at the end of the run.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">$ docker buildx imagetools inspect registry.cn-hangzhou.aliyuncs.com/waynerv/arch-demo:latest
Name:      registry.cn-hangzhou.aliyuncs.com/waynerv/arch-demo:latest
MediaType: application/vnd.docker.distribution.manifest.list.v2+json
Digest:    sha256:e2c3c5b330c19ac9d09f8aaccc40224f8673e12b88ff59cb68971c36b76e95ca
           
Manifests: 
  Name:      registry.cn-hangzhou.aliyuncs.com/waynerv/arch-demo:latest@sha256:cb6a7614ee3db03c8858e3680b1585f32a6fe3de9b371e37e25cf42a83f6e0ba
  MediaType: application/vnd.docker.distribution.manifest.v2+json
  Platform:  linux/amd64
             
  Name:      registry.cn-hangzhou.aliyuncs.com/waynerv/arch-demo:latest@sha256:034aa0077a452a6c2585f8b4969c7c85d5d2bf65f801fcc803a00d0879ce900e
  MediaType: application/vnd.docker.distribution.manifest.v2+json
  Platform:  linux/arm64
             
  Name:      registry.cn-hangzhou.aliyuncs.com/waynerv/arch-demo:latest@sha256:db0ee3a876fb789d2e733471385eef0a056f64ee12d9e7ef94e411469d054eb5
  MediaType: application/vnd.docker.distribution.manifest.v2+json
  Platform:  linux/arm/v7
</code></pre></td></tr></table>
</div>
</div><p>Finally, pull and run images on different platforms with the <code>latest</code> tag to verify that the build is correct. When using Docker Desktop, its own integrated virtualization feature allows you to run images from different platforms and pull images directly with <code>sha256</code> values.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">$ docker run --rm registry.cn-hangzhou.aliyuncs.com/waynerv/arch-demo:latest@sha256:cb6a7614ee3db03c8858e3680b1585f32a6fe3de9b371e37e25cf42a83f6e0ba
Hello world!
Running in <span class="o">[</span>amd64<span class="o">]</span> architecture.
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">$ docker run --rm registry.cn-hangzhou.aliyuncs.com/waynerv/arch-demo:latest@sha256:034aa0077a452a6c2585f8b4969c7c85d5d2bf65f801fcc803a00d0879ce900e
Hello world!
Running in <span class="o">[</span>arm64<span class="o">]</span> architecture.
</code></pre></td></tr></table>
</div>
</div><h2 id="how-to-cross-compile-golangs-cgo-projects">How to cross-compile Golang&rsquo;s CGO projects</h2>
<p>Support for cross-compiling to common operating systems and CPU architectures is one of the great advantages of Golang, but the solution in the above example only works with pure Go code, and the situation becomes more complicated if the project calls C code via <code>cgo</code>.</p>
<h3 id="preparing-the-cross-compilation-environment-and-dependencies">Preparing the cross-compilation environment and dependencies</h3>
<p>In order to compile C code to the target platform smoothly, you need to install the C cross-compiler (usually based on <code>gcc</code>) for the target platform in the compilation environment.</p>
<p>Next, you need to install the C standard libraries for the target platform (usually the standard libraries are installed as dependencies of the cross-compiler and do not need to be installed separately), and depending on the dependencies of the C code you are calling, you may need to install some additional C dependencies (e.g. <code>libopus-dev</code> or something like that).</p>
<p>We will use the official <code>golang:1.14</code> image for the <code>amd64</code> architecture as the base image for compilation, and the Linux distribution is Debian. assuming the target platform for cross-compilation is <code>linux/arm64</code>, the cross-compiler to be prepared is <code>gcc-aarch64-linux-gnu</code> and the C standard library is <code>libc6-dev-arm64-cross</code>, and the installer is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">$ apt-get update
$ apt-get install gcc-aarch64-linux-gnu
</code></pre></td></tr></table>
</div>
</div><p><code>libc6-dev-arm64-cross</code> will be installed at the same time.</p>
<p>Thanks to the multi-architecture installation capabilities provided by the Debian package manager <code>dpkg</code>, if our code relies on non-standard libraries such as <code>libopus-dev</code>, we can install their <code>arm64</code> architecture installers via <code>&lt;library&gt;:&lt;architecture&gt;</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">$ dpkg --add-architecture arm64
$ apt-get update
$ apt-get install -y libopus-dev:arm64
</code></pre></td></tr></table>
</div>
</div><h3 id="cross-compiling-cgo-examples">Cross-compiling CGO examples</h3>
<p>Suppose the following sample code for <code>cgo</code> is available.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="cm">/*
</span><span class="cm">#include &lt;stdlib.h&gt;
</span><span class="cm">*/</span>
<span class="kn">import</span> <span class="s">&#34;C&#34;</span>
<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">Random</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nx">C</span><span class="p">.</span><span class="nf">random</span><span class="p">())</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Seed</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">C</span><span class="p">.</span><span class="nf">srandom</span><span class="p">(</span><span class="nx">C</span><span class="p">.</span><span class="nb">uint</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span>  <span class="p">{</span>
    <span class="nx">rand</span> <span class="o">:=</span> <span class="nf">Random</span><span class="p">()</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Hello %d\n&#34;</span><span class="p">,</span> <span class="nx">rand</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The Dockerfile that will be used is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">FROM</span> <span class="o">--</span><span class="nx">platform</span><span class="p">=</span><span class="err">$</span><span class="nx">BUILDPLATFORM</span> <span class="nx">golang</span><span class="p">:</span><span class="mf">1.14</span> <span class="nx">as</span> <span class="nx">builder</span>

<span class="nx">ARG</span> <span class="nx">TARGETARCH</span>
<span class="nx">RUN</span> <span class="nx">apt</span><span class="o">-</span><span class="nx">get</span> <span class="nx">update</span> <span class="o">&amp;&amp;</span> <span class="nx">apt</span><span class="o">-</span><span class="nx">get</span> <span class="nx">install</span> <span class="o">-</span><span class="nx">y</span> <span class="nx">gcc</span><span class="o">-</span><span class="nx">aarch64</span><span class="o">-</span><span class="nx">linux</span><span class="o">-</span><span class="nx">gnu</span>

<span class="nx">WORKDIR</span> <span class="o">/</span><span class="nx">app</span>
<span class="nx">COPY</span> <span class="p">.</span> <span class="o">/</span><span class="nx">app</span><span class="o">/</span>

<span class="nx">RUN</span> <span class="k">if</span> <span class="p">[</span> <span class="s">&#34;$TARGETARCH&#34;</span> <span class="p">=</span> <span class="s">&#34;arm64&#34;</span> <span class="p">];</span> <span class="nx">then</span> <span class="nx">CC</span><span class="p">=</span><span class="nx">aarch64</span><span class="o">-</span><span class="nx">linux</span><span class="o">-</span><span class="nx">gnu</span><span class="o">-</span><span class="nx">gcc</span> <span class="o">&amp;&amp;</span> <span class="nx">CC_FOR_TARGET</span><span class="p">=</span><span class="nx">gcc</span><span class="o">-</span><span class="nx">aarch64</span><span class="o">-</span><span class="nx">linux</span><span class="o">-</span><span class="nx">gnu</span><span class="p">;</span> <span class="nx">fi</span> <span class="o">&amp;&amp;</span> \
  <span class="nx">CGO_ENABLED</span><span class="p">=</span><span class="mi">1</span> <span class="nx">GOOS</span><span class="p">=</span><span class="nx">linux</span> <span class="nx">GOARCH</span><span class="p">=</span><span class="err">$</span><span class="nx">TARGETARCH</span> <span class="nx">CC</span><span class="p">=</span><span class="err">$</span><span class="nx">CC</span> <span class="nx">CC_FOR_TARGET</span><span class="p">=</span><span class="err">$</span><span class="nx">CC_FOR_TARGET</span> <span class="k">go</span> <span class="nx">build</span> <span class="o">-</span><span class="nx">a</span> <span class="o">-</span><span class="nx">ldflags</span> <span class="err">&#39;</span><span class="o">-</span><span class="nx">extldflags</span> <span class="s">&#34;-static&#34;</span><span class="err">&#39;</span> <span class="o">-</span><span class="nx">o</span> <span class="o">/</span><span class="nx">main</span> <span class="nx">main</span><span class="p">.</span><span class="k">go</span>
</code></pre></td></tr></table>
</div>
</div><p>Dockerfile installs <code>gcc-aarch64-linux-gnu</code> as a cross-compiler via <code>apt-get</code>, and the example program is simple so no additional dependencies are needed. When running <code>go build</code> for compilation, you need to specify the cross-compiler to use via the <code>CC</code> and <code>CC_FOR_TARGET</code> environment variables.</p>
<p>In order to perform multiple builds on the same Dockerfile (assuming the target architecture is only <code>amd64</code> / <code>arm64</code>), the <code>RUN</code> command at the bottom uses a trick to execute different build commands via Bash&rsquo;s conditional syntax.</p>
<ul>
<li>If the target platform of the build task is <code>arm64</code>, specify <code>CC</code> and <code>CC_FOR_TARGET</code> environment variables as installed cross-compilers (note that their values are different).</li>
<li>If the target platform for the build task is <code>amd64</code>, no cross-compiler-related variables are specified, and the default <code>gcc</code> is used as the compiler.</li>
</ul>
<p>The final command to execute the build using buildx is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">$ docker buildx build --platform linux/amd64,linux/arm64 -t registry.cn-hangzhou.aliyuncs.com/waynerv/cgo-demo -o <span class="nv">type</span><span class="o">=</span>registry .
</code></pre></td></tr></table>
</div>
</div><h2 id="summary">Summary</h2>
<p>With the help of the <code>Buildx</code> plugin, we can use <code>docker</code> to easily build cross-platform application images in the absence of infrastructure.</p>
<p>However, the default way of virtualizing target platform instructions via QEMU has a significant performance bottleneck, and if the language used to write the application supports cross-compilation, we can achieve higher efficiency by combining <code>buildx</code> with cross-compilation.</p>
<p>This article concludes with a solution for an advanced scenario: how to cross-compile a Golang project that uses CGO, and gives an example of compiling to the <code>linux/arm64</code> platform.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/golang/">golang</a>
          <a href="/tags/docker/">docker</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-03/git-cherry-pick-intro/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">A deeper understanding of the git cherry-pick operation</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-03/git-rebase-intro/">
            <span class="next-text nav-default">Git rebase Usage Details and How it Works</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
