<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Go classical blocking TCP protocol stream parsing in practice - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="This article describes the parsing of the Go classical blocking TCP protocol." /><meta name="keywords" content="golang, blocking, tcp" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-03/go-block-tcp-parse/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Go classical blocking TCP protocol stream parsing in practice" />
<meta property="og:description" content="This article describes the parsing of the Go classical blocking TCP protocol." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-03/go-block-tcp-parse/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-03-27T09:48:26+08:00" />
<meta property="article:modified_time" content="2022-03-27T09:48:26+08:00" />

<meta itemprop="name" content="Go classical blocking TCP protocol stream parsing in practice">
<meta itemprop="description" content="This article describes the parsing of the Go classical blocking TCP protocol."><meta itemprop="datePublished" content="2022-03-27T09:48:26+08:00" />
<meta itemprop="dateModified" content="2022-03-27T09:48:26+08:00" />
<meta itemprop="wordCount" content="4004">
<meta itemprop="keywords" content="golang," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go classical blocking TCP protocol stream parsing in practice"/>
<meta name="twitter:description" content="This article describes the parsing of the Go classical blocking TCP protocol."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Go classical blocking TCP protocol stream parsing in practice</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-03-27 09:48:26 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 4004 words </span>
          <span class="more-meta"> 8 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#1-gos-tcp-network-programming-model-for-classical-blocking-io">1. Go&rsquo;s TCP network programming model for classical blocking I/O</a></li>
        <li><a href="#2-brief-description-of-the-custom-protocol">2. Brief description of the custom protocol</a></li>
        <li><a href="#3-create-frame-and-packet-abstractions">3. Create Frame and Packet abstractions</a></li>
        <li><a href="#4-basic-program-structure-for-blocking-tcp-stream-protocol-parsing">4. Basic program structure for blocking TCP stream protocol parsing</a></li>
        <li><a href="#5-possible-optimization-points">5. Possible optimization points</a></li>
        <li><a href="#6-simple-stress-test">6. simple stress test</a></li>
        <li><a href="#7-summary">7. Summary</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="1-gos-tcp-network-programming-model-for-classical-blocking-io">1. Go&rsquo;s TCP network programming model for classical blocking I/O</h2>
<p>The Go language has made rapid development over the past decade or so since its birth and has been widely accepted and used by developers around the world for a wide range of applications, including: Web services, databases, network programming, system programming, DevOps, security detection and control, data science, and artificial intelligence. The following are some of the results of the official Go 2020 developer survey.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/27/f06df59f8ed74ecabfb43c8fa9cad9de.png" alt="some of the results of the official Go 2020 developer survey"></p>
<p>We see <strong>&ldquo;Web Programming&rdquo;</strong> and <strong>&ldquo;Network Programming&rdquo;</strong> in first and fourth place respectively, an application area data distribution that fits well with the Go language&rsquo;s original design goals for large-scale distributed web services. <strong>Network communication</strong> This piece is an essential and critical part of server-side programming. net package of the Go standard library is the basis for network programming in Go. Even if you don&rsquo;t use the functions/methods or interfaces of the net package for TCP sockets directly, you have always used the net/http package, which implements HTTP, the application layer protocol, and still uses TCP sockets at the transport layer.</p>
<p>Go is a cross-platform programming language with its own runtime. Due to the need of Go runtime scheduling, Go designs and implements its own TCP socket network programming model based on <strong>I/O multiplexing</strong> mechanism (epoll on linux, kqueue on macOS and freebsd). And, in keeping with its design philosophy of simplicity, Go exposes a simple TCP socket API interface to language users, leaving the &ldquo;complexity&rdquo; of Go TCP socket network programming to itself and hiding it in the Go runtime implementation. This way, in most cases, Go developers do not need to care about whether the socket is blocking or not, nor do they need to register the socket file descriptor callback function into a system call like epoll themselves, but simply do it in the simplest and easiest to use <strong>&ldquo;blocking I/O model&rdquo;</strong> in the corresponding goroutine for each connection. &ldquo;Socket operations are performed in the simplest and easiest to use <strong>&ldquo;blocking I/O model&rdquo;</strong> in the goroutine corresponding to each connection (as shown in the figure below), a design that greatly reduces the mental burden on web application developers.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/27/3c2b8fc1afb046308c73383cc1534dac.png" alt="go blocking I/O model"></p>
<p>This is the classic Go tcp network programming model. Since TCP is a full-duplex model, each end (peer) can read and write separately on the established connection, so in Go we often create two goroutines for an established TCP connection, one for reading data from the connection (or the read goroutine can reply directly if a response (ack) is needed), and one for writing newly generated business data to the connection. one is responsible for writing the newly generated business data to the connection.</p>
<p>As an example, a typical program structure of a <strong>read goroutine</strong> is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">handleConn</span><span class="p">(</span><span class="nx">c</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="c1">// read from the connection c
</span><span class="c1"></span>        <span class="o">...</span> <span class="o">...</span>
        <span class="c1">// write ack to the connection c
</span><span class="c1"></span>        <span class="o">...</span> <span class="o">...</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">l</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Listen</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;:8888&#34;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;listen error:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">{</span>
        <span class="nx">c</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nf">Accept</span><span class="p">()</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;accept error:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
            <span class="k">break</span>
        <span class="p">}</span>
        <span class="c1">// start a new goroutine to handle
</span><span class="c1"></span>        <span class="c1">// the new connection.
</span><span class="c1"></span>        <span class="k">go</span> <span class="nf">handleConn</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="c1">// start a read goroutine
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>From the above code, we see that for each successful connection established to the server, the program will start a reader goroutine responsible for reading data from the connection, and after processing, return (write to the connection) response (ack). The structure of this program is so straightforward that it can&rsquo;t be any more straightforward. Even if you are a novice network programmer, it will not take many brain cells to understand such a program.</p>
<p>As we know, TCP Transmission Control Protocol is a connection-oriented, reliable, byte-stream-based transport layer communication protocol, so TCP socket programming is mostly stream data (streaming) processing. This data is characterized by sequential byte-by-byte transfers with no obvious data boundaries at the transport layer (only the application layer can identify protocol data boundaries, which depends on the definition of the application layer protocol). 1000 bytes are sent by the TCP sender and 1000 bytes are received by the TCP receiver. The sender may send the 1000 bytes in one send operation, but the receiver may read the 1000 bytes in 10 read operations, i.e. <strong>there is no strict one-to-one correspondence between the send action on the sender side and the receive action on the receiver side</strong> . This is fundamentally different from the datagram-based data transfer form of the UDP protocol (more on the differences between tcp and udp can be found in the book &ldquo;TCP/IP Volume 1: Protocols&rdquo;).</p>
<p>In this article we will look at the basic model for parsing custom TCP stream-based protocols based on the classic Go blocking network I/O model.</p>
<h2 id="2-brief-description-of-the-custom-protocol">2. Brief description of the custom protocol</h2>
<p>To facilitate the subsequent content development, we now describe here the custom stream protocol we are about to parse. There are two common modes of definition for TCP-based custom application layer flow protocols.</p>
<ul>
<li>Binary mode</li>
</ul>
<p>Using length field separation, common ones include: mqtt (one of the most commonly used application layer protocols for IoT), cmpp (China Mobile Internet SMS gateway interface protocol), etc.</p>
<ul>
<li>Text mode</li>
</ul>
<p>Use specific separators to segment and identify, common ones include http, etc.</p>
<p>Here we use binary mode to define the application layer protocols we are about to parse, and the following protocols are defined.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/27/1e8c978bcae04d838359952a3ddecefa.png" alt="tcp protocols"></p>
<p>This is a request-response protocol. The first field of both the request and reply packets is the total packet length, which is the most important field used at the application layer to &ldquo;split the packet&rdquo;. The second field is used to identify the packet type, and here we define four types.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt">onst (
    CommandConn   = iota + 0x01 // 0x01，连接请求包
    CommandSubmit               // 0x02，消息发送请求包
)

const (
    CommandConnAck   = iota + 0x80 // 0x81，连接请求的响应包
    CommandSubmitAck               //0x82，消息发送请求的响应包
)
</code></pre></td></tr></table>
</div>
</div><p>The ID is the flow of messages requested on each connection and is mostly used by the request sender to subsequently match the response packet. The only difference between the request packet and the response packet is the last field, the request packet defines the payload (payload), while the response packet defines the response status field of the request packet (result).</p>
<p>Once the definition of the application layer protocol packet is clear, let&rsquo;s see how to parse such a stream protocol.</p>
<h2 id="3-create-frame-and-packet-abstractions">3. Create Frame and Packet abstractions</h2>
<p>Before we actually start writing the code, let&rsquo;s establish two abstractions for the above application layer protocols: Frame and Packet.</p>
<p>First, we set up the data flow from client to server or server to client, which is composed of one Frame after another, and the above protocols are encapsulated in these individual Frames. We can separate Frame from Frame by a specific method.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/27/50864f1af08140cebbb5a4d01d0a7cbe.png" alt="Create Frame and Packet abstractions"></p>
<p>Each Frame consists of a totalLength and frame payload, as shown in the following left Frame structure.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/27/0177c7813d50400b91177745d6fb27ee.png" alt="Frame structure"></p>
<p>In this way, we can isolate the Frames from each other by using Frame header: totalLength. We define a Frame payload as a packet, and the structure of each packet is shown in the right side of the figure above. Each packet contains the commandID, ID and payload (packet payload) fields.</p>
<p>This way we convert the above protocol into a TCP stream consisting of two abstractions, Frame and Packet.</p>
<h2 id="4-basic-program-structure-for-blocking-tcp-stream-protocol-parsing">4. Basic program structure for blocking TCP stream protocol parsing</h2>
<p>After creating the abstraction, we need to start parsing the protocol! The following diagram shows the server flow diagram for parsing the blocking TCP stream protocol.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/27/c1a2ded70c3a4d9fa3c5c3f25de01de2.png" alt="TCP stream protocol"></p>
<p>We see that the tcp stream data is successively decoded by frame decode and packet decode to get the packet data required by the application layer, and the response from the application layer is successively written to the tcp response stream after encoding by packet and encoding by frame.</p>
<p>Let&rsquo;s take a look at the code of frame encoding and decoding. We first define the interface type of frame encoder.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// github.com/bigwhite/experiments/tree/master/tcp-stream-proto/demo1/pkg/frame/frame.go
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">FramePayload</span> <span class="p">[]</span><span class="kt">byte</span>

<span class="kd">type</span> <span class="nx">StreamFrameCodec</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">Encode</span><span class="p">(</span><span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">FramePayload</span><span class="p">)</span> <span class="kt">error</span>   <span class="c1">// data -&gt; frame，并写入io.Writer
</span><span class="c1"></span>    <span class="nf">Decode</span><span class="p">(</span><span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span> <span class="p">(</span><span class="nx">FramePayload</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="c1">// 从io.Reader中提取frame payload，并返回给上层
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>We define the input of the stream data as io.Reader and the output of the stream data as io.Writer. As in the design sense in the above diagram, the Decode method returns the framePayload and Encode encodes the input framePayload into a frame and writes it to the outbound tcp stream.</p>
<p>Once the set of interface methods is defined, let&rsquo;s give an implementation of the StreamFrameCodec interface.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// github.com/bigwhite/experiments/tree/master/tcp-stream-proto/demo1/pkg/frame/frame.go
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">myFrameCodec</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="nf">NewMyFrameCodec</span><span class="p">()</span> <span class="nx">StreamFrameCodec</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">myFrameCodec</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">myFrameCodec</span><span class="p">)</span> <span class="nf">Encode</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">framePayload</span> <span class="nx">FramePayload</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">f</span> <span class="p">=</span> <span class="nx">framePayload</span>
    <span class="kd">var</span> <span class="nx">totalLen</span> <span class="kt">int32</span> <span class="p">=</span> <span class="nb">int32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">framePayload</span><span class="p">))</span> <span class="o">+</span> <span class="mi">4</span>

    <span class="nx">err</span> <span class="o">:=</span> <span class="nx">binary</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">binary</span><span class="p">.</span><span class="nx">BigEndian</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">totalLen</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>

    <span class="c1">// make sure all data will be written to outbound stream
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">{</span>
        <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">f</span><span class="p">))</span> <span class="c1">// write the frame payload to outbound stream
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">err</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nx">n</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">break</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">f</span> <span class="p">=</span> <span class="nx">f</span><span class="p">[</span><span class="nx">n</span><span class="p">:]</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">myFrameCodec</span><span class="p">)</span> <span class="nf">Decode</span><span class="p">(</span><span class="nx">r</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span> <span class="p">(</span><span class="nx">FramePayload</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">totalLen</span> <span class="kt">int32</span>
    <span class="nx">err</span> <span class="o">:=</span> <span class="nx">binary</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="nx">binary</span><span class="p">.</span><span class="nx">BigEndian</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">totalLen</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
    <span class="p">}</span>

    <span class="nx">buf</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">totalLen</span><span class="o">-</span><span class="mi">4</span><span class="p">)</span>
    <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">io</span><span class="p">.</span><span class="nf">ReadFull</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="nx">buf</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nf">FramePayload</span><span class="p">(</span><span class="nx">buf</span><span class="p">),</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>In the above in this implementation, there are three points to note.</p>
<ul>
<li>
<p>the network byte order uses BigEndian, so either Encode or Decode, we are using binary.</p>
</li>
<li>
<p>binary.Read or Write will read or write bytes corresponding to the number of bytes according to the width of the parameter, here totalLen uses int32, then Read or Write will only operate on 4 bytes in the stream.</p>
</li>
<li>
<p>ReadFull will generally read the full number of bytes you need, unless it encounters EOF or ErrUnexpectedEOF.</p>
</li>
</ul>
<p>Next, let&rsquo;s look at Packet codecs. Unlike Frame, Packet has multiple types (only Conn, submit, connack, submit ack are defined here). So let&rsquo;s first abstract the common interface that these types need to follow.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// github.com/bigwhite/experiments/tree/master/tcp-stream-proto/demo1/pkg/packet/packet.go
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">Packet</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">Decode</span><span class="p">([]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">error</span>     <span class="c1">// []byte -&gt; struct
</span><span class="c1"></span>    <span class="nf">Encode</span><span class="p">()</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="c1">//  struct -&gt; []byte
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Decode is to decode a byte stream data into a Packet type, which may be conn, submit, etc. (judged by the decoded commandID). Encode is to encode a Packet type into a byte stream data. The following is the Packet interface implementation for submit and submitack types.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// github.com/bigwhite/experiments/tree/master/tcp-stream-proto/demo1/pkg/packet/packet.go
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">Submit</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">ID</span>      <span class="kt">string</span>
    <span class="nx">Payload</span> <span class="p">[]</span><span class="kt">byte</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Submit</span><span class="p">)</span> <span class="nf">Decode</span><span class="p">(</span><span class="nx">pktBody</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">s</span><span class="p">.</span><span class="nx">ID</span> <span class="p">=</span> <span class="nb">string</span><span class="p">(</span><span class="nx">pktBody</span><span class="p">[:</span><span class="mi">8</span><span class="p">])</span>
    <span class="nx">s</span><span class="p">.</span><span class="nx">Payload</span> <span class="p">=</span> <span class="nx">pktBody</span><span class="p">[</span><span class="mi">8</span><span class="p">:]</span>
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Submit</span><span class="p">)</span> <span class="nf">Encode</span><span class="p">()</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">bytes</span><span class="p">.</span><span class="nf">Join</span><span class="p">([][]</span><span class="kt">byte</span><span class="p">{[]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">ID</span><span class="p">[:</span><span class="mi">8</span><span class="p">]),</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Payload</span><span class="p">},</span> <span class="kc">nil</span><span class="p">),</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">SubmitAck</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">ID</span>     <span class="kt">string</span>
    <span class="nx">Result</span> <span class="kt">uint8</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">SubmitAck</span><span class="p">)</span> <span class="nf">Decode</span><span class="p">(</span><span class="nx">pktBody</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">s</span><span class="p">.</span><span class="nx">ID</span> <span class="p">=</span> <span class="nb">string</span><span class="p">(</span><span class="nx">pktBody</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">8</span><span class="p">])</span>
    <span class="nx">s</span><span class="p">.</span><span class="nx">Result</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">pktBody</span><span class="p">[</span><span class="mi">8</span><span class="p">])</span>
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">SubmitAck</span><span class="p">)</span> <span class="nf">Encode</span><span class="p">()</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">bytes</span><span class="p">.</span><span class="nf">Join</span><span class="p">([][]</span><span class="kt">byte</span><span class="p">{[]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">ID</span><span class="p">[:</span><span class="mi">8</span><span class="p">]),</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">{</span><span class="nx">s</span><span class="p">.</span><span class="nx">Result</span><span class="p">}},</span> <span class="kc">nil</span><span class="p">),</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>However, the various types of codecs mentioned above are called only if it is clear what type the data stream is, so we need to provide an external function Decode at the package level, which is responsible for resolving the corresponding type from the byte stream (based on the commandID) and calling the Decode method of the corresponding type.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// github.com/bigwhite/experiments/tree/master/tcp-stream-proto/demo1/pkg/packet/packet.go
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Decode</span><span class="p">(</span><span class="nx">packet</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">Packet</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
 <span class="nx">commandID</span> <span class="o">:=</span> <span class="nx">packet</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
 <span class="nx">pktBody</span> <span class="o">:=</span> <span class="nx">packet</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

 <span class="k">switch</span> <span class="nx">commandID</span> <span class="p">{</span>
 <span class="k">case</span> <span class="nx">CommandConn</span><span class="p">:</span>
  <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span>
 <span class="k">case</span> <span class="nx">CommandConnAck</span><span class="p">:</span>
  <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span>
 <span class="k">case</span> <span class="nx">CommandSubmit</span><span class="p">:</span>
  <span class="nx">s</span> <span class="o">:=</span> <span class="nx">Submit</span><span class="p">{}</span>
  <span class="nx">err</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Decode</span><span class="p">(</span><span class="nx">pktBody</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
   <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="nx">s</span><span class="p">,</span> <span class="kc">nil</span>
 <span class="k">case</span> <span class="nx">CommandSubmitAck</span><span class="p">:</span>
  <span class="nx">s</span> <span class="o">:=</span> <span class="nx">SubmitAck</span><span class="p">{}</span>
  <span class="nx">err</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Decode</span><span class="p">(</span><span class="nx">pktBody</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
   <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="nx">s</span><span class="p">,</span> <span class="kc">nil</span>
 <span class="k">default</span><span class="p">:</span>
  <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;unknown commandID [%d]&#34;</span><span class="p">,</span> <span class="nx">commandID</span><span class="p">)</span>
 <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Similarly, we need packet-level Encode functions to call the corresponding Encode method to encode the object according to the incoming packet type.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// github.com/bigwhite/experiments/tree/master/tcp-stream-proto/demo1/pkg/packet/packet.go
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Encode</span><span class="p">(</span><span class="nx">p</span> <span class="nx">Packet</span><span class="p">)</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
 <span class="kd">var</span> <span class="nx">commandID</span> <span class="kt">uint8</span>
 <span class="kd">var</span> <span class="nx">pktBody</span> <span class="p">[]</span><span class="kt">byte</span>
 <span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>

 <span class="k">switch</span> <span class="nx">t</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
 <span class="k">case</span> <span class="o">*</span><span class="nx">Submit</span><span class="p">:</span>
  <span class="nx">commandID</span> <span class="p">=</span> <span class="nx">CommandSubmit</span>
  <span class="nx">pktBody</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">Encode</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
   <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
  <span class="p">}</span>
 <span class="k">case</span> <span class="o">*</span><span class="nx">SubmitAck</span><span class="p">:</span>
  <span class="nx">commandID</span> <span class="p">=</span> <span class="nx">CommandSubmitAck</span>
  <span class="nx">pktBody</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">Encode</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
   <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
  <span class="p">}</span>
 <span class="k">default</span><span class="p">:</span>
  <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;unknown type [%s]&#34;</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>
 <span class="p">}</span>
 <span class="k">return</span> <span class="nx">bytes</span><span class="p">.</span><span class="nf">Join</span><span class="p">([][]</span><span class="kt">byte</span><span class="p">{[]</span><span class="kt">byte</span><span class="p">{</span><span class="nx">commandID</span><span class="p">},</span> <span class="nx">pktBody</span><span class="p">},</span> <span class="kc">nil</span><span class="p">),</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Well, everything is ready but the wind! Let&rsquo;s write the program structure to connect the tcp conn to Frame and Packet.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// github.com/bigwhite/experiments/tree/master/tcp-stream-proto/demo1/cmd/server/main.go
</span><span class="c1"></span>
<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
 <span class="s">&#34;fmt&#34;</span>
 <span class="s">&#34;net&#34;</span>

 <span class="s">&#34;github.com/bigwhite/tcp-stream-proto/demo1/pkg/frame&#34;</span>
 <span class="s">&#34;github.com/bigwhite/tcp-stream-proto/demo1/pkg/packet&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">handlePacket</span><span class="p">(</span><span class="nx">framePayload</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">ackFramePayload</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
 <span class="kd">var</span> <span class="nx">p</span> <span class="nx">packet</span><span class="p">.</span><span class="nx">Packet</span>
 <span class="nx">p</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">packet</span><span class="p">.</span><span class="nf">Decode</span><span class="p">(</span><span class="nx">framePayload</span><span class="p">)</span>
 <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;handleConn: packet decode error:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
  <span class="k">return</span>
 <span class="p">}</span>

 <span class="k">switch</span> <span class="nx">p</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
 <span class="k">case</span> <span class="o">*</span><span class="nx">packet</span><span class="p">.</span><span class="nx">Submit</span><span class="p">:</span>
  <span class="nx">submit</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.(</span><span class="o">*</span><span class="nx">packet</span><span class="p">.</span><span class="nx">Submit</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;recv submit: id = %s, payload=%s\n&#34;</span><span class="p">,</span> <span class="nx">submit</span><span class="p">.</span><span class="nx">ID</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">submit</span><span class="p">.</span><span class="nx">Payload</span><span class="p">))</span>
  <span class="nx">submitAck</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">packet</span><span class="p">.</span><span class="nx">SubmitAck</span><span class="p">{</span>
   <span class="nx">ID</span><span class="p">:</span>     <span class="nx">submit</span><span class="p">.</span><span class="nx">ID</span><span class="p">,</span>
   <span class="nx">Result</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="p">}</span>
  <span class="nx">ackFramePayload</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">packet</span><span class="p">.</span><span class="nf">Encode</span><span class="p">(</span><span class="nx">submitAck</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;handleConn: packet encode error:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
   <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">ackFramePayload</span><span class="p">,</span> <span class="kc">nil</span>
 <span class="k">default</span><span class="p">:</span>
  <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;unknown packet type&#34;</span><span class="p">)</span>
 <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">handleConn</span><span class="p">(</span><span class="nx">c</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="p">{</span>
 <span class="k">defer</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
 <span class="nx">frameCodec</span> <span class="o">:=</span> <span class="nx">frame</span><span class="p">.</span><span class="nf">NewMyFrameCodec</span><span class="p">()</span>

 <span class="k">for</span> <span class="p">{</span>
  <span class="c1">// read from the connection
</span><span class="c1"></span>
  <span class="c1">// decode the frame to get the payload
</span><span class="c1"></span>  <span class="c1">// the payload is undecoded packet
</span><span class="c1"></span>  <span class="nx">framePayload</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">frameCodec</span><span class="p">.</span><span class="nf">Decode</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;handleConn: frame decode error:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
   <span class="k">return</span>
  <span class="p">}</span>

  <span class="c1">// do something with the packet
</span><span class="c1"></span>  <span class="nx">ackFramePayload</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">handlePacket</span><span class="p">(</span><span class="nx">framePayload</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;handleConn: handle packet error:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
   <span class="k">return</span>
  <span class="p">}</span>

  <span class="c1">// write ack frame to the connection
</span><span class="c1"></span>  <span class="nx">err</span> <span class="p">=</span> <span class="nx">frameCodec</span><span class="p">.</span><span class="nf">Encode</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">ackFramePayload</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;handleConn: frame encode error:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
   <span class="k">return</span>
  <span class="p">}</span>
 <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
 <span class="nx">l</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Listen</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;:8888&#34;</span><span class="p">)</span>
 <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;listen error:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
  <span class="k">return</span>
 <span class="p">}</span>

 <span class="k">for</span> <span class="p">{</span>
  <span class="nx">c</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nf">Accept</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;accept error:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
   <span class="k">break</span>
  <span class="p">}</span>
  <span class="c1">// start a new goroutine to handle
</span><span class="c1"></span>  <span class="c1">// the new connection.
</span><span class="c1"></span>  <span class="k">go</span> <span class="nf">handleConn</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
 <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>In the above program, the main function is the standard &ldquo;one connection per goroutine&rdquo; structure, and the key logic is in handleConn. In handleConn, we see a very clear code structure.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">
<span class="nx">read</span> <span class="nx">conn</span>
 <span class="o">-</span><span class="p">&gt;</span><span class="nx">frame</span> <span class="nx">decode</span>
  <span class="o">-</span><span class="p">&gt;</span> <span class="nx">handle</span> <span class="nx">packet</span>
   <span class="o">-</span><span class="p">&gt;</span> <span class="nx">packet</span> <span class="nx">decode</span>
   <span class="o">-</span><span class="p">&gt;</span> <span class="nf">packet</span><span class="p">(</span><span class="nx">ack</span><span class="p">)</span> <span class="nx">encode</span>
 <span class="o">-</span><span class="p">&gt;</span><span class="nf">frame</span><span class="p">(</span><span class="nx">ack</span><span class="p">)</span> <span class="nx">encode</span>
<span class="nx">write</span> <span class="nx">conn</span>
</code></pre></td></tr></table>
</div>
</div><p>Here, a classic blocking TCP stream parsing demo is finished (you can verify it by running the client and server provided in the demo).</p>
<h2 id="5-possible-optimization-points">5. Possible optimization points</h2>
<p>In demo1 above, we directly pass the net.Conn instance to frame.Decode as a real parameter to the io.Reader parameter, so that every time we call the Read method we are reading data directly from Conn. However, Go runtime uses net poller to convert net.Conn.Read to io multiplexed wait, avoiding the need to convert every direct read from net.Conn to a single system call. But even then, there may be one more goroutine context switch (in case the data is not yet ready). Although the cost of goroutine context switching is much smaller compared to thread switching, after all, such switching is not free and we want to reduce it. We can reduce the frequency of real calls to net.Conn.Read by caching the reads. We can transform the demo1 example like the following.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// github.com/bigwhite/experiments/tree/master/tcp-stream-proto/demo2/cmd/server/main.go
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">handleConn</span><span class="p">(</span><span class="nx">c</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
    <span class="nx">frameCodec</span> <span class="o">:=</span> <span class="nx">frame</span><span class="p">.</span><span class="nf">NewMyFrameCodec</span><span class="p">()</span>
    <span class="nx">rbuf</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="c1">// 为io增加缓存
</span><span class="c1"></span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="c1">// read from the connection
</span><span class="c1"></span>
        <span class="c1">// decode the frame to get the payload
</span><span class="c1"></span>        <span class="c1">// the payload is undecoded packet
</span><span class="c1"></span>        <span class="nx">framePayload</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">frameCodec</span><span class="p">.</span><span class="nf">Decode</span><span class="p">(</span><span class="nx">rbuf</span><span class="p">)</span> <span class="c1">// 使用bufio，减少直接read conn.Conn的次数
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;handleConn: frame decode error:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="p">}</span>
        <span class="o">...</span> <span class="o">...</span>
    <span class="p">}</span>
    <span class="o">...</span> <span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>bufio internally tries to read the size of its internal cache (buf) from net.Conn each time, instead of the size of the data the user passed in that it wants to read. This data is cached in memory so that subsequent Reads can get the data directly from memory instead of reading from net.Conn each time, thus reducing the frequency of goroutine context switches.</p>
<p>In addition to this, our implementation of frame Decode in the frame package is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// github.com/bigwhite/experiments/tree/master/tcp-stream-proto/demo2/pkg/frame/frame.go
</span><span class="c1"></span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">myFrameCodec</span><span class="p">)</span> <span class="nf">Decode</span><span class="p">(</span><span class="nx">r</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span> <span class="p">(</span><span class="nx">FramePayload</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">totalLen</span> <span class="kt">int32</span>
    <span class="nx">err</span> <span class="o">:=</span> <span class="nx">binary</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="nx">binary</span><span class="p">.</span><span class="nx">BigEndian</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">totalLen</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
    <span class="p">}</span>

    <span class="nx">buf</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">totalLen</span><span class="o">-</span><span class="mi">4</span><span class="p">)</span>
    <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">io</span><span class="p">.</span><span class="nf">ReadFull</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="nx">buf</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nf">FramePayload</span><span class="p">(</span><span class="nx">buf</span><span class="p">),</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>We see that each call to this method allocates a buf, and the buf is indefinite, these heap memory objects on the critical path of the program will bring pressure to the GC, we want to try to avoid or reduce its frequency, one possible way is to try to reuse the object, in Go when it comes to reuse memory objects, we think of sync. Pool, but there is a problem here, that is, &ldquo;indefinite length&rdquo;, which makes it more difficult to use sync.</p>
<p><a href="https://github.com/bytedance/gopkg/tree/master/lang/mcache">mcache</a> is a multi-level sync.Pool package open-sourced by the Bytedance technical team. It allows you to choose different sync.Pool pools depending on the size of the object you want to allocate. Somewhat similar to tcmalloc&rsquo;s multi-level (class) memory object management, and Go runtime&rsquo;s mcache is also similar. mcache is divided into a total of 46 levels, one sync.Pool per level.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// github.com/bytedance/gopkg/tree/master/lang/mcache/mcache.go
</span><span class="c1"></span><span class="kd">const</span> <span class="nx">maxSize</span> <span class="p">=</span> <span class="mi">46</span>

<span class="c1">// index contains []byte which cap is 1&lt;&lt;index
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">caches</span> <span class="p">[</span><span class="nx">maxSize</span><span class="p">]</span><span class="nx">sync</span><span class="p">.</span><span class="nx">Pool</span>
</code></pre></td></tr></table>
</div>
</div><p>We can allocate memory from mcache to replace the action of requesting a []byte each time to achieve memory object reuse and reduce GC pressure.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// github.com/bigwhite/experiments/tree/master/tcp-stream-proto/demo3/pkg/frame/frame.go
</span><span class="c1"></span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">myFrameCodec</span><span class="p">)</span> <span class="nf">Decode</span><span class="p">(</span><span class="nx">r</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span> <span class="p">(</span><span class="nx">FramePayload</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">totalLen</span> <span class="kt">int32</span>
    <span class="nx">err</span> <span class="o">:=</span> <span class="nx">binary</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="nx">binary</span><span class="p">.</span><span class="nx">BigEndian</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">totalLen</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
    <span class="p">}</span>

    <span class="nx">buf</span> <span class="o">:=</span> <span class="nx">mcache</span><span class="p">.</span><span class="nf">Malloc</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nx">totalLen</span> <span class="o">-</span> <span class="mi">4</span><span class="p">))</span>  <span class="c1">// 这里我们重用mcache中的内存对象
</span><span class="c1"></span>    <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">io</span><span class="p">.</span><span class="nf">ReadFull</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="nx">buf</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nf">FramePayload</span><span class="p">(</span><span class="nx">buf</span><span class="p">),</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>With mcache.Malloc, we need to call mcache.Free to return the memory object at a specific location, and Decode in the packet is the best place to do that.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// github.com/bigwhite/experiments/tree/master/tcp-stream-proto/demo3/pkg/packet/packet.go
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">Decode</span><span class="p">(</span><span class="nx">packet</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">Packet</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="nx">mcache</span><span class="p">.</span><span class="nf">Free</span><span class="p">(</span><span class="nx">packet</span><span class="p">)</span> <span class="c1">// 在decode结束后，释放对象回mcache
</span><span class="c1"></span>    <span class="nx">commandID</span> <span class="o">:=</span> <span class="nx">packet</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="nx">pktBody</span> <span class="o">:=</span> <span class="nx">packet</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="o">...</span> <span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The above are two of the more obvious optimization points that can be identified without using a tool like pprof, and there are probably many more, so I won&rsquo;t list them all here.</p>
<h2 id="6-simple-stress-test">6. simple stress test</h2>
<p>Now that the optimization points are given, let&rsquo;s roughly stress test the program before and after optimization. We add counters based on the standard library expvar to both versions of the program (take the pre-optimized demo1 as an example).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// github.com/bigwhite/experiments/tree/master/tcp-stream-proto/demo1-with-metrics/cmd/server/main.go
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">handleConn</span><span class="p">(</span><span class="nx">c</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
    <span class="nx">frameCodec</span> <span class="o">:=</span> <span class="nx">frame</span><span class="p">.</span><span class="nf">NewMyFrameCodec</span><span class="p">()</span>
    
    <span class="k">for</span> <span class="p">{</span>
        <span class="c1">// read from the connection
</span><span class="c1"></span>        <span class="o">...</span> <span class="o">...</span>
        <span class="c1">// write ack frame to the connection
</span><span class="c1"></span>        <span class="nx">err</span> <span class="p">=</span> <span class="nx">frameCodec</span><span class="p">.</span><span class="nf">Encode</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">ackFramePayload</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;handleConn: frame encode error:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="p">}</span>   
        <span class="nx">monitor</span><span class="p">.</span><span class="nx">SubmitInTotal</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// 每处理完一条消息，计数器+1
</span><span class="c1"></span>    <span class="p">}</span>   
<span class="p">}</span>   
</code></pre></td></tr></table>
</div>
</div><p>In the monitor package, we calculate the processing performance per second.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">
<span class="c1">// github.com/bigwhite/experiments/tree/master/tcp-stream-proto/demo1-with-metrics/pkg/monitor/monitor.go
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// register statistics index
</span><span class="c1"></span>    <span class="nx">SubmitInTotal</span> <span class="p">=</span> <span class="nx">expvar</span><span class="p">.</span><span class="nf">NewInt</span><span class="p">(</span><span class="s">&#34;submitInTotal&#34;</span><span class="p">)</span>
    <span class="nx">submitInRate</span> <span class="p">=</span> <span class="nx">expvar</span><span class="p">.</span><span class="nf">NewInt</span><span class="p">(</span><span class="s">&#34;submitInRate&#34;</span><span class="p">)</span>

    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">lastSubmitInTotal</span> <span class="kt">int64</span>

        <span class="nx">ticker</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTicker</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
        <span class="k">defer</span> <span class="nx">ticker</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>
        <span class="k">for</span> <span class="p">{</span>
            <span class="k">select</span> <span class="p">{</span>
            <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ticker</span><span class="p">.</span><span class="nx">C</span><span class="p">:</span>
                <span class="nx">newSubmitInTotal</span> <span class="o">:=</span> <span class="nx">SubmitInTotal</span><span class="p">.</span><span class="nf">Value</span><span class="p">()</span>
                <span class="nx">submitInRate</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="nx">newSubmitInTotal</span> <span class="o">-</span> <span class="nx">lastSubmitInTotal</span><span class="p">)</span> <span class="c1">// 两秒处理的消息量之差作为处理速度
</span><span class="c1"></span>                <span class="nx">lastSubmitInTotal</span> <span class="p">=</span> <span class="nx">newSubmitInTotal</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>With the expvar-based counter, we can get the processing performance of the program per second by using the expvarmon tool with the export csv function (the compression test client can use the demo1-with-metrics client). The following performance comparison chart is obtained on a 4-core 8g cloud host (conditions are limited, and the press test client and server are placed on one machine, which is bound to interfere with each other).</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/27/6fcb7fab07334d7381ab298049f6858c.png" alt="test result"></p>
<p>We see that the optimized program is slightly better than the pre-optimized one in terms of trend (though not very stable).</p>
<p>If you think collecting instantaneous values is too professional enough ^_^, you can also add a go-metrics-based metric to the program under test, and leave that assignment to everyone :)</p>
<h2 id="7-summary">7. Summary</h2>
<p>In this paper, we have briefly illustrated the TCP network programming model for Go classical blocking I/O. The biggest benefit of this model is its simplicity, reducing the mental burden on developers when dealing with network I/O and focusing more attention on the business level. The paper gives a framework for parsing implementations of custom flow protocols based on this model and illustrates some optimization points that can be made. In non-mega-connection scenarios, such models can have good performance and development efficiency. Once the number of connections skyrockets, the number of goroutines handling these connections increases linearly, and the overhead of goroutine scheduling increases significantly, at which point we need to consider whether to use other models to cope, which we will talk about in subsequent chapters.</p>
<p>All the code involved in this paper can be downloaded from here <a href="https://github.com/bigwhite/experiments/tree/master/tcp-stream-proto">https://github.com/bigwhite/experiments/tree/master/tcp-stream-proto</a></p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/golang/">golang</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-03/go-multiplexing-tcp/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Go I/O multiplexing based TCP protocol stream parsing in practice</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-03/vs-fix-error/">
            <span class="next-text nav-default">Fix the contents of the Error.cshtml file of the ASP.NET MVC 5 project template in Visual Studio</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
