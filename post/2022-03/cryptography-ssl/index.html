<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Cryptography fundamentals and SSL/TLS protocols - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="In this article, we will start with the basics of cryptography, and then go into detail on the principles, processes and some important features of the SSL protocol, and finally we will expand on the differences, security and key new features of TLS 1.3." /><meta name="keywords" content="Cryptography , ssl, tls, aes, rsa" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-03/cryptography-ssl/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Cryptography fundamentals and SSL/TLS protocols" />
<meta property="og:description" content="In this article, we will start with the basics of cryptography, and then go into detail on the principles, processes and some important features of the SSL protocol, and finally we will expand on the differences, security and key new features of TLS 1.3." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-03/cryptography-ssl/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-03-24T15:00:05+08:00" />
<meta property="article:modified_time" content="2022-03-24T15:00:05+08:00" />

<meta itemprop="name" content="Cryptography fundamentals and SSL/TLS protocols">
<meta itemprop="description" content="In this article, we will start with the basics of cryptography, and then go into detail on the principles, processes and some important features of the SSL protocol, and finally we will expand on the differences, security and key new features of TLS 1.3."><meta itemprop="datePublished" content="2022-03-24T15:00:05+08:00" />
<meta itemprop="dateModified" content="2022-03-24T15:00:05+08:00" />
<meta itemprop="wordCount" content="8578">
<meta itemprop="keywords" content="ssl,tls," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Cryptography fundamentals and SSL/TLS protocols"/>
<meta name="twitter:description" content="In this article, we will start with the basics of cryptography, and then go into detail on the principles, processes and some important features of the SSL protocol, and finally we will expand on the differences, security and key new features of TLS 1.3."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Cryptography fundamentals and SSL/TLS protocols</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-03-24 15:00:05 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 8578 words </span>
          <span class="more-meta"> 41 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#foundations-of-cryptography">Foundations of cryptography</a>
          <ul>
            <li><a href="#classical-ciphers">Classical Ciphers</a></li>
            <li><a href="#symmetric-passwords">Symmetric passwords</a></li>
            <li><a href="#pattern-of-block-cipher">Pattern of block cipher</a></li>
            <li><a href="#public-key-ciphers-asymmetric-ciphers">Public key ciphers (asymmetric ciphers)</a></li>
            <li><a href="#one-way-hash-function-hash">One-way hash function (Hash)</a></li>
            <li><a href="#message-authentication-code-mac">Message Authentication Code (MAC)</a></li>
            <li><a href="#digital-signatures-rsa-ecdsa">Digital signatures (RSA, ECDSA)</a></li>
            <li><a href="#digital-certificates-ca">Digital Certificates, CA</a></li>
            <li><a href="#hybrid-cryptosystems">Hybrid Cryptosystems</a></li>
            <li><a href="#random-number-generator">Random Number Generator</a></li>
            <li><a href="#key-derivation-function-key-derivation-function">Key derivation function key derivation function</a></li>
            <li><a href="#ssltls-protocol-in-detail">SSL/TLS protocol in detail</a></li>
            <li><a href="#what-is-ssltls-protocol">What is SSL/TLS protocol</a></li>
            <li><a href="#protocol-layering">Protocol layering</a></li>
            <li><a href="#ssl-record">SSL record</a></li>
            <li><a href="#algorithm-suites-ciphersuites">Algorithm Suites CipherSuites</a></li>
            <li><a href="#ssl-handshake">SSL handshake</a></li>
            <li><a href="#session-reuse">Session Reuse</a></li>
            <li><a href="#certificate-revocation-blacklisting">Certificate revocation (blacklisting)</a></li>
            <li><a href="#server-name-indication-sni">Server Name Indication (SNI)</a></li>
          </ul>
        </li>
        <li><a href="#gmssl-protocol-differences">GMSSL Protocol Differences</a>
          <ul>
            <li><a href="#protocol-number">Protocol Number</a></li>
            <li><a href="#algorithm-suite">Algorithm suite</a></li>
            <li><a href="#dual-certificate-system">Dual certificate system</a></li>
            <li><a href="#security">Security</a></li>
            <li><a href="#common-attacks">Common Attacks</a></li>
            <li><a href="#forward-security">Forward security</a></li>
          </ul>
        </li>
        <li><a href="#tls-13-new-features">TLS 1.3 New Features</a>
          <ul>
            <li><a href="#key-exchange-modes">Key Exchange Modes</a></li>
            <li><a href="#1-rtt-handshake">1-RTT handshake</a></li>
            <li><a href="#reuse-and-psk">Reuse and PSK</a></li>
            <li><a href="#0-rtt-handshake-with-side-effects">0-RTT handshake with side effects</a></li>
            <li><a href="#key-derivation-process">Key derivation process</a></li>
          </ul>
        </li>
        <li><a href="#common-implementations">Common Implementations</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>SSL protocol is an important part of modern network communication, which provides data security at the transport layer. In order to facilitate your understanding, this article will start with the basics of cryptography, and then move on to a detailed explanation of the SSL protocol principles, processes and some important features, and finally will expand on the differences between the national SSL protocols, security and the key new features of TLS 1.3.</p>
<p>Due to the limitation of space and personal knowledge, this article will not cover too much detail. In particular, this article will not cover the specific principles of the algorithm, nor the actual code implementation. Instead, we will try to understand the basic principles and processes in a visual way, such as with diagrams.</p>
<h2 id="foundations-of-cryptography">Foundations of cryptography</h2>
<h3 id="classical-ciphers">Classical Ciphers</h3>
<p>The history of cryptography goes back a long way, as early as the Roman Republic, when Julius Caesar is said to have used the Caesar Code to communicate with his generals.</p>
<h4 id="caesars-cipher">Caesar&rsquo;s cipher</h4>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/b7cb5f42283846ef9624bd3e464aebe5.png" alt="Caesar&rsquo;s cipher"></p>
<p>The Caesar password is a simple shift operation. Caesar keys are very easy to crack, just try the key from 0 to 25 using <strong>brute-force cracking</strong>.</p>
<h4 id="simple-substitution-of-passwords">Simple substitution of passwords</h4>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/60fb1f7f0bfa4831874a342b835f7eac.png" alt="Simple substitution of passwords"></p>
<p>Simple substitution passwords with a random mapping relationship between the plaintext alphabet and the ciphertext alphabet. This way the key space is <code>26! ~= 4 * 10^26</code>, which is no longer possible to find the correct key using brute force cracking. But it can be deciphered using <strong>frequency analysis</strong>.</p>
<h4 id="enigma-cipher-machine">Enigma cipher machine</h4>
<p>A series of rotor-mechanical encryption and decryption machines used in Germany during World War II. Despite the high security of this machine, Allied cryptographers succeeded in deciphering a large number of messages encrypted by this machine.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/74805a5e58db40148a8fcccc3626b000.png" alt="Enigma cipher machine"></p>
<p>Main weaknesses.</p>
<ul>
<li>The communication password is entered twice in succession and encrypted</li>
<li>Communication codes are artificially selected</li>
<li>IDF codebooks must be distributed</li>
</ul>
<h3 id="symmetric-passwords">Symmetric passwords</h3>
<h4 id="block-ciphers-and-stream-ciphers">Block ciphers and stream ciphers</h4>
<p>The above ciphers actually belong to the category of symmetric ciphers, and symmetric encryption algorithms can be divided into two types of ciphers, block cipher and stream cipher.</p>
<ul>
<li>Block cipher: Only blocks of a specific length can be processed at a time. The length of a block is called the block length (group length)</li>
<li>Stream cipher: A class of cryptographic algorithms that process data streams continuously. It generally encrypts and decrypts in units of 1 bit, 8 bits, or 32 bits.</li>
</ul>
<h4 id="aes-advanced-encryption-standard">AES (Advanced Encryption Standard)</h4>
<p>AES is one of the most commonly used symmetric algorithms today. A symmetric encryption algorithm, as the name implies, is <strong>encrypted and decrypted using the same key</strong> . The sender uses the key K to encrypt the plaintext P to get the ciphertext C. Then the ciphertext C is sent to the receiver, who uses the same key K to decrypt the ciphertext to get the plaintext P.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/438e6fe86b7f4948a1645cc3daf5600a.png" alt="Advanced Encryption Standard"></p>
<p>AES uses the Rijndael algorithm, and the following diagram shows the operation of a round in Rijndael encryption.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/269a5d15283e42c19b34de542bf8159b.png" alt="operation of a round in Rijndael encryption"></p>
<p>Each round performs byte substitution, row shifting, column blending and rounds of key dissimilarity, allowing the input bits to be fully <strong>obfuscated</strong>. The encryption of a block will go through many rounds of operations to finally get the ciphertext.</p>
<p>Since all 4 rounds of operations are <strong>reversible</strong>, the decryption is an opposite process.</p>
<h3 id="pattern-of-block-cipher">Pattern of block cipher</h3>
<h4 id="mode">Mode</h4>
<p>The block cipher algorithm can only encrypt a fixed length block, but the plaintext we need to encrypt may exceed the block length of the block cipher, so we need to iterate over the block cipher algorithm in order to encrypt a long block of plaintext. The method of <strong>iterating between blocks</strong> is called <strong>mode</strong> of the packet cipher.</p>
<p>Commonly used modes are: ECB, CBC, OFB, CFB, CTR, etc. For the sake of space, we will only introduce ECB, CBC and CTR.</p>
<h5 id="ecb-mode">ECB mode</h5>
<p>ECB is the simplest mode, where each block is encrypted independently. The result of encrypting the plaintext group becomes a ciphertext group directly after encryption. When the content of the last plaintext group is less than the group length, it needs to be padded with some specific data (padding).</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/0f4afaa153ae40318f180b36d41f7d61.png" alt="AES ECB">
<img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/a723bec6ea7d4f90bf3e138ce9cc7975.png" alt="AES ECB"></p>
<p>The ECB mode has a very significant <strong>disadvantage</strong>: the same plaintext blocks are encrypted into identical ciphertext blocks; therefore, it does not hide the data patterns very well. In some occasions, this method cannot provide strict data confidentiality.</p>
<p>For example, in the penguin picture below, after encrypting it with ECB mode to get the middle picture, the outline of the picture can still be clearly seen, which cannot protect the data confidentiality well. And after encrypting with other modes, we get the result as shown in the third figure, and the obvious features can no longer be seen.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/46cb2a124ef64431bfd5c2ae0ac24460.png" alt="penguin">
<img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/4883e02b482a4b2588a71a46e44ea774.png" alt="penguin">
<img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/94fab3c6c3a24c9396f6ac657cfb813a.png" alt="penguin"></p>
<h5 id="cbc-mode">CBC mode</h5>
<p>In CBC mode, each plaintext block is first dissociated with the previous ciphertext block and then encrypted. So each plaintext block depends on all the previous plaintext blocks. Also, to ensure the uniqueness of each message, the initialization vector (IV) needs to be used in the first block.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/cdafb4d8d6a64784ac3cee8793cc2514.png" alt="AES CBC">
<img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/edad1f6a5c734d6f869325c35919ab08.png" alt="AES CBC"></p>
<p>CBC is the most common working mode in TLS1.2 era. It does not have the problem of the same original text encrypted as the same ciphertext in ECB mode, but it also results in less parallel computing capability than ECB mode.</p>
<h5 id="ctr-mode">CTR mode</h5>
<p>Counter mode actually converts block encryption into stream encryption, it encrypts a counter that accumulates one by one, and then XORs the encrypted bit sequence with the plaintext to get the ciphertext.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/8eabe4f74bad440fbb2838101be75c07.png" alt="AES CTR">
<img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/f54e9928d0074197a0e80f948334fad4.png" alt="AES CTR"></p>
<p>The counter acts similarly to IV in CBC mode, ensuring that the same plaintext will be encrypted into different ciphertexts. The CTR mode has the following <strong>advantages</strong> over CBC and other modes: it is very suitable for parallel computation, and the corresponding bits in the wrong ciphertext will only affect the corresponding bits in the plaintext.</p>
<h4 id="aead-authenticated-encryption-with-associated-data">AEAD (Authenticated Encryption with Associated Data)</h4>
<p>All those previous models have been found to have different procedural drawbacks or problems. In the era of TLS1.3, only the AEAD type of encryption mode is retained. AEAD adds the function of authentication along with encryption, and the commonly used ones are GCM, CCM, and Ploy1305.</p>
<h5 id="gcm-galoiscounter-mode">GCM (Galois/Counter Mode)</h5>
<p>The G in GCM refers to GMAC (we will talk about MAC later), and C refers to the CTR counter mode we mentioned earlier. The upper right part of the figure below is the Counter Mode encryption above, and the remaining part is the GMAC. the final result contains the initial counter value, the encrypted ciphertext and the MAC value.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/bb65722b9d93478a9db177f12256e607.png" alt="GCM (Galois/Counter Mode)"></p>
<h3 id="public-key-ciphers-asymmetric-ciphers">Public key ciphers (asymmetric ciphers)</h3>
<p>When using symmetric encryption, you are bound to run into the problem of <strong>key distribution (key exchange)</strong>. The use of pre-shared keys has limitations and a secure way to hand over the keys to each other is needed. This leads to public key ciphers.</p>
<h4 id="public-key-cryptographic-algorithms-rsa-national-security-sm2">Public Key Cryptographic Algorithms (RSA, National Security SM2)</h4>
<p>The most commonly used public key algorithm is the famous RSA, while the SM2 algorithm is used in the national secret. The public key cipher has two keys, one of which is the public key, which can be distributed, and the other is the private key, which needs to be kept strictly by oneself. For example, if Bob wants to send a message to Alice, Bob encrypts the message with Alice&rsquo;s public key and sends it to Alice, who then decrypts it with her private key.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/e8540e85a83f41f896f85e3e33a423c2.png" alt="Public Key Cryptographic Algorithms (RSA, National Security SM2)"></p>
<h4 id="diffie-hellman-key-exchange">Diffie-Hellman key exchange</h4>
<p>Another commonly used public key cipher is the DH class of algorithms, which can be explained graphically in the following diagram.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/30f5c49e825045718092e41589984904.png" alt="Diffie-Hellman key exchange"></p>
<p>First both parties negotiate an identical base color (algorithm parameter), then each generates its own private color (equivalent to the private key) and obtains the corresponding public color (equivalent to the public key) by mixing. Then both parties exchange their public colors and mix them with their private key colors to finally negotiate an identical color (i.e., the exchanged key). An eavesdropper cannot generate the same key even if he gets this information exchanged between the two parties, <strong>the difficulty of solving the discrete object problem</strong> ensures the security of the DH algorithm.</p>
<h4 id="ecdh-and-ecdhe">ECDH and ECDHE</h4>
<p><code>ECDH</code> is an elliptic curve-based DH algorithm, which is basically the same as DH in principle, mainly replacing the modulo power operation on finite fields with the dot product operation on elliptic curves. Compared with DH algorithm, it is faster and more difficult to be inverted.</p>
<p>DH and ECDH both use a fixed key, once the key is leaked, all previous cipher messages are broken. <code>ECDHE</code> provides forward security, it uses a temporary key each time and generates a session key based on this temporary key for key exchange. Even if this temporary key is compromised, it only affects the messages of the current SSL session.</p>
<h3 id="one-way-hash-function-hash">One-way hash function (Hash)</h3>
<p>The previous symmetric key and public key cipher solves the problem of <strong>confidentiality</strong> of message transmission, so that the message we transmit is not eavesdropped. But the problem of <strong>integrity</strong> has not been solved, and the message may be &quot; <strong>tampered</strong> &quot; in the middle. So it&rsquo;s the turn of one-way hash functions to come into play.</p>
<p>The <strong>one-way hash function</strong> can calculate a fixed-length hash value (digest value) based on the input message, and this hash value can be used as a fingerprint of the message to check the integrity of the message. By modifying any 1 bit of the original message, the final generated hash value may be completely different.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/a6bc62d5e02a45d4b5581ec4d7e68f1b.png" alt="One-way hash function (Hash)"></p>
<p>The ideal hash function has the following properties.</p>
<ol>
<li>deterministic: the same message always produces the same hash value</li>
<li>any given message can quickly calculate the hash value</li>
<li>unidirectional: the message cannot be back-calculated from the hash value</li>
<li><strong>Weak collision resistance</strong>: it is difficult to find a message that can generate a given hash value</li>
<li><strong>Strong collision resistance</strong>: it is difficult to find messages that can generate two identical hashes</li>
<li>A small change in a message can cause a large change in the hash value</li>
</ol>
<h3 id="message-authentication-code-mac">Message Authentication Code (MAC)</h3>
<p>While the one-way hash function guarantees the <strong>integrity</strong> of a message, a clever attacker can tamper with the message along with its hash value without the receiver being able to identify it. So there is also a need for <strong>authentication</strong> of the message, with traditional authentication methods such as handwritten signatures, stamps, handprints, IDs, passphrases (which are actually a shared key), etc. In the cryptographic domain, authentication can be performed by means of message authentication codes. The message authentication code has an additional shared key to authenticate the message compared to the one-way hash function. The attacker cannot forge the MAC value because he does not have this key.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/767ef742e3614395be29f932dbf64695.png" alt="Message Authentication Code (MAC)"></p>
<h4 id="problems-with-mac">Problems with MAC</h4>
<ul>
<li>MAC requires a shared key just like symmetric ciphers, so there are also problems with key distribution.</li>
<li>Unable to prove to third parties</li>
<li>Unable to prevent denial</li>
</ul>
<h3 id="digital-signatures-rsa-ecdsa">Digital signatures (RSA, ECDSA)</h3>
<p>To solve the MAC problem, digital signatures were introduced again.</p>
<p>Digital signatures also belong to the category of public key ciphers. The difference from before is that it uses a private key for encryption (the operation is called signing) and anyone can decrypt it with a public key (the operation is called signature checking). Since the public key is public, it solves the problem of third-party certification. And because the private key is only possessed by the person himself, the person without the private key cannot in fact generate this ciphertext, so it can also prevent denial. So all three problems of MAC can be solved by digital signature.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/4fb141b39f63448ab3bd741059061c42.png" alt="Digital signatures (RSA, ECDSA)"></p>
<p>This is usually used in conjunction with a hash function to ensure integrity and speed up the process. As shown in the figure below, Alice sends a message to Bob by sending him her public key, then she computes a hash of the message and encrypts the hash with her private key to get the signature of the message. Then she sends the initial message and the signature to Bob, who receives it and performs the same hash calculation on the message, decrypts the signature data with Alice&rsquo;s public key to get the decrypted hash value, and then compares the two calculated hashes to verify the validity of the signature.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/6ad7232a0e664a51bd624428db5ad649.png" alt="Digital signatures (RSA, ECDSA)"></p>
<h3 id="digital-certificates-ca">Digital Certificates, CA</h3>
<p>So far, our public key ciphers, digital signatures address confidentiality, integrity, the ability to authenticate, and prevent denial. But it&rsquo;s all based on one premise: <strong>the public key belongs to the real sender</strong>. If the public key is forged, then all of this is lost. The aforementioned digital signature can only guarantee that the other party has the private key corresponding to the public key, but it cannot authenticate the identity of the public key owner itself.</p>
<p>In order to solve this problem, digital certificates were created. The solution is to have a <strong>trusted third party</strong> sign the public key. This trusted third party is generally called <strong>Certificate authorities (CA)</strong>.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/cc515836561047479822adb608b9724e.png" alt="Digital Certificates, CA"></p>
<p>Let&rsquo;s see what the actual certificate looks like. Where <code>Subject</code> is the information of the certificate owner, <code>Issuer</code> is the information of its issuer, <code>Subject Public Key Info</code> is the actual public key information, and the RSA 2048-bit key is used here. The certificate is finally the signature of the CA with its own private key. Anyone who owns the CA&rsquo;s certificate (including the public key) can verify this certificate, thus verifying the identity of the public key owner. <code>Validity</code> is the validity period of this certificate.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">$ openssl x509 -in ~/sharefile/certs/rsa-user.pem -text -noout
Certificate:
    Data:
        Version: <span class="m">3</span> <span class="o">(</span>0x2<span class="o">)</span>
        Serial Number:
            a2:95:90:e8:e0:f6:3a:e4
    Signature Algorithm: sha256WithRSAEncryption
        Issuer: <span class="nv">C</span><span class="o">=</span>CN, <span class="nv">ST</span><span class="o">=</span>SH, <span class="nv">L</span><span class="o">=</span>Shanghai, <span class="nv">O</span><span class="o">=</span>Awesome Software, <span class="nv">OU</span><span class="o">=</span>SSL Group, <span class="nv">CN</span><span class="o">=</span>RSA_CA_Cert/emailAddress<span class="o">=</span>ssl@ca.com
        Validity
            Not Before: Nov  <span class="m">5</span> 01:47:05 <span class="m">2018</span> GMT
            Not After : Nov  <span class="m">2</span> 01:47:05 <span class="m">2028</span> GMT
        Subject: <span class="nv">C</span><span class="o">=</span>CN, <span class="nv">ST</span><span class="o">=</span>SH, <span class="nv">L</span><span class="o">=</span>Shanghai, <span class="nv">O</span><span class="o">=</span>Awesome Software, <span class="nv">OU</span><span class="o">=</span>SSL Group, <span class="nv">CN</span><span class="o">=</span>RSA_USER/emailAddress<span class="o">=</span>rsa@site.com
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: <span class="o">(</span><span class="m">2048</span> bit<span class="o">)</span>
                Modulus:
                    00:f4:a0:b6:57:e7:68:39:98:39:13:11:b9:61:ee:
                    1d:5c:60:c6:53:51:ec:0e:59:53:0e:12:75:1c:5b:
                    b1:b7:e4:dd:4d:c8:c1:b8:eb:07:32:12:a1:fc:50:
                    33:d9:63:4a:30:7f:b4:b5:e9:87:d9:71:33:65:ab:
                    56:54:ba:34:92:06:9a:af:ff:84:8e:a3:29:af:46:
                    61:3b:45:39:c5:a8:0a:f9:ae:fb:d4:2b:20:5a:9d:
                    ce:00:fe:c9:87:b2:f4:d2:f8:bf:b7:2e:7a:79:5e:
                    94:54:7d:f9:09:73:4a:ec:c7:22:01:79:4c:62:11:
                    55:a9:d3:3b:f8:ef:3e:1d:56:e3:2f:34:ef:c6:0f:
                    2c:94:40:01:a3:6f:1e:3b:61:bd:79:00:bf:26:f7:
                    d6:c3:a6:22:22:50:f0:6e:aa:03:1e:ea:d9:e6:ad:
                    4d:a9:60:4f:6d:81:80:f4:f9:a9:89:31:ab:f1:a3:
                    9b:1a:a2:57:ed:44:30:39:fc:3a:3a:c3:6e:c8:a6:
                    db:2e:14:c1:3b:6b:5b:ca:ab:b7:0d:fb:85:39:08:
                    bf:6b:41:c1:f6:42:b1:3f:9c:45:5c:4c:37:8e:7d:
                    c6:18:f8:9b:87:16:80:7f:25:34:8f:14:a9:02:2e:
                    7c:07:c9:8a:21:77:33:03:6a:9c:86:f1:73:9c:c8:
                    2d:f1
                Exponent: <span class="m">65537</span> <span class="o">(</span>0x10001<span class="o">)</span>
        X509v3 extensions:
            X509v3 Basic Constraints:
                CA:FALSE
            X509v3 Key Usage:
                Digital Signature, Non Repudiation, Key Encipherment
    Signature Algorithm: sha256WithRSAEncryption
         30:cf:b2:9f:50:ea:d7:0d:e2:87:50:e6:bd:d7:b0:17:12:31:
         b1:9f:59:16:50:60:bc:52:c0:46:7a:43:d0:34:43:48:d0:bd:
         e1:a0:dc:75:a2:60:a0:c9:8f:ed:d4:36:14:18:75:c0:ef:c3:
         92:fa:43:fa:34:5a:12:77:2f:03:00:eb:a6:db:d9:6b:50:ff:
         44:56:22:c6:51:73:73:9a:4b:fd:bb:53:ff:2b:7e:97:55:d3:
         4d:bb:bd:26:69:37:8d:71:30:41:bf:fd:48:40:fc:6f:cd:e2:
         b7:4a:90:6f:a2:11:85:a7:88:d3:61:d5:03:0a:50:98:cc:0e:
         aa:d5:83:38:b4:d5:f0:06:ff:a5:eb:d4:e6:54:14:e9:65:af:
         36:a5:e4:3e:8b:78:18:0b:d6:7c:cc:f1:a3:da:7a:03:fd:89:
         23:f0:e1:3e:af:7b:b1:7a:53:82:11:4a:5e:1d:84:b6:0b:cc:
         96:b4:3a:8a:43:cf:ff:b3:3a:be:47:e0:40:c0:48:15:b4:f3:
         2d:2b:73:b8:07:d2:21:83:3c:c4:4c:c2:31:17:4e:4c:15:da:
         66:fd:06:9a:b7:ed:b5:9e:71:a3:40:0b:39:12:3c:7b:cb:cb:
         a0:af:d0:c7:fe:59:41:35:04:7f:f3:f3:38:d0:d0:ac:7a:15:
         7e:fa:ee:fd
</code></pre></td></tr></table>
</div>
</div><p>In actual use, multi-level certificate chains are usually used, with each level of certificate issued by the CA at the previous level and checked and signed by the certificate of the CA at the previous level. The final Root CA certificate can only be issued by itself, i.e., it signs its own public key with its own private key, otherwise it is infinitely recursive.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/9ac166f86bc549dc942ad009095361aa.png" alt="CA"></p>
<p>So a digital certificate is actually a chain of trust transferring the authentication of many individuals to a few CAs, which can reduce the risk of man-in-the-middle attacks. From public key ciphers and certificates this leads to <strong>Public Key Infrastructure (PKI)</strong> : This is the general term for a set of specifications and specifications that are developed to enable more effective use of public keys.</p>
<h3 id="hybrid-cryptosystems">Hybrid Cryptosystems</h3>
<p>So with public-key ciphers, is there no need for symmetric ciphers? Although public-key ciphers solve the key distribution problem of symmetric ciphers, they are several orders of magnitude slower than symmetric ciphers in terms of computational speed. Here are the results of testing RSA1024 and AES128 with <code>openssl speed</code>. AES128 (same block size) is roughly 1200 times faster than RSA1024 signature and 70 times faster than check-sign.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt">$ openssl speed rsa1024
                  sign    verify    sign/s verify/s
rsa 1024 bits 0.000103s 0.000006s   9732.8 162578.8

$ openssl speed -evp aes128
type             16 bytes     64 bytes    256 bytes   1024 bytes   8192 bytes  16384 bytes
aes-128-cbc    1075884.36k  1452740.12k  1510392.06k  1530545.83k  1537414.49k  1537114.11k
</code></pre></td></tr></table>
</div>
</div><p>Because symmetric and asymmetric ciphers have their own advantages and disadvantages, they are usually combined in practical applications, using asymmetric ciphers to complete the key exchange, then generating session keys as keys for symmetric ciphers, and using symmetric ciphers to encrypt and decrypt messages.</p>
<h3 id="random-number-generator">Random Number Generator</h3>
<p>Up to now, we have solved many problems, including confidentiality, integrity, authentication, and anti-repudiation, but there is actually one big problem we have not solved: namely, how do we generate our <strong>session key</strong>? All the security of a secure algorithm should be based on the security of its <strong>key</strong>, and if our key can be easily cracked or predicted, then everything we&rsquo;ve built falls apart. So the random number generator plays a crucial role here.</p>
<p>Random numbers also play an important role in <strong>anti-replay attacks</strong>, where the attacker saves the eavesdropped data and sends it to the receiver later as it is to achieve his specific attack purpose. The common means to prevent replay are the use of serial numbers, timestamps, random numbers, etc.</p>
<p>Here is a question left for your consideration. What is the use of replay since the attacker can neither decrypt the message nor tamper with it because of confidentiality and integrity protection?</p>
<p>The ideal random number generator has the following properties.</p>
<ul>
<li>Randomness: no statistical bias, a completely jumbled sequence of numbers</li>
<li>Unpredictability: the next occurrence of a number cannot be inferred from past series</li>
<li>Irreproducibility: the same series cannot be reproduced unless the series itself is preserved</li>
</ul>
<h3 id="key-derivation-function-key-derivation-function">Key derivation function key derivation function</h3>
<p>KDF can be used to extend key material into longer keys or to obtain keys in the desired format, the PRF algorithm is used in TLS 1.2 and the HKDF algorithm is used in TLS 1.3.</p>
<h3 id="ssltls-protocol-in-detail">SSL/TLS protocol in detail</h3>
<h3 id="what-is-ssltls-protocol">What is SSL/TLS protocol</h3>
<p>Well, with the previous cryptographic foundation, we can formally enter the introduction of the TLS protocol. While the previous ones are basically independent algorithms or components that combine several algorithms, the SSL/TLS protocol is a <strong>finished cryptographic protocol</strong> based on these underlying algorithmic primitives and components that are finally put together.</p>
<p>SSL is known as <code>Secure Sockets Layer</code>, which was designed by Netscape as a secure transport protocol primarily for the Web to provide confidentiality, authentication, and data integrity protection for network communications. Today, SSL has become the industry standard for secure Internet communications.</p>
<p>The initial versions of SSL (SSL 1.0, SSL 2.0, SSL 3.0) were designed and maintained by Netscape. From version 3.1 onwards, the SSL protocol was officially taken over by the Internet Engineering Task Force (IETF) and renamed TLS (Transport Layer Security), which has evolved to TLS 1.0, TLS1.1, TLS1.2 and TLS1.3. TLS 1.0, TLS1.1, TLS1.2. At present, the mainstream is still TLS1.2, but TLS1.3 will soon be the trend.</p>
<table>
<thead>
<tr>
<th>Protocol</th>
<th>Published</th>
<th>Status</th>
</tr>
</thead>
<tbody>
<tr>
<td>SSL 1.0</td>
<td>Unpublished</td>
<td>Unpublished</td>
</tr>
<tr>
<td>SSL 2.0</td>
<td>1995</td>
<td>Deprecated in 2011 <code>(RFC 6176)</code></td>
</tr>
<tr>
<td>SSL 3.0</td>
<td>1996</td>
<td>Deprecated in 2015 <code>(RFC 7568)</code></td>
</tr>
<tr>
<td>TLS 1.0</td>
<td>1999</td>
<td>Deprecated in 2020 <code>(RFC 8996)[8][9][10]</code></td>
</tr>
<tr>
<td>TLS 1.1</td>
<td>2006</td>
<td>Deprecated in 2020 <code>(RFC 8996)[8][9][10]</code></td>
</tr>
<tr>
<td>TLS 1.2</td>
<td>2008</td>
<td></td>
</tr>
<tr>
<td>TLS 1.3</td>
<td>2018</td>
<td></td>
</tr>
</tbody>
</table>
<p>The main security objectives that the SSL/TLS protocol can provide include the following.</p>
<ul>
<li><strong>Confidentiality</strong> : Preventing third-party eavesdropping with the help of encryption</li>
<li><strong>Authentication</strong>: Authentication of server-side and client-side identities with the help of digital certificates to prevent identity forgery</li>
<li><strong>Integrity</strong>: safeguard data integrity and prevent message tampering with the help of Message Authentication Code (MAC)</li>
<li><strong>Anti-Replay</strong> : Prevents replay attacks</li>
</ul>
<h3 id="protocol-layering">Protocol layering</h3>
<p>I believe you are already familiar with the TCP/IP 5-layer model. The TLS protocol, as its name suggests (Transport Layer Security), is used to secure the transport layer. It is located above the transport layer and below the application layer.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/9a77c46f5a114b4b8787ccca22270d6d.png" alt="Protocol layering"></p>
<p>The SSL/TLS protocol has a highly modular architecture, which is internally divided into many sub-protocols: Handshake protocol, Alert protocol, ChangeCipherSpec protocol, Application protocol. They are all based on the Record protocol at the bottom, and the Record layer protocol is responsible for identifying different upper layer message types and segmented encryption authentication of messages, etc.</p>
<ul>
<li>Handshake protocol: including negotiation of security parameters and algorithm suites, server authentication (client authentication optional), key exchange</li>
<li>Application protocol: used to transmit application layer data</li>
<li>ChangeCipherSpec protocol: a message indicating that the handshake protocol has been completed</li>
<li>Alert protocol: an error alert for some exceptions in the handshake protocol, divided into two levels: fatal and warning. fatal type errors will directly break the SSL connection, while warning level errors will generally continue the SSL connection, but will only give an error warning</li>
</ul>
<p>The SSL/TLS protocol is designed as a two-phase protocol, divided into <strong>Handshake Phase</strong> and <strong>Application Phase</strong>.</p>
<p><strong>Handshake Phase</strong>: Also known as the Negotiation Phase, the main goal of this phase is to negotiate the security parameters and algorithm suite we have already mentioned, authentication (based on digital certificates), and key exchange to generate keys for subsequent encrypted communications.</p>
<p><strong>Application phase</strong>: Both parties use the keys negotiated in the handshake phase to communicate securely.</p>
<h3 id="ssl-record">SSL record</h3>
<p>The format of the SSL record layer packet is similar to that of the IP or TCP layers below it. All data exchanged over an SSL session is encapsulated into frames in the following format. The record layer protocol is responsible for identifying the different message types, as well as segmentation, compression, message authentication and integrity protection, encryption, etc.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/ec737714b1b04445abbf15795cc91cd0.png" alt="SSL record"></p>
<p>A typical record layer workflow (packet cipher algorithm) is as follows.</p>
<ul>
<li>Record layer receives data from the application layer</li>
<li>Chunking of the received data</li>
<li>Compute the MAC or HMAC using the negotiated MAC key and add it to the record block</li>
<li>Encrypt the logged data using the negotiated Cipher Key</li>
</ul>
<p>When the encrypted data reaches the receiving end, the other side does the opposite: decrypts the data, verifies the MAC, reorganizes the data and hands it to the application layer.</p>
<p>All this work is done by the SSL layer and is completely transparent to the upper layer applications.</p>
<p>For messages in the handshake phase, the payload is plaintext, so of course there is no MAC or Padding. all other messages have a ciphertext payload.</p>
<p>For <strong>stream encryption algorithm</strong>, there is no padding after it. for <strong>block encryption algorithm</strong> records, there is an optional IV field before the payload depending on the algorithm used.</p>
<p>For <strong>AEAD algorithm</strong> , there is no MAC and Padding field after it because authentication is already included in the algorithm. payload is preceded by an external nonce field.</p>
<h3 id="algorithm-suites-ciphersuites">Algorithm Suites CipherSuites</h3>
<p>Before we dive into the handshake process, let&rsquo;s understand the concept of algorithm suites. Earlier in the Cryptography Basics section we have learned about various algorithms, including authentication algorithms, key exchange algorithms, symmetric cryptographic algorithms, and algorithms for integrity authentication.</p>
<h4 id="tls-12-">TLS 1.2-</h4>
<p>A <strong>Algorithm Suite</strong> is a combination of these algorithm types used in an SSL connection and contains the following components.</p>
<ul>
<li>Key Exchange (Kx)</li>
<li>Authentication (Au)</li>
<li>Encryption (Enc)</li>
<li>Message Authentication Code (Mac)</li>
</ul>
<p>Common algorithm suite types such as <code>TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256</code>, <code>TLS_RSA_WITH_AES_256_GCM_SHA384</code>, <code>TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384</code>, <code>ECC _SM2_WITH_SM4_SM3</code> (national secret), <code>ECDHE_SM2_WITH_SM4_SM3</code> (national secret).</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/d43c8ad15bc04ee3b07604113fd3ee53.png" alt="Algorithm Suite"></p>
<p>Taking <code>ECDHE-ECDSA-AES128-GCM-SHA256</code> as an example, the preceding <code>ECDHE</code> denotes the key exchange algorithm, <code>ECDSA</code> denotes the authentication algorithm, and <code>AES128-GCM</code> denotes the symmetric encryption algorithm, where <code>128</code> denotes the block length, <code>GCM</code> is its mode, and <code>SHA256</code> denotes the hash algorithm. For <code>AEAD</code> since message authentication and encryption have been merged together, the last <code>SHA256</code> only represents the algorithm of the key derivation function, while for the traditional algorithm suite where data encryption and authentication are separated, it also represents the algorithm of <code>MAC</code>.</p>
<p>The details of each algorithm suite can be viewed with the following command: <code>openssl ciphers -V | column -t | less</code>.</p>
<h4 id="tls-13">TLS 1.3</h4>
<p>For TLSv1.3, because the key exchange and authentication algorithms have been separated from the algorithm suite, the algorithm suite represents only the encryption algorithms and key derivation functions. The reason for this separation is that the number of supported algorithms has increased, resulting in a large number of algorithm suites after multiplication.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/484b03f98b894ffea44b183434d0028c.png" alt="TLS 1.3"></p>
<p>You can check which TLS 1.3 algorithm suites are currently supported with the following command: <code>openssl ciphers -V | column -t | grep 'TLSv1.3'</code> .</p>
<h3 id="ssl-handshake">SSL handshake</h3>
<p>Finally we get to the core handshake protocol part. As mentioned earlier, the SSL handshake does several things: first you have to discuss what algorithm suite to use, then you have to authenticate each other as needed (based on digital certificates), and finally you have to exchange keys based on the chosen algorithm suite to generate the keys used for subsequent encrypted communications. (This section describes the situation for TLS 1.2 and previous versions)</p>
<p>The following diagram shows the process of establishing a complete SSL handshake:</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/730ee3ae47f94c35a682c9caba6958ea.png" alt="SSL handshake"></p>
<p>The first is the 3 TCP handshake to establish the TCP connection, then the client initiates the SSL handshake. A complete SSL handshake consists of two interactions, the first of which is to complete the selection of the algorithm suite. The second interaction is to complete the authentication and key exchange. Once these are negotiated, the SSL secure channel is established. Subsequent application data is then encrypted and transmitted over the secure channel.</p>
<h4 id="key-exchange-process---rsa">Key Exchange Process - RSA</h4>
<p>The key exchange process based on RSA is as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/cb14b5afc80f4d8194416ea8cb71607d.png" alt="The key exchange process based on RSA "></p>
<p>Let&rsquo;s simulate the negotiation process.</p>
<ul>
<li>Client: Hi, server side, I support these algorithms on my side, here&rsquo;s my random number for this time.</li>
<li>Client: Okay, let&rsquo;s see, let&rsquo;s go with this algorithm suite, this is my random number this time, this is my certificate, you use the public key in this certificate to encrypt the premaster key.</li>
<li>Client: Wait a minute let me check the certificate, well, it&rsquo;s indeed a server-side certificate. This is the premaster key encrypted with the public key in the certificate. (Use two random numbers + the pre-master key to calculate the master key, and then generate the session key.) Okay, OK on my end.</li>
<li>Server side: received. (Decrypt the pre-master key with the private key, calculate the master key using two random numbers + the pre-master key, and then generate the session key.) Okay, OK on my side too.</li>
<li>Client: This is the encrypted application data&hellip;.</li>
<li>Server side: This is the encrypted application data&hellip;.</li>
</ul>
<p>Note: The above process is a one-way authentication (the server does not verify the client&rsquo;s identity), if the server also needs to verify the client&rsquo;s identity, it will send <code>Certificate Request</code> message in the first interaction, and the client will accordingly send its own <code>Certificate</code> and <code>CertificateVerify</code> messages in the second interaction. messages to the server.</p>
<h4 id="key-exchange-process---dh">Key exchange process - DH</h4>
<p>The DH-based key exchange process is as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/11468e318a1548f3b0258f21359ea530.png" alt="The DH-based key exchange process"></p>
<p>Let&rsquo;s simulate the negotiation process as well.</p>
<ul>
<li>Client: Hi, server, I support these algorithms on my side, here&rsquo;s my random number for this time.</li>
<li>Server side: Okay, let&rsquo;s see, let&rsquo;s go with this algorithm suite, this is my random number for this time, and give you my certificate. I&rsquo;ll use this DH parameter on my side, and this is the corresponding signature.</li>
<li>Client: Wait a minute I&rsquo;ll check the certificate and signature, well, it&rsquo;s indeed a server-side certificate, and the signature is fine. This is the DH parameter on my side. (Use DH parameters to derive the pre-master key, then use two random numbers + pre-master key to calculate the master key, and then generate the session key.) Okay, OK on my side.</li>
<li>Server side: received. (Use the DH parameter to derive the premaster key, then use two random numbers + the premaster key to calculate the master key, and then generate the session key.) Okay, OK on my side too.</li>
<li>Client: This is the encrypted application data&hellip;.</li>
<li>Server side: This is the encrypted application data&hellip;.</li>
</ul>
<h4 id="key-generation">Key generation</h4>
<p>Through the first interaction between ClientHello and ServerHello, and the key exchange process, both the client and server get the client random number, server random number and the pre-master key. The next step is to use these to calculate the master key.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="nv">master_secret</span> <span class="o">=</span> PRF<span class="o">(</span>pre_master_secret, <span class="s2">&#34;master secret&#34;</span>,
                    ClientHello.random + ServerHello.random<span class="o">)</span>
                    <span class="o">[</span>0..47<span class="o">]</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>Once the master key is obtained, it is then expanded into a sequence of secure bytes.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">key_block</span> <span class="o">=</span> <span class="n">PRF</span><span class="p">(</span><span class="n">SecurityParameters</span><span class="p">.</span><span class="n">master_secret</span><span class="p">,</span>
                     <span class="s">&#34;key expansion&#34;</span><span class="p">,</span>
                     <span class="n">SecurityParameters</span><span class="p">.</span><span class="n">server_random</span> <span class="o">+</span>
                     <span class="n">SecurityParameters</span><span class="p">.</span><span class="n">client_random</span><span class="p">);</span>

</code></pre></td></tr></table>
</div>
</div><p>Then it is sliced into MAC key, symmetric encryption key and IV respectively.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">client_write_MAC_key</span><span class="p">[</span><span class="n">SecurityParameters</span><span class="p">.</span><span class="n">mac_key_length</span><span class="p">]</span>
<span class="n">server_write_MAC_key</span><span class="p">[</span><span class="n">SecurityParameters</span><span class="p">.</span><span class="n">mac_key_length</span><span class="p">]</span>
<span class="n">client_write_key</span><span class="p">[</span><span class="n">SecurityParameters</span><span class="p">.</span><span class="n">enc_key_length</span><span class="p">]</span>
<span class="n">server_write_key</span><span class="p">[</span><span class="n">SecurityParameters</span><span class="p">.</span><span class="n">enc_key_length</span><span class="p">]</span>
<span class="n">client_write_IV</span><span class="p">[</span><span class="n">SecurityParameters</span><span class="p">.</span><span class="n">fixed_iv_length</span><span class="p">]</span>
<span class="n">server_write_IV</span><span class="p">[</span><span class="n">SecurityParameters</span><span class="p">.</span><span class="n">fixed_iv_length</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p>If you draw a diagram, it looks like the following.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/0999c6c1d45d4d759686d5590703d7c8.png" alt="tls1.2 Key generation"></p>
<h3 id="session-reuse">Session Reuse</h3>
<p>The SSL handshake introduces an additional <strong>two interactions</strong> and <strong>CPU-intensive</strong> algorithmic operations. Is there any way to optimize the performance of the SSL handshake, which is very performance intensive for every connection? Obviously improving hardware performance and software performance are both effective methods. In fact, SSL takes this into account at the protocol level by providing a &ldquo;session reuse&rdquo; feature. After the previous SSL connection is established, both parties can save the SSL session. Session reuse requires only one SSL handshake interaction and does not require authentication or key exchange, thus significantly reducing the latency and computational overhead of the process.</p>
<p>In fact, if a browser is initiating multiple connections to the same site, it will typically wait for the first SSL handshake to complete before initiating additional connections, so that the other connections can reuse the previous Session.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/ab6d82be6cdd41669a7deff10846ce57.png" alt="tls Session Reuse"></p>
<p>There are two mechanisms for Session reuse, Session IDs and Session tickets.</p>
<h4 id="session-ids">Session IDs</h4>
<p>Let&rsquo;s look at the session reuse process when using Session IDs. As you can see from the flowchart of the previous key exchange, the server sends the <code>Session ID</code> of the session to the client in the <code>Server Hello</code> message. After completing the handshake, the server will save the session.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/ec0edda2960c4e39acc56edd13c520fe.png" alt="tls Session IDs"></p>
<p>The client can then restore the session to establish an SSL connection. This is done by including the Session ID to be recovered in the <code>ClientHello</code> message, then the server will look up the corresponding session based on the Session ID, and if everything is OK, it will recover the session key and other information based on the saved session. If the server does not support session reuse, or if the Session ID is not found, or if the session has expired, then it will degrade to a full SSL handshake.</p>
<h4 id="session-ticket">Session Ticket</h4>
<p>The Session ID mechanism requires the server to save each client&rsquo;s session cache, which causes several problems on the server side: additional memory overhead, the requirement for session saving and elimination policies, and then the challenge of sharing the session cache in a high-performance manner for sites with multiple servers.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/fe98b015c76c47d6bb68a5165bc388a2.png" alt="tls Session Ticket"></p>
<p>The Session Ticket mechanism was proposed to solve the Session ID problem. Instead, if the client claims that it supports session tickets, the server sends the client a <code>New Session Ticket</code> message, which contains the encrypted data related to the session, with the encryption key known only to the server.</p>
<p>The client saves the session ticket, and when it needs to resume the session, it will bring the session ticket in the <code>SessionTicket</code> extension of the <code>ClientHello</code> message, and the server will decrypt the session data after receiving it to resume the last session.</p>
<p>So the session ticket mechanism is a kind of stateless reuse for the server, which does not require the server to save the session cache, and of course there is no problem of multi-server synchronization.</p>
<h3 id="certificate-revocation-blacklisting">Certificate revocation (blacklisting)</h3>
<p>When we introduced the certificate, we have seen that the certificate has a validity period, and it cannot be verified outside the validity period. But what should we do if we want to let the certificate expire within the validity period? For example, if a company employee leaves, or if the private key is leaked, it is impossible to take back the issued certificate.</p>
<p>So we introduce certificate revocation, CA can revoke a certificate and perform additional blacklist verification when verifying the validity of the certificate. There are several mechanisms for blacklist validation as follows.</p>
<h4 id="certificate-revocation-list-crl">Certificate Revocation List (CRL)</h4>
<p>CRL, or Certificate Revocation List, is a list of revoked certificates maintained by CAs, which contains the information of revoked certificates. The verifying party needs to download this list for blacklist verification.</p>
<p>The drawback of CRL is also obvious: the certificate verifier must download this list, and the downloaded list may not be synchronized with the actual CA authority&rsquo;s list. If a certificate has actually been revoked but is not in the local list, it may pose a security risk.</p>
<h4 id="online-certificate-status-protocol-ocsp">Online Certificate Status Protocol (OCSP)</h4>
<p>OCSP, or Online Certificate Status Protocol. It performs blacklist verification by online request, without downloading the whole list, but only sending the serial number of the certificate to the CA for verification. Deploying OCSP also introduces certain requirements for CAs, which need to build a high-performance server to provide authentication services. If the server hangs, then all the blacklist validation will be considered as passed, which has some security risks.</p>
<h4 id="ocsp-stapling">OCSP Stapling</h4>
<p>OCSP Stapling is an extension of OCSP standard, the main goal is to improve performance and security. The certificate owner itself sends requests to OCSP server periodically. The OCSP response is time-stamped and signed directly by the CA.</p>
<p>OCSP Stapling improves the overall performance, on the one hand, the certificate verifier does not need to directly request CA&rsquo;s server to query the status, on the other hand, the pressure on CA&rsquo;s OCSP server is reduced.</p>
<h3 id="server-name-indication-sni">Server Name Indication (SNI)</h3>
<p>When multiple Servers are deployed on a site (equivalent to multiple domains mapped to one IP), different Servers may need to use different certificates. The problem is how to know which host to access in the SSL handshake phase (not yet in the HTTP phase, can&rsquo;t use the <code>HOST</code> field in the request header), so as to decide to use the corresponding certificate?</p>
<p>SNI is designed to solve this problem by adding SNI to the <code>ClientHello</code> extension so that the server can know which host it needs to access and choose the appropriate certificate.</p>
<h2 id="gmssl-protocol-differences">GMSSL Protocol Differences</h2>
<p>GMSSL is modified from TLS1.1, and in general there is not much difference with TLS protocol. See GMT 0024-2014 SSL VPN Technical Specification for more details.</p>
<h3 id="protocol-number">Protocol Number</h3>
<p>The protocol numbers of TLSv1.0, TSLv1.1, TLSv1.2, TLSv1.3 are <code>0x0301</code>, <code>0x0302</code>, <code>0x0303</code>, <code>0x0304</code> respectively.</p>
<p>And the version number of State Secrets is <code>0x0101</code>.</p>
<h3 id="algorithm-suite">Algorithm suite</h3>
<p>There are several algorithm suites defined, such as <code>ECC_SM4_SM3</code> and <code>ECDHE_SM4_SM3</code>. <code>ECDHE_SM4_SM3</code> requires bi-directional authentication.</p>
<p>The key exchange process for <code>ECC_SM4_SM3</code> is similar to the RSA key exchange process, where the client encrypts the premaster key with the server&rsquo;s public key and sends it to the server. The key exchange process of <code>ECDHE_SM4_SM3</code> is similar to the ECDHE key exchange of normal TLS, where the pre-primary key is derived by both the client and the server. The authentication of both <code>ECC_SM4_SM3</code> and <code>ECDHE_SM4_SM3</code> is done by signature/checking of SM2.</p>
<h3 id="dual-certificate-system">Dual certificate system</h3>
<h4 id="certificate-message">Certificate Message</h4>
<p>SMIT SSL uses a dual certificate system: one signature certificate and one encryption certificate. The signing certificate is used for authentication and the encryption certificate is used for key exchange. When sending a <code>Certificate</code> message, two certificates should be sent at the same time, the format is the same as the standard TLS message format, the first certificate is the signing certificate and the second certificate is the encryption certificate.</p>
<h4 id="ecc_sm4_sm3-key-exchange">ECC_SM4_SM3 key exchange</h4>
<p>Because of the dual certificate system, it is slightly different in the SSL state machine. The key exchange process for <code>ECC_SM4_SM3</code> is as follows: the server sends a <code>Certificate</code> message followed by a <code>ServerKeyExchange</code> message (which is different from the RSA key exchange), the <code>ServerKeyExchange</code> contains a signature value, which is signed by the private key (the signing private key) corresponding to the server&rsquo;s signing certificate. The signature is computed by the private key (signature private key) corresponding to the server-side signature certificate, and the content of the signature includes the random numbers in ClientHello and ServerHello as well as the encryption certificate.</p>
<p>After the client verifies the certificate and signature, it encrypts the pre-master key using the server-side encryption certificate and sends it to the server, which then decrypts the pre-master key by its own encryption private key.</p>
<h4 id="ecdhe_sm4_sm3-key-exchange">ECDHE_SM4_SM3 key exchange</h4>
<p>The key exchange process for <code>ECDHE_SM4_SM3</code> is as follows: after the server sends a <code>Certificate</code> message, it also sends a <code>ServerKeyExchange</code> message, the <code>ServerKeyExchange</code> contains a signature value, and the signature is calculated by the private key (signing private key) corresponding to the server&rsquo;s signing certificate . The content of the signature is different from that of <code>ECC_SM4_SM3</code>, including the random numbers in ClientHello and ServerHello and the server-side ECDH parameters (curve, public key). The key derivation method of ECDHE is also different from that of TLS. TLS only needs the temporary public key of the other party and its own temporary private key to participate in the calculation, while the State Secret needs the temporary public key and fixed public key of the other party (i.e. the public key in the encryption certificate) and its own temporary private key and fixed private key (i.e. the encryption private key) to participate in the calculation. Therefore, the national secret <code>ECDHE</code> must be a two-way authentication, because the server side also needs to use the client&rsquo;s encryption certificate when the key derivation is performed.</p>
<p>After verifying the certificate and signature, the client sends its own certificate to the server, and then generates its own temporary key according to the ECDH parameter information in <code>ServerKeyExchange</code>, and then performs key derivation with its own encryption key, the temporary public key and encryption public key of the server to get the pre-master key. The server side also uses its own temporary key, encryption key, client&rsquo;s temporary public key and encryption public key to perform key derivation to get the pre-master key.</p>
<p>Because it is a two-way authentication, the client needs to send a <code>CertificateVerify</code> message after sending the <code>ClientKeyExchange</code> message, signed by all the handshake messages that have been exchanged so far, starting from the ClientHello message.</p>
<h3 id="security">Security</h3>
<h3 id="common-attacks">Common Attacks</h3>
<p>Some are for protocol design vulnerabilities, others are for implementation bugs, often used in combination with degradation attacks. For space reasons, only two representative renegotiation attacks and Heartbleed are highlighted here, for the rest of the attacks you can refer to <a href="https://datatracker.ietf.org/doc/html/rfc7457">rfc7457 - Summary of Known Attacks</a></p>
<h4 id="renegotiation-attacks">renegotiation attacks</h4>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/553d10d5c33b46a8a7dc87035bdbb9f8.png" alt="renegotiation attacks"></p>
<p>The man-in-the-middle successfully inserts his forged data before the real data of the user without hijacking and decrypting the SSL/TLS connection. The man-in-the-middle, if he understands the APP protocol (e.g. HTTPS), will carefully construct incomplete data to make the server&rsquo;s APP program think a sticky packet has occurred, put the data on hold and continue to wait for the subsequent data to come up. For example, the attacker first sent the following &ldquo;half&rdquo; request.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">GET /bank/sendmoney.asp?acct<span class="o">=</span>attacker<span class="p">&amp;</span><span class="nv">amount</span><span class="o">=</span><span class="m">1000000</span> 
X-Ignore-This:
</code></pre></td></tr></table>
</div>
</div><p>Later, when the client sends over the real request</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt">GET /ebanking 
Cookie: validcookie
</code></pre></td></tr></table>
</div>
</div><p>The APP program splices the request, and the real request header is blocked, but it keeps the user&rsquo;s cookie information, thus using the user&rsquo;s cookie to access the website content. The server side will think that the request sent in front is sent by the real client.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">GET /bank/sendmoney.asp?acct<span class="o">=</span>attacker<span class="p">&amp;</span><span class="nv">amount</span><span class="o">=</span><span class="m">1000000</span> 
X-Ignore-This: GET /ebanking HTTP/1.1
Cookie: validcookie
</code></pre></td></tr></table>
</div>
</div><p>This vulnerability is caused by what the client thinks is the first negotiation but the server thinks is a renegotiation, and the lack of correlation between the first negotiation and the renegotiation. The workaround is to disable renegotiation or use <a href="https://datatracker.ietf.org/doc/html/rfc5746">secure renegotiation</a>. Secure renegotiation adds a secure renegotiation flag and an associativity check to confirm the first negotiation and renegotiation, thus ensuring that man-in-the-middle attacks can be identified and rejected and renegotiation secured.</p>
<p>Let&rsquo;s see how security renegotiation is secured, for the previous case where ClientHello2 does not carry a security renegotiation representation inside.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/6637c380ed4643ed841af24d85302929.png" alt="ClientHello2 does not carry a security renegotiation representation inside"></p>
<p>For the previous case of ClientHello2 carrying a secure renegotiation representation inside.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/f9bf92bc99cd4c66bec1d3b523c2a234.png" alt="ClientHello2 carrying a secure renegotiation representation inside"></p>
<p>In either case, the middleman is guaranteed to be untouchable. And the hallmark of this security renegotiation is the provision of a new extension <code>renegotiation_info</code> . Since SSLv3/TLS 1.0 does not support extensions, an alternative approach is provided by adding <code>TLS_EMPTY_RENEGOTIATION_INFO_SCSV(0xFF)</code> to the list of algorithm suites, which is not a real algorithm suite but only serves as an identifier.</p>
<p>The process of security renegotiation is as follows.</p>
<ol>
<li>During the first SSL handshake when the connection is established, both parties notify each other of their support for secure renegotiation via the <code>renegotiation_info</code> extension or the <code>SCSV</code> suite</li>
<li>Then after the handshake, both client and server record <code>client_verify_data</code> and <code>server_verify_data</code> in the <code>Finish</code> message respectively.</li>
<li>When renegotiating, client includes <code>client_verify_data</code> in <code>ClientHello</code> and server includes <code>client_verify_data</code> and <code>server_verify_data</code> in <code>ServerHello</code>. For victims, if these data are not carried in the negotiation, the connection cannot be established. And since the Finished message is encrypted, the attacker cannot get the values of client_verify_data and server_verify_data.</li>
</ol>
<h4 id="heartbleed">Heartbleed</h4>
<p><a href="https://heartbleed.com/">Heartbleed</a>, This is a bug in the implementation of the OpenSSL library, not in the TLS protocol itself, and is caused by the implementation of the TLS heartbeat extension not performing proper input validation (lack of bounds checking), which is also named after heartbeat. The failure to perform boundary checking resulted in more data being read than was allowed.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/44bce3aece4944cea59be2e3e6d33e0e.png" alt="Heartbleed"></p>
<p>This bug is currently having a very widespread impact, with surveys showing that many sites are still exposed to this attack years after the vulnerability was announced. This bug warns us that even if the protocol is secure, the implementation can still introduce security problems. Security is like a barrel, where the overall security depends on the shortest board.</p>
<h4 id="crime-and-breach-attacks">CRIME and BREACH attacks</h4>
<p>Both attacks are based on compression algorithms, which can decrypt certain information by changing the request body and comparing the length of the ciphertext after being compressed.</p>
<p>CRIME is able to decrypt session cookies by running JavaScript code in the victim&rsquo;s browser and listening to HTTPS transmission data at the same time, mainly for TLS compression.</p>
<p>The Javascript code attempts to brute force the cookie value one by one. The man-in-the-middle component is able to observe the ciphertext of each cracked request and response, looking for differences, and once one is found, he communicates with the Javascript performing the crack and continues to crack the next one.</p>
<p>BREACH attack is an upgraded version of CRIME attack, the attack method is the same as CRIME, the difference is that BREACH utilizes not SSL/TLS compression, but HTTP compression. So to defend against BREACH attack you must disable HTTP compression.</p>
<h4 id="beast-attack">BEAST attack</h4>
<p>Prior to TLS version 1.1, the IV of the next record was a direct use of the ciphertext of the previous record. the BEAST attack exploits this, where the attacker controls the victim to send a large number of requests and guesses critical information using predictable IVs. The solution is to deploy TLS 1.1 or higher.</p>
<h4 id="rc4-attack">RC4 attack</h4>
<p>Based on the security of the RC4 algorithm, RC4 is currently insecure and should be disabled.</p>
<h4 id="poodle-attack">POODLE Attack</h4>
<p>is an SSL 3.0 design vulnerability that uses non-deterministic CBC-padding, making it easier for a man-in-the-middle attacker to obtain plaintext data via a padding-oracle attack.</p>
<h4 id="downgrade-attack-version-fallback-attack">Downgrade attack (version fallback attack)</h4>
<p>Trick a server into using a lower version of the insecure TLS protocol, often used in combination with other attacks. Removing backward compatibility is usually the only way to prevent degradation attacks.</p>
<h3 id="forward-security">Forward security</h3>
<p>Without forward security, once the private key is leaked, not only future sessions will be affected, but all past sessions will be affected as well. A patient hacker can first save the previously intercepted data first, and once the private key is leaked or cracked, he can crack all the previous ciphertexts. This is called <strong>intercept today, crack tomorrow</strong> .</p>
<p>One of the implementations of TLS is to generate session keys by using a temporary DH key exchange, and <strong>one cipher at a time</strong> ensures that even if a hacker goes to great lengths to crack the session key this time, only this communication will be attacked, and the previous historical messages will not be affected. This we already talked about in part 1.</p>
<p>But even if a temporary DH key exchange is used, the session management mechanism on the server side affects the forward security. In the previous section on session reuse we talked about session ticket, whose protection is entirely dependent on symmetric encryption, so a long valid session ticket key prevents the implementation of forward security.</p>
<p>In practice, the temporary DH key exchange class algorithm suite should be used in preference, the validity of session should not be set too long, and the key of session ticket should be changed frequently.</p>
<h2 id="tls-13-new-features">TLS 1.3 New Features</h2>
<p>TLS 1.3 is a huge change from TLS 1.2, with the main goals being <strong>maximum compatibility</strong>, <strong>enhanced security</strong>, and <strong>improved performance</strong>.</p>
<p>The following are the <strong>major differences</strong> compared to TLS 1.3.</p>
<ul>
<li>Symmetric encryption algorithm retains only the AEAD class of algorithms, separating the key exchange and authentication algorithms from the concept of algorithm suites</li>
<li>0-RTT mode has been added</li>
<li>Removed static RSA and DH key negotiation (all public key-based key exchanges now provide forward security)</li>
<li>All handshake messages after <code>ServerHello</code> are now encrypted</li>
<li>Key derivation function redesigned, KDF replaced with standard <code>HKDF</code></li>
<li>The handshake state machine has been significantly refactored, cutting out redundant messages such as <code>ChangeCipherSpec</code></li>
<li>Use a unified PSK model, replacing the previous Session Resumption (including Session ID and Session Ticket) and the earlier TLS version of the PSK-based (rfc4279) algorithm suite</li>
</ul>
<p>A few key features are introduced here</p>
<h3 id="key-exchange-modes">Key Exchange Modes</h3>
<p>TLS 1.3 proposes 3 modes of key exchange.</p>
<ul>
<li>(EC)DHE</li>
<li>PSK-only (pre-shared symmetric key)</li>
<li>PSK with (EC)DHE A combination of the first two with forward security</li>
</ul>
<h3 id="1-rtt-handshake">1-RTT handshake</h3>
<p>As mentioned earlier, the full TLS 1.2 handshake has 2 RTTs, the first RTT is <code>ClientHello/ServerHello</code> and the second RTT is <code>ServerKeyExchange/ClientKeyExchange</code>. The reason why two RTTs are needed is that TLS 1.2 supports a variety of key exchange algorithms and different parameters, which all rely on the first RTT to negotiate out. <code>ECDH P-256</code> or <code>X25519</code>. So simply let the client cache what key exchange algorithm the server used last time, and merge <code>KeyExchange</code> directly into the first RTT. if the server finds that the algorithm sent up by the client is not correct, then tell it the correct one and let the client retry. (This introduces the <code>HelloRetryRequest</code> message). This basically has no side effects, and it&rsquo;s down to 1-RTT.</p>
<p>The full handshake flow for TLS 1.3 is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt">       Client                                           Server

Key  ^ ClientHello
Exch | + key_share*
     | + signature_algorithms*
     | + psk_key_exchange_modes*
     v + pre_shared_key*       --------&gt;
                                                  ServerHello  ^ Key
                                                 + key_share*  | Exch
                                            + pre_shared_key*  v
                                        {EncryptedExtensions}  ^  Server
                                        {CertificateRequest*}  v  Params
                                               {Certificate*}  ^
                                         {CertificateVerify*}  | Auth
                                                   {Finished}  v
                               &lt;--------  [Application Data*]
     ^ {Certificate*}
Auth | {CertificateVerify*}
     v {Finished}              --------&gt;
       [Application Data]      &lt;-------&gt;  [Application Data]

              +  Indicates noteworthy extensions sent in the
                 previously noted message.

              *  Indicates optional or situation-dependent
                 messages/extensions that are not always sent.

              {} Indicates messages protected using keys
                 derived from a [sender]_handshake_traffic_secret.

              [] Indicates messages protected using keys
                 derived from [sender]_application_traffic_secret_N.

               Figure 1: Message Flow for Full TLS Handshake
</code></pre></td></tr></table>
</div>
</div><p>The handshake process can be divided into three phases.</p>
<ul>
<li>Key exchange: Shared key material is established and encryption parameters are selected. All messages after this phase are encrypted.</li>
<li>Server-side parameters: Establish other handshake parameters, such as whether the client needs authentication, application layer protocol support</li>
<li>Authentication: Authentication, provide key confirmation and handshake integrity</li>
</ul>
<h3 id="reuse-and-psk">Reuse and PSK</h3>
<p>PSKs for TLS can be established directly out-of-band or through the session of the previous connection. Once a handshake is complete, the server sends the client a PSK id corresponding to the key derived from the initial handshake. (This corresponds to the Session ID and Session Tickets of TLS 1.2 and earlier, both of which are deprecated in TLS 1.3).</p>
<p>PSK can be used alone or in combination with (EC)DHE key exchange to provide forward security.</p>
<p>The reuse and PSK handshake flow is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt">       Client                                               Server

Initial Handshake:
       ClientHello
       + key_share               --------&gt;
                                                       ServerHello
                                                       + key_share
                                             {EncryptedExtensions}
                                             {CertificateRequest*}
                                                    {Certificate*}
                                              {CertificateVerify*}
                                                        {Finished}
                                 &lt;--------     [Application Data*]
       {Certificate*}
       {CertificateVerify*}
       {Finished}                --------&gt;
                                 &lt;--------      [NewSessionTicket]
       [Application Data]        &lt;-------&gt;      [Application Data]


Subsequent Handshake:
       ClientHello
       + key_share*
       + pre_shared_key          --------&gt;
                                                       ServerHello
                                                  + pre_shared_key
                                                      + key_share*
                                             {EncryptedExtensions}
                                                        {Finished}
                                 &lt;--------     [Application Data*]
       {Finished}                --------&gt;
       [Application Data]        &lt;-------&gt;      [Application Data]

            Figure 3: Message Flow for Resumption and PSK
</code></pre></td></tr></table>
</div>
</div><p>The identity of the server in this case is authenticated by PSK, so the server does not send <code>Certficate</code> and <code>CertificateVerify</code> messages. When the client proposes reuse via PSK, the <code>key_share</code> extension should also be provided to allow the server to fall back to a full handshake if reuse is rejected.</p>
<h3 id="0-rtt-handshake-with-side-effects">0-RTT handshake with side effects</h3>
<p>When the client and server share a PSK (either obtained externally or through the preceding handshake), TLS 1.3 allows the client to send data (early data) on the first flight. The client uses the PSK to authenticate the server and encrypt the early data.</p>
<p>The 0-RTT handshake flow is as follows, with the addition of the <code>early_data</code> extension and the 0-RTT application data on the first flight compared to the 1-RTT handshake with PSK reuse. After receiving the <code>Finished</code> message from the server, an <code>EndOfEarlyData</code> message is sent to indicate the replacement of the encryption key later.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt">Client                                               Server

ClientHello
+ early_data
+ key_share*
+ psk_key_exchange_modes
+ pre_shared_key
(Application Data*)     --------&gt;
                                                ServerHello
                                           + pre_shared_key
                                               + key_share*
                                      {EncryptedExtensions}
                                              + early_data*
                                                 {Finished}
                        &lt;--------       [Application Data*]
(EndOfEarlyData)
{Finished}              --------&gt;
[Application Data]      &lt;-------&gt;        [Application Data]

      +  Indicates noteworthy extensions sent in the
         previously noted message.

      *  Indicates optional or situation-dependent
         messages/extensions that are not always sent.

      () Indicates messages protected using keys
         derived from a client_early_traffic_secret.

      {} Indicates messages protected using keys
         derived from a [sender]_handshake_traffic_secret.

      [] Indicates messages protected using keys
         derived from [sender]_application_traffic_secret_N.

      Figure 4: Message Flow for a 0-RTT Handshake
</code></pre></td></tr></table>
</div>
</div><p>The data security of 0-RTT is weak.</p>
<ul>
<li>0-RTT data has no forward security because its encryption key is purely derived from PSK</li>
<li>Application data in 0-RTT can be replayed across connections (regular TLS 1.3 1-RTT data is replay-proof via random numbers on the server side)</li>
</ul>
<h3 id="key-derivation-process">Key derivation process</h3>
<p>The key derivation process uses the HKDF-Extract and HKDF-Expand functions, and the following functions</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-h" data-lang="h"><span class="n">HKDF</span><span class="o">-</span><span class="n">Expand</span><span class="o">-</span><span class="n">Label</span><span class="p">(</span><span class="n">Secret</span><span class="p">,</span> <span class="n">Label</span><span class="p">,</span> <span class="n">Context</span><span class="p">,</span> <span class="n">Length</span><span class="p">)</span> <span class="o">=</span>
      <span class="n">HKDF</span><span class="o">-</span><span class="n">Expand</span><span class="p">(</span><span class="n">Secret</span><span class="p">,</span> <span class="n">HkdfLabel</span><span class="p">,</span> <span class="n">Length</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>where <code>HkdfLabel</code> indicates</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="p">{</span>
  <span class="n">uint16</span> <span class="n">length</span> <span class="o">=</span> <span class="n">Length</span><span class="p">;</span>
  <span class="n">opaque</span> <span class="n">label</span><span class="o">&lt;</span><span class="mf">7..255</span><span class="o">&gt;</span> <span class="o">=</span> <span class="s">&#34;tls13 &#34;</span> <span class="o">+</span> <span class="n">Label</span><span class="p">;</span>
  <span class="n">opaque</span> <span class="n">context</span><span class="o">&lt;</span><span class="mf">0..255</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">Context</span><span class="p">;</span>
<span class="p">}</span> <span class="n">HkdfLabel</span><span class="p">;</span>

<span class="n">Derive</span><span class="o">-</span><span class="n">Secret</span><span class="p">(</span><span class="n">Secret</span><span class="p">,</span> <span class="n">Label</span><span class="p">,</span> <span class="n">Messages</span><span class="p">)</span> <span class="o">=</span> <span class="n">HKDF</span><span class="o">-</span><span class="n">Expand</span><span class="o">-</span><span class="n">Label</span><span class="p">(</span>
  <span class="n">Secret</span><span class="p">,</span> <span class="n">Label</span><span class="p">,</span> <span class="n">Transcript</span><span class="o">-</span><span class="n">Hash</span><span class="p">(</span><span class="n">Messages</span><span class="p">),</span> <span class="n">Hash</span><span class="p">.</span><span class="n">length</span><span class="p">)</span>

</code></pre></td></tr></table>
</div>
</div><p>No matter which key exchange mode is given to go through the whole process below, when there is no corresponding input key material (IKM), the corresponding position is replaced with a 0-value string of Hash length. For example, if there is no PSK, Early Secret is <code>HKDF-Extract(0, 0)</code>.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/24/218cdf57e02a4314bf21ecec4fe135fd.png" alt="HKDF-Extract(0, 0)"></p>
<p>where <code>exporter_secret</code> is the export key for other user-defined purposes. <code>resumption_master_secret</code> is used to generate tickets <code>client_early_traffic_secret</code> is used to derive the early-data key for 0-RTT, <code>*_handshake_traffic_secret</code> is used to derive the encryption key for handshake messages , <code>*_application_traffic_secret_N</code> for deriving the encryption key for application messages.</p>
<h2 id="common-implementations">Common Implementations</h2>
<p>OpenSSL: very popular open source implementation, largest amount of code, worst written?</p>
<p>LibreSSL: also a fork of OpenSSL, OpenBSD project</p>
<p>BoringSSL: a fork of OpenSSL, mainly used in Google&rsquo;s Chrome/Chromium, Android and other applications</p>
<p>JSSE (Java Secure Socket Extension): Java implementation</p>
<p>NSS: a library originally developed by Netscape, now mainly used by browsers and client software, for example Firefox uses the NSS library (developed by Mozilla).</p>
<p>go.crypto: Go language implementation</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/ssl/">ssl</a>
          <a href="/tags/tls/">tls</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-03/ssl-gmvpn-handlshake/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">SSL and GMVPN Handshake Protocol Explained</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-03/function-calling-conventions-in-c/">
            <span class="next-text nav-default">Function calling conventions in C</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
