<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>When will variables caught by closures be recycled in Go? - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="This article explains in detail when variables caught by closures are reclaimed in Go." /><meta name="keywords" content="golang, gc, Closures, Variables" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-03/when-variables-captured-by-closures-are-recycled-in-go/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="When will variables caught by closures be recycled in Go?" />
<meta property="og:description" content="This article explains in detail when variables caught by closures are reclaimed in Go." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-03/when-variables-captured-by-closures-are-recycled-in-go/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-03-26T11:53:27+08:00" />
<meta property="article:modified_time" content="2022-03-26T11:53:27+08:00" />

<meta itemprop="name" content="When will variables caught by closures be recycled in Go?">
<meta itemprop="description" content="This article explains in detail when variables caught by closures are reclaimed in Go."><meta itemprop="datePublished" content="2022-03-26T11:53:27+08:00" />
<meta itemprop="dateModified" content="2022-03-26T11:53:27+08:00" />
<meta itemprop="wordCount" content="1962">
<meta itemprop="keywords" content="golang," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="When will variables caught by closures be recycled in Go?"/>
<meta name="twitter:description" content="This article explains in detail when variables caught by closures are reclaimed in Go."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">When will variables caught by closures be recycled in Go?</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-03-26 11:53:27 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 1962 words </span>
          <span class="more-meta"> 10 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#1-go-function-closures">1. Go function closures</a></li>
        <li><a href="#2-go-closure-function-objects">2. Go closure function objects</a></li>
        <li><a href="#3-summary">3. Summary</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/26/9a5abd5acfec43da82591072bf62210d.png" alt="go gc closures"></p>
<h2 id="1-go-function-closures">1. Go function closures</h2>
<p>The Go language provides native support for closures. In Go, closures are <a href="https://tip.golang.org/ref/spec#Function_literals">function literals</a>. The Go specification interprets closures in the following way.</p>
<blockquote>
<p>function literals are closures: they can refer to variables defined in their wrapping function. These variables are then shared between the wrapping function and the function literals, and they continue to exist as long as they can be accessed.</p>
</blockquote>
<p>Closures have a wide range of applications in Go, most often used in conjunction with the go keyword to create a new goroutine, such as the following code from the net/http package in the standard library.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// $GOROOT/src/net/http/fileTransport.go
</span><span class="c1"></span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">fileTransport</span><span class="p">)</span> <span class="nf">RoundTrip</span><span class="p">(</span><span class="nx">req</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">(</span><span class="nx">resp</span> <span class="o">*</span><span class="nx">Response</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">rw</span><span class="p">,</span> <span class="nx">resc</span> <span class="o">:=</span> <span class="nf">newPopulateResponseWriter</span><span class="p">()</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">fh</span><span class="p">.</span><span class="nf">ServeHTTP</span><span class="p">(</span><span class="nx">rw</span><span class="p">,</span> <span class="nx">req</span><span class="p">)</span>
        <span class="nx">rw</span><span class="p">.</span><span class="nf">finish</span><span class="p">()</span>
    <span class="p">}()</span>
    <span class="k">return</span> <span class="o">&lt;-</span><span class="nx">resc</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The RoundTrip method in the above code creates a new goroutine using the go keyword in combination with closures, and the function running in this goroutine also references the variables that belong to its external wrapper function: t, rw, and req, or both share these variables.</p>
<p>Once a variable that was only used inside the RoundTrip method is &ldquo;shared&rdquo; with another function, it cannot be allocated on the stack and escaping to the heap is a deterministic event.</p>
<p>So here&rsquo;s the problem! When can these external variables allocated on the heap that are referenced or called <strong>captured by closure</strong> be reclaimed? Perhaps the above example is still very easy to understand; these variables can be reclaimed when the newly created goroutine finishes executing. What about the following closure function?</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">foo</span><span class="p">()</span> <span class="kd">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="nx">i</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">15</span><span class="p">:</span> <span class="mi">128</span><span class="p">}</span>
    <span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
        <span class="nx">n</span><span class="o">+=</span><span class="nx">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="nx">n</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>In this foo function, when can the slice variable i of length 16, which is captured by the closure function, be reclaimed?</p>
<blockquote>
<p>Note: When we define closures, we like to use the term variable that references the external wrapper function, but in the <a href="https://github.com/golang/go/tree/master/src/cmd/compile/internal/gc/closure.go">Go compiler implementation code</a>, we use is capture var, which translates to &ldquo;captured variables&rdquo;, so the term &ldquo;<strong>capture</strong>&rdquo; is also used here to denote variables in externally wrapped functions or even further functions that are shared by the closure.</p>
</blockquote>
<p>The return value type of the foo function is a function, which means that the local variable i of the foo function is captured by the newly created closure function returned by foo and i is not reclaimed. Usually a memory object on the heap has a clear reference to it or a pointer to its address before it survives and is reclaimed by GC when it is unreachable, that is, when there is no more reference to it or a pointer to it.</p>
<p>So, who exactly is variable i referenced by? When will variable i be reclaimed?</p>
<p>Let&rsquo;s first go back to a general function that is not a closure.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">f1</span><span class="p">()</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
    <span class="nx">i</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">15</span><span class="p">:</span> <span class="mi">128</span><span class="p">}</span>
    <span class="k">return</span> <span class="nx">i</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">f2</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">sl</span> <span class="o">:=</span> <span class="nf">f1</span><span class="p">()</span>
    <span class="nx">sl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="nx">sl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">10</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">sl</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">f2</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>We see that after f1 returns its own local slice variable i, the variable is referenced by sl in the f2 function. After the execution of the f2 function is complete, the slice variable i will become unreachable and the GC will reclaim the heap memory corresponding to the variable.</p>
<p>If we switch to a closure function, such as the foo function earlier, we are likely to use it in this way.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// https://github.com/bigwhite/experiments/tree/master/closure/closure1.go
</span><span class="c1"></span>
<span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
<span class="kd">func</span> <span class="nf">foo</span><span class="p">()</span> <span class="kd">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="nx">i</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">15</span><span class="p">:</span> <span class="mi">128</span><span class="p">}</span>
    <span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
        <span class="nx">n</span> <span class="o">+=</span> <span class="nx">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="nx">n</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">bar</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">f</span> <span class="o">:=</span> <span class="nf">foo</span><span class="p">()</span>
    <span class="nx">a</span> <span class="o">:=</span> <span class="nf">f</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">bar</span><span class="p">()</span>
    <span class="nx">g</span> <span class="o">:=</span> <span class="nf">foo</span><span class="p">()</span>
    <span class="nx">b</span> <span class="o">:=</span> <span class="nf">g</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>In the example here, the local variables of the foo function are referenced whenever they are in the closure function. This suddenly reminds me of the &ldquo;functions are also first-class citizens feature in Go&rdquo;. Could it be that the closure function is an object that references the local variables of the foo function? Then how does the closure function refer to the local integer slice variable i of the foo function on the memory layout? What is the closure function mapped to in the memory layout?</p>
<blockquote>
<p>If a programming language has no restrictions on the creation and use of certain language elements, and we can treat such syntax elements like value, then we call such syntax elements &ldquo;first-class citizens&rdquo; of the programming language.</p>
</blockquote>
<h2 id="2-go-closure-function-objects">2. Go closure function objects</h2>
<p>To answer this question, we have to ask <a href="https://tip.golang.org/doc/asm">Go assembly</a> for help. We generate the above assembly code for closure1.go (we use go compiler version 1.16.5).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="nv">$go</span> tool compile -S closure1.go &gt; closure1.s
</code></pre></td></tr></table>
</div>
</div><p>In the assembly code, we find the assembly code corresponding to the creation of a closure function at line 7 in closure1.go.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">// https://github.com/bigwhite/experiments/tree/master/closure/closure1.s

    0x0052 <span class="m">00082</span> <span class="o">(</span>closure1.go:7<span class="o">)</span>    LEAQ    type.noalg.struct <span class="o">{</span> F uintptr<span class="p">;</span> <span class="s2">&#34;&#34;</span>.i <span class="o">[]</span>int <span class="o">}(</span>SB<span class="o">)</span>, CX
    0x0059 <span class="m">00089</span> <span class="o">(</span>closure1.go:7<span class="o">)</span>    MOVQ    CX, <span class="o">(</span>SP<span class="o">)</span>
    0x005d <span class="m">00093</span> <span class="o">(</span>closure1.go:7<span class="o">)</span>    PCDATA  <span class="nv">$1</span>, <span class="nv">$1</span>
    0x005d <span class="m">00093</span> <span class="o">(</span>closure1.go:7<span class="o">)</span>    NOP
    0x0060 <span class="m">00096</span> <span class="o">(</span>closure1.go:7<span class="o">)</span>    CALL    runtime.newobject<span class="o">(</span>SB<span class="o">)</span>
    0x0065 <span class="m">00101</span> <span class="o">(</span>closure1.go:7<span class="o">)</span>    MOVQ    8<span class="o">(</span>SP<span class="o">)</span>, AX
    0x006a <span class="m">00106</span> <span class="o">(</span>closure1.go:7<span class="o">)</span>    LEAQ    <span class="s2">&#34;&#34;</span>.foo.func1<span class="o">(</span>SB<span class="o">)</span>, CX
    0x0071 <span class="m">00113</span> <span class="o">(</span>closure1.go:7<span class="o">)</span>    MOVQ    CX, <span class="o">(</span>AX<span class="o">)</span>
    0x0074 <span class="m">00116</span> <span class="o">(</span>closure1.go:7<span class="o">)</span>    MOVQ    <span class="nv">$16</span>, 16<span class="o">(</span>AX<span class="o">)</span>
    0x007c <span class="m">00124</span> <span class="o">(</span>closure1.go:7<span class="o">)</span>    MOVQ    <span class="nv">$16</span>, 24<span class="o">(</span>AX<span class="o">)</span>
    0x0084 <span class="m">00132</span> <span class="o">(</span>closure1.go:7<span class="o">)</span>    PCDATA  <span class="nv">$0</span>, <span class="nv">$-</span><span class="m">2</span>
    0x0084 <span class="m">00132</span> <span class="o">(</span>closure1.go:7<span class="o">)</span>    CMPL    runtime.writeBarrier<span class="o">(</span>SB<span class="o">)</span>, <span class="nv">$0</span>
    0x008b <span class="m">00139</span> <span class="o">(</span>closure1.go:7<span class="o">)</span>    JNE <span class="m">165</span>
    0x008d <span class="m">00141</span> <span class="o">(</span>closure1.go:7<span class="o">)</span>    MOVQ    <span class="s2">&#34;&#34;</span>..autotmp_7+16<span class="o">(</span>SP<span class="o">)</span>, CX
    0x0092 <span class="m">00146</span> <span class="o">(</span>closure1.go:7<span class="o">)</span>    MOVQ    CX, 8<span class="o">(</span>AX<span class="o">)</span>
    0x0096 <span class="m">00150</span> <span class="o">(</span>closure1.go:7<span class="o">)</span>    PCDATA  <span class="nv">$0</span>, <span class="nv">$-</span><span class="m">1</span>
    0x0096 <span class="m">00150</span> <span class="o">(</span>closure1.go:7<span class="o">)</span>    MOVQ    AX, <span class="s2">&#34;&#34;</span>.~r0+40<span class="o">(</span>SP<span class="o">)</span>
    0x009b <span class="m">00155</span> <span class="o">(</span>closure1.go:7<span class="o">)</span>    MOVQ    24<span class="o">(</span>SP<span class="o">)</span>, BP
    0x00a0 <span class="m">00160</span> <span class="o">(</span>closure1.go:7<span class="o">)</span>    ADDQ    <span class="nv">$32</span>, SP
    0x00a4 <span class="m">00164</span> <span class="o">(</span>closure1.go:7<span class="o">)</span>    RET
    0x00a5 <span class="m">00165</span> <span class="o">(</span>closure1.go:7<span class="o">)</span>    PCDATA  <span class="nv">$0</span>, <span class="nv">$-</span><span class="m">2</span>
    0x00a5 <span class="m">00165</span> <span class="o">(</span>closure1.go:7<span class="o">)</span>    LEAQ    8<span class="o">(</span>AX<span class="o">)</span>, DI
    0x00a9 <span class="m">00169</span> <span class="o">(</span>closure1.go:7<span class="o">)</span>    MOVQ    <span class="s2">&#34;&#34;</span>..autotmp_7+16<span class="o">(</span>SP<span class="o">)</span>, CX
    0x00ae <span class="m">00174</span> <span class="o">(</span>closure1.go:7<span class="o">)</span>    CALL    runtime.gcWriteBarrierCX<span class="o">(</span>SB<span class="o">)</span>
    0x00b3 <span class="m">00179</span> <span class="o">(</span>closure1.go:7<span class="o">)</span>    JMP <span class="m">150</span>
    0x00b5 <span class="m">00181</span> <span class="o">(</span>closure1.go:7<span class="o">)</span>    NOP
</code></pre></td></tr></table>
</div>
</div><p>The assembly is always obscure. Let&rsquo;s focus on the first line.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"> 0x0052 <span class="m">00082</span> <span class="o">(</span>closure1.go:7<span class="o">)</span>    LEAQ    type.noalg.struct <span class="o">{</span> F uintptr<span class="p">;</span> <span class="s2">&#34;&#34;</span>.i <span class="o">[]</span>int <span class="o">}(</span>SB<span class="o">)</span>, CX
</code></pre></td></tr></table>
</div>
</div><p>We see that line 7, which corresponds to the creation of the closure function in the Go source code, this line of assembly code roughly means to put the address of a structure object into CX. let&rsquo;s extract this structure object.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">F</span> <span class="kt">uintptr</span>
    <span class="nx">i</span> <span class="p">[]</span><span class="kt">int</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Where does this structure object come from? Apparently the Go compiler created it based on the &ldquo;characteristics&rdquo; of the closure function. The F is the address of the closure function itself, which after all is a function, and should be in the same memory area as a normal function (like the read-only data area of rodata), but what about the integer slice variable i? Is this the local variable i of the Foo function that is captured by the closure function. Exactly. If you don&rsquo;t believe me, we can define another closure function that captures more variables to verify it.</p>
<p>Here is the generator function for a closure function that captures 3 integer variables.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// https://github.com/bigwhite/experiments/tree/master/closure/closure2.go
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">foo</span><span class="p">()</span> <span class="kd">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span> <span class="kt">int</span> <span class="p">=</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span>
    <span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
        <span class="nx">a</span> <span class="o">+=</span> <span class="nx">n</span>
        <span class="nx">b</span> <span class="o">+=</span> <span class="nx">n</span>
        <span class="nx">c</span> <span class="o">+=</span> <span class="nx">n</span>
        <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span> <span class="o">+</span> <span class="nx">c</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The structure of that closure function in its corresponding assembly code is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">0x0084 <span class="m">00132</span> <span class="o">(</span>closure2.go:10<span class="o">)</span>   LEAQ    type.noalg.struct <span class="o">{</span> F uintptr<span class="p">;</span> <span class="s2">&#34;&#34;</span>.a *int<span class="p">;</span> <span class="s2">&#34;&#34;</span>.b *int<span class="p">;</span> <span class="s2">&#34;&#34;</span>.c *int <span class="o">}(</span>SB<span class="o">)</span>, CX
</code></pre></td></tr></table>
</div>
</div><p>Extract the structure, i.e.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">F</span> <span class="kt">uintptr</span>
    <span class="nx">a</span> <span class="o">*</span><span class="kt">int</span>
    <span class="nx">b</span> <span class="o">*</span><span class="kt">int</span>
    <span class="nx">c</span> <span class="o">*</span><span class="kt">int</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>At this point, we have confirmed that <strong>it is the closure function itself that references the local variables of the wrapped function, i.e., the closure function structure object</strong> that the compiler has created in memory for it. With the unsafe package, we can even export this closure function object. Let&rsquo;s try it with closure2.go as an example, as shown in the following code.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// https://github.com/bigwhite/experiments/tree/master/closure/closure2.go
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">foo</span><span class="p">()</span> <span class="kd">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span> <span class="kt">int</span> <span class="p">=</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span>
    <span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
        <span class="nx">a</span> <span class="o">+=</span> <span class="nx">n</span>
        <span class="nx">b</span> <span class="o">+=</span> <span class="nx">n</span>
        <span class="nx">c</span> <span class="o">+=</span> <span class="nx">n</span>
        <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span> <span class="o">+</span> <span class="nx">c</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">closure</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">f</span> <span class="kt">uintptr</span>
    <span class="nx">a</span> <span class="o">*</span><span class="kt">int</span>
    <span class="nx">b</span> <span class="o">*</span><span class="kt">int</span>
    <span class="nx">c</span> <span class="o">*</span><span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">bar</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">f</span> <span class="o">:=</span> <span class="nf">foo</span><span class="p">()</span>
    <span class="nf">f</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="nx">pc</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="o">**</span><span class="nx">closure</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">f</span><span class="p">))</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%#v\n&#34;</span><span class="p">,</span> <span class="o">*</span><span class="nx">pc</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;a=%d, b=%d,c=%d\n&#34;</span><span class="p">,</span> <span class="o">*</span><span class="nx">pc</span><span class="p">.</span><span class="nx">a</span><span class="p">,</span> <span class="o">*</span><span class="nx">pc</span><span class="p">.</span><span class="nx">b</span><span class="p">,</span> <span class="o">*</span><span class="nx">pc</span><span class="p">.</span><span class="nx">c</span><span class="p">)</span>
    <span class="nf">f</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;a=%d, b=%d,c=%d\n&#34;</span><span class="p">,</span> <span class="o">*</span><span class="nx">pc</span><span class="p">.</span><span class="nx">a</span><span class="p">,</span> <span class="o">*</span><span class="nx">pc</span><span class="p">.</span><span class="nx">b</span><span class="p">,</span> <span class="o">*</span><span class="nx">pc</span><span class="p">.</span><span class="nx">c</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>In the above code, we refer to the assembly output to define the closure structure to correspond to the closure function object in memory (each closure object is different, a trick is to refer to the assembly output to define the object), through the address conversion of unsafe, we map the closure object in memory to the closure structure instance. Running the above program, we can get the following output.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt">$go run closure2.go
main.closure{f:0x10a4d80, a:(*int)(0xc000118000), b:(*int)(0xc000118008), c:(*int)(0xc000118010)}
a=16, b=17,c=18
a=22, b=23,c=24
</code></pre></td></tr></table>
</div>
</div><p>In the above example, the closure function captures external variables a, b and c, which are essentially referenced by a closure memory object created by the compiler. When we call the foo function, the closure function object is created (its address is assigned to the variable f). Thus, the f object keeps referring to variables a, b, and c. Only when f is reclaimed will a, b, and c be reclaimed as unreachable.</p>
<p>If we simply perform read-only operations on captured external variables in a closure function, the closure function object will not store pointers to these variables, but will only make a copy of the values. Of course, if a variable is captured by multiple closures created in a function, and some are read-only and some are modified, then the closure function object will still store the address of that variable.</p>
<p>Understanding the nature of closed functions makes it much easier to look at the question in the title of this article. The answer is that <strong>after the closure function object that captures the variable is reclaimed, if there are no other references to those captured variables, they will become unreachable and subsequently reclaimed by GC</strong>.</p>
<h2 id="3-summary">3. Summary</h2>
<p>Let&rsquo;s recall the quote from the beginning of the article about the Go language specification&rsquo;s interpretation of closures: &ldquo;They will continue to exist as long as they can be accessed&rdquo;. It now appears that we can interpret this to mean that <strong>as long as the closure function object exists, those variables it captures will exist and will not be recycled</strong> .</p>
<p>This mechanism of the closure function dictates that we should always consider the possible &ldquo;delayed recycling&rdquo; of the variables captured by the closure function in our daily use. If there is a scenario where the variables referenced by the closure take up a lot of memory, and the closure function object is created in large numbers and executed with a long delay due to business needs (e.g. timer scenarios), this can lead to a high level of heap memory for a long time, and we need to consider whether the memory capacity can withstand such a level, and if not, we need to consider a different implementation.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/golang/">golang</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-03/vs-fix-error/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Fix the contents of the Error.cshtml file of the ASP.NET MVC 5 project template in Visual Studio</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-03/private-go-module/">
            <span class="next-text nav-default">Small company internal private Go module pulling solution</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
