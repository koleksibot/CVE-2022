<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Go doesn&#39;t need a Java-style GC - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Modern languages like Go, Julia and Rust don&amp;rsquo;t need a garbage collector as complex as the one used by Java c#. But why is that? We first need to understand how garbage collectors work and how the various languages differ in the way they allocate memory. First, let&amp;rsquo;s look at why Java needs such a complex garbage collector. This article will cover many different garbage collector topics. Why Java relies" /><meta name="keywords" content="golang, java, gc" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-03/go-does-not-need-a-java-style-gc/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Go doesn&#39;t need a Java-style GC" />
<meta property="og:description" content="Modern languages like Go, Julia and Rust don&rsquo;t need a garbage collector as complex as the one used by Java c#. But why is that? We first need to understand how garbage collectors work and how the various languages differ in the way they allocate memory. First, let&rsquo;s look at why Java needs such a complex garbage collector. This article will cover many different garbage collector topics. Why Java relies" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-03/go-does-not-need-a-java-style-gc/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-03-06T16:41:32+08:00" />
<meta property="article:modified_time" content="2022-03-06T16:41:32+08:00" />

<meta itemprop="name" content="Go doesn&#39;t need a Java-style GC">
<meta itemprop="description" content="Modern languages like Go, Julia and Rust don&rsquo;t need a garbage collector as complex as the one used by Java c#. But why is that? We first need to understand how garbage collectors work and how the various languages differ in the way they allocate memory. First, let&rsquo;s look at why Java needs such a complex garbage collector. This article will cover many different garbage collector topics. Why Java relies"><meta itemprop="datePublished" content="2022-03-06T16:41:32+08:00" />
<meta itemprop="dateModified" content="2022-03-06T16:41:32+08:00" />
<meta itemprop="wordCount" content="4492">
<meta itemprop="keywords" content="golang,java," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go doesn&#39;t need a Java-style GC"/>
<meta name="twitter:description" content="Modern languages like Go, Julia and Rust don&rsquo;t need a garbage collector as complex as the one used by Java c#. But why is that? We first need to understand how garbage collectors work and how the various languages differ in the way they allocate memory. First, let&rsquo;s look at why Java needs such a complex garbage collector. This article will cover many different garbage collector topics. Why Java relies"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Go doesn&#39;t need a Java-style GC</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-03-06 16:41:32 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 4492 words </span>
          <span class="more-meta"> 9 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#why-java-needs-fast-gc-more-than-other-languages">Why Java needs fast GC more than other languages</a>
          <ul>
            <li><a href="#memory-fragmentation">Memory fragmentation</a></li>
            <li><a href="#how-java-overcomes-memory-fragmentation">How Java overcomes memory fragmentation</a></li>
            <li><a href="#adding-complexity">Adding complexity</a></li>
          </ul>
        </li>
        <li><a href="#how-modern-languages-avoid-the-same-flaws-as-java">How modern languages avoid the same flaws as Java</a>
          <ul>
            <li><a href="#value-types">Value Types</a></li>
            <li><a href="#value-types-are-not-enough">Value types are not enough</a></li>
            <li><a href="#customizing-secondary-allocators">Customizing secondary allocators</a></li>
          </ul>
        </li>
        <li><a href="#problems-with-java-bump-allocator">Problems with Java Bump allocator</a></li>
        <li><a href="#generational-gc-and-escape-analysis">Generational GC and escape analysis</a>
          <ul>
            <li><a href="#limitations-of-java-escape-analysis">Limitations of Java escape analysis</a></li>
            <li><a href="#advantages-of-go-language-escape-analysis">Advantages of Go language escape analysis</a></li>
          </ul>
        </li>
        <li><a href="#modern-languages-do-not-require-compressed-gc">Modern languages do not require compressed GC</a></li>
        <li><a href="#generational-gc-vs-concurrent-gc-suspension">Generational GC vs Concurrent GC Suspension</a>
          <ul>
            <li><a href="#what-if-garbage-is-being-generated-faster-than-it-can-be-cleaned-up">What if garbage is being generated faster than it can be cleaned up?</a></li>
          </ul>
        </li>
        <li><a href="#in-a-nutshell">In a nutshell</a></li>
        <li><a href="#gcs-tradeoff-no-longer-applies">GC&rsquo;s Tradeoff no longer applies</a>
          <ul>
            <li><a href="#old-technology-is-inherently-bad">Old technology is inherently bad?</a></li>
            <li><a href="#go-not-c">Go not <code>C#</code></a></li>
            <li><a href="#memory-compression-tidying">Memory compression tidying</a></li>
            <li><a href="#heap-overhead">Heap Overhead</a></li>
          </ul>
        </li>
        <li><a href="#why-low-latency-is-important-for-java-too">Why low latency is important for Java too</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>Modern languages like Go, Julia and Rust don&rsquo;t need a garbage collector as complex as the one used by Java c#. But why is that?</p>
<p>We first need to understand how garbage collectors work and how the various languages differ in the way they allocate memory. First, let&rsquo;s look at why Java needs such a complex garbage collector.</p>
<p>This article will cover many different garbage collector topics.</p>
<ul>
<li>Why Java relies on fast GC I will cover some of the design choices in the Java language itself that can put a lot of pressure on GC.</li>
<li>Memory fragmentation and its impact on GC design. Why this is important for Java, but not so much for Go.</li>
<li>Value types and how they change GC.</li>
<li>Generational garbage collector and why Go doesn&rsquo;t need it.</li>
<li>Escape analysis &ndash; a trick Go uses to reduce GC pressure.</li>
<li>Compressed garbage collector &ndash; this is important in Java, but Go doesn&rsquo;t need it. Why?</li>
<li>Concurrent garbage collection &ndash; Go solves many GC challenges by using multiple threads to run concurrent garbage collectors. Why is this more difficult to do with Java.</li>
<li>Common criticisms of Go GC, and why many of the assumptions behind such criticisms are often flawed or completely wrong.</li>
</ul>
<h2 id="why-java-needs-fast-gc-more-than-other-languages">Why Java needs fast GC more than other languages</h2>
<p>Basically, Java outsources memory management completely to its garbage collector. This has proven to be a huge mistake. However, in order to be able to explain this, I need to present more details.</p>
<p>Let&rsquo;s start at the beginning. It is 1991 and work on Java has begun. Garbage collectors are now very popular. The related research looks promising, and the designers of Java are betting on an advanced garbage collector that will solve all the challenges in memory management.</p>
<p>For this reason, all objects in Java - except for basic types such as integers and floating-point values - are designed to be allocated on the heap. When discussing memory allocation, we usually distinguish between what is called the heap and the stack.</p>
<p>The stack is very fast to use, but has limited space and can only be used for those objects that are within the lifetime of a function call. The stack is only available for local variables.</p>
<p>The heap can be used for all objects. Java essentially ignores the stack and chooses to allocate everything on the heap except for basic types such as integers and floating point. Whenever you write <code>new Something()</code> in Java, it is the memory on the heap that is consumed.</p>
<p>However, this memory management is actually quite expensive as far as memory usage is concerned. You might think that creating a 32-bit integer object requires only 4 bytes of memory.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Knight</span> <span class="o">{</span>
   <span class="kt">int</span> <span class="n">health</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>However, in order for the garbage collector to work, Java stores a header information that contains.</p>
<ul>
<li>Type/Type - Identifies the class the object belongs to or its type.</li>
<li>Lock - Used to synchronize statements.</li>
<li>Mark / Mark - Mark and sweep (mark and sweep) used by the garbage collector.</li>
</ul>
<p>This data is usually 16 bytes. Therefore, the ratio of header information to actual data is 4:1. The c++ source code for the Java object is defined as: <a href="http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/87ee5ee27509/src/share/vm/oops/oop.hpp#l59">OpenJDK base class</a>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">oopDesc</span> <span class="o">{</span>
    <span class="kd">volatile</span> <span class="n">markOop</span>  <span class="n">_mark</span><span class="o">;</span>   <span class="c1">// for mark and sweep
</span><span class="c1"></span>    <span class="n">Klass</span><span class="o">*</span>           <span class="n">_klass</span><span class="o">;</span>   <span class="c1">// the type
</span><span class="c1"></span><span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="memory-fragmentation">Memory fragmentation</h3>
<p>The next problem is memory fragmentation. When Java allocates an array of objects, it actually creates an array of references that point to other objects in memory. These objects can end up scattered throughout the heap memory. This is very bad for performance, because modern microprocessors do not read individual bytes of data. Because it is slower to start transferring memory data, each time the CPU tries to access a memory address, the CPU reads a contiguous chunk of memory.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/06/3c42a133c24c41a3a161d6291d6a3468.png" alt="Memory fragmentation"></p>
<p>This contiguous block of memory is called a cache line . the CPU has its own cache, which is much smaller than memory. the CPU cache is used to store recently accessed objects, as these objects are likely to be accessed again. If the memory is fragmented, this means that the cache line will also be fragmented and the CPU cache will be filled with a lot of useless data. the hit rate of the CPU cache will be reduced.</p>
<h3 id="how-java-overcomes-memory-fragmentation">How Java overcomes memory fragmentation</h3>
<p>To address these major drawbacks, Java maintainers have invested a lot of resources in advanced garbage collectors. They came up with the concept of compact, that is, moving objects into adjacent blocks in memory. This operation is very expensive, as moving memory data from one location to another consumes CPU cycles, as does updating references to these objects.</p>
<p>The garbage collector cannot update these references while they are in use. So updating these references requires suspending all threads. This usually results in a complete pause of hundreds of milliseconds while the Java program moves objects, updates references, and reclaims unused memory.</p>
<h3 id="adding-complexity">Adding complexity</h3>
<p>To reduce these long pauses, Java uses so-called generational garbage collectors. These are based on the following premises.</p>
<blockquote>
<p>Most of the objects allocated in the program are released soon. Therefore, if the GC spends more time on recently allocated objects, it should reduce the pressure on the GC.</p>
</blockquote>
<p>This is why Java divides the objects they allocate into two groups.</p>
<ul>
<li>Aged objects - objects that have survived multiple mark and purge operations by GC. Each mark and scan operation updates a generation counter to keep track of the object&rsquo;s &ldquo;age&rdquo;.</li>
<li>Young objects - These are objects that are younger in &ldquo;age&rdquo;, meaning they have been recently allocated.</li>
</ul>
<p>Java more aggressively processes, scans for recently allocated objects, and checks to see if they should be recycled or moved. As objects get &ldquo;older&rdquo;, they are moved out of the younger generation area.</p>
<p>All these optimizations create more complexity, and it requires more development effort. It requires paying more money to hire better developers.</p>
<h2 id="how-modern-languages-avoid-the-same-flaws-as-java">How modern languages avoid the same flaws as Java</h2>
<p>Modern languages do not need a complex garbage collector like Java and c#. This is because these languages were not designed to rely on garbage collectors as Java does.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Point</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">X</span><span class="p">,</span> <span class="nx">Y</span> <span class="kt">int</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">points</span> <span class="p">[</span><span class="mi">15000</span><span class="p">]</span><span class="nx">Point</span>
</code></pre></td></tr></table>
</div>
</div><p>In the Go code example above, we allocated 15,000 Point objects. This allocates memory just once, producing a pointer. In Java, this would require 15,000 memory allocations, each of which produces a reference that these applications would also have to manage up separately. Each <code>Point</code> object has the 16-byte header information overhead mentioned earlier. And whether in the Go language, Julia or Rust, you don&rsquo;t see header information; objects usually don&rsquo;t have that header information.</p>
<p>In Java, the GC tracks and manages 15,000 separate objects. go only needs to track one object.</p>
<h3 id="value-types">Value Types</h3>
<p>In languages other than Java, value types are basically supported. The following code defines a rectangle with a Min and Max point to define its range.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Rect</span> <span class="kd">struct</span> <span class="p">{</span>
   <span class="nx">Min</span><span class="p">,</span> <span class="nx">Max</span> <span class="nx">Point</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>This becomes a contiguous block of memory. In Java, this becomes a <code>Rect</code> object, which references two separate objects, the <code>Min</code> and <code>Max</code> objects. So in Java, a <code>Rect</code> instance requires 3 memory allocations, but in Go, Rust, C/c++ and Julia it only requires 1 memory allocation.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/06/01cd2b94422b489b91c1061a0e25f595.png" alt="sobyte"></p>
<blockquote>
<p>Java-style memory fragments on the left. In Go, C/C++, Julia, etc. programs, on the right on contiguous memory blocks.</p>
</blockquote>
<p>The lack of value types causes serious problems when porting Git to Java. Without value types, it is difficult to get good performance. As Shawn O. Pearce <a href="https://marc.info/?l=git&amp;m=124111702609723">on the JGit developer mailing list</a> said.</p>
<blockquote>
<p>JGit has struggled with not having an efficient way to represent SHA-1. C simply enters <code>unsigned char[20]</code> and inlines it into the container&rsquo;s memory allocation. <code>byte[20]</code> in Java would consume an additional 16 bytes of memory and be slow to access because the 10 bytes and the container object are in non-adjacent memory areas. We tried to solve this problem by converting a <code>byte[20]</code> to 5 int, but this costs extra CPU instructions.</p>
</blockquote>
<p>What are we talking about? In Go, I can do the same thing as in C/C++ and define a structure like this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Sha1</span> <span class="kd">struct</span> <span class="p">{</span>
   <span class="nx">data</span> <span class="p">[</span><span class="mi">20</span><span class="p">]</span><span class="kt">byte</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>These bytes will be located in a complete block of memory. And Java would create a pointer to somewhere else.</p>
<p>Java developers realized that they screwed up and that developers really need value types to get good performance. You can say that this statement is rather exaggerated, but you need to explain the <a href="https://en.wikipedia.org/wiki/Project_Valhalla_(Java_language)">Valhalla project</a>. This is Oracle&rsquo;s effort for Java value types, and it&rsquo;s done so for exactly the reasons I&rsquo;m talking about here.</p>
<h3 id="value-types-are-not-enough">Value types are not enough</h3>
<p>So does the Valhalla project solve Java&rsquo;s problems? Not really. It simply brought Java to the same level as c#. c# came along a few years after Java and realized that garbage collectors were not as magical as everyone thought. As a result, they added value types.</p>
<p>However, this did not put c#/Java on par with languages like Go and C/C++ in terms of memory management flexibility. Java does not support true pointers. In Go, I can write it like this.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">ptr</span> <span class="o">*</span><span class="nx">Point</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">rect</span><span class="p">.</span><span class="nx">Min</span> <span class="c1">// 把指向 Min 的指针存储到 ptr 中
</span><span class="c1"></span><span class="o">*</span><span class="nx">ptr</span> <span class="p">=</span> <span class="nf">Point</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>         <span class="c1">// 替换 rect.Min 对象
</span></code></pre></td></tr></table>
</div>
</div><p>Just like in C/C++, you can get the address of an object or a field of an object in Go and store it in a pointer. You can then pass this pointer and use it to modify the field it points to. This means that you can create large value objects in Go and pass them as function pointers to optimize performance. The situation is better in c# because it has <em>limited</em> support for pointers. The preceding Go example can be written in c# as:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c#" data-lang="c#"><span class="k">unsafe</span> <span class="k">void</span> <span class="n">foo</span><span class="p">()</span> <span class="p">{</span>
   <span class="k">ref</span> <span class="kt">var</span> <span class="n">ptr</span> <span class="p">=</span> <span class="k">ref</span> <span class="n">rect</span><span class="p">.</span><span class="n">Min</span><span class="p">;</span>
   <span class="n">ptr</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Point</span><span class="p">(</span><span class="m">2</span><span class="p">,</span> <span class="m">4</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>However, c#&rsquo;s pointer support comes with some warnings that don&rsquo;t apply to Go:</p>
<ul>
<li>Code that uses pointers must be marked as <strong>unsafe</strong>. This produces code that is less safe and more likely to crash.</li>
<li>Must be a pure value type allocated on the stack (all structure fields must also be value types).</li>
<li>In the context of <strong>fixed</strong>, the fixed keyword turns off garbage collection.</li>
</ul>
<p>Therefore, the normal and safe way to use value types in c# is to copy them, as this does not require defining unsafe or fixed code fields. However, for larger value types, this can create performance problems. go does not have these problems. You can create pointers to objects managed by the garbage collector in Go. there is no need to mark the code that uses pointers separately in Go, as you would in c#.</p>
<h3 id="customizing-secondary-allocators">Customizing secondary allocators</h3>
<p>Using the right pointers, you can do a lot of things that value types can&rsquo;t do. One example is creating secondary allocators. Chandra Sekar S gives an example: <a href="https://blog.cskr.dev/posts/arena-allocation-in-go/">Arena allocation in Go</a>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Arena</span> <span class="p">[]</span><span class="nx">Node</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">arena</span> <span class="o">*</span><span class="nx">Arena</span><span class="p">)</span> <span class="nf">Alloc</span><span class="p">()</span> <span class="o">*</span><span class="nx">Node</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="o">*</span><span class="nx">arena</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="o">*</span><span class="nx">arena</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">Node</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">n</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="nx">arena</span><span class="p">)[</span><span class="nb">len</span><span class="p">(</span><span class="o">*</span><span class="nx">arena</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="o">*</span><span class="nx">arena</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">arena</span><span class="p">)[:</span><span class="nb">len</span><span class="p">(</span><span class="o">*</span><span class="nx">arena</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="nx">n</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Why are these useful? If you look at some microbenchmarks, such as the algorithm for constructing a binary tree, you will usually find that Java has a big advantage over Go. This is because the construct binary tree algorithm is usually used to test how fast the garbage collector is when allocating objects. Java is very fast at this because it uses what we call bump pointers. It just adds a pointer value and Go will find a suitable location in memory to allocate the object. However, using the Arena allocator, you can also build binary trees quickly in Go.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">buildTree</span><span class="p">(</span><span class="nx">item</span><span class="p">,</span> <span class="nx">depth</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">arena</span> <span class="o">*</span><span class="nx">Arena</span><span class="p">)</span> <span class="o">*</span><span class="nx">Node</span> <span class="p">{</span>
    <span class="nx">n</span> <span class="o">:=</span> <span class="nx">arena</span><span class="p">.</span><span class="nf">Alloc</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">depth</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="o">*</span><span class="nx">n</span> <span class="p">=</span> <span class="nx">Node</span><span class="p">{</span><span class="nx">item</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="o">*</span><span class="nx">n</span> <span class="p">=</span> <span class="nx">Node</span><span class="p">{</span>
              <span class="nx">item</span><span class="p">,</span>
              <span class="nf">buildTree</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="nx">item</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">depth</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">arena</span><span class="p">),</span>
              <span class="nf">buildTree</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="nx">item</span><span class="p">,</span> <span class="nx">depth</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">arena</span><span class="p">),</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">n</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>This is why a real pointer would be beneficial. You can&rsquo;t create a pointer to an element in a contiguous block of memory, as follows:</p>
<p><code>n := &amp;(*arena)[len(*arena)-1]</code></p>
<h2 id="problems-with-java-bump-allocator">Problems with Java Bump allocator</h2>
<p>The bump allocator used by Java GC is similar to the Arena allocator in that you only need to move one pointer to get the next value. However, developers do not need to manually specify the use of the Bump allocator. This may seem smarter. But it causes some problems that are not present in the Go language.</p>
<ul>
<li>Sooner or later, memory will need to be compacted (compressed), which involves moving data and fixing pointers. the Arena allocator does not need to do this.</li>
<li>In multi-threaded programs, bump allocators require locks (unless you use thread-local storage). This wipes out their performance benefits, either because locks degrade performance or because thread-local storage will lead to fragmentation, which will require compression later.</li>
</ul>
<p>Ian Lance Taylor, one of the creators of Go, <a href="https://groups.google.com/g/golang-nuts/c/KJiyv2mV2pU">explains the problem with the bump allocator</a>.</p>
<blockquote>
<p>In general, it may be more efficient to use a set of per-thread caches to allocate memory, and at this point you&rsquo;ve lost the advantage of the bump allocator. Therefore, I would assert that there is usually no real advantage to using a compressed memory allocator for multi-threaded programs, despite the many caveats.</p>
</blockquote>
<h2 id="generational-gc-and-escape-analysis">Generational GC and escape analysis</h2>
<p>The Java garbage collector has more work to do because it allocates more objects. Why? We just talked about it. Without value objects and real pointers, it will always end up with a lot of objects when allocating large arrays or complex data structures. Therefore, it requires generational GC.</p>
<p>The need to allocate fewer objects is beneficial to the Go language. But the Go language has another trick up its sleeve. both Go and Java perform escape analysis when compiling functions.</p>
<p>Escape analysis consists of looking at a pointer created inside a function and determining if the pointer escaped out of the scope of the function.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">escapingPtr</span><span class="p">()</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
   <span class="nx">values</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">}</span>
   <span class="k">return</span> <span class="nx">values</span>
<span class="p">}</span>

<span class="nx">fun</span> <span class="nf">nonEscapingPtr</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="nx">values</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">}</span>
    <span class="kd">var</span> <span class="nx">total</span> <span class="kt">int</span> <span class="p">=</span> <span class="nf">addUp</span><span class="p">(</span><span class="nx">values</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">total</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>In the first example, <code>values</code> points to a slice, which is essentially the same as a pointer to an array. It escaped because it was returned. This means that <code>values</code> must be allocated on the heap.</p>
<p>However, in the second example, the pointer to <code>values</code> does not leave the <code>nonEscapingPtr</code> function. Therefore, <code>values</code> can be allocated on the stack, an action that is very fast and cost effective. The escape analysis itself only analyzes whether a pointer escapes.</p>
<h3 id="limitations-of-java-escape-analysis">Limitations of Java escape analysis</h3>
<p>Java also does escape analysis, but there are more restrictions on its use. From the Java SE 16 Oracle documentation covering the hotspot VM.</p>
<blockquote>
<p>It does not replace heap allocations with stack allocations for objects that are not globally escaped.</p>
</blockquote>
<p>However, Java uses another technique called <em>scalar substitution</em>, which avoids the need to put objects on the stack. Essentially, it breaks up the object and puts its basic members on the stack. Remember, Java can already place basic values such as <code>int</code> and <code>float</code> on the stack. However, as <a href="https://pkolaczk.github.io/overhead-of-optional/">Piotr Kołaczkowski</a> found in 2021, in practice scalar substitution does not work even in very trivial cases.</p>
<p>On the contrary, the main advantage of scalar substitution is the avoidance of locks. If you know that a pointer will not be used outside of a function, you can also be sure that it does not need a lock.</p>
<h3 id="advantages-of-go-language-escape-analysis">Advantages of Go language escape analysis</h3>
<p>However, Go uses escape analysis to determine which objects can be allocated on the stack. This greatly reduces the number of short-lived objects that could have benefited from a generational GC. But remember that the whole point of generational GC is to take advantage of the fact that recently allocated objects have a very short lifetime. However, most objects in the Go language will probably live a long time, because objects with short survival times are likely to be caught by escape analysis.</p>
<p>Unlike Java, in which escape analysis also applies to complex objects, Java can usually only successfully perform escape analysis on simple objects such as byte arrays. Even the built-in ByteBuffer cannot be allocated on the stack using scalar substitution.</p>
<h2 id="modern-languages-do-not-require-compressed-gc">Modern languages do not require compressed GC</h2>
<p>You can read that many experts in garbage collectors claim that Go is more likely to run out of memory than Java due to memory fragmentation. The argument goes like this: because Go doesn&rsquo;t have a compressed garbage collector, memory will fragment over time. When memory is fragmented, you will reach a point where loading a new object into memory will become difficult.</p>
<p>However, this problem is greatly reduced for two reasons.</p>
<ol>
<li>Go does not allocate as many small objects as Java does. It can allocate large arrays of objects as a single block of memory.</li>
<li>Modern memory allocators such as Google&rsquo;s TCMalloc or Intel&rsquo;s Scalable Malloc do not segment memory.</li>
</ol>
<p>Memory fragmentation was a big problem for memory allocators when Java was designed. People didn&rsquo;t think this problem could be solved. But even back in 1998, shortly after Java was introduced, researchers began to address the problem. Here is <a href="https://dl.acm.org/doi/10.1145/286860.286864">a paper by Mark S. Johnstone and Paul R. Wilson</a>.</p>
<blockquote>
<p>This essentially reinforces our previous results, which show that the memory fragmentation problem is often misunderstood and that a good allocator strategy can provide good memory usage for most programs.</p>
</blockquote>
<p>As a result, many of the assumptions made when designing Java memory allocation strategies are no longer true.</p>
<h2 id="generational-gc-vs-concurrent-gc-suspension">Generational GC vs Concurrent GC Suspension</h2>
<p>The Java strategy of using generational GC is designed to make the garbage collection cycle shorter. Be aware that in order to move data and repair pointers, Java must stop all operations. If it pauses for too long, it will reduce the performance and responsiveness of the program. With generational GC, less data is checked each time, thus reducing the checking time.</p>
<p>However, Go solves the same problem with some alternative strategies.</p>
<ol>
<li>there is less work to do during the GC run because there is no memory to move and no pointers to fix. the Go GC does only one mark and cleanup: it looks in the object graph for objects that should be freed.</li>
<li>It runs concurrently. Therefore, a separate GC thread can look for objects to be released without stopping other threads.</li>
</ol>
<p>Why Go can run GC concurrently but Java can&rsquo;t? Because Go does not repair any pointers or move any objects in memory. Therefore, there is no risk of trying to access a pointer to an object that has just been moved but the pointer has not been updated. An object that no longer has any reference will not suddenly gain a reference because some concurrent thread is running. Therefore, there is no risk of moving a &ldquo;dead&rdquo; object in parallel.</p>
<p>What&rsquo;s going on here? Suppose you have 4 threads working in a Go program. One of the threads performs a temporary GC job at any time <code>T</code> seconds, for a total of 4 seconds.</p>
<p>Now imagine that a Java program&rsquo;s GC does only 2 seconds of GC work. Which program squeezes out the most performance? Who did the most in <code>T</code> seconds? Sounds like a Java program, right? Wrong!</p>
<p>4 worker threads in a Java program will stop all threads for 2 seconds. This means that 2 x 4 = 8 seconds of work is lost in <code>T</code> seconds. So, although Go takes longer to stop, each stop has less impact on the program&rsquo;s work because all threads are not stopped. Thus, a slow concurrent GC may outperform a faster GC that relies on stopping all threads to perform its work.</p>
<h3 id="what-if-garbage-is-being-generated-faster-than-it-can-be-cleaned-up">What if garbage is being generated faster than it can be cleaned up?</h3>
<p>A popular argument against current garbage collectors is that active worker threads can generate garbage faster than the garbage collector threads can collect it. In the Java world, this is known as &ldquo;concurrency mode failure&rdquo;.</p>
<p>In this case, the runtime has no choice but to stop the program completely and wait for the GC cycle to complete. So, when Go claims that the GC pause time is very low, this only applies if the GC has enough CPU time and space over the main program.</p>
<p>But Go has a clever trick to get around <a href="https://blog.golang.org/ismmkeynote">this problem described by Go GC guru Rick Hudson</a>. Go uses what is called a &ldquo;Pacer&rdquo;.</p>
<blockquote>
<p>If needed, Pacer slows down allocation while speeding up tagging. At a higher level, Pacer stops Goroutine, which does a lot of allocating, and lets it do the marking. The workload is proportional to the allocation of Goroutine. This speeds up the garbage collector while slowing down the mutator.</p>
</blockquote>
<p>Goroutines are kind of like green threads that are multiplexed on a thread pool. Basically, Go takes over the threads that are running workloads that generate a lot of garbage and lets them help the GC clean up that garbage. It will keep taking over threads until the GC is running faster than the garbage-generating concurrent threads.</p>
<h2 id="in-a-nutshell">In a nutshell</h2>
<p>While advanced garbage collectors solve real problems in Java, modern languages, such as Go and Julia, avoid these problems from the start and therefore do not need to use Rolls Royce garbage collectors. When you have value types, escape analysis, pointers, multicore processors, and modern allocators, many of the assumptions behind Java&rsquo;s design are thrown out the window. They no longer apply.</p>
<h2 id="gcs-tradeoff-no-longer-applies">GC&rsquo;s Tradeoff no longer applies</h2>
<p>Mike Hearn has a very popular story on Medium in which he criticizes the Go GC claim: <a href="https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e">Modern Garbage Collection</a>.</p>
<p>Hearn&rsquo;s key message is that there are always trade-offs in GC design. His point is that because Go aims for low latency collection, they will suffer in many other metrics. This is an interesting read because it covers a lot of details about tradeoffs in GC design.</p>
<p>First, what does low latency mean?Go GCs pause for an average of 0.5 milliseconds, while various Java collectors can take hundreds of milliseconds.</p>
<p>I think the problem with Mike Hearn&rsquo;s arguments is that they are based on the flawed premise that memory access patterns are the same for all languages. As I mentioned in this article, this is simply not the case. Go will generate far fewer objects that require GC management, and it will use escape analysis to clean up many of them in advance.</p>
<h3 id="old-technology-is-inherently-bad">Old technology is inherently bad?</h3>
<p>Hearn&rsquo;s argument declares that simple collection is somehow bad:.</p>
<blockquote>
<p>Stop-the-world (STW) markup/cleanup is the most common GC algorithm used in undergraduate computer science courses. When doing job interviews, I sometimes ask candidates to talk a bit about GC, but almost always, they either see GC as a black box and know nothing about it, or they think it is still used today with this very old technique.</p>
</blockquote>
<p>Yes, it may be old, but this technology allows running GC concurrently, something that &ldquo;modern&rdquo; technology does not allow. In our modern hardware world with multiple cores, this is even more important.</p>
<h3 id="go-not-c">Go not <code>C#</code></h3>
<p>Another way of saying :</p>
<blockquote>
<p>Since Go is a relatively common imperative language with value types, its memory access model may be comparable to C#, where the assumption of partitioning certainly holds, and thus .NET uses a partitioned collector.</p>
</blockquote>
<p>This is not the case. c# developers minimize the use of large-valued objects because code related to pointers cannot be used safely. We must assume that c# developers prefer to copy value types rather than use pointers, because this can be done safely in the CLR. This naturally brings a higher overhead.</p>
<p>As far as I know, C# also does not make use of escape analysis to reduce the generation of short-lived objects on the heap. Secondly, C# is not very good at running a large number of tasks simultaneously. go can take advantage of their concurrency to speed up collection at the same time, as Pacer mentions.</p>
<h3 id="memory-compression-tidying">Memory compression tidying</h3>
<blockquote>
<p>Compression: Because there is no compression, your program will end up fragmenting the heap. I will discuss heap fragmentation further below. Neatly placing things in the cache will not benefit you either.</p>
</blockquote>
<p>Mike Hearn&rsquo;s description of allocators here is not up to date. modern allocators such as TCMalloc essentially eliminate this problem.</p>
<blockquote>
<p>Program throughput:Since GC must do a lot of work for each cycle, this steals CPU time from the program itself and slows it down.</p>
</blockquote>
<p>This does not apply when you have a concurrent GC. All other threads can continue to run while the GC is working - unlike Java, which has to stop the whole world.</p>
<h3 id="heap-overhead">Heap Overhead</h3>
<p>Hearn raises the issue of &ldquo;concurrent mode failure&rdquo;, assuming that Go GC runs the risk of not being able to keep up with the garbage generator.</p>
<blockquote>
<p>Heap overhead: Since collecting the heap by marking/clearing is very slow, you need a lot of free space to make sure you don&rsquo;t experience &ldquo;concurrent mode failures&rdquo;. The default heap overhead is 100%, which doubles the amount of memory your program needs.</p>
</blockquote>
<p>I&rsquo;m skeptical of this claim, as many real-world examples I&rsquo;ve seen seem to suggest that Go programs use less memory. Not to mention, this ignores the existence of Pacer, which will grab Goroutines and generate a lot of garbage for them to clean up.</p>
<h2 id="why-low-latency-is-important-for-java-too">Why low latency is important for Java too</h2>
<p>We live in a world of Docker and microservices. This means that many smaller programs communicate and work with each other. Imagine a request going through several services. In a chain, if one of these services has a major stall, it will have a chain reaction. It causes all other processes to stop working. If the next service in the pipeline is waiting for garbage collection from STW, then it will not work.</p>
<p>Therefore, the latency/throughput tradeoff is no longer a tradeoff in GC design. When multiple services are working together, high latency will cause throughput to drop. Java&rsquo;s preference for high throughput and high latency GC applies to a single block world. It no longer applies to the microservice world.</p>
<p>This is a fundamental problem with Mike Hearn&rsquo;s view that there is no panacea, only trade-offs and trade-offs. It tries to give the impression that Java&rsquo;s trade-offs are equally valid. But the trade-offs have to be adapted to the world we live in.</p>
<p>In short, I think the Go language has made a lot of smart moves and strategic choices. If it&rsquo;s just a trade-off that anyone can do, then it&rsquo;s not advisable to omit it.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/golang/">golang</a>
          <a href="/tags/java/">java</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-03/solve-gin-router-path-conflict/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Solve Gin Router Path Conflict</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-03/mysql-fix-only-full-group-by/">
            <span class="next-text nav-default">Several ways to solve the MySQL database ONLY_FULL_GROUP_BY exception</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
