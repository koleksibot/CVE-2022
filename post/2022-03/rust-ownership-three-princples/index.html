<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Three principles of Rust ownership - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="The core concept of Rust is Ownership, a GC-enabled language that allows the runtime to sweep the heap at runtime and release unreferenced garbage objects, such as go. For languages like c/c&#43;&#43;, you need to manage the allocation and release of memory yourself. Rust uses the concept of Ownership and appends various check rules to the compiler to implement memory management. Note that most of Rust&amp;rsquo;s work is done at" /><meta name="keywords" content="rust, Ownership, Three Princples" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-03/rust-ownership-three-princples/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Three principles of Rust ownership" />
<meta property="og:description" content="The core concept of Rust is Ownership, a GC-enabled language that allows the runtime to sweep the heap at runtime and release unreferenced garbage objects, such as go. For languages like c/c&#43;&#43;, you need to manage the allocation and release of memory yourself. Rust uses the concept of Ownership and appends various check rules to the compiler to implement memory management. Note that most of Rust&rsquo;s work is done at" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-03/rust-ownership-three-princples/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-03-09T14:40:15+08:00" />
<meta property="article:modified_time" content="2022-03-09T14:40:15+08:00" />

<meta itemprop="name" content="Three principles of Rust ownership">
<meta itemprop="description" content="The core concept of Rust is Ownership, a GC-enabled language that allows the runtime to sweep the heap at runtime and release unreferenced garbage objects, such as go. For languages like c/c&#43;&#43;, you need to manage the allocation and release of memory yourself. Rust uses the concept of Ownership and appends various check rules to the compiler to implement memory management. Note that most of Rust&rsquo;s work is done at"><meta itemprop="datePublished" content="2022-03-09T14:40:15+08:00" />
<meta itemprop="dateModified" content="2022-03-09T14:40:15+08:00" />
<meta itemprop="wordCount" content="1206">
<meta itemprop="keywords" content="rust," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Three principles of Rust ownership"/>
<meta name="twitter:description" content="The core concept of Rust is Ownership, a GC-enabled language that allows the runtime to sweep the heap at runtime and release unreferenced garbage objects, such as go. For languages like c/c&#43;&#43;, you need to manage the allocation and release of memory yourself. Rust uses the concept of Ownership and appends various check rules to the compiler to implement memory management. Note that most of Rust&rsquo;s work is done at"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Three principles of Rust ownership</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-03-09 14:40:15 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 1206 words </span>
          <span class="more-meta"> 3 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li>
          <ul>
            <li><a href="#raii">RAII</a></li>
            <li><a href="#ownership">Ownership</a></li>
            <li><a href="#ownership-and-functions">Ownership and functions</a></li>
            <li><a href="#movecopyclone">Move,Copy,Clone</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>The core concept of Rust is <code>Ownership</code>, a GC-enabled language that allows the runtime to sweep the heap at runtime and release unreferenced garbage objects, such as go. For languages like c/c++, you need to manage the allocation and release of memory yourself.</p>
<p>Rust uses the concept of <code>Ownership</code> and appends various check rules to the compiler to implement memory management. Note that most of Rust&rsquo;s work is done at compile time, so there is no additional overhead at runtime. Here are three principles.</p>
<ul>
<li><strong>each value, has an owner</strong></li>
<li><strong>At the same time, a value can have only one owner</strong></li>
<li><strong>When the owner leaves the scope, the corresponding value is automatically droppe</strong></li>
</ul>
<h3 id="raii">RAII</h3>
<p>Let&rsquo;s first look at leaving the scope and releasing it automatically.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">_s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>The simplest code, just one line, allocates the string on the heap and disassembles it to observe how memory is managed.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">Dump of assembler code for function hello_cargo::main:
src/main.rs:
1	fn main() {
   0x000055555555d190 &lt;+0&gt;:	sub    $0x18,%rsp

2	    let _s = String::from(&#34;hello&#34;);
   0x000055555555d194 &lt;+4&gt;:	mov    %rsp,%rdi
   0x000055555555d197 &lt;+7&gt;:	lea    0x2bf86(%rip),%rsi        # 0x555555589124
   0x000055555555d19e &lt;+14&gt;:	mov    $0x5,%edx
   0x000055555555d1a3 &lt;+19&gt;:	callq  0x55555555c480 &lt;&lt;alloc::string::String as core::convert::From&lt;&amp;str&gt;&gt;::from&gt;

3	}
=&gt; 0x000055555555d1a8 &lt;+24&gt;:	mov    %rsp,%rdi
   0x000055555555d1ab &lt;+27&gt;:	callq  0x55555555c700 &lt;core::ptr::drop_in_place&lt;alloc::string::String&gt;&gt;
   0x000055555555d1b0 &lt;+32&gt;:	add    $0x18,%rsp
   0x000055555555d1b4 &lt;+36&gt;:	retq
End of assembler dump.
</code></pre></td></tr></table>
</div>
</div><p>The assembly on line 2 calls <code>core::convert::From</code> to create the string variable. Then on line 3, at the end of main, <code>core::ptr::drop_in_place</code> is called automatically to free the string.</p>
<p>The automatic destructuring out of scope is much like c++&rsquo;s <code>RAII</code> (Resource Acquisition Is Initialization), except that rust calls <code>drop trait</code> out of scope.</p>
<h3 id="ownership">Ownership</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s1</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;s1 = {}, s2 = {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="n">s2</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>This code will definitely work with go, but not with rust.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt">hello_cargo# cargo run
   Compiling hello_cargo v0.1.0 (/root/zerun.dong/code/rusttest/hello_cargo)
error[E0382]: borrow of moved value: `s1`
 --&gt; src/main.rs:5:34
  |
2 |     let s1 = String::from(&#34;hello&#34;);
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 |
5 |     println!(&#34;s1 = {}, s2 = {}&#34;, s1, s2);
  |                                  ^^ value borrowed here after move
</code></pre></td></tr></table>
</div>
</div><p>The execution reports an error because the ownership of the s1 value has been moved to s2, and the original s1 is no longer available. <strong>move occurs because <code>s1</code> has type <code>String</code> , which does not implement the <code>Copy</code> trait</strong>.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/09/d6f8328cacc4430bad0fc359abaa8d48.png" alt="rust ownership"></p>
<p>You can see the result of the string, just like go, the string header has pointer pointing to heap memory. If s1, s2 are shallow copies and the pointer points to data on the heap, then the same piece of memory will be freed twice after leaving scope!</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s1</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;s1 = {}, s2 = {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="n">s2</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>You can call <code>s1.clone()</code> to make a deep copy to solve this problem. But it is inefficient to make a memory copy every time, so the concept of <code>reference references</code> will be introduced later.</p>
<h3 id="ownership-and-functions">Ownership and functions</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">);</span><span class="w">  </span><span class="c1">// s comes into scope
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="n">takes_ownership</span><span class="p">(</span><span class="n">s</span><span class="p">);</span><span class="w">             </span><span class="c1">// s&#39;s value moves into the function...
</span><span class="c1"></span><span class="w">                                    </span><span class="c1">// ... and so is no longer valid here
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w">                      </span><span class="c1">// x comes into scope
</span><span class="c1"></span><span class="w">
</span><span class="w">    </span><span class="n">makes_copy</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w">                  </span><span class="c1">// x would move into the function,
</span><span class="c1"></span><span class="w">                                    </span><span class="c1">// but i32 is Copy, so it&#39;s okay to still
</span><span class="c1"></span><span class="w">                                    </span><span class="c1">// use x afterward
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w"> </span><span class="c1">// Here, x goes out of scope, then s. But because s&#39;s value was moved, nothing
</span><span class="c1"></span><span class="w">  </span><span class="c1">// special happens.
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">takes_ownership</span><span class="p">(</span><span class="n">some_string</span>: <span class="nb">String</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// some_string comes into scope
</span><span class="c1"></span><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">some_string</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w"> </span><span class="c1">// Here, some_string goes out of scope and `drop` is called. The backing
</span><span class="c1"></span><span class="w">  </span><span class="c1">// memory is freed.
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">makes_copy</span><span class="p">(</span><span class="n">some_integer</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// some_integer comes into scope
</span><span class="c1"></span><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">some_integer</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w"> </span><span class="c1">// Here, some_integer goes out of scope. Nothing special happens.
</span><span class="c1"></span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>This is an example from the website. When <code>takes_ownership</code> is executed, the ownership of the value corresponding to s is transferred to the function and released when it leaves the scope, so if the main function tries to use it again, it will report an error.</p>
<p>But at the same time, x is an int value, and the <code>makes_copy</code> function will copy this value, not transfer ownership.</p>
<h3 id="movecopyclone">Move,Copy,Clone</h3>
<p>In Rust, if the type does not implement <code>Copy</code>, then the type is assigned, passed, and returned with <code>Move</code> semantics, which is a bit awkward and not intuitive.</p>
<p>The previous string is a <code>Move</code>, so let&rsquo;s look at an integer example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="n">zerun</span><span class="p">.</span><span class="n">dong</span><span class="cp">$</span><span class="w"> </span><span class="n">cat</span><span class="w"> </span><span class="n">src</span><span class="o">/</span><span class="n">main</span><span class="p">.</span><span class="n">rs</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1234</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s1</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;s1 = {}, s2 = {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="n">s2</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="n">zerun</span><span class="p">.</span><span class="n">dong</span><span class="cp">$</span><span class="w"> </span><span class="n">cargo</span><span class="w"> </span><span class="n">run</span><span class="w">
</span><span class="w">    </span><span class="n">Finished</span><span class="w"> </span><span class="n">dev</span><span class="w"> </span><span class="p">[</span><span class="n">unoptimized</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">debuginfo</span><span class="p">]</span><span class="w"> </span><span class="n">target</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mf">0.00</span><span class="n">s</span><span class="w">
</span><span class="w">     </span><span class="n">Running</span><span class="w"> </span><span class="err">`</span><span class="n">target</span><span class="o">/</span><span class="n">debug</span><span class="o">/</span><span class="n">hello_cargo</span><span class="err">`</span><span class="w">
</span><span class="w"></span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1234</span><span class="p">,</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1234</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>Here s1 is the i32 type by default, which implements the <code>Copy</code> semantics, so s1 can be used afterwards.</p>
<p>To see which types implement <code>Copy</code> semantics by default, they are generally scalars, i.e. types allocated on the stack and sized at compile time.</p>
<ul>
<li>All the integer types, such as u32.</li>
<li>The Boolean type, bool, with values true and false.</li>
<li>All the floating point types, such as f64.</li>
<li>The character type, char.</li>
<li>Tuples, if they only contain types that also implement Copy. For example, (i32, i32) implements Copy, but (i32, String) does not.</li>
</ul>
<p>So how is it handled for custom types, such as struct?</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt">struct Data {
    a: i64,
    b: i64,
}

fn test(d: Data) {
    let _d = d;
}

fn main() {
    let d = Data{a:1,b:1};
    test(d);
    println!(&#34;a is {}, b is {}&#34;, d.a, d.b);
}

zerun.dong$ cargo run
   Compiling hello_cargo v0.1.0 (/Users/zerun.dong/code/rusttest/hello_cargo)
error[E0382]: borrow of moved value: `d`
  --&gt; src/main.rs:14:39
   |
12 |     let d = Data{a:1,b:1};
   |         - move occurs because `d` has type `Data`, which does not implement the `Copy` trait
13 |     test(d);
   |          - value moved here
14 |     println!(&#34;a is {}, b is {}&#34;, d.a, d.b);
   |                                       ^^^ value borrowed here after move
</code></pre></td></tr></table>
</div>
</div><p>As you can see, the error is reported because d has been moved when <code>test</code> is called, so the variable d can no longer be used in main.</p>
<p>But the problem is that struct Data members are all integers, and they all implement <code>Copy</code> by default.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[derive(Copy, Clone)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Data</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">a</span>: <span class="kt">i64</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">b</span>: <span class="kt">i64</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>Here you need to mark the struct <code>#[derive(Copy, Clone)]</code> , so that the custom type automatically implements the <code>Copy trait</code>, which requires that all fields have already implemented <code>Copy</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="nc">E1</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Text</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Digit</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">S2</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">u</span>: <span class="kt">usize</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">e</span>: <span class="nc">E1</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">s</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">Clone</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">S2</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// 生成新的E1实例
</span><span class="c1"></span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">e</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">E1</span>::<span class="n">Text</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">E1</span>::<span class="n">Text</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">E1</span>::<span class="n">Digit</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">E1</span>::<span class="n">Digit</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="p">};</span><span class="w">
</span><span class="w">        </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">u</span>: <span class="nc">self</span><span class="p">.</span><span class="n">u</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">e</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="n">s</span>: <span class="nc">self</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">clone</span><span class="p">(),</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>For <code>struct S2</code> , since S2 has String type in its field, String type does not implement <code>Copy trait</code>, so S2 type cannot implement <code>Copy trait</code>.</p>
<p>S2 also contains E1 type, which does not implement <code>Clone</code> and <code>Copy trait</code>, but we can implement <code>Clone trait</code> for S2 type ourselves, and generate a new E1 instance in <code>Clone::clone</code> method, which can clone a new S2 instance.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/rust/">rust</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-03/rust-shit-ref-borrow/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Rust&#39;s confusing references and borrowings</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-03/how-debug-with-systemtap/">
            <span class="next-text nav-default">How to troubleshoot problems with systemtap</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
