<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Vite &#43; React Component Development Practice - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="1. Vite brings the light It&amp;rsquo;s no exaggeration to say that Vite has brought an absolute revolution to the front-end.
Or we can say that the integration of esbuild, Browser es modules, HMR, Pre-Bundling, and other advanced tools and ideas about JS compilation development in the community behind Vite has brought about a revolutionary changes.
The main reason why Vite is faster is that esbuild does pre-bundles dependencies &#43; browser native ESM dynamic compilation, which I won&amp;rsquo;t go into too much detail here" /><meta name="keywords" content="vite,react" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2021-06/vite&#43;react-component-development-practice/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Vite &#43; React Component Development Practice" />
<meta property="og:description" content="1. Vite brings the light It&rsquo;s no exaggeration to say that Vite has brought an absolute revolution to the front-end.
Or we can say that the integration of esbuild, Browser es modules, HMR, Pre-Bundling, and other advanced tools and ideas about JS compilation development in the community behind Vite has brought about a revolutionary changes.
The main reason why Vite is faster is that esbuild does pre-bundles dependencies &#43; browser native ESM dynamic compilation, which I won&rsquo;t go into too much detail here" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2021-06/vite&#43;react-component-development-practice/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-06-22T11:02:48+08:00" />
<meta property="article:modified_time" content="2021-06-22T11:02:48+08:00" />

<meta itemprop="name" content="Vite &#43; React Component Development Practice">
<meta itemprop="description" content="1. Vite brings the light It&rsquo;s no exaggeration to say that Vite has brought an absolute revolution to the front-end.
Or we can say that the integration of esbuild, Browser es modules, HMR, Pre-Bundling, and other advanced tools and ideas about JS compilation development in the community behind Vite has brought about a revolutionary changes.
The main reason why Vite is faster is that esbuild does pre-bundles dependencies &#43; browser native ESM dynamic compilation, which I won&rsquo;t go into too much detail here"><meta itemprop="datePublished" content="2021-06-22T11:02:48+08:00" />
<meta itemprop="dateModified" content="2021-06-22T11:02:48+08:00" />
<meta itemprop="wordCount" content="1695">
<meta itemprop="keywords" content="vite,react," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Vite &#43; React Component Development Practice"/>
<meta name="twitter:description" content="1. Vite brings the light It&rsquo;s no exaggeration to say that Vite has brought an absolute revolution to the front-end.
Or we can say that the integration of esbuild, Browser es modules, HMR, Pre-Bundling, and other advanced tools and ideas about JS compilation development in the community behind Vite has brought about a revolutionary changes.
The main reason why Vite is faster is that esbuild does pre-bundles dependencies &#43; browser native ESM dynamic compilation, which I won&rsquo;t go into too much detail here"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Vite &#43; React Component Development Practice</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-06-22 11:02:48 </span>
        <div class="post-category">
            <a href="/categories/skills/"> skills </a>
            <a href="/categories/frontend/"> frontend </a>
            </div>
          <span class="more-meta"> 1695 words </span>
          <span class="more-meta"> 8 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#1-vite-brings-the-light">1. Vite brings the light</a></li>
        <li><a href="#2-design-ideas">2. Design ideas</a>
          <ul>
            <li><a href="#21-component-usage">2.1 Component Usage</a></li>
            <li><a href="#22-components-runtime">2.2 Components Runtime</a></li>
            <li><a href="#23-components-props-interface">2.3 components <code>Props Interface</code></a></li>
          </ul>
        </li>
        <li><a href="#3-components-build">3. Components Build</a></li>
        <li><a href="#4-summary">4. Summary</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="1-vite-brings-the-light">1. Vite brings the light</h2>
<p>It&rsquo;s no exaggeration to say that <code>Vite</code> has brought an absolute revolution to the front-end.</p>
<p>Or we can say that the integration of <code>esbuild</code>, <code>Browser es modules</code>, <code>HMR</code>, <code>Pre-Bundling</code>, and other advanced tools and ideas about <code>JS</code> compilation development in the community behind <code>Vite</code> has brought about a revolutionary changes.</p>
<p>The main reason why <code>Vite</code> is faster is that <code>esbuild</code> does <code>pre-bundles dependencies</code> + browser <code>native ESM</code> dynamic compilation, which I won&rsquo;t go into too much detail here</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/06/22/94101cbea7c141a3bbbf1feee7c18fe3.png" alt="native ESM"></p>
<p>In the context of this idea, going back to our component development scenario and looking at it again will reveal the following issues that are highly compatible:</p>
<ul>
<li>Component libraries are developed without actually compiling all the components.</li>
<li>Component development, compilation of preview pages mainly for developers, browser compatibility can be controlled.</li>
<li>The <code>HMR</code> (hot update) capability is even more immediate with <code>Vite</code>, which used to be the most time-consuming area for component development and debugging.</li>
<li>All source modules in <code>Vite</code> are dynamically compiled, i.e. <code>TypeScript</code> type definitions and <code>JS</code> annotations can also be compiled dynamically, greatly reducing the scope of compilation.</li>
</ul>
<p>Then, the old way of thinking like <code>StoryBook</code> and the previous way we used to extract <code>tsx</code> component type definitions will be able to make a relatively big change</p>
<p>Previously, in order to get the type data of the component input, a plugin was made at the <code>Wwebpack</code> level to dynamically analyze the <code>tsx</code> component of <code>export</code>, and a static attribute variable of <code>__docgenInfo</code> was dynamically added under the component to inject the type data and annotation information obtained from <code>AST</code> analysis into the component <code>JS Bundle</code>, which can be further processed into dynamic parameter settings.</p>
<p>TypeScript&rsquo;s definition of component Props:</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/06/22/6302cef7ada94b33b12d0af705930ba4.png" alt="TypeScript&rsquo;s definition of component Props"></p>
<p>Analyze the content injected into the <code>JS Bundle</code>:</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/06/22/3f99416d1f204d16809fa97b23276bef.png" alt="JS Bundle"></p>
<p>Analysis of the parameter interaction settings achieved after conversion</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/06/22/9b5de818d48249f2b168828645885510.png" alt="-"></p>
<p>So for the component, actually getting this metadata for the type definition is redundant for the component itself. Whether or not this metadata is used in the component, it will be extracted and injected into the component <code>Bundle</code> during <code>Webpack</code> compilation, which is obviously very inefficient.</p>
<p>In the idea of <code>Vite</code>, it is perfectly possible to get the metadata information of a component when it is used, for example, loading a <code>React</code> component as:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">import</span> <span class="nx">ReactComponent</span> <span class="nx">from</span> <span class="s1">&#39;./component1.tsx&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p>Then load its metadata i.e.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">import</span> <span class="nx">ComponentTypeInfo</span> <span class="nx">from</span> <span class="s1">&#39;./component1.tsx.type.json&#39;</span><span class="p">;</span> 

<span class="c1">// or 
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">ComponentTypeInfoPromise</span> <span class="o">=</span> <span class="kr">import</span><span class="p">(</span><span class="s1">&#39;./component1.tsx.type.json&#39;</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>Load <code>.type</code> <code>.json</code> file type through <code>Rollup</code> plugin capability in <code>Vite</code> to parse component metadata. Also, with the ability of <code>Rollup</code> itself for compilation dependency collection and <code>HMR</code>, we can do the hot update of component type changes</p>
<h2 id="2-design-ideas">2. Design ideas</h2>
<p>The above is a preliminary idea inspired by the module loading idea of <code>Vite</code>.</p>
<p>But if we really want to make such a <code>React</code> and <code>Rax</code> component development kit based on <code>Vite</code>, there are certainly other problems that need to be solved besides the acquisition of component entry metadata, the first of which is the parsing of <code>.md</code> files</p>
<h3 id="21-component-usage">2.1 Component Usage</h3>
<p>Referring to the component development ideas provided by <code>dumi</code> and <code>Icework</code>, the component <code>Usage</code> can be written to any <code>.md</code> file in the form of a <code>Markdown</code> write document, which is dynamically parsed by the compiler for <code>jsx</code>, <code>tsx</code>, <code>css</code>, <code>scss</code>, <code>less</code> code block, and compiles it as an executable <code>script</code> to run on the page</p>
<p>This is not only in writing the document, but also can run debugging components under the different components into the performance of the component, how many components in the <code>Case</code>, can be written in different blocks for the user to choose to see, this design idea is really let people applaud!</p>
<p>Finally, if you can combine the <code>esbuild</code> dynamic loading and <code>HMR</code> capabilities of <code>Vite</code> mentioned above, the whole component development experience will take another quantum leap</p>
<p>So for <code>Markdown</code> files a <code>Vite</code> plugin needs to be made to perform file parsing and loading of <code>.md</code>, with the following expected capabilitieswill be as follows:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">import</span> <span class="p">{</span> <span class="nx">content</span><span class="p">,</span> <span class="nx">modules</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&#34;./component1/README.md&#34;</span><span class="p">;</span>

<span class="c1">// The original content of content README.md
</span><span class="c1">// modules run modules by parsing the obtained `jsx`, `tsx`, `css`, `scss`, `less`
</span></code></pre></td></tr></table>
</div>
</div><p>Please click to enlarge to see the expected effect.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/06/22/637051b9a7c14a598567643fcfed74d9.gif" alt=" "></p>
<h3 id="22-components-runtime">2.2 Components Runtime</h3>
<p>What should a regular component repository directory look like? Whether it is in a separate component repository or in an existing business project, the directory structure of components is actually similar, roughly as follows:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">components
├── component1
│   ├── README.md 
│   ├── index.scss
│   └── index.tsx
├── component2
│   ├── README.md
│   ├── index.scss
│   └── index.tsx
</code></pre></td></tr></table>
</div>
</div><p>In our scenario you can start the component development mode in any project, and after running <code>vite-comp</code> you will see a component-specific interface, where the component <code>Usage</code> written in <code>README.md</code> and <code>index.tsx</code> defined in <code>index.tsx</code> are already parsed and rendered for you. <code>interface</code>, you just need to access the different file paths to see how the corresponding component is represented</p>
<p>At the same time, you can finally compile and package all the contents of this interface and publish the screenshots to <code>NPM</code>, so that others can see the component clearly and see the component parameters, usage, screenshots, etc. You can even open the <code>Demo</code> address and modify the component parameters to see how the component behaves in different states.</p>
<p>To achieve this effect, a set of component runtime <code>Runtime</code> support is needed to coordinate <code>React</code> components, <code>README.md</code>, <code>TypeScript</code> type definitions in tandem into the component debugging + documentation we need for the integrated component development page.</p>
<p>In such a <code>Runtime</code>, it is also necessary to use the module parsing capabilities of <code>Vite</code> to convert the request whose <code>URL</code> is <code>*//(README|*).html</code> into an accessible component <code>Runtime Html</code> that is returned to the browser, thus allowing the browser to run the real component development page.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">http://localhost:7000/components/component1/README.html
-&gt; 
/components/component1/README.html 
-&gt;
/components/component1/README.md
-&gt; 
Runtime Html
</code></pre></td></tr></table>
</div>
</div><h3 id="23-components-props-interface">2.3 components <code>Props Interface</code></h3>
<p>As I mentioned above, if you use <code>Vite</code> to add a component <code>props interface</code> type resolution capability to <code>tsx</code>, you can also make a standalone plugin for parsing file types ending in <code>.tsx</code> <code>.type</code> <code>.json</code> by <code>importing</code> such types of files which allows the compiler to dynamically parse the <code>TypeScript</code> types defined in its <code>tsx</code> files and return them to the front-end for consumption as modules</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/06/22/789c5a8593124ade83940d7dd91e8bcf.png" alt=" "></p>
<p>The loading process can be treated as a virtual module, which means that you can directly <code>import</code> a virtual file address and get the corresponding <code>React</code> component meta information</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="c1">// React Component
</span><span class="c1"></span><span class="kr">import</span> <span class="nx">Component</span> <span class="nx">from</span> <span class="s1">&#39;./component1.tsx&#39;</span><span class="p">;</span>
<span class="c1">// React Component Props Interface
</span><span class="c1"></span><span class="kr">import</span> <span class="nx">ComponentTypeInfo</span> <span class="nx">from</span> <span class="s1">&#39;./component1.tsx.type.json&#39;</span><span class="p">;</span>

<span class="c1">// or
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">ComponentTypeInfoPromise</span> <span class="o">=</span> <span class="kr">import</span><span class="p">(</span><span class="s1">&#39;./component1.tsx.type.json&#39;</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>Since this parsing capability is not performed with the help of <code>esbuild</code>, it is not possible to synchronize the conversion performance with the compilation of the main flow of the component.</p>
<p>When requesting this file type, consider opening a new thread in <code>Vite</code>&rsquo;s <code>Serve</code> mode to compile this part, as the whole process is asynchronous and will not affect the component main flow rendering progress. When the request returns a response, it is then used to render the component <code>Props</code> definition and the sidebar panel part.</p>
<p>During the hot update process, it is also necessary to consider whether the scope of the <code>tsx</code> file modification involves <code>TypeScript</code> type changes, and then trigger the <code>HMR</code> event to update the module if the modification is found to result in a type change</p>
<h2 id="3-components-build">3. Components Build</h2>
<p>The above are discussing the situation of components in the <code>Serve</code> state of <code>Vite</code> (that is, the development state), and we heavily relied on <code>Vite</code> above to take advantage of the loading capabilities of the browser&rsquo;s <code>es module</code> to do some extensions to the dynamic loading capabilities of the development state.</p>
<p>But <code>Vite</code> does not have a <code>Server</code> service to start during the final <code>Build</code> of the component, and of course it will not be dynamically loaded by the browser, so in order to allow others to see the component we have developed and to experience how we debug the component during development, we need to consider compiling a <code>html</code> for the component that can be run by the browser.</p>
<p>So in the <code>Vite</code> plugin development process, it is necessary to consider the compilation path in the <code>Build</code> state, if it is in the <code>Build</code> state, <code>Vite</code> will use the <code>Rollup</code> compilation ability, then you need to consider manually provide all components of the <code>rollup.input(entries)</code>.</p>
<p>During the plugin writing process, it is important to follow the plugin loading lifecycle provided by <code>Rollup</code> to ensure that the module loading logic and compilation logic of the <code>Build</code> process and the <code>Serve</code> process are consistent.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/06/22/782c67c856874091808e41766c554684.png" alt=" "></p>
<p>I didn&rsquo;t understand the relationship between <code>Vite</code> and <code>Rollup</code> well enough in the beginning, and relied a lot on the server-side middleware capabilities provided by <code>Vite</code>&rsquo;s <code>Server</code> in the module parsing process. It was only when considering the <code>Build</code> state that I realized the problem, and ended up almost rewriting the previous loading logic</p>
<h2 id="4-summary">4. Summary</h2>
<p>I will call this program (kit) <code>vite-comp</code>, its general composition is composed of <code>Vite + 3 Vite Pugins</code>, each plug-in is not coupled with each other, mutual responsibilities are not the same, that is, you can get any one <code>Vite</code> plug-in to do other purposes, the follow-up will consider separate open source, respectively.</p>
<ul>
<li><code>Markdown</code>, used to parse <code>.md</code> files and load them to get the original text and runnable blocks such as <code>jsx</code> and <code>tsx</code>.</li>
<li><code>TypeScript Interface</code>, used to parse <code>.tsx</code> files for <code>props</code> type definitions of <code>export</code> components</li>
<li><code>Vite Comp Runtime</code>, used to run the component development state and compile the final component documentation</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/06/22/cf289e7ad5b447daa09468b9033e56ba.png" alt=" "></p>
<p>Preview Experience</p>
<p>Start:</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/06/22/b94b42ac81444df58c5294c16f0a90c2.gif" alt=" "></p>
<p>Millisecond response for Markdown component documents:</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/06/22/fb9102f1d30a11eb9f9800ff0fe55167.gif" alt=" "></p>
<p>TypeScript type recognition</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/06/22/85738b9cd30b11eb9f9800ff0fe55167.gif" alt=" "></p>
<p>This new compile mode has already brought me a lot of development state gains, combined with the <code>Vite</code> play in the future will certainly be endless, such as <code>Midway + lambda + Vite</code> front-end integration program is also to see the people to applaud, in this thriving front-end era, I believe that different front-end products will be combined with the <code>Vite</code> out of the next legendary story.</p>
<hr>
<p>Reference <code>https://mp.weixin.qq.com/s/j4F2KVTlJjbMs99FjBn_6A</code></p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/vite/">vite</a>
          <a href="/tags/react/">react</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2021-06/certify-your-git-commits-on-github-with-gpg/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Certify Your Git Commits on Github With GPG</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2021-06/introduction-to-introspector-for-java/">
            <span class="next-text nav-default">Introduction to Introspector for Java</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
