<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Installation, usage and personal experience with Argo Workflows, the cloud-native pipeline - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Note: This article is not an introductory tutorial, to learn Argo Workflows please go to the official documentation Argo Documentation Argo Workflows is a cloud-native workflow engine that focuses on orchestrating parallel tasks. It has the following features. defines workflows using Kubernetes Custom Resources (CR), where each step in a workflow is a container. model multi-step workflows as a series of tasks, or use directed acyclic graphs (DAGs) to describe" /><meta name="keywords" content="argo, Workflow" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-01/expirence-of-argo-workflow/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Installation, usage and personal experience with Argo Workflows, the cloud-native pipeline" />
<meta property="og:description" content="Note: This article is not an introductory tutorial, to learn Argo Workflows please go to the official documentation Argo Documentation Argo Workflows is a cloud-native workflow engine that focuses on orchestrating parallel tasks. It has the following features. defines workflows using Kubernetes Custom Resources (CR), where each step in a workflow is a container. model multi-step workflows as a series of tasks, or use directed acyclic graphs (DAGs) to describe" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-01/expirence-of-argo-workflow/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-01-08T14:56:49+08:00" />
<meta property="article:modified_time" content="2022-01-08T14:56:49+08:00" />

<meta itemprop="name" content="Installation, usage and personal experience with Argo Workflows, the cloud-native pipeline">
<meta itemprop="description" content="Note: This article is not an introductory tutorial, to learn Argo Workflows please go to the official documentation Argo Documentation Argo Workflows is a cloud-native workflow engine that focuses on orchestrating parallel tasks. It has the following features. defines workflows using Kubernetes Custom Resources (CR), where each step in a workflow is a container. model multi-step workflows as a series of tasks, or use directed acyclic graphs (DAGs) to describe"><meta itemprop="datePublished" content="2022-01-08T14:56:49+08:00" />
<meta itemprop="dateModified" content="2022-01-08T14:56:49+08:00" />
<meta itemprop="wordCount" content="4203">
<meta itemprop="keywords" content="argo," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Installation, usage and personal experience with Argo Workflows, the cloud-native pipeline"/>
<meta name="twitter:description" content="Note: This article is not an introductory tutorial, to learn Argo Workflows please go to the official documentation Argo Documentation Argo Workflows is a cloud-native workflow engine that focuses on orchestrating parallel tasks. It has the following features. defines workflows using Kubernetes Custom Resources (CR), where each step in a workflow is a container. model multi-step workflows as a series of tasks, or use directed acyclic graphs (DAGs) to describe"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Installation, usage and personal experience with Argo Workflows, the cloud-native pipeline</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-01-08 14:56:49 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 4203 words </span>
          <span class="more-meta"> 9 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#i-argo-workflows-vs-jenkins">I. Argo Workflows vs. Jenkins</a>
          <ul>
            <li><a href="#1-definition-of-workflow">1. Definition of Workflow</a></li>
            <li><a href="#2-workflow-orchestration">2. Workflow orchestration</a></li>
            <li><a href="#3-declarative-configuration-of-workflow">3. Declarative configuration of Workflow</a></li>
            <li><a href="#4-web-ui">4. Web UI</a></li>
            <li><a href="#5-classification-of-workflow">5. Classification of Workflow</a></li>
            <li><a href="#6-ways-to-trigger-builds">6. Ways to trigger builds</a></li>
            <li><a href="#7-secrets-management">7. secrets management</a></li>
            <li><a href="#8-artifacts">8. Artifacts</a></li>
            <li><a href="#9-container-image-building">9. Container image building</a></li>
            <li><a href="#10-clientsdk">10. Client/SDK</a></li>
          </ul>
        </li>
        <li><a href="#ii-install-argo-workflows">II. Install Argo Workflows</a>
          <ul>
            <li><a href="#serviceaccount-configuration">ServiceAccount configuration</a></li>
            <li><a href="#workflow-executors">Workflow Executors</a></li>
          </ul>
        </li>
        <li><a href="#iii-using-argo-workflows-as-a-ci-tool">III. Using Argo Workflows as a CI tool</a></li>
        <li><a href="#iv-frequently-asked-questions">IV. Frequently Asked Questions</a>
          <ul>
            <li><a href="#1-does-workflow-use-the-root-account-by-default">1. Does workflow use the root account by default?</a></li>
            <li><a href="#2-how-to-read-secrets-from-hashicorp-vault">2. How to read secrets from hashicorp vault?</a></li>
            <li><a href="#3-how-do-i-use-the-same-secrets-in-multiple-namespaces">3. How do I use the same secrets in multiple namespaces?</a></li>
            <li><a href="#4-argos-validation-of-cr-resources-is-not-rigorous-enough-it-doesnt-even-report-an-error-if-you-write-the-wrong-key">4. Argo&rsquo;s validation of CR resources is not rigorous enough, it doesn&rsquo;t even report an error if you write the wrong key</a></li>
            <li><a href="#5-how-to-archive-historical-data">5. how to archive historical data?</a></li>
            <li><a href="#6-other-advanced-configurations-for-argo">6. Other advanced configurations for Argo</a></li>
            <li><a href="#7-should-i-try-to-use-the-features-provided-by-cicd-tools">7. Should I try to use the features provided by CI/CD tools?</a></li>
            <li><a href="#8-how-to-improve-the-speed-of-creation-and-destruction-of-argo-workflows">8. How to improve the speed of creation and destruction of Argo Workflows?</a></li>
          </ul>
        </li>
        <li><a href="#experience">Experience</a></li>
        <li><a href="#how-to-handle-dependencies-between-other-kubernetes-resources">How to handle dependencies between other Kubernetes resources</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/08/81fad0141df246e9bc30ed804ffc19f5.png" alt="image"></p>
<blockquote>
<p>Note: This article is not an introductory tutorial, to learn Argo Workflows please go to the official documentation <a href="https://argoproj.github.io/argo-workflows/">Argo Documentation</a></p>
</blockquote>
<p><a href="https://github.com/argoproj/argo-workflows/">Argo Workflows</a> is a cloud-native workflow engine that focuses on <strong>orchestrating parallel tasks</strong>. It has the following features.</p>
<ol>
<li>defines workflows using Kubernetes Custom Resources (CR), where each step in a workflow is a container.</li>
<li>model multi-step workflows as a series of tasks, or use directed acyclic graphs (DAGs) to describe the dependencies between tasks.</li>
<li>Computationally intensive jobs for machine learning or data processing can be easily run in a short period of time.</li>
<li>Argo Workflows can be seen as an enhanced version of Tekton, so obviously it is also possible to run CI/CD streamlines (Pipielines) with Argo Workflows.</li>
</ol>
<p>AliCloud is a deep user and contributor to Argo Workflows, and the underlying workflow engine of Kubeflow is also Argo Workflows.</p>
<h2 id="i-argo-workflows-vs-jenkins">I. Argo Workflows vs. Jenkins</h2>
<p>Before we switched to Argo Workflows, the CI/CD tool we used was Jenkins. Here is a more detailed comparison between Argo Workflows and Jenkins to understand the advantages and disadvantages of Argo Workflows.</p>
<h3 id="1-definition-of-workflow">1. Definition of Workflow</h3>
<p><code>Workflow</code> is defined using the kubernetes CR, so it&rsquo;s obviously a yaml configuration.</p>
<p>A Workflow is a pipeline running on Kubernetes that corresponds to a single Build of Jenkins.</p>
<p>A WorkflowTemplate is a reusable Workflow template that corresponds to a Job in Jenkins.</p>
<p>The yaml definition of <code>WorkflowTemplate</code> is identical to <code>Workflow</code>, except for <code>Kind</code>!</p>
<p>WorkflowTemplate can be referenced and triggered by other Workflows, or can be passed manually to generate a Workflow workflow.</p>
<h3 id="2-workflow-orchestration">2. Workflow orchestration</h3>
<p>The most important feature of Argo Workflows compared to other pipeline projects (Jenkins/Tekton/Drone/Gitlab-CI) is its powerful pipeline orchestration capability.</p>
<p>Other pipeline projects give little thought to the interconnectedness of pipelines, and basically assume that pipelines are independent of each other.</p>
<p>Argo Workflows, on the other hand, assumes that there are dependencies between &ldquo;tasks&rdquo;, and provides two methods for coordinating the scheduling of &ldquo;tasks&rdquo;: Steps and DAGs.</p>
<p>With the help of <a href="https://argoproj.github.io/argo/workflow-templates/#referencing-other-workflowtemplates">templateRef</a> or <a href="https://argoproj.github.io/argo/workflow-of-workflows/">Workflow of Workflows</a>, the orchestration of Workflows can be implemented.</p>
<p><strong>The main reason we chose Argo Workflows over Tekton is that Argo&rsquo;s pipeline orchestration is much more powerful than Tekton.</strong> (Perhaps because our backend middleware structure is special, our CI pipeline needs to have complex orchestration capabilities)</p>
<p>An example of a complex workflow is as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/08/e1adcdefa6f548c2b7a8a2b6949b28fc.png" alt="image"></p>
<h3 id="3-declarative-configuration-of-workflow">3. Declarative configuration of Workflow</h3>
<p>Argo uses Kubernetes Custom Resources (CR) to define Workflow, and users familiar with Kubernetes Yaml should get up to speed quickly.</p>
<p>Here&rsquo;s a comparison of the Workflow definition file and the Jenkinsfile.</p>
<ul>
<li>argo uses yaml entirely to define the pipeline, and the learning cost is lower than the groovy Jenkinsfile. This is especially true for students familiar with Kubernetes.</li>
<li>After rewriting the jenkinsfile with argo, there is a significant bloat in the amount of code. A 20-line Jenkinsfile may become 60 lines when rewritten with Argo.</li>
</ul>
<p>Configuration bloat is a problem, but given that it&rsquo;s fairly readable, and that Argo&rsquo;s Workflow scheduling feature replaces some of the Python build code we currently maintain, among other benefits, configuration bloat is an acceptable problem.</p>
<h3 id="4-web-ui">4. Web UI</h3>
<p>The Argo Workflows web UI feels primitive. It does have all the features it should support, but it doesn&rsquo;t seem to be &ldquo;user&rdquo; oriented and is rather low level.</p>
<p>It doesn&rsquo;t have a very user-friendly interface like Jenkins (although Jenkins' UI is also very old&hellip;)</p>
<p>In addition, all of its workflows are independent of each other, so there is no way to visually find all the build records of a WorkflowTemplate, you can only sort them by label/namespace and search by task name.</p>
<p>Jenkins, on the other hand, makes it easy to see all the build histories of the same Job.</p>
<h3 id="5-classification-of-workflow">5. Classification of Workflow</h3>
<h4 id="why-workflow-needs-to-be-classified-in-detail">Why Workflow needs to be classified in detail</h4>
<p>Common microservices projects are often split into many Git repositories (microservices) for development, and having many Git repositories can lead to the creation of many CI/CD pipelines. Without any classification, it becomes a challenge to manage this large number of pipelines.</p>
<p>The most obvious requirements: it would be good to have a distinction between the front-end and back-end pipelines, with a breakdown down to the front-end web side and client side, and a distinction between the back-end business layer and the middle office.</p>
<p>We also want to integrate Ops and automation testing tasks into the system (we currently use Jenkins for Ops and automation testing tasks), without any categories, this huge pipeline will be chaotic.</p>
<h4 id="argo-workflows-classification-capabilities">Argo Workflows' Classification Capabilities</h4>
<p>When there are more and more Workflows, it can be very confusing to have a bunch of WorkflowTemplates stacked together without categorization. (Yes, I think Drone has this problem&hellip;)</p>
<p>Argo is completely based on Kubernetes, so for now it can only be categorized by namespace/labels.</p>
<p>This classification structure is very different from Jenkins' view-folder system, which doesn&rsquo;t feel very useful at the moment (or maybe it&rsquo;s purely a web UI issue)</p>
<h3 id="6-ways-to-trigger-builds">6. Ways to trigger builds</h3>
<p>Argo Workflows' pipeline has several ways to trigger.</p>
<ul>
<li>Manual trigger: manually committing a Workflow triggers a build. This can be done by <a href="https://argoproj.github.io/argo/workflow-templates/#create-workflow-from-workflowtemplate-spec">workflowTemplateRef</a> directly referencing a ready-made workflow template.</li>
<li>Timed triggers: <a href="https://argoproj.github.io/argo/cron-workflows/">CronWorkflow</a></li>
<li>Triggered by Git repository changes: you can do this with <a href="https://github.com/argoproj/argo-events">argo-events</a>, see the documentation for details.
<ul>
<li>It&rsquo;s also unclear how reliable WebHook is. Could a Git repository change without Workflow triggering because of a downtime or disconnection, and there&rsquo;s no visible error notification? If this error is just hidden away, it could lead to serious problems!</li>
</ul>
</li>
</ul>
<h3 id="7-secrets-management">7. secrets management</h3>
<p>The Argo Workflows pipeline can get information from kubernetes secrets/configmap, inject it into environment variables, or mount it as a file in a Pod.</p>
<p>Git private keys, Harbor repository credentials, and kubeconfig for CDs are all available directly from secrets/configmap.</p>
<p>Also, since Vault is so popular, you can save secrets in Vault and inject them into the Pod via the vault agent.</p>
<h3 id="8-artifacts">8. Artifacts</h3>
<p>Argo supports access to an object store to make a global Artifact repository, which can be used locally with MinIO.</p>
<p>The biggest benefit of using an object store to store Artifacts is that you can pass data between Pods at will, and Pods can run on any node in a Kubernetes cluster in a completely distributed fashion.</p>
<p>Also consider using the Artifact repository to implement cache reuse across pipelines (not tested) to improve build speed.</p>
<h3 id="9-container-image-building">9. Container image building</h3>
<p>Distributed builds of container images can be achieved with container image build tools such as Buildkit.</p>
<p>Buildkit also has good support for build caching, which can be stored directly in the container image repository.</p>
<blockquote>
<p>Google&rsquo;s Kaniko is not recommended, it does not have good support for cache reuse, and the community is not active.</p>
</blockquote>
<h3 id="10-clientsdk">10. Client/SDK</h3>
<p>Argo has a command line client available, as well as an HTTP API to use.</p>
<p>The following projects are worth trying.</p>
<ul>
<li><a href="https://github.com/argoproj-labs/argo-client-python">argo-client-python</a>: Python client for Argo Workflows
<ul>
<li>To be honest, it feels as hard to use as kubernetes-client/python, after all, it&rsquo;s all generated by openapi-generator&hellip;</li>
</ul>
</li>
<li><a href="https://github.com/argoproj-labs/argo-python-dsl">argo-python-dsl</a>: writing Argo Workflows using Python DSL
<ul>
<li>Feels more difficult to use than yaml, and not very useful.</li>
</ul>
</li>
<li><a href="https://github.com/couler-proj/couler">couler</a>: provide a unified build and management interface for Argo/Tekton/Airflow
<ul>
<li>Good idea, to be studied</li>
</ul>
</li>
</ul>
<p>I think couler is pretty good, you can write WorkflowTemplate in Python directly, so all CI/CD code is in Python in one step.</p>
<p>In addition, since Argo Workflows is a kubernetes custom resource CR, you can also use helm/kustomize to do workflow generation.</p>
<p>Currently some of our Argo workflow configurations, which are very multi-step but also very repetitive, are generated using helm - the key data is extracted into values.yaml and the workflow configuration is generated using the helm template + <code>range</code> loop.</p>
<h2 id="ii-install-argo-workflows">II. Install Argo Workflows</h2>
<p>Install a cluster wide version of Argo Workflows, using MinIO for artifacts storage.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">kubectl apply -f https://raw.githubusercontent.com/argoproj/argo/stable/manifests/install.yaml
</code></pre></td></tr></table>
</div>
</div><p>Deploy MinIO:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">helm repo add minio https://helm.min.io/ <span class="c1"># official minio Helm charts</span>
<span class="c1"># 查看历史版本</span>
helm search repo minio/minio -l <span class="p">|</span> head
<span class="c1"># 下载并解压 chart</span>
helm pull minio/minio --untar --version 8.0.9

<span class="c1"># 编写 custom-values.yaml，然后部署 minio</span>
kubectl create namespace minio
helm install minio ./minio -n argo -f custom-values.yaml
</code></pre></td></tr></table>
</div>
</div><p>When minio is deployed, it saves the default <code>accesskey</code> and <code>secretkey</code> in a secret named <code>minio</code>. We need to modify argo&rsquo;s configuration to make minio its default artifact repository.</p>
<p>Add the following fields to the data in configmap <code>workflow-controller-configmap</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="w">  </span><span class="nt">artifactRepository</span><span class="p">:</span><span class="w"> </span><span class="p">|</span><span class="sd">
</span><span class="sd">    # 是否将 main 容器的日志保存为 artifact，这样 pod 被删除后，仍然可以在 artifact 中找到日志
</span><span class="sd">    archiveLogs: true
</span><span class="sd">    s3:
</span><span class="sd">      bucket: argo-bucket   # bucket 名称，这个 bucket 需要先手动创建好！
</span><span class="sd">      endpoint: minio:9000  # minio 地址
</span><span class="sd">      insecure: true
</span><span class="sd">      # 从 minio 这个 secret 中获取 key/secret
</span><span class="sd">      accessKeySecret:
</span><span class="sd">        name: minio
</span><span class="sd">        key: accesskey
</span><span class="sd">      secretKeySecret:
</span><span class="sd">        name: minio
</span><span class="sd">        key: secretkey</span><span class="w">    
</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>There is one last step left: manually access minio&rsquo;s Web UI and create the bucket <code>argo-bucket</code>. You can access the Web UI by directly accessing minio&rsquo;s port 9000 (you need to expose this port using nodeport/ingress, etc.) and logging in using the aforementioned secret <code>minio</code> with the key/secret, and you can create the bucket.</p>
<h3 id="serviceaccount-configuration">ServiceAccount configuration</h3>
<p>Argo Workflows rely on the ServiceAccount for authentication and authorization, and by default it uses the <code>default</code> ServiceAccount of the namespace where it runs the workflow.</p>
<p>But the <code>default</code> ServiceAccount doesn&rsquo;t have any privileges by default! So Argo&rsquo;s artifacts, outputs, access to secrets, etc. are all unusable due to insufficient permissions!</p>
<p>For this reason, Argo&rsquo;s official documentation provides two solutions.</p>
<p>Method 1 is to bind <code>cluster-admin</code> ClusterRole directly to default and give it cluster administrator privileges with a single command (but obviously security is a concern).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">kubectl create rolebinding default-admin --clusterrole<span class="o">=</span>admin --serviceaccount<span class="o">=</span>&lt;namespace&gt;:default -n &lt;namespace&gt;
</code></pre></td></tr></table>
</div>
</div><p>Method 2, the official <a href="https://argoproj.github.io/argo/workflow-rbac/">Role definition of the least privilege required for Argo Workflows</a> is given, I changed it to a ClusterRole for convenience:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">rbac.authorization.k8s.io/v1</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">ClusterRole</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">argo-workflow-role</span><span class="w">
</span><span class="w"></span><span class="nt">rules</span><span class="p">:</span><span class="w">
</span><span class="w"></span><span class="c"># pod get/watch is used to identify the container IDs of the current pod</span><span class="w">
</span><span class="w"></span><span class="c"># pod patch is used to annotate the step&#39;s outputs back to controller (e.g. artifact location)</span><span class="w">
</span><span class="w"></span>- <span class="nt">apiGroups</span><span class="p">:</span><span class="w">
</span><span class="w">  </span>- <span class="s2">&#34;&#34;</span><span class="w">
</span><span class="w">  </span><span class="nt">resources</span><span class="p">:</span><span class="w">
</span><span class="w">  </span>- <span class="l">pods</span><span class="w">
</span><span class="w">  </span><span class="nt">verbs</span><span class="p">:</span><span class="w">
</span><span class="w">  </span>- <span class="l">get</span><span class="w">
</span><span class="w">  </span>- <span class="l">watch</span><span class="w">
</span><span class="w">  </span>- <span class="l">patch</span><span class="w">
</span><span class="w"></span><span class="c"># logs get/watch are used to get the pods logs for script outputs, and for log archival</span><span class="w">
</span><span class="w"></span>- <span class="nt">apiGroups</span><span class="p">:</span><span class="w">
</span><span class="w">  </span>- <span class="s2">&#34;&#34;</span><span class="w">
</span><span class="w">  </span><span class="nt">resources</span><span class="p">:</span><span class="w">
</span><span class="w">  </span>- <span class="l">pods/log</span><span class="w">
</span><span class="w">  </span><span class="nt">verbs</span><span class="p">:</span><span class="w">
</span><span class="w">  </span>- <span class="l">get</span><span class="w">
</span><span class="w">  </span>- <span class="l">watch</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>Create the smallest ClusterRole above, then for each namespace, run the following command to bind the default account to the clusterrole:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">kubectl create rolebinding default-argo-workflow --clusterrole<span class="o">=</span>argo-workflow-role  --serviceaccount<span class="o">=</span>&lt;namespace&gt;:default -n &lt;namespace&gt;
</code></pre></td></tr></table>
</div>
</div><p>This will give the default account minimal access to run workflow.</p>
<p>Or if you want to use another ServiceAccount to run workflow, you can create your own ServiceAccount and then follow the process in method 2 above, but at the end, remember to set the <code>spec.ServiceAccountName</code>.</p>
<h3 id="workflow-executors">Workflow Executors</h3>
<p>A Workflow Executor is a process that conforms to a specific interface and through which Argo can perform actions such as monitoring Pod logs, collecting Artifacts, managing container lifecycles, etc&hellip;</p>
<p>There are several implementations of Workflow Executor, which can be selected via the configmap <code>workflow-controller-configmap</code> mentioned earlier.</p>
<p>The available options are as follows.</p>
<ol>
<li>docker (default): Currently the most widely used, but the least secure. It requires mount access to <code>docker.sock</code>, so you must have root privileges!</li>
<li>kubelet: Very little used and currently lacking in functionality, must also provide root privileges</li>
<li>Kubernetes API (k8sapi): directly by calling k8sapi to achieve log monitoring, Artifacts phone and other functions, very secure, but performance is not good.
Process Namespace Sharing (pns): Less secure than k8sapi because Process is visible to all other containers. But the relative performance is much better.</li>
</ol>
<p>At a time when docker is being abandoned by kubernetes, if you have switched to containerd as the kubernetes runtime, argo will not work because it uses docker as the runtime by default!</p>
<p>We recommend changing the workflow executore to <code>pns</code> to balance security and performance, and <code>workflow-controller-configmap</code> as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">ConfigMap</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">workflow-controller-configmap</span><span class="w">
</span><span class="w"></span><span class="nt">data</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">config</span><span class="p">:</span><span class="w"> </span><span class="p">|</span><span class="sd">
</span><span class="sd">    # ...省略若干配置...
</span><span class="sd">
</span><span class="sd">    # Specifies the container runtime interface to use (default: docker)
</span><span class="sd">    # must be one of: docker, kubelet, k8sapi, pns
</span><span class="sd">    containerRuntimeExecutor: pns
</span><span class="sd">    # ...    </span><span class="w">    
</span></code></pre></td></tr></table>
</div>
</div><h2 id="iii-using-argo-workflows-as-a-ci-tool">III. Using Argo Workflows as a CI tool</h2>
<p>The official Reference is quite detailed and provides a lot of examples for our reference, here we provide a few common workflow definitions.</p>
<ol>
<li>use buildkit to build images: <a href="https://github.com/argoproj/argo-workflows/blob/master/examples/buildkit-template.yaml">https://github.com/argoproj/argo-workflows/blob/master/examples/buildkit-template.yaml</a>
<ol>
<li>buildkit supports caching, you can customize the parameters based on this example</li>
<li>Note that using PVC to share storage across steps is much faster than using artifacts.</li>
</ol>
</li>
</ol>
<h2 id="iv-frequently-asked-questions">IV. Frequently Asked Questions</h2>
<h3 id="1-does-workflow-use-the-root-account-by-default">1. Does workflow use the root account by default?</h3>
<p>If your image defaults to a non-root account and you want to modify the files, you are likely to encounter Permission Denined issues.</p>
<p>Solution: Manually set the user/group of the container via Pod Security Context:</p>
<ul>
<li><a href="https://argoproj.github.io/argo/workflow-pod-security-context/">Workflow Pod Security Context</a></li>
</ul>
<p>For security reasons, I recommend that all workflows manually set <code>securityContext</code>, for example</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">argoproj.io/v1alpha1</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">WorkflowTemplate</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">xxx</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">securityContext</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">runAsNonRoot</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span><span class="w">    </span><span class="nt">runAsUser</span><span class="p">:</span><span class="w"> </span><span class="m">1000</span><span class="w">
</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>Or you can set the default workflow configuration with <code>workflowDefaults</code> of <code>workflow-controller-configmap</code>.</p>
<h3 id="2-how-to-read-secrets-from-hashicorp-vault">2. How to read secrets from hashicorp vault?</h3>
<blockquote>
<p>Refer to <a href="https://github.com/argoproj/argo/issues/3267#issuecomment-650119636">Support to get secrets from Vault</a></p>
</blockquote>
<p>hashicorp vault is currently arguably the most popular secrets management tool in the cloud-native space. We use it as a distributed configuration center in our production environment, and we also use it to store sensitive information in our local CI/CD.</p>
<p>Now that we are migrating to argo, we of course want to have a good way to read the configuration from the vault.</p>
<p>The most recommended method, by far, is to use vault&rsquo;s vault-agent to inject secrets into the pod as a file.</p>
<p>With the valut-policy - vault-role - k8s-serviceaccount configuration, you can set very granular secrets permissions rules, and the configuration information cannot be re-read, making it very secure.</p>
<h3 id="3-how-do-i-use-the-same-secrets-in-multiple-namespaces">3. How do I use the same secrets in multiple namespaces?</h3>
<p>A common problem when using Namespace to classify workflow is how to use secrets necessary for workflow such as <code>private-git-creds</code> / <code>docker-config</code> / <code>minio</code> / <code>vault</code> in multiple namespaces.</p>
<p>A common approach is to create secrets once in all namespaces.</p>
<p>But there are also more convenient tools for secrets synchronization.</p>
<p>For example, to configure secrets synchronization using <a href="https://github.com/kyverno/kyverno">kyverno</a>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">kyverno.io/v1</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">ClusterPolicy</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">sync-secrets</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">background</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="w">
</span><span class="w">  </span><span class="nt">rules</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="c"># 将 secret vault 从 argo Namespace 同步到其他所有 Namespace</span><span class="w">
</span><span class="w">  </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">sync-vault-secret</span><span class="w">
</span><span class="w">    </span><span class="nt">match</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">resources</span><span class="p">:</span><span class="w">
</span><span class="w">        </span><span class="nt">kinds</span><span class="p">:</span><span class="w">
</span><span class="w">        </span>- <span class="l">Namespace</span><span class="w">
</span><span class="w">    </span><span class="nt">generate</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Secret</span><span class="w">
</span><span class="w">      </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">regcred</span><span class="w">
</span><span class="w">      </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;{{request.object.metadata.name}}&#34;</span><span class="w">
</span><span class="w">      </span><span class="nt">synchronize</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span><span class="w">      </span><span class="nt">clone</span><span class="p">:</span><span class="w">
</span><span class="w">        </span><span class="nt">namespace</span><span class="p">:</span><span class="w"> </span><span class="l">argo</span><span class="w">
</span><span class="w">        </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">vault</span><span class="w">
</span><span class="w">  </span><span class="c"># 可以配置多个 rules，每个 rules 同步一个 secret</span><span class="w">
</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>The kyverno configuration provided above will monitor all Namespace changes in real time and will immediately sync the <code>vault</code> secret to a new Namespace as soon as it is created.</p>
<p>Alternatively, use the dedicated secrets/configmap replication tool: <a href="https://github.com/mittwald/kubernetes-replicator">kubernetes-replicator</a></p>
<h3 id="4-argos-validation-of-cr-resources-is-not-rigorous-enough-it-doesnt-even-report-an-error-if-you-write-the-wrong-key">4. Argo&rsquo;s validation of CR resources is not rigorous enough, it doesn&rsquo;t even report an error if you write the wrong key</h3>
<p>To be studied</p>
<h3 id="5-how-to-archive-historical-data">5. how to archive historical data?</h3>
<p>When Argo is used for a long time, all the Workflows/Pods run by Argo are saved in Kubernetes/Argo Server, which makes Argo slower and slower.</p>
<p>To solve this problem, Argo provides some configurations to limit the number of Workflows and Pods, see: [Limit The Total Number Of Workflows And Pods](<a href="https://argoproj.github.io/argo/cost-">https://argoproj.github.io/argo/cost-</a> optimisation/#limit-the-total-number-of-workflows-and-pods)</p>
<p>These limits are Workflow parameters, if you want to set a global default limit, you can modify argo&rsquo;s <code>workflow-controller-configmap</code> configmap as follows:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">ConfigMap</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">workflow-controller-configmap</span><span class="w">
</span><span class="w"></span><span class="nt">data</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">config</span><span class="p">:</span><span class="w"> </span><span class="p">|</span><span class="sd">
</span><span class="sd">    # Default values that will apply to all Workflows from this controller, unless overridden on the Workflow-level
</span><span class="sd">    # See more: docs/default-workflow-specs.md
</span><span class="sd">    workflowDefaults:
</span><span class="sd">      spec:
</span><span class="sd">        # must complete in 8h (28,800 seconds)
</span><span class="sd">        activeDeadlineSeconds: 28800
</span><span class="sd">        # keep workflows for 1d (86,400 seconds)
</span><span class="sd">        ttlStrategy:
</span><span class="sd">          secondsAfterCompletion: 86400
</span><span class="sd">          # secondsAfterSuccess: 5
</span><span class="sd">          # secondsAfterFailure: 500
</span><span class="sd">        # delete all pods as soon as they complete
</span><span class="sd">        podGC:
</span><span class="sd">          # 可选项：&#34;OnPodCompletion&#34;, &#34;OnPodSuccess&#34;, &#34;OnWorkflowCompletion&#34;, &#34;OnWorkflowSuccess&#34;
</span><span class="sd">          strategy: OnPodCompletion    </span><span class="w">    
</span></code></pre></td></tr></table>
</div>
</div><h3 id="6-other-advanced-configurations-for-argo">6. Other advanced configurations for Argo</h3>
<p>The configuration of Argo Workflows is stored in the <code>workflow-controller-configmap</code> configmap, which we have already touched on.</p>
<p>Here is a full example of this configuration file: <a href="https://github.com/argoproj/argo/blob/master/docs/workflow-controller-configmap.yaml">https://github.com/argoproj/argo/blob/master/docs/workflow-controller-configmap.yaml</a></p>
<p>Some of the parameters that may need to be customized are as follows.</p>
<ul>
<li><code>parallelism</code> : the maximum number of parallelism for the workflow</li>
<li><code>persistence</code> : save completed workflows to postgresql/mysql, so that you can view workflow records even if the workflow is deleted from k8s
<ul>
<li>also supports configuring the expiration time</li>
</ul>
</li>
<li><code>sso</code> : enable single sign-on</li>
</ul>
<h3 id="7-should-i-try-to-use-the-features-provided-by-cicd-tools">7. Should I try to use the features provided by CI/CD tools?</h3>
<p>I know from my colleagues and the web that some DevOps people advocate using Python/Go to implement the CI/CD pipeline by themselves as much as possible, and not to use the features provided by CI/CD tools if they can.</p>
<p>That&rsquo;s why I have this question. Here&rsquo;s a detailed analysis.</p>
<p>Try to use the CI/CD tools to provide plug-ins / features, the benefit is not to achieve their own, can reduce maintenance costs. But the relative operations and maintenance staff will need to learn the use of this CI/CD tool in depth, in addition to the CI/CD tool binding, will increase the difficulty of migration.</p>
<p>If you try to use Python code to implement the pipeline and let the CI/CD tool only be responsible for scheduling and running the Python code, then the CI/CD can be easily changed at will, and the operation and maintenance personnel do not need to learn the use of the CI/CD tool in depth. The downside is that it may increase the complexity of the CI/CD code.</p>
<p>I have observed some examples of argo/drone and found that they are characterized by: 1.</p>
<ol>
<li>all CI/CD related logic is implemented in the pipeline, no other build code is needed</li>
<li>each step uses a dedicated image: golang/nodejs/python
<ol>
<li>for example, first use golang image for testing, building, and then use kaniko to package into container images</li>
</ol>
</li>
</ol>
<p>So should we try to use the features provided by CI/CD tools? ** It&rsquo;s really a question of which method to use when there are multiple ways to implement the same thing. This question is common in all areas. **</p>
<p>In my experience so far, it needs to be problem specific, using Argo Workflows as an example.</p>
<ol>
<li>the pipeline itself is very simple, then you can directly use argo to implement, no need to get a python script
<ol>
<li>a simple pipeline, migration is often very simple. There is no need to use argo to call a python script just for the sake of migratability.</li>
</ol>
</li>
<li>If there is a lot of logic/data passing between steps in the pipeline, there is probably something wrong with your pipeline design!
<ol>
<li><strong>The data passed between steps of the pipeline should be as small as possible! Complex logical judgments should be encapsulated in one of the steps as much as possible!</strong>.</li>
<li>in this case, python scripts should be used to encapsulate the complex logic, instead of exposing it to Argo Workflows!</li>
</ol>
</li>
<li>I need to run a lot of pipelines in batch, with complex dependencies between them: I should obviously take advantage of the advanced features of argo wrokflow.
<ol>
<li>argo&rsquo;s dag/steps and workflow of workflows are two features that can be combined to simply implement the above functionality.</li>
</ol>
</li>
</ol>
<h3 id="8-how-to-improve-the-speed-of-creation-and-destruction-of-argo-workflows">8. How to improve the speed of creation and destruction of Argo Workflows?</h3>
<p>We found that workflow pods consume a lot of time to create and destroy, especially destruction. This caused our single pipeline to run on argo, but not as fast as on jenkins.</p>
<h2 id="experience">Experience</h2>
<p>I&rsquo;ve been using Argo Workflows for over a month now, and in general, the most difficult part is the Web UI.</p>
<p>All the others are minor problems, but the Web UI is really hard to use, I feel like I haven&rsquo;t designed it properly&hellip;</p>
<p>Urgently need a third party Web UI&hellip;</p>
<h2 id="how-to-handle-dependencies-between-other-kubernetes-resources">How to handle dependencies between other Kubernetes resources</h2>
<p>The most important feature of Argo, compared to other CI tools, is that it assumes that there are dependencies between &ldquo;tasks&rdquo;, so it provides a variety of ways to orchestrate &ldquo;tasks&rdquo;.</p>
<p>However, it seems that Argo CD does not inherit this concept. When Argo CD is deployed, it does not define dependencies between kubernetes resources through DAG and other methods.</p>
<p>Microservices have dependencies and want to be deployed as such, while ArgoCD/FluxCD deploys kubernetes yaml without any dependencies in mind. There is a contradiction here.</p>
<p>There are many ways to solve this contradiction, I have checked many sources and done some thinking myself, and the best practice I got is from <a href="https://developer.aliyun.com/article/573791">Resolving Service Dependencies - AliCloud ACK Container Service</a>, which gives two options.</p>
<ol>
<li><strong>Application-side service dependency checking</strong> : that is, add dependency checking logic to the entry of microservices to ensure that all dependent microservices/databases are accessible before the renewal probe returns 200. If it times out, it directly Crashes</li>
<li><strong>Independent Service Dependency Checking Logic</strong> : Some legacy code may be difficult to modify using method 1, so you can consider using <strong>pod initContainer</strong> or adding dependency checking logic to the container startup script.</li>
</ol>
<p>But there are still some problems with these two solutions, so before I explain the problem, let me explain our &ldquo;<strong>deploy in order</strong>&rdquo; application scenario.</p>
<p>We are a very small team, and when we do RPC interface upgrade on the backend, we usually do the full upgrade + test directly in the development environment. Therefore, on the O&amp;M side as well, we do a full upgrade every time.</p>
<p>Because there is no protocol negotiation mechanism, the &ldquo;RPC server&rdquo; of the new microservice will be compatible with both the old and new protocols of v1 v2, while the new &ldquo;RPC client&rdquo; will directly use the v2 protocol to request other microservices. This means that we <strong>must upgrade the &ldquo;RPC server&rdquo; before we can upgrade the &ldquo;RPC client &ldquo;</strong>.</p>
<p>For this reason, when performing a full upgrade of a microservice, it is necessary to upgrade sequentially along the RPC call chain, which involves the dependencies between Kubernetes resources.</p>
<blockquote>
<p>The key problem I&rsquo;ve learned so far is that we&rsquo;re not using a true microservice development model, but are treating the entire microservice system as a &ldquo;single service&rdquo;, which leads to this dependency critical issue. The new company I joined had no such problem at all. All services were decoupled at the CI/CD stage, and the CI/CD did not need to consider the dependencies between services, nor did it have the ability to automatically batch release microservices according to the dependencies, which were all maintained by the developers themselves. Perhaps this is the correct posture, if you do not move to update a large number of services, the design of the microservice system, splitting must be a problem, and the production environment will not allow such a frivolous update.</p>
</blockquote>
<p>As mentioned earlier, AliCloud&rsquo;s &ldquo;application-side service dependency checking&rdquo; and &ldquo;independent service dependency checking logic&rdquo; are best practices. Their advantages are.</p>
<ol>
<li>simplify the deployment logic, each time directly do a full deployment OK. 2.</li>
<li>improve deployment speed, as evidenced by: GitOps deployment process only needs to go once (sequential deployment is many times), all images are pulled in advance, and all Pods are started in advance.</li>
</ol>
<p>However, there is a problem with &ldquo;grayscale releases&rdquo; or &ldquo;rolling updates&rdquo;, both of which have the problem of <strong>new and old versions co-existing</strong>.</p>
<p>If there is an RPC interface upgrade, then you must first complete the &ldquo;gray release&rdquo; or &ldquo;rolling update&rdquo; of the &ldquo;RPC server&rdquo;, and then update the &ldquo;RPC client&rdquo;.</p>
<p>Otherwise, if you do grayscale update for all microservices directly and only rely on &ldquo;service dependency checking&rdquo;, you will have this problem - the &ldquo;RPC server&rdquo; is in a &ldquo;Schrödinger&rdquo; state, and the version of the server you invoke is new or old, depending on the load balancing policy and probability.</p>
<p><strong>So when doing a full upgrade of RPC interfaces, relying only on &ldquo;service dependency checking&rdquo; won&rsquo;t work.</strong> The options I have in mind so far are as follows.</p>
<ul>
<li>Our current use scenario: <strong>Implement sequential deployment in the yaml deployment step</strong> and poll kube-apiserver after each deployment to make sure all grayed out before proceeding to the next stage of yaml deployment.</li>
<li><strong>Let the backend add a parameter to control the version of the RPC protocol used by the client, or have a protocol negotiation</strong>. This eliminates the need to control the order of microservice releases.</li>
<li>The deployment of many stateful applications in the community involves complex operations such as deployment order, and a popular solution is <strong>to use Operator+CRD for such applications</strong>.</li>
</ul>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/argo/">argo</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-01/expirence-of-vault/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Introduction, installation and use of the secrets management tool Vault</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-01/socat-netcat/">
            <span class="next-text nav-default">The Swiss Army knife of Linux networking tools - socat &amp; netcat</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
