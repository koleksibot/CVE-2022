<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>C programming implementation of memory management functions with out-of-bounds checking - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="The C language is highly efficient, flexible, feature-rich and portable, and is highly sought after in programming, especially in system software development. Its efficient flexibility is largely due to its ability to provide low-end control over memory by pointing to it, but at the cost of programmers having to handle memory access details with extra care to avoid operational errors such as memory leaks and buffer overflows.
 Writing in C or C&#43;&#43; is like running a chain saw with all the safety guards removed." /><meta name="keywords" content="c, Memory Overrun Detection" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-01/memory-overrun-detection/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="C programming implementation of memory management functions with out-of-bounds checking" />
<meta property="og:description" content="The C language is highly efficient, flexible, feature-rich and portable, and is highly sought after in programming, especially in system software development. Its efficient flexibility is largely due to its ability to provide low-end control over memory by pointing to it, but at the cost of programmers having to handle memory access details with extra care to avoid operational errors such as memory leaks and buffer overflows.
 Writing in C or C&#43;&#43; is like running a chain saw with all the safety guards removed." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-01/memory-overrun-detection/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-01-10T13:37:56+08:00" />
<meta property="article:modified_time" content="2022-01-10T13:37:56+08:00" />

<meta itemprop="name" content="C programming implementation of memory management functions with out-of-bounds checking">
<meta itemprop="description" content="The C language is highly efficient, flexible, feature-rich and portable, and is highly sought after in programming, especially in system software development. Its efficient flexibility is largely due to its ability to provide low-end control over memory by pointing to it, but at the cost of programmers having to handle memory access details with extra care to avoid operational errors such as memory leaks and buffer overflows.
 Writing in C or C&#43;&#43; is like running a chain saw with all the safety guards removed."><meta itemprop="datePublished" content="2022-01-10T13:37:56+08:00" />
<meta itemprop="dateModified" content="2022-01-10T13:37:56+08:00" />
<meta itemprop="wordCount" content="1686">
<meta itemprop="keywords" content="c," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="C programming implementation of memory management functions with out-of-bounds checking"/>
<meta name="twitter:description" content="The C language is highly efficient, flexible, feature-rich and portable, and is highly sought after in programming, especially in system software development. Its efficient flexibility is largely due to its ability to provide low-end control over memory by pointing to it, but at the cost of programmers having to handle memory access details with extra care to avoid operational errors such as memory leaks and buffer overflows.
 Writing in C or C&#43;&#43; is like running a chain saw with all the safety guards removed."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">C programming implementation of memory management functions with out-of-bounds checking</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-01-10 13:37:56 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 1686 words </span>
          <span class="more-meta"> 8 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li>
          <ul>
            <li><a href="#program-objective">Program Objective</a></li>
            <li><a href="#design-implementation">Design Implementation</a></li>
            <li><a href="#compile-and-run">Compile and run</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>The C language is highly efficient, flexible, feature-rich and portable, and is highly sought after in programming, especially in system software development. Its efficient flexibility is largely due to its ability to provide low-end control over memory by pointing to it, but at the cost of programmers having to handle memory access details with extra care to avoid operational errors such as memory leaks and buffer overflows.</p>
<blockquote>
<p>Writing in C or C++ is like running a chain saw with all the safety guards removed. It’s powerful, but it’s easy to cut off your fingers.
— Bob Gray（senior director of consulting firm Virtual Solutions, cited in Byte (1998) Vol 23, Nr 1-4. p . 70. ）</p>
</blockquote>
<p>To overcome this weakness of C programming, developers have developed many runtime memory debugging tools to quickly detect memory leaks and locate buffer overflow errors in real time. The well-known open source free memory debuggers are <a href="https://www.valgrind.org/">Valgrind</a>, <a href="https://dmalloc.com/">dmalloc</a> and <a href="https://packetmania.github.io/2021/08/03/asan-intro/">AddressSanitizer</a>, etc. A general design idea of memory debugging tools is to reserve some storage space to hold relevant information when allocating memory, and then use this information to do status checks during runtime and memory release.</p>
<p>In particular, if the memory allocation function reserves some blocks of storage before and after the memory area returned to the caller for use, filled with a fixed sequence of bytes as boundary identifiers, then it can be checked in real time at subsequent program runs to see if the before and after boundary identifiers have been changed. If so, a buffer overflow error has occurred and a problem with memory usage is reported immediately. These reserved memory blocks are also called red zones, which means that when a memory access is out of bounds, it is like running a program that has stepped on a red line and should be alerted.</p>
<h3 id="program-objective">Program Objective</h3>
<p>For learning purposes, here is a demonstration of a memory management function implemented in C programming language that supports out-of-bounds checking. The objectives to be achieved by the program are.</p>
<ul>
<li>Write your own memory allocation and release functions that internally encapsulate the standard library functions <code>malloc()/free()</code></li>
<li>When allocating memory, add a 4-byte red zone to the beginning and end of the returned memory area
<ul>
<li>write <code>0x0D0C0B0A</code> to the header</li>
<li>The tail (footer) writes <code>0x12345678</code></li>
</ul>
</li>
<li>Write a review function to check the address of the given memory allocation and alert if there is an error</li>
<li>When freeing the memory, check again if the red zone is modified and alert if it is</li>
<li>Write test code to verify that the above memory management functions do what they are designed to do</li>
</ul>
<h3 id="design-implementation">Design Implementation</h3>
<p>Here are the implementation details of the program. First, we understand that the standard library function <code>malloc()</code> returns the address of the allocated memory, and the size of the memory area is determined by the input parameter <code>size</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="o">*</span><span class="nf">malloc</span><span class="p">(</span><span class="n">size_t</span> <span class="n">size</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>Considering the 4-byte red zone at the beginning and tail, it is clear that the new memory allocation function must request an additional 8 bytes of memory. But this is not enough, to check the trailing red area, the review function must know the size of the allocated memory, otherwise it cannot locate the trailing part. So 4 more bytes have to be allocated to preserve the memory area size <code>size</code>. The resulting structure of the entire memory allocation is shown in the following figure.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/10/a009f808d6054403a5a3d558498c70bb.png" alt="image"></p>
<p>So the actual memory size to be passed to the standard library function <code>malloc()</code> is the amount of memory requested plus 12, and the available memory address returned by the new memory allocation function is the pointer returned by <code>malloc()</code> plus an address offset of 8. With these key details in hand, the implementation of the new memory allocation function is now clear.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* redzone patterns */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">header</span> <span class="o">=</span> <span class="mh">0x0D0C0B0A</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">footer</span> <span class="o">=</span> <span class="mh">0x12345678</span><span class="p">;</span>

<span class="kt">void</span><span class="o">*</span> <span class="nf">my_malloc</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">sz</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span> <span class="p">(</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">sz</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
    <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span> <span class="o">=</span> <span class="n">header</span><span class="p">;</span>
    <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">=</span> <span class="n">sz</span><span class="p">;</span>
    <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span><span class="p">)(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">+</span> <span class="n">sz</span><span class="p">)</span> <span class="o">=</span> <span class="n">footer</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">8</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The implementation of the corresponding memory review and release functions is simple. The memory review function can call the assertion <code>assert()</code> library function to confirm that the available memory size value and the first and last red zone byte sequence have not been changed. The same check is done when releasing memory, and it is released after there are no errors. The two functions are implemented as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">my_check</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">sz</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span><span class="p">)(</span><span class="n">p</span> <span class="o">-</span> <span class="mi">8</span><span class="p">)</span> <span class="o">==</span> <span class="n">header</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span><span class="p">)(</span><span class="n">p</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="n">sz</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="n">p</span> <span class="o">+</span> <span class="n">sz</span><span class="p">)</span> <span class="o">==</span> <span class="n">footer</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">my_free</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">real_p</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="mi">8</span><span class="p">;</span>
    <span class="n">assert</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">real_p</span> <span class="o">==</span> <span class="n">header</span><span class="p">);</span>
    <span class="n">size_t</span> <span class="n">sz</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span><span class="p">)(</span><span class="n">real_p</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span><span class="p">)(</span><span class="n">real_p</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">+</span> <span class="n">sz</span><span class="p">)</span> <span class="o">==</span> <span class="n">footer</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">real_p</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The next step is to write the test code. When debugging and testing software, it is often necessary to print the contents of the storage area in hexadecimal format, and the following my_hexdump() provides this aid (the macro HDMP_COLS defines printing 16 bytes per line).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#ifndef HDMP_COLS
</span><span class="cp">#define HDMP_COLS 16
</span><span class="cp">#endif
</span><span class="cp"></span>
<span class="kt">void</span> <span class="nf">my_hexdump</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">mem</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">extra</span><span class="p">;</span>
    <span class="n">extra</span> <span class="o">=</span> <span class="p">(</span><span class="n">len</span> <span class="o">%</span> <span class="n">HDMP_COLS</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">HDMP_COLS</span> <span class="o">-</span> <span class="n">len</span> <span class="o">%</span> <span class="n">HDMP_COLS</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">+</span> <span class="n">extra</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">HDMP_COLS</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* print address */</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">&#34;</span><span class="se">\n</span><span class="s">%p: &#34;</span><span class="p">,</span> <span class="n">mem</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span> 
        <span class="p">}</span>   
 
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* print hex data */</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%02x &#34;</span><span class="p">,</span> <span class="mh">0xFF</span> <span class="o">&amp;</span> <span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">mem</span><span class="p">)[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="cm">/* print 3 space chars for alignment */</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">&#34;   &#34;</span><span class="p">);</span>
        <span class="p">}</span>   

        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">HDMP_COLS</span> <span class="o">==</span> <span class="p">(</span><span class="n">HDMP_COLS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
            <span class="cm">/* print ASCII dump */</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="p">(</span><span class="n">HDMP_COLS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
                    <span class="cm">/* end of block */</span>
                    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;</span><span class="se">\n\n</span><span class="s">&#34;</span><span class="p">);</span>
                    <span class="k">return</span><span class="p">;</span>
                <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">isprint</span><span class="p">(((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">mem</span><span class="p">)[</span><span class="n">j</span><span class="p">]))</span> <span class="p">{</span>
                    <span class="cm">/* printable char */</span>
                    <span class="n">putchar</span><span class="p">(</span><span class="mh">0xFF</span> <span class="o">&amp;</span> <span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">mem</span><span class="p">)[</span><span class="n">j</span><span class="p">]);</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="cm">/* other char, print &#39;.&#39; instead */</span>
                    <span class="n">putchar</span><span class="p">(</span><span class="sc">&#39;.&#39;</span><span class="p">);</span>
                <span class="p">}</span>   
            <span class="p">}</span>   
        <span class="p">}</span>   
    <span class="p">}</span>   
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The following code snippet shows that the main function first performs a positive test on the new memory management function, i.e., no out-of-bounds write operation and no assertion error.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">my_malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span> <span class="s">&#34;Usable memory start at %p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
    <span class="n">my_hexdump</span><span class="p">(</span><span class="n">ptr</span> <span class="o">-</span> <span class="mi">8</span><span class="p">,</span> <span class="n">size</span> <span class="o">+</span> <span class="mi">12</span><span class="p">);</span>
    <span class="n">my_check</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
    <span class="n">my_free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Basic test passed!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    
    <span class="n">strcpy_test</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>And on the last line, the main function calls <code>strcpy_test()</code> (the implementation code is below). This is a negative test function. It uses the unsafe string copy library function <code>strcpy()</code> to copy a 12-character string into a dynamically allocated buffer, which is also 12 bytes in size. However, because <code>strcpy()</code> copies the terminator ('\0') at the end of the string along with it, a buffer overflow error is generated. So if the new free function <code>my_free()</code> with an out-of-bounds check functioned correctly, we would see the program assert an error here.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">strcpy_test</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span> <span class="o">=</span> <span class="s">&#34;Hello world!&#34;</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">mlen</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">my_malloc</span><span class="p">(</span><span class="n">mlen</span><span class="p">);</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
    <span class="n">my_hexdump</span><span class="p">(</span><span class="n">buffer</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span> <span class="n">mlen</span><span class="o">+</span><span class="mi">12</span><span class="p">);</span>
    <span class="n">my_free</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="compile-and-run">Compile and run</h3>
<p>On a Red Hat Enterprise Linux 8.1 system environment, the linked program is compiled using GCC 8.3.1 and the final run results are</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">&gt; gcc -v
Using built-in specs.
<span class="nv">COLLECT_GCC</span><span class="o">=</span>gcc
<span class="nv">COLLECT_LTO_WRAPPER</span><span class="o">=</span>/usr/libexec/gcc/x86_64-redhat-linux/8/lto-wrapper
<span class="nv">OFFLOAD_TARGET_NAMES</span><span class="o">=</span>nvptx-none
<span class="nv">OFFLOAD_TARGET_DEFAULT</span><span class="o">=</span><span class="m">1</span>
Target: x86_64-redhat-linux
Configured with: ../configure --enable-bootstrap --enable-languages<span class="o">=</span>c,c++,fortran,lto --prefix<span class="o">=</span>/usr --mandir<span class="o">=</span>/usr/share/man --infodir<span class="o">=</span>/usr/share/info --with-bugurl<span class="o">=</span>http://bugzilla.redhat.com/bugzilla --enable-shared --enable-threads<span class="o">=</span>posix --enable-checking<span class="o">=</span>release --enable-multilib --with-system-zlib --enable-__cxa_atexit --disable-libunwind-exceptions --enable-gnu-unique-object --enable-linker-build-id --with-gcc-major-version-only --with-linker-hash-style<span class="o">=</span>gnu --enable-plugin --enable-initfini-array --with-isl --disable-libmpx --enable-offload-targets<span class="o">=</span>nvptx-none --without-cuda-driver --enable-gnu-indirect-function --enable-cet --with-tune<span class="o">=</span>generic --with-arch_32<span class="o">=</span>x86-64 --build<span class="o">=</span>x86_64-redhat-linux
Thread model: posix
gcc version 8.3.1 <span class="m">20190507</span> <span class="o">(</span>Red Hat 8.3.1-4<span class="o">)</span> <span class="o">(</span>GCC<span class="o">)</span> 
&gt;
&gt; gcc -o memcheck memcheck.c
&gt; 
&gt; memcheck
Usable memory start at 0x1823268

0x1823260: 0a 0b 0c 0d <span class="m">20</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> .... ...........
0x1823270: <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> ................
0x1823280: <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">78</span> <span class="m">56</span> <span class="m">34</span> <span class="m">12</span>             ........xV4.

Basic <span class="nb">test</span> passed!
Hello world!

0x18236b0: 0a 0b 0c 0d 0c <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">48</span> <span class="m">65</span> 6c 6c 6f <span class="m">20</span> <span class="m">77</span> 6f ........Hello wo
0x18236c0: <span class="m">72</span> 6c <span class="m">64</span> <span class="m">21</span> <span class="m">00</span> <span class="m">56</span> <span class="m">34</span> <span class="m">12</span>                         rld!.V4.

memcheck: memcheck.c:86: my_free: Assertion <span class="sb">`</span>*<span class="o">(</span>unsigned int*<span class="o">)(</span>real_p + <span class="m">8</span> + sz<span class="o">)==</span>footer<span class="err">&#39;</span> failed.
Abort
</code></pre></td></tr></table>
</div>
</div><p>As you can see, the output of <code>Basic test passed!</code> indicates that the positive test passed, and the previously printed memory area also shows the correct sequence of red zone bytes and the available memory area size value of 0x20. Note that the host system is <code>Little Endian</code>, so the sequence of red zone bytes is in the opposite order to that defined in the program. Finally, the output of the negative test case shows that the use of <code>strcpy()</code> caused a buffer overflow, changing the first byte of the trailing red zone 0x78 to 0x00. This error was caught by the free function <code>my_free()</code>, and the program asserted an error while executing the trailing byte sequence check and exited early (Abort).</p>
<p>To summarize, we have learned and programmatically practiced a basic memory out-of-bounds checking method here. Although its working principle is simple, it is the basis for understanding and applying more advanced memory debugging tools. Similar questions may come up in programmer interviews, and a full grasp of all of the above will allow you to give accurate and precise answers.</p>
<p>The full program can be downloaded here: <a href="https://www.packetmania.net/2021/03/28/Memory-overrun-detection/memcheck.c.gz">memcheck.c.gz</a></p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/c/">c</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-01/hpg-concurrency-control/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Control the number of concurrent goroutines</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-01/rpi-nas-plex/">
            <span class="next-text nav-default">Build your own home NAS and streaming server using Raspberry Pi</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
