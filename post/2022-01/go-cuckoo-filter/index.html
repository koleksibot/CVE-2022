<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Golang implementation of cuckoo filters - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Introduction In our work, if we encounter such things as web URL de-duplication, spam identification, or the determination of duplicate elements in a large collection, we usually think of saving all the elements in the collection and then determining them by comparison. If we use the best performance Hash table to make the determination, then as the number of elements in the collection increases, the storage space we need will" /><meta name="keywords" content="golang, Cuckoo, Filter" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-01/go-cuckoo-filter/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Golang implementation of cuckoo filters" />
<meta property="og:description" content="Introduction In our work, if we encounter such things as web URL de-duplication, spam identification, or the determination of duplicate elements in a large collection, we usually think of saving all the elements in the collection and then determining them by comparison. If we use the best performance Hash table to make the determination, then as the number of elements in the collection increases, the storage space we need will" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-01/go-cuckoo-filter/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-01-24T11:56:28+08:00" />
<meta property="article:modified_time" content="2022-01-24T11:56:28+08:00" />

<meta itemprop="name" content="Golang implementation of cuckoo filters">
<meta itemprop="description" content="Introduction In our work, if we encounter such things as web URL de-duplication, spam identification, or the determination of duplicate elements in a large collection, we usually think of saving all the elements in the collection and then determining them by comparison. If we use the best performance Hash table to make the determination, then as the number of elements in the collection increases, the storage space we need will"><meta itemprop="datePublished" content="2022-01-24T11:56:28+08:00" />
<meta itemprop="dateModified" content="2022-01-24T11:56:28+08:00" />
<meta itemprop="wordCount" content="3032">
<meta itemprop="keywords" content="golang," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Golang implementation of cuckoo filters"/>
<meta name="twitter:description" content="Introduction In our work, if we encounter such things as web URL de-duplication, spam identification, or the determination of duplicate elements in a large collection, we usually think of saving all the elements in the collection and then determining them by comparison. If we use the best performance Hash table to make the determination, then as the number of elements in the collection increases, the storage space we need will"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Golang implementation of cuckoo filters</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-01-24 11:56:28 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 3032 words </span>
          <span class="more-meta"> 7 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#introduction">Introduction</a></li>
        <li><a href="#principle-of-implementation">Principle of implementation</a>
          <ul>
            <li><a href="#simple-working-principle">Simple working principle</a></li>
            <li><a href="#cuckoo-filters">Cuckoo filters</a></li>
          </ul>
        </li>
        <li><a href="#code-implementation">Code implementation</a>
          <ul>
            <li><a href="#data-structure">Data structure</a></li>
            <li><a href="#initialisation">Initialisation</a></li>
            <li><a href="#inserting-elements">Inserting elements</a></li>
            <li><a href="#querying-data">Querying data</a></li>
            <li><a href="#deleting-data">Deleting data</a></li>
            <li><a href="#disadvantages">Disadvantages</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="introduction">Introduction</h2>
<p>In our work, if we encounter such things as web URL de-duplication, spam identification, or the determination of duplicate elements in a large collection, we usually think of saving all the elements in the collection and then determining them by comparison. If we use the best performance Hash table to make the determination, then as the number of elements in the collection increases, the storage space we need will also grow linearly and eventually reach the bottleneck.</p>
<p>So many times the choice is made to use a Bloom filter to do this. Bloom filters reduce the space cost significantly by mapping the keys stored in the bitmap to a fixed size binary vector or bitmap, and then to a mapping function. The complexity of the Bloom filter in terms of storage space and insertion/query time is a constant O(K). However, as the number of elements deposited increases, the Bloom filter miscalculation rate increases, and elements cannot be deleted.</p>
<p>Those who want to experience the insertion step of the Bloom filter can look here: <a href="https://www.jasondavies.com/bloomfilter/">https://www.jasondavies.com/bloomfilter/</a></p>
<p>So the Cuckoo filter was born. The disadvantages of the Bloom filter are stated directly in the paper Cuckoo Filter: Practically Better Than Bloom.</p>
<blockquote>
<p>A limitation of standard Bloom filters is that one cannot remove existing items without rebuilding the entire filter.</p>
</blockquote>
<p>The paper also mentions 4 major advantages of the cuckoo filter.</p>
<blockquote>
<ol>
<li>It supports adding and removing items dynamically;</li>
<li>It provides higher lookup performance than traditional Bloom filters, even when close to full (e.g., 95% space utilized);</li>
<li>It is easier to implement than alternatives such as the quotient filter; and</li>
<li>It uses less space than Bloom filters in many practical applications, if the target false positive rate is less than 3%.</li>
</ol>
</blockquote>
<h2 id="principle-of-implementation">Principle of implementation</h2>
<h3 id="simple-working-principle">Simple working principle</h3>
<p>You can simply put the cuckoo filter inside two hash tables T1, T2, two hash tables corresponding to two hash functions H1, H2.</p>
<p>The specific insertion steps are as follows.</p>
<ol>
<li>when a non-existent element is inserted, its position in the T1 table is first calculated according to H1, if the position is empty then it can be put in.</li>
<li>if the position is not empty, the position in the T2 table is calculated from H2 and can be put in if the position is empty. 3. if the T1 table and the T2 table are not empty, the position in the T2 table is calculated from H2 and can be put in if the position is empty.</li>
<li>if neither the T1 table nor the T2 table is empty, then a random hash table is selected to kick out the element.</li>
<li>the kicked element will cycle through to find its other position, and if it is temporarily kicked out, one will be randomly selected and the kicked element will cycle through to find its position again.</li>
<li>if there is a cycle of kicking out resulting in no elements being placed, then a threshold is set, beyond which the hash table is considered almost full, and it is then necessary to expand it and reposition all the elements.</li>
</ol>
<p>An example is given below to illustrate this.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/24/0b42406b29cf4cd4917a9377cbcdc159.png" alt="sobyte"></p>
<p>If you want to insert an element Z into the filter.</p>
<ol>
<li>first Z will be hash-calculated and it is found that both slot 1 and slot 2 corresponding to T1 and T2 are already occupied.</li>
<li>randomly kicks out element X from slot 1 in T1, and slot 4 corresponding to T2 of X is already occupied by element 3.</li>
<li>kick out element 3 from slot 4 in T2, and element 3 is found to be empty in slot 6 of T1 after hash calculation, so element 3 is inserted into slot 6 of T1.</li>
</ol>
<p>When Z has been inserted it looks like this.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/24/756508d1845847cab37f82f53c26b702.png" alt="sobyte"></p>
<h3 id="cuckoo-filters">Cuckoo filters</h3>
<p>The cuckoo filter is similar in structure to the above implementation, except that the above array structure stores the entire element, whereas the cuckoo filter only stores a few bits of the element, called fingerprint information. Here, data accuracy is sacrificed in favour of space efficiency.</p>
<p>In the above implementation, each slot in the hash table can only hold one element, which is only 50% space efficient, whereas in the cuckoo filter each slot can hold multiple elements, turning it from one-dimensional to two-dimensional. The paper indicates that.</p>
<blockquote>
<p>With k = 2 hash functions, the load factor α is 50% when the bucket size b = 1 (i.e., the hash table is directly mapped), but increases to 84%, 95% or 98% respectively using bucket size b = 2, 4 or 8.</p>
</blockquote>
<p>The diagram below represents a two-dimensional array that can hold 4 elements per slot, and differs from the above implementation in that instead of using two arrays to hold them, only one is used.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/24/8776bd56a47e4bd1833140f971a653fd.png" alt="sobyte"></p>
<p>Having said that, here are the changes to the data structure, and here are the changes to the position calculation.</p>
<p>Our simple implementation of the position calculation formula above is done like this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">p1 = hash1(x) % arr length
p2 = hash2(x) % arr length
</code></pre></td></tr></table>
</div>
</div><p>And the formula for calculating the position of the cuckoo filter can be seen in the paper as follows:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">f = fingerprint(x);

i1 = hash(x);

i2 = i1 ⊕ hash( f);
</code></pre></td></tr></table>
</div>
</div><p>We can see that the position i2 is calculated by taking an anomaly between i1 and the fingerprint information corresponding to the element X. The fingerprint information, as explained above, is a few bits of the element X, sacrificing some precision in exchange for space.</p>
<p>So why do we need to use an iso-or here? Because it is possible to use the self-reflexive nature of the iso-or: <code>A ⊕ B ⊕ B = A</code>, so that instead of knowing whether the current position is i1 or i2, the current position can be iso-ored with hash(f) to obtain another position.</p>
<p>One detail to note here is that the computation of i2 requires the hash of the fingerprint of element X before taking the iso-or, as the paper also shows.</p>
<blockquote>
<p>If the alternate location were calculated by &ldquo;i⊕fingerprint&rdquo; without hashing the fingerprint, the items kicked out from nearby buckets would land close to each other in the table, if the size of the fingerprint is small compared to the table size.</p>
</blockquote>
<p>If you do a direct diff, it is likely that i1 and i2 will be located very close to each other, especially in a small hash table, increasing the probability of collisions.</p>
<p>There is also a constraint that the cuckoo filter forces the length of the array to be an exponent of 2, so instead of modulo the length of the array, the cuckoo filter takes the last n bits of the hash value.</p>
<p>If the length of the array in a cuckoo filter is 2^8, i.e. 256, then the last n bits of the hash value are taken, i.e.: hash &amp; 255, so that the final position information is obtained. The final position information is 23 as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/24/bb96aa2c4ff446b9981a647f875caf1c.png" alt="sobyte"></p>
<h2 id="code-implementation">Code implementation</h2>
<h3 id="data-structure">Data structure</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="nx">bucketSize</span> <span class="p">=</span> <span class="mi">4</span>
<span class="kd">type</span> <span class="nx">fingerprint</span> <span class="kt">byte</span>
<span class="c1">// 二维数组，大小是4
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">bucket</span> <span class="p">[</span><span class="nx">bucketSize</span><span class="p">]</span><span class="nx">fingerprint</span>

<span class="kd">type</span> <span class="nx">Filter</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// 一维数组
</span><span class="c1"></span>    <span class="nx">buckets</span>   <span class="p">[]</span><span class="nx">bucket</span>
    <span class="c1">// Filter 中已插入的元素
</span><span class="c1"></span>    <span class="nx">count</span>     <span class="kt">uint</span>
    <span class="c1">// 数组buckets长度中对应二进制包含0的个数
</span><span class="c1"></span>    <span class="nx">bucketPow</span> <span class="kt">uint</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Here we assume that a fingerprint fingerprint takes up 1byte of bytes and has 4 seats per location.</p>
<h3 id="initialisation">Initialisation</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="p">(</span>
    <span class="nx">altHash</span> <span class="p">=</span> <span class="p">[</span><span class="mi">256</span><span class="p">]</span><span class="kt">uint</span><span class="p">{}</span>
    <span class="nx">masks</span>   <span class="p">=</span> <span class="p">[</span><span class="mi">65</span><span class="p">]</span><span class="kt">uint</span><span class="p">{}</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="c1">// 用于缓存 256 个fingerprint的hash信息
</span><span class="c1"></span>        <span class="nx">altHash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="p">(</span><span class="nb">uint</span><span class="p">(</span><span class="nx">metro</span><span class="p">.</span><span class="nf">Hash64</span><span class="p">([]</span><span class="kt">byte</span><span class="p">{</span><span class="nb">byte</span><span class="p">(</span><span class="nx">i</span><span class="p">)},</span> <span class="mi">1337</span><span class="p">)))</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uint</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">64</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="c1">// 取 hash 值的最后 n 位
</span><span class="c1"></span>        <span class="nx">masks</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">i</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The init function caches two global variables, altHash and masks. since the fingerprint length is 1byte, the initialization of altHash uses a 256 size array to cache the corresponding hash information to avoid having to recalculate it each time; masks is used to fetch the last n bits of the hash value. This will be used later.</p>
<p>We will use a NewFilter function to get the filter Filter by passing in the size of the filter that it can hold.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewFilter</span><span class="p">(</span><span class="nx">capacity</span> <span class="kt">uint</span><span class="p">)</span> <span class="o">*</span><span class="nx">Filter</span> <span class="p">{</span>
    <span class="c1">// 计算 buckets 数组大小
</span><span class="c1"></span>    <span class="nx">capacity</span> <span class="p">=</span> <span class="nf">getNextPow2</span><span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">capacity</span><span class="p">))</span> <span class="o">/</span> <span class="nx">bucketSize</span>
    <span class="k">if</span> <span class="nx">capacity</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">capacity</span> <span class="p">=</span> <span class="mi">1</span>
    <span class="p">}</span>
    <span class="nx">buckets</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">bucket</span><span class="p">,</span> <span class="nx">capacity</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">Filter</span><span class="p">{</span>
        <span class="nx">buckets</span><span class="p">:</span>   <span class="nx">buckets</span><span class="p">,</span>
        <span class="nx">count</span><span class="p">:</span>     <span class="mi">0</span><span class="p">,</span>
        <span class="c1">// 获取 buckets 数组大小的二进制中以 0 结尾的个数
</span><span class="c1"></span>        <span class="nx">bucketPow</span><span class="p">:</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">bits</span><span class="p">.</span><span class="nf">TrailingZeros</span><span class="p">(</span><span class="nx">capacity</span><span class="p">)),</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The NewFilter function adjusts the capacity to an exponential multiple of 2 by calling getNextPow2, which returns 16 if the capacity passed in is 9; it then calculates the length of the buckets array and instantiates Filter; bucketPow returns the number of bits in the binary ending in 0. Since capacity is an exponential multiple of 2, bucketPow is the number of bits in the capacity binary minus 1.</p>
<h3 id="inserting-elements">Inserting elements</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">cf</span> <span class="o">*</span><span class="nx">Filter</span><span class="p">)</span> <span class="nf">Insert</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="c1">// 获取 data 的 fingerprint 以及 位置 i1
</span><span class="c1"></span>    <span class="nx">i1</span><span class="p">,</span> <span class="nx">fp</span> <span class="o">:=</span> <span class="nf">getIndexAndFingerprint</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">cf</span><span class="p">.</span><span class="nx">bucketPow</span><span class="p">)</span>
    <span class="c1">// 将 fingerprint 插入到 Filter 的 buckets 数组中
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">cf</span><span class="p">.</span><span class="nf">insert</span><span class="p">(</span><span class="nx">fp</span><span class="p">,</span> <span class="nx">i1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">true</span>
    <span class="p">}</span>
    <span class="c1">// 获取位置 i2
</span><span class="c1"></span>    <span class="nx">i2</span> <span class="o">:=</span> <span class="nf">getAltIndex</span><span class="p">(</span><span class="nx">fp</span><span class="p">,</span> <span class="nx">i1</span><span class="p">,</span> <span class="nx">cf</span><span class="p">.</span><span class="nx">bucketPow</span><span class="p">)</span>
    <span class="c1">// 将 fingerprint 插入到 Filter 的 buckets 数组中
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">cf</span><span class="p">.</span><span class="nf">insert</span><span class="p">(</span><span class="nx">fp</span><span class="p">,</span> <span class="nx">i2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">true</span>
    <span class="p">}</span>
    <span class="c1">// 插入失败，那么进行循环插入踢出元素
</span><span class="c1"></span>    <span class="k">return</span> <span class="nx">cf</span><span class="p">.</span><span class="nf">reinsert</span><span class="p">(</span><span class="nx">fp</span><span class="p">,</span> <span class="nf">randi</span><span class="p">(</span><span class="nx">i1</span><span class="p">,</span> <span class="nx">i2</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">cf</span> <span class="o">*</span><span class="nx">Filter</span><span class="p">)</span> <span class="nf">insert</span><span class="p">(</span><span class="nx">fp</span> <span class="nx">fingerprint</span><span class="p">,</span> <span class="nx">i</span> <span class="kt">uint</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="c1">// 获取 buckets 中的槽位进行插入
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">cf</span><span class="p">.</span><span class="nx">buckets</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nf">insert</span><span class="p">(</span><span class="nx">fp</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Filter 中元素个数+1
</span><span class="c1"></span>        <span class="nx">cf</span><span class="p">.</span><span class="nx">count</span><span class="o">++</span>
        <span class="k">return</span> <span class="kc">true</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">bucket</span><span class="p">)</span> <span class="nf">insert</span><span class="p">(</span><span class="nx">fp</span> <span class="nx">fingerprint</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="c1">// 遍历槽位的 4 个元素，如果为空则插入
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">tfp</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">b</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">tfp</span> <span class="o">==</span> <span class="nx">nullFp</span> <span class="p">{</span>
            <span class="nx">b</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">fp</span>
            <span class="k">return</span> <span class="kc">true</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>the getIndexAndFingerprint function will get the fingerprint of the data, and the position i1;</li>
<li>then call insert to insert into Filter&rsquo;s buckets array, if the buckets array is full of 4 elements corresponding to slot i1, then try to get position i2 and try to insert the element into the corresponding slot i2 in the buckets array.</li>
<li>the corresponding slot i2 is also full, then call the reinsert method to randomly get a position in slots i1 and i2 to grab, then kick out the old element and repeat the insertion cycle.</li>
</ol>
<p>Here&rsquo;s how getIndexAndFingerprint gets the fingerprint and slot i1.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">getIndexAndFingerprint</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">bucketPow</span> <span class="kt">uint</span><span class="p">)</span> <span class="p">(</span><span class="kt">uint</span><span class="p">,</span> <span class="nx">fingerprint</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 将 data 进行hash
</span><span class="c1"></span>    <span class="nx">hash</span> <span class="o">:=</span> <span class="nx">metro</span><span class="p">.</span><span class="nf">Hash64</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="mi">1337</span><span class="p">)</span>
    <span class="c1">// 取 hash 的指纹信息
</span><span class="c1"></span>    <span class="nx">fp</span> <span class="o">:=</span> <span class="nf">getFingerprint</span><span class="p">(</span><span class="nx">hash</span><span class="p">)</span>
    <span class="c1">// 取 hash 高32位，对 hash 的高32位进行取与获取槽位 i1
</span><span class="c1"></span>    <span class="nx">i1</span> <span class="o">:=</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">hash</span><span class="o">&gt;&gt;</span><span class="mi">32</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nx">masks</span><span class="p">[</span><span class="nx">bucketPow</span><span class="p">]</span>
    <span class="k">return</span> <span class="nx">i1</span><span class="p">,</span> <span class="nf">fingerprint</span><span class="p">(</span><span class="nx">fp</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// 取 hash 的指纹信息
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">getFingerprint</span><span class="p">(</span><span class="nx">hash</span> <span class="kt">uint64</span><span class="p">)</span> <span class="kt">byte</span> <span class="p">{</span>
    <span class="nx">fp</span> <span class="o">:=</span> <span class="nb">byte</span><span class="p">(</span><span class="nx">hash</span><span class="o">%</span><span class="mi">255</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">fp</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>After hashing the data in getIndexAndFingerprint, the result is modulo the fingerprint information, and then the higher 32 bits of the hash value are summed to get the slot i1. masks has already been seen during initialization, <code>masks[bucketPow]</code> gets the binary result of 1, which is used to get the lower bit of the hash. hash&rsquo;s lower value.</p>
<p>If the initialization passes in a capacity of 1024, then the bucketPow is calculated to be 8, which gives <code>masks[8] = (1 &lt;&lt; 8) - 1</code>, which is 255, the binary is <code>1111, 1111</code>, and the high 32 of hash is summed to get the slot i1 in the final buckets.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/24/4b3e01c3a3364cc68bf03be78d3eaeb2.png" alt="sobyte"></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">getAltIndex</span><span class="p">(</span><span class="nx">fp</span> <span class="nx">fingerprint</span><span class="p">,</span> <span class="nx">i</span> <span class="kt">uint</span><span class="p">,</span> <span class="nx">bucketPow</span> <span class="kt">uint</span><span class="p">)</span> <span class="kt">uint</span> <span class="p">{</span>
    <span class="nx">mask</span> <span class="o">:=</span> <span class="nx">masks</span><span class="p">[</span><span class="nx">bucketPow</span><span class="p">]</span>
    <span class="nx">hash</span> <span class="o">:=</span> <span class="nx">altHash</span><span class="p">[</span><span class="nx">fp</span><span class="p">]</span> <span class="o">&amp;</span> <span class="nx">mask</span>
    <span class="k">return</span> <span class="nx">i</span> <span class="p">^</span> <span class="nx">hash</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The slot in getAltIndex is obtained by using altHash to obtain the hash value of the fingerprint information and then taking an iso-or to return the slot value. Note that due to the nature of the iso-or, either slot i1 or slot i2 can be passed in to return the corresponding other slot.</p>
<p>Here is a look at the loop kick out insert reinsert.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="nx">maxCuckooCount</span> <span class="p">=</span> <span class="mi">500</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">cf</span> <span class="o">*</span><span class="nx">Filter</span><span class="p">)</span> <span class="nf">reinsert</span><span class="p">(</span><span class="nx">fp</span> <span class="nx">fingerprint</span><span class="p">,</span> <span class="nx">i</span> <span class="kt">uint</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="c1">// 默认循环 500 次
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">k</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">k</span> <span class="p">&lt;</span> <span class="nx">maxCuckooCount</span><span class="p">;</span> <span class="nx">k</span><span class="o">++</span> <span class="p">{</span>
        <span class="c1">// 随机从槽位中选取一个元素
</span><span class="c1"></span>        <span class="nx">j</span> <span class="o">:=</span> <span class="nx">rand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="nx">bucketSize</span><span class="p">)</span>
        <span class="nx">oldfp</span> <span class="o">:=</span> <span class="nx">fp</span>
        <span class="c1">// 获取槽位中的值 
</span><span class="c1"></span>        <span class="nx">fp</span> <span class="p">=</span> <span class="nx">cf</span><span class="p">.</span><span class="nx">buckets</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span>
        <span class="c1">// 将当前循环的值插入
</span><span class="c1"></span>        <span class="nx">cf</span><span class="p">.</span><span class="nx">buckets</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">oldfp</span>

        <span class="c1">// 获取另一个槽位
</span><span class="c1"></span>        <span class="nx">i</span> <span class="p">=</span> <span class="nf">getAltIndex</span><span class="p">(</span><span class="nx">fp</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">cf</span><span class="p">.</span><span class="nx">bucketPow</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">cf</span><span class="p">.</span><span class="nf">insert</span><span class="p">(</span><span class="nx">fp</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">true</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>This will loop through the slots a maximum of 500 times to get the slot information. Since each slot can hold up to 4 elements, rand is used to randomly kick out an element from one of the 4 slots, insert the element from the current loop, get the information of the other slot of the kicked out element, and call insert again.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/24/fb5c042001674966902535e23f543adc.png" alt="sobyte"></p>
<p>The above diagram shows that when element X is inserted into the hash table, it is hashed twice to find that the corresponding slots 0 and 3 are full, so one of the elements in slot 3 is randomly seized and the seized element is re-hashed and inserted into the third position of slot 5.</p>
<h3 id="querying-data">Querying data</h3>
<p>When you query the data, you are looking to see if there is a corresponding fingerprint in the corresponding position.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">cf</span> <span class="o">*</span><span class="nx">Filter</span><span class="p">)</span> <span class="nf">Lookup</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="c1">// 获取槽位 i1 以及指纹信息
</span><span class="c1"></span>    <span class="nx">i1</span><span class="p">,</span> <span class="nx">fp</span> <span class="o">:=</span> <span class="nf">getIndexAndFingerprint</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">cf</span><span class="p">.</span><span class="nx">bucketPow</span><span class="p">)</span>
    <span class="c1">// 遍历槽位中 4 个位置，查看有没有相同元素
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">cf</span><span class="p">.</span><span class="nx">buckets</span><span class="p">[</span><span class="nx">i1</span><span class="p">].</span><span class="nf">getFingerprintIndex</span><span class="p">(</span><span class="nx">fp</span><span class="p">)</span> <span class="p">&gt;</span> <span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">true</span>
    <span class="p">}</span>
    <span class="c1">// 获取另一个槽位 i2
</span><span class="c1"></span>    <span class="nx">i2</span> <span class="o">:=</span> <span class="nf">getAltIndex</span><span class="p">(</span><span class="nx">fp</span><span class="p">,</span> <span class="nx">i1</span><span class="p">,</span> <span class="nx">cf</span><span class="p">.</span><span class="nx">bucketPow</span><span class="p">)</span>
    <span class="c1">// 遍历槽位 i2 中 4 个位置，查看有没有相同元素
</span><span class="c1"></span>    <span class="k">return</span> <span class="nx">cf</span><span class="p">.</span><span class="nx">buckets</span><span class="p">[</span><span class="nx">i2</span><span class="p">].</span><span class="nf">getFingerprintIndex</span><span class="p">(</span><span class="nx">fp</span><span class="p">)</span> <span class="p">&gt;</span> <span class="o">-</span><span class="mi">1</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">bucket</span><span class="p">)</span> <span class="nf">getFingerprintIndex</span><span class="p">(</span><span class="nx">fp</span> <span class="nx">fingerprint</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">tfp</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">b</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">tfp</span> <span class="o">==</span> <span class="nx">fp</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">i</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="deleting-data">Deleting data</h3>
<p>When you delete data, you also just erase the fingerprint information on that slot.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">cf</span> <span class="o">*</span><span class="nx">Filter</span><span class="p">)</span> <span class="nf">Delete</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="c1">// 获取槽位 i1 以及指纹信息
</span><span class="c1"></span>    <span class="nx">i1</span><span class="p">,</span> <span class="nx">fp</span> <span class="o">:=</span> <span class="nf">getIndexAndFingerprint</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">cf</span><span class="p">.</span><span class="nx">bucketPow</span><span class="p">)</span>
    <span class="c1">// 尝试删除指纹信息
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">cf</span><span class="p">.</span><span class="nb">delete</span><span class="p">(</span><span class="nx">fp</span><span class="p">,</span> <span class="nx">i1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">true</span>
    <span class="p">}</span>
    <span class="c1">// 获取槽位 i2
</span><span class="c1"></span>    <span class="nx">i2</span> <span class="o">:=</span> <span class="nf">getAltIndex</span><span class="p">(</span><span class="nx">fp</span><span class="p">,</span> <span class="nx">i1</span><span class="p">,</span> <span class="nx">cf</span><span class="p">.</span><span class="nx">bucketPow</span><span class="p">)</span>
    <span class="c1">// 尝试删除指纹信息
</span><span class="c1"></span>    <span class="k">return</span> <span class="nx">cf</span><span class="p">.</span><span class="nb">delete</span><span class="p">(</span><span class="nx">fp</span><span class="p">,</span> <span class="nx">i2</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">cf</span> <span class="o">*</span><span class="nx">Filter</span><span class="p">)</span> <span class="nb">delete</span><span class="p">(</span><span class="nx">fp</span> <span class="nx">fingerprint</span><span class="p">,</span> <span class="nx">i</span> <span class="kt">uint</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="c1">// 遍历槽位 4个元素，尝试删除指纹信息
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">cf</span><span class="p">.</span><span class="nx">buckets</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nb">delete</span><span class="p">(</span><span class="nx">fp</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">cf</span><span class="p">.</span><span class="nx">count</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nx">cf</span><span class="p">.</span><span class="nx">count</span><span class="o">--</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="kc">true</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">bucket</span><span class="p">)</span> <span class="nb">delete</span><span class="p">(</span><span class="nx">fp</span> <span class="nx">fingerprint</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">tfp</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">b</span> <span class="p">{</span>
        <span class="c1">// 指纹信息相同，将此槽位置空
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">tfp</span> <span class="o">==</span> <span class="nx">fp</span> <span class="p">{</span>
            <span class="nx">b</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nullFp</span>
            <span class="k">return</span> <span class="kc">true</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="disadvantages">Disadvantages</h3>
<p>After implementing the cuckoo filter, let&rsquo;s think about what would happen if the cuckoo filter did multiple consecutive insertions of the same element.</p>
<p>Then the element would hog all the positions on both slots and eventually, when the 9th identical element was inserted, it would keep cycling and squeezing until the maximum number of cycles, and then return a false.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/24/71e43714dbbc45b38a3c2b6a425a2124.png" alt="sobyte"></p>
<p>Would it solve the problem if a check was done before insertion? This would indeed not result in a circular squeeze, but there would be a certain probability of a false positive situation.</p>
<p>As we can see from the above implementation, the fingerprint information set in each location is 1byte and there are 256 possibilities. If two elements have the same hash location and the same fingerprint, then this insertion check will assume that they are equal leading to the assumption that the element already exists.</p>
<p>In fact, we can reduce the probability of false positives by adjusting the amount of fingerprint information stored, e.g. in the above implementation the probability of false positives is 0.03 for a 1byte fingerprint with 8 bits of information, when the fingerprint information is increased to 2bytes with 16 bits of information the probability of false positives is reduced to 0.0001.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/golang/">golang</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-01/go-dispatch-loop/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Explaining the Golang dispatch loop source code implementation</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-01/go-timer-analysis/">
            <span class="next-text nav-default">The principle of timer implementation in Go and source code analysis</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
