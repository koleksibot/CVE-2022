<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Redis Large Cluster Scaling Performance Optimization in Practice - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="1. Background In existing network environments, some businesses using Redis clusters often need to expand their node capacity as business volume increases. I have previously learnt that some of my operations and maintenance colleagues have experienced a decrease in performance after scaling a Redis cluster with a relatively large number of nodes, as evidenced by a significant increase in access latency. Some businesses are sensitive to Redis cluster access latency," /><meta name="keywords" content="Redis, Cluster, Scaling, Performance Optimization" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-01/redis-cluster/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Redis Large Cluster Scaling Performance Optimization in Practice" />
<meta property="og:description" content="1. Background In existing network environments, some businesses using Redis clusters often need to expand their node capacity as business volume increases. I have previously learnt that some of my operations and maintenance colleagues have experienced a decrease in performance after scaling a Redis cluster with a relatively large number of nodes, as evidenced by a significant increase in access latency. Some businesses are sensitive to Redis cluster access latency," />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-01/redis-cluster/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-01-13T14:12:01+08:00" />
<meta property="article:modified_time" content="2022-01-13T14:12:01+08:00" />

<meta itemprop="name" content="Redis Large Cluster Scaling Performance Optimization in Practice">
<meta itemprop="description" content="1. Background In existing network environments, some businesses using Redis clusters often need to expand their node capacity as business volume increases. I have previously learnt that some of my operations and maintenance colleagues have experienced a decrease in performance after scaling a Redis cluster with a relatively large number of nodes, as evidenced by a significant increase in access latency. Some businesses are sensitive to Redis cluster access latency,"><meta itemprop="datePublished" content="2022-01-13T14:12:01+08:00" />
<meta itemprop="dateModified" content="2022-01-13T14:12:01+08:00" />
<meta itemprop="wordCount" content="4140">
<meta itemprop="keywords" content="redis," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Redis Large Cluster Scaling Performance Optimization in Practice"/>
<meta name="twitter:description" content="1. Background In existing network environments, some businesses using Redis clusters often need to expand their node capacity as business volume increases. I have previously learnt that some of my operations and maintenance colleagues have experienced a decrease in performance after scaling a Redis cluster with a relatively large number of nodes, as evidenced by a significant increase in access latency. Some businesses are sensitive to Redis cluster access latency,"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Redis Large Cluster Scaling Performance Optimization in Practice</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-01-13 14:12:01 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 4140 words </span>
          <span class="more-meta"> 9 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#1-background">1. Background</a>
          <ul>
            <li><a href="#11-problem-description">1.1 Problem Description</a></li>
            <li><a href="#12-description-of-the-current-network-environment">1.2 Description of the current network environment</a></li>
            <li><a href="#13-observing-the-phenomenon">1.3 Observing the phenomenon</a></li>
          </ul>
        </li>
        <li><a href="#2-troubleshooting">2. Troubleshooting</a>
          <ul>
            <li><a href="#21-redis-hotspot-troubleshooting">2.1 Redis hotspot troubleshooting</a></li>
            <li><a href="#22-client-troubleshooting">2.2 Client troubleshooting</a></li>
            <li><a href="#23-summary-of-troubleshooting">2.3 Summary of troubleshooting</a></li>
            <li><a href="#23-summary-of-troubleshooting-1">2.3 Summary of troubleshooting</a></li>
          </ul>
        </li>
        <li><a href="#3-optimization">3. Optimization</a>
          <ul>
            <li><a href="#31-current-situation-analysis">3.1 Current Situation Analysis</a></li>
            <li><a href="#32-optimisation-options">3.2 Optimisation options</a></li>
            <li><a href="#33-implementation">3.3 Implementation</a></li>
          </ul>
        </li>
        <li><a href="#comparison-of-optimisation-results">Comparison of Optimisation Results</a>
          <ul>
            <li><a href="#41-test-environment--pressure-test-scenarios">4.1 Test Environment &amp; Pressure Test Scenarios</a></li>
            <li><a href="#42-cpu-resource-usage-comparison">4.2 CPU resource usage comparison</a></li>
            <li><a href="#43-time-consumption-comparison">4.3 Time consumption comparison</a></li>
          </ul>
        </li>
        <li><a href="#5-summary">5. Summary</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="1-background">1. Background</h2>
<p>In existing network environments, some businesses using Redis clusters often need to expand their node capacity as business volume increases.</p>
<p>I have previously learnt that some of my operations and maintenance colleagues have experienced a decrease in performance after scaling a Redis cluster with a relatively large number of nodes, as evidenced by a significant increase in access latency.</p>
<p>Some businesses are sensitive to Redis cluster access latency, such as the existing network environment for real-time model reads, or some businesses rely on the synchronisation process of reading Redis clusters, which can affect the real-time process latency of the business. This may not be acceptable on the business side.</p>
<p>To find the root cause of this problem, we troubleshoot the cluster performance degradation after a particular Redis cluster migration operation.</p>
<h3 id="11-problem-description">1.1 Problem Description</h3>
<p>The scenario for this specific Redis cluster issue is that a particular Redis cluster has undergone a scaling operation. The business side uses Hiredis-vip for Redis cluster access and performs MGET operations.</p>
<p>The business side perceives that the latency to access the Redis cluster becomes high.</p>
<h3 id="12-description-of-the-current-network-environment">1.2 Description of the current network environment</h3>
<ul>
<li>Most of the Redis versions deployed in the current network environment are 3.x or 4.x versions;</li>
<li>The business is using the client Hiredis-vip to access the Redis cluster;</li>
<li>The Redis cluster has a relatively large number of nodes, 100+ in size;</li>
<li>The cluster has been previously expanded.</li>
</ul>
<h3 id="13-observing-the-phenomenon">1.3 Observing the phenomenon</h3>
<p>Because the latency becomes high, we troubleshoot in several ways.</p>
<ul>
<li>whether the bandwidth is fully occupied.</li>
<li>whether the CPU is over-occupied.</li>
<li>whether the OPS is high.</li>
</ul>
<p>By simple monitoring and troubleshooting, the bandwidth load is not high. However, the CPU was found to be behaving abnormally.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/13/9c6bbfc91cdd4b9fb71ec387fdea6493.png" alt="image"></p>
<h4 id="131-comparing-ops-and-cpu-load">1.3.1 Comparing OPS and CPU load</h4>
<p>Looking at the MGET and CPU load used by the business feedback, we found the corresponding monitoring curves.</p>
<p>Analyzed in terms of time, there is no direct correlation between high MGET and CPU load. The feedback from the business side was a general increase in latency for MGET. Here we see that the OPS and CPU load of MGET are staggered.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/13/e8645b236ceb40f58b1a16aa63f32d7b.png" alt="image"></p>
<p>Here it can be tentatively determined that there is no direct relationship between business requests and CPU load for the time being, but it can be seen from the curves: there is a staggering of business requests and CPU load on the same timeline, and there should be an indirect relationship between the two.</p>
<h4 id="132-comparing-cluster-command-ops-and-cpu-load">1.3.2 Comparing Cluster command OPS and CPU load</h4>
<p>As a colleague on the operations side has previously had feedback that the cluster has undergone expansion operations, there is bound to be a migration of slots.</p>
<p>Considering that business clients generally use caches to store slot topology information for Redis clusters, it was suspected that there was some connection between the Cluster directive and CPU load.</p>
<p>We found that there was indeed some connection.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/13/801606e28d19456ab01627ed47182c66.png" alt="image"></p>
<p>Here it is obvious: the CPU usage of a certain instance rises significantly when executing Cluster instructions.</p>
<p>Based on the above phenomena, a simple focus can be roughly made on.</p>
<ul>
<li>MGET execution on the business side, where the Cluster instruction is executed for some reason.</li>
<li>Cluster instructions that for some reason cause high CPU usage affecting other operations.</li>
<li>Cluster instructions are suspected to be a performance bottleneck.</li>
</ul>
<p>Also, to elicit a few issues of concern.</p>
<p><strong>Why are there more Cluster instructions being executed?</strong></p>
<p><strong>Why are CPU resources higher when Cluster instructions are executed?</strong></p>
<p><strong>Why are clusters with large node sizes prone to &ldquo;hitting&rdquo; the migration slots?</strong></p>
<p><strong>Why is it easy to &ldquo;get caught&rdquo; in a cluster migration slot operation with large node sizes?</strong></p>
<h2 id="2-troubleshooting">2. Troubleshooting</h2>
<h3 id="21-redis-hotspot-troubleshooting">2.1 Redis hotspot troubleshooting</h3>
<p>We performed a simple analysis using perf top on a Redis instance that appeared to have a high CPU load on site.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/13/b444cd91fc45446f8ea7a179b820d492.png" alt="image"></p>
<p>As you can see from the above diagram, the function (ClusterReplyMultiBulkSlots) takes up 51.84% of the CPU resources, which is an exception.</p>
<h4 id="211-clusterreplymultibulkslots-implementation-principle">2.1.1 ClusterReplyMultiBulkSlots implementation principle</h4>
<p>We analyse the clusterReplyMultiBulkSlots function.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span><span class="lnt">94
</span><span class="lnt">95
</span><span class="lnt">96
</span><span class="lnt">97
</span><span class="lnt">98
</span><span class="lnt">99
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="nf">clusterReplyMultiBulkSlots</span><span class="p">(</span><span class="n">client</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* Format: 1) 1) start slot
</span><span class="cm">     *            2) end slot
</span><span class="cm">     *            3) 1) master IP
</span><span class="cm">     *               2) master port
</span><span class="cm">     *               3) node ID
</span><span class="cm">     *            4) 1) replica IP
</span><span class="cm">     *               2) replica port
</span><span class="cm">     *               3) node ID
</span><span class="cm">     *           ... continued until done
</span><span class="cm">     */</span>
 
    <span class="kt">int</span> <span class="n">num_masters</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">slot_replylen</span> <span class="o">=</span> <span class="n">addDeferredMultiBulkLength</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
 
    <span class="n">dictEntry</span> <span class="o">*</span><span class="n">de</span><span class="p">;</span>
    <span class="n">dictIterator</span> <span class="o">*</span><span class="n">di</span> <span class="o">=</span> <span class="n">dictGetSafeIterator</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">);</span>
    <span class="k">while</span><span class="p">((</span><span class="n">de</span> <span class="o">=</span> <span class="n">dictNext</span><span class="p">(</span><span class="n">di</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/*注意：此处是对当前Redis节点记录的集群所有主节点都进行了遍历*/</span>
        <span class="n">clusterNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">dictGetVal</span><span class="p">(</span><span class="n">de</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">start</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
 
        <span class="cm">/* Skip slaves (that are iterated when producing the output of their
</span><span class="cm">         * master) and  masters not serving any slot. */</span>
        <span class="cm">/*跳过备节点。备节点的信息会从主节点侧获取。*/</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nodeIsMaster</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">||</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">numslots</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">CLUSTER_SLOTS</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/*注意：此处是对当前节点中记录的所有slot进行了遍历*/</span>
            <span class="kt">int</span> <span class="n">bit</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
            <span class="cm">/*确认当前节点是不是占有循环终端的slot*/</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">bit</span> <span class="o">=</span> <span class="n">clusterNodeGetSlotBit</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="n">j</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">start</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="cm">/*简单分析，此处的逻辑大概就是找出连续的区间，是的话放到返回中；不是的话继续往下递归slot。
</span><span class="cm">              如果是开始的话，开始一个连续区间，直到和当前的不连续。*/</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">bit</span> <span class="o">||</span> <span class="n">j</span> <span class="o">==</span> <span class="n">CLUSTER_SLOTS</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
                <span class="kt">int</span> <span class="n">nested_elements</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="cm">/* slots (2) + master addr (1). */</span>
                <span class="kt">void</span> <span class="o">*</span><span class="n">nested_replylen</span> <span class="o">=</span> <span class="n">addDeferredMultiBulkLength</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
 
                <span class="k">if</span> <span class="p">(</span><span class="n">bit</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">==</span> <span class="n">CLUSTER_SLOTS</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">j</span><span class="o">++</span><span class="p">;</span>
 
                <span class="cm">/* If slot exists in output map, add to it&#39;s list.
</span><span class="cm">                 * else, create a new output map for this slot */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">==</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">addReplyLongLong</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span> <span class="cm">/* only one slot; low==high */</span>
                    <span class="n">addReplyLongLong</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="n">addReplyLongLong</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span> <span class="cm">/* low */</span>
                    <span class="n">addReplyLongLong</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>   <span class="cm">/* high */</span>
                <span class="p">}</span>
                <span class="n">start</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
 
                <span class="cm">/* First node reply position is always the master */</span>
                <span class="n">addReplyMultiBulkLen</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
                <span class="n">addReplyBulkCString</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">);</span>
                <span class="n">addReplyLongLong</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>
                <span class="n">addReplyBulkCBuffer</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">CLUSTER_NAMELEN</span><span class="p">);</span>
 
                <span class="cm">/* Remaining nodes in reply are replicas for slot range */</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">numslaves</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                    <span class="cm">/*注意：此处遍历了节点下面的备节点信息，用于返回*/</span>
                    <span class="cm">/* This loop is copy/pasted from clusterGenNodeDescription()
</span><span class="cm">                     * with modifications for per-slot node aggregation */</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">nodeFailed</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">slaves</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="k">continue</span><span class="p">;</span>
                    <span class="n">addReplyMultiBulkLen</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
                    <span class="n">addReplyBulkCString</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">slaves</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">);</span>
                    <span class="n">addReplyLongLong</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">slaves</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>
                    <span class="n">addReplyBulkCBuffer</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">slaves</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">CLUSTER_NAMELEN</span><span class="p">);</span>
                    <span class="n">nested_elements</span><span class="o">++</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">setDeferredMultiBulkLength</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">nested_replylen</span><span class="p">,</span> <span class="n">nested_elements</span><span class="p">);</span>
                <span class="n">num_masters</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">dictReleaseIterator</span><span class="p">(</span><span class="n">di</span><span class="p">);</span>
    <span class="n">setDeferredMultiBulkLength</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">slot_replylen</span><span class="p">,</span> <span class="n">num_masters</span><span class="p">);</span>
<span class="p">}</span>
 
<span class="cm">/* Return the slot bit from the cluster node structure. */</span>
<span class="cm">/*该函数用于判断指定的slot是否属于当前clusterNodes节点*/</span>
<span class="kt">int</span> <span class="nf">clusterNodeGetSlotBit</span><span class="p">(</span><span class="n">clusterNode</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slot</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">bitmapTestBit</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">,</span><span class="n">slot</span><span class="p">);</span>
<span class="p">}</span>
 
<span class="cm">/* Test bit &#39;pos&#39; in a generic bitmap. Return 1 if the bit is set,
</span><span class="cm"> * otherwise 0. */</span>
<span class="cm">/*此处流程用于判断指定的的位置在bitmap上是否为1*/</span>
<span class="kt">int</span> <span class="nf">bitmapTestBit</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">bitmap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">off_t</span> <span class="n">byte</span> <span class="o">=</span> <span class="n">pos</span><span class="o">/</span><span class="mi">8</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">bit</span> <span class="o">=</span> <span class="n">pos</span><span class="o">&amp;</span><span class="mi">7</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">bitmap</span><span class="p">[</span><span class="n">byte</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">bit</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">clusterNode</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="cm">/*使用一个长度为CLUSTER_SLOTS/8的char数组对当前分配的slot进行记录*/</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">slots</span><span class="p">[</span><span class="n">CLUSTER_SLOTS</span><span class="o">/</span><span class="mi">8</span><span class="p">];</span> <span class="cm">/* slots handled by this node */</span>
    <span class="p">...</span>
<span class="p">}</span> <span class="n">clusterNode</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>Each node (ClusterNode) uses a bitmap (char slots[CLUSTER_SLOTS/8]) to store information about the allocation of slots.</p>
<p>A brief description of the logic of BitmapTestBit: clusterNode-&gt;slots is an array of length CLUSTER_SLOTS/8. CLUSTER_SLOTS is a fixed value of 16384. each bit of the array represents a slot. the subscript of the bitmap array here is 0 to 2047, and the range of slots is 0 to 16383. The range of slots is 0 to 16383.</p>
<p>Since it is important to determine whether the bit at the pos position is a 1, therefore.</p>
<ul>
<li>off_t byte = pos/8: gets the information on which byte (Byte) on the bitmap corresponds to this pos position. Since there are 8 bits in a Byte, using pos/8 gives a guide as to which Byte to look for. Here the bitmap is treated as an array, and here it corresponds to the Byte with the corresponding subscript.</li>
<li>int bit = pos&amp;7: Get the information about which bit corresponds to the pos position on this byte. You can imagine grouping pos in groups of 8, and the last group (not satisfying 8) corresponds to the subscript position of the bit array on the corresponding byte of the bitmap.</li>
<li>(bitmap[byte] &amp; (1&laquo;bit)): determine whether the corresponding bit exists on the bitmap[byte].</li>
</ul>
<p>Example with a slot of 10001.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/13/0965c673856243d69474e0d8f5181f29.png" alt="image"></p>
<p>Therefore the slot 10001 corresponds to the byte with subscript 1250, and the bit to be checked is the subscript 1.</p>
<p>The corresponding position on the ClusterNode-&gt;slots.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/13/d0545517a3494c15b275a1c681054dd8.png" alt="image"></p>
<p>The green square shows bitmap[1250], which is the byte that holds slot 10001; the red box (bit[1]) corresponds to the location 1&laquo;bit. bitmap[byte] &amp; (1&laquo;bit), which is to confirm whether the location corresponding to the red box is 1. If so, it means that 10001 on the bitmap has been If so, the bitmap is marked with 10001.</p>
<p>The summary logic of ClusterNodeGetSlotBit is: <strong>Determine if the current slot is allocated on the current node</strong> . So the approximate logic of ClusterReplyMultiBulkSlots is as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/13/efa59ba5c33e479d82b4dd3382928b3e.png" alt="image"></p>
<p>The approximate steps are as follows.</p>
<ul>
<li>Iterate over each node.</li>
<li>For each node, traverse all slots and use ClusterNodeGetSlotBit to determine if the slots in the traversal are assigned to the current node.</li>
</ul>
<p>From the result of the GetCLUSTER SLOTS command, we can see that the complexity is <code>&lt;number of cluster master nodes&gt; * &lt;total number of slots&gt;</code>. Where the total number of slots is 16384, a fixed value.</p>
<h4 id="212-redis-hotspot-troubleshooting-summary">2.1.2 Redis hotspot troubleshooting summary</h4>
<p>As far as we can see, the CLUSTER SLOTS instruction latency grows linearly with the number of master nodes in the Redis cluster. The larger number of master nodes in the cluster we are investigating explains the larger latency of the CLUSTER SLOTS command in the current network.</p>
<h3 id="22-client-troubleshooting">2.2 Client troubleshooting</h3>
<p>We understand that the operation and maintenance students have expansion operations, and after the expansion is completed, some keys are bound to have MOVED errors when they are accessed.</p>
<p>The current use of Hiredis-vip client code for a simple browse, a brief analysis of the following current business use of Hiredis-vip client in the encounter MOVED when how to deal with. As most other businesses commonly use the Jedis client, this is also a brief analysis of the corresponding process for the Jedis client.</p>
<h4 id="221-principles-of-hiredis-vip-implementation-for-moved-processing">2.2.1 Principles of Hiredis-vip implementation for MOVED processing</h4>
<p>Hiredis-vip operation for MOVED.</p>
<p>To see the process of calling Cluster_update_route.</p>
<p>Here the cluster_update_route_by_addr performs a CLUSTER SLOT operation. As can be seen, when a MOVED error is fetched, Hiredis-vip re-updates the Redis cluster topology with the following characteristics.</p>
<ul>
<li>Because the nodes are hashed the same way through ip:port as the key, multiple clients can easily access the same node at the same time if the cluster topology is similar.</li>
<li>If a node fails to access, it goes through an iterator to find the next node, and for the above reasons, multiple clients can easily access to the next node at the same time.</li>
</ul>
<h4 id="222-principles-of-jedis-implementation-of-moved-processing">2.2.2 Principles of Jedis implementation of MOVED processing</h4>
<p>A brief glance at the Jedis client code shows that renewSlotCache is called if there is a MOVED error.</p>
<p>Continuing to look at the renewSlotCache call, we can confirm that Jedis sends the Redis command CLUSTER SLOTS when it encounters a MOVED error in cluster mode, which pulls the Redis cluster&rsquo;s slot topology again.</p>
<h4 id="223-summary-of-client-implementation-principles">2.2.3 Summary of client implementation principles</h4>
<p>As Jedis is a Redis client for Java and Hiredis-vip is a Redis client for C++, it can be simply assumed that this exception handling mechanism is a common operation.</p>
<p>The process for sorting out MOVED in client-side cluster mode is roughly as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/13/da5c66655a5543e7893e5924bb80d0ea.png" alt="image"></p>
<p>In summary.</p>
<ol>
<li>
<p>access to the key using the client-side cached slot topology.</p>
</li>
<li>
<p>Redis node returns normal.</p>
<ul>
<li>Access is normal, continue with subsequent operations</li>
</ul>
</li>
<li>
<p>Redis node returns MOVED.</p>
<ul>
<li>Execute the CLUSTER SLOTS command on the Redis node to update the topology.</li>
<li>Re-access to the key using the new topology.</li>
</ul>
</li>
</ol>
<h4 id="223-client-troubleshooting-summary">2.2.3 Client troubleshooting summary</h4>
<p>The Redis cluster is expanding, which means that there are bound to be some Redis clients that are accessing the Redis cluster and encountering MOVED, executing the Redis command CLUSTER SLOTS for topology updates.</p>
<p>If the migrated key has a high hit rate, the CLUSTER SLOTS command will be executed more frequently. This results in the Redis cluster being continuously executed by the client during the migration process with the CLUSTER SLOTS command.</p>
<h3 id="23-summary-of-troubleshooting">2.3 Summary of troubleshooting</h3>
<h3 id="23-summary-of-troubleshooting-1">2.3 Summary of troubleshooting</h3>
<p>Here, combined with the Redis-side CLUSTER SLOTS mechanism and the client-side processing logic for MOVED, several questions can be answered.</p>
<p><strong>Why are there more Cluster instructions being executed?</strong></p>
<p>Because a migration operation has occurred, the business accessing some of the migrated keys will get a MOVED return, and the client will pull the slot topology information again for that return and perform CLUSTER SLOTS.</p>
<p><strong>Why are CPU resources higher when Cluster instructions are executed?</strong></p>
<p>Analyzing the Redis source code, I found that the time complexity of the CLUSTER SLOT instruction is proportional to the number of master nodes. The business&rsquo;s current Redis cluster has a high number of master nodes, so it naturally takes a lot of time and CPU resources.</p>
<p><strong>Why is it easy to &ldquo;hit&rdquo; a cluster with a large node size to migrate a slot operation?</strong></p>
<ul>
<li>Migration operations inevitably bring about the return of MOVED for some client access to the key.</li>
<li>clients execute the CLUSTER SLOTS command for the return of MOVED.</li>
<li>the CLUSTER SLOTS instruction increases in latency as the number of cluster master nodes increases.</li>
<li>Business accesses rise during migration of slots due to CLUSTER SLOTS latency, which is perceived externally as elevated latency in executing instructions.</li>
</ul>
<h2 id="3-optimization">3. Optimization</h2>
<h3 id="31-current-situation-analysis">3.1 Current Situation Analysis</h3>
<p>According to the current situation, it is a normal process for a client to encounter MOVED for CLUSTER SLOTS execution, as the cluster&rsquo;s slot topology needs to be updated to improve the efficiency of subsequent cluster accesses.</p>
<p>In addition to Jedis and Hiredis-vip, other clients should also perform similar sloot information caching optimizations. There is not much room for optimization of this process, as the cluster access mechanism of Redis dictates.</p>
<p>The cluster information logging for Redis is therefore analysed.</p>
<h4 id="311-redis-cluster-metadata-analysis">3.1.1 Redis cluster metadata analysis</h4>
<p>Each Redis node in the cluster has some cluster metadata records, recorded in server.cluster, which are as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">clusterState</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">dict</span> <span class="o">*</span><span class="n">nodes</span><span class="p">;</span>          <span class="cm">/* Hash table of name -&gt; clusterNode structures */</span>
    <span class="cm">/*nodes记录的是所有的节点，使用dict记录*/</span>
    <span class="p">...</span>
    <span class="n">clusterNode</span> <span class="o">*</span><span class="n">slots</span><span class="p">[</span><span class="n">CLUSTER_SLOTS</span><span class="p">];</span><span class="cm">/*slots记录的是slot数组，内容是node的指针*/</span>
    <span class="p">...</span>
<span class="p">}</span> <span class="n">clusterState</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>As described in <strong>2.1</strong>, the original logic obtained the topology by traversing the slot information of each node.</p>
<h4 id="312-redis-cluster-metadata-analysis">3.1.2 Redis cluster metadata analysis</h4>
<p>Observe the results returned by CLUSTER SLOTS.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* Format: 1) 1) start slot
</span><span class="cm"> *            2) end slot
</span><span class="cm"> *            3) 1) master IP
</span><span class="cm"> *               2) master port
</span><span class="cm"> *               3) node ID
</span><span class="cm"> *            4) 1) replica IP
</span><span class="cm"> *               2) replica port
</span><span class="cm"> *               3) node ID
</span><span class="cm"> *           ... continued until done
</span><span class="cm"> */</span>
</code></pre></td></tr></table>
</div>
</div><p>In combination with the cluster information stored in server.cluster, I think that here we can use server.cluster-&gt;slots for traversal. This is because server.cluster-&gt;slots already gets updated at every cluster topology change, saving the node pointers.</p>
<h3 id="32-optimisation-options">3.2 Optimisation options</h3>
<p>A simple optimisation idea is as follows.</p>
<ul>
<li>Iterate over the slots to find blocks where the nodes in the slots are contiguous.</li>
<li>If the node of the currently traversed slot is the same as the previously traversed node, then the currently accessed slot is under the same node as the previous one, i.e. it is in a &ldquo;contiguous&rdquo; slot region under a node.</li>
<li>If the node of the currently traversed slot does not match the previously traversed node, the currently accessed slot is different from the previous one, and the previous &ldquo;continuous&rdquo; slot region can be exported; the current slot is used as the start of the next new &ldquo;continuous&rdquo; slot region.</li>
</ul>
<p>Therefore, it is sufficient to iterate over server.cluster-&gt;slots to satisfy the requirement. A simple representation would look like this.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/13/5d532c2e64824325bfa0b5745c03a762.png" alt="image"></p>
<p>This reduces the time complexity to <code>&lt;total number of slots&gt;</code>.</p>
<h3 id="33-implementation">3.3 Implementation</h3>
<p>The optimisation logic is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="nf">clusterReplyMultiBulkSlots</span><span class="p">(</span><span class="n">client</span> <span class="o">*</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* Format: 1) 1) start slot
</span><span class="cm">     *            2) end slot
</span><span class="cm">     *            3) 1) master IP
</span><span class="cm">     *               2) master port
</span><span class="cm">     *               3) node ID
</span><span class="cm">     *            4) 1) replica IP
</span><span class="cm">     *               2) replica port
</span><span class="cm">     *               3) node ID
</span><span class="cm">     *           ... continued until done
</span><span class="cm">     */</span>
    <span class="n">clusterNode</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">num_masters</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">start</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">slot_replylen</span> <span class="o">=</span> <span class="n">addReplyDeferredLen</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
 
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">CLUSTER_SLOTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/*对所有slot进行遍历*/</span>
        <span class="cm">/* Find start node and slot id. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">CLUSTER_SLOTS</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
 
        <span class="cm">/* Add cluster slots info when occur different node with start
</span><span class="cm">         * or end of slot. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">CLUSTER_SLOTS</span> <span class="o">||</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="cm">/*遍历主节点下面的备节点，添加返回客户端的信息*/</span>
            <span class="n">addNodeReplyForClusterSlot</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
            <span class="n">num_masters</span><span class="o">++</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">CLUSTER_SLOTS</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">setDeferredArrayLen</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">slot_replylen</span><span class="p">,</span> <span class="n">num_masters</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>By traversing server.cluster-&gt;slots, a &ldquo;contiguous&rdquo; slot region under a node is found, and once it is subsequently discontiguous, the node information of the previous &ldquo;contiguous&rdquo; slot region and its backup nodes are output, and then the next &ldquo;contiguous&rdquo; slot region is found and output. If the slots are not consecutive, the node information of the previous &ldquo;consecutive&rdquo; slot region and its backup nodes are output, and then the next &ldquo;consecutive&rdquo; slot region is found and output.</p>
<h2 id="comparison-of-optimisation-results">Comparison of Optimisation Results</h2>
<p>A side-by-side comparison of the CLUSTER SLOTS command between the two versions of Redis.</p>
<h3 id="41-test-environment--pressure-test-scenarios">4.1 Test Environment &amp; Pressure Test Scenarios</h3>
<p>Operating system: manjaro 20.2</p>
<p><strong>Hardware configuration:</strong></p>
<ul>
<li>CPU: AMD Ryzen 7 4800H</li>
<li>DRAM: DDR4 3200MHz 8G*2</li>
</ul>
<p><strong>Redis Cluster Information:</strong></p>
<ol>
<li>
<p>Persistence Configuration</p>
<ul>
<li>Turn off aof</li>
<li>Turn off bgsave</li>
</ul>
</li>
<li>
<p>Cluster node information.</p>
<ul>
<li>Number of nodes: 100</li>
<li>All nodes are master nodes</li>
</ul>
</li>
</ol>
<p><strong>Pressure testing scenarios:</strong></p>
<ul>
<li>Using the benchmark tool to send CLUSTER SLOTS commands continuously to individual nodes of the cluster.</li>
<li>After pressure testing one of the versions, recycle the cluster, redeploy it and then proceed to the next round of pressure testing.</li>
</ul>
<h3 id="42-cpu-resource-usage-comparison">4.2 CPU resource usage comparison</h3>
<p>perf exported flame chart. Original version.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/13/c5b15f5b7b7349f9b39f66ae5df9c6b1.png" alt="image"></p>
<p>Optimised for.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/13/de642d25c8a44af883682a4e04e50ada.png" alt="image"></p>
<p>It is clear to see that the optimised share has dropped significantly. This is largely as expected.</p>
<h3 id="43-time-consumption-comparison">4.3 Time consumption comparison</h3>
<p>Tests were carried out on, with embedded time consuming test code on.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span><span class="s">&#34;slots&#34;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* CLUSTER SLOTS */</span>
        <span class="kt">long</span> <span class="kt">long</span> <span class="n">now</span> <span class="o">=</span> <span class="n">ustime</span><span class="p">();</span>
        <span class="n">clusterReplyMultiBulkSlots</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
        <span class="n">serverLog</span><span class="p">(</span><span class="n">LL_NOTICE</span><span class="p">,</span>
            <span class="s">&#34;cluster slots cost time:%lld us&#34;</span><span class="p">,</span> <span class="n">ustime</span><span class="p">()</span> <span class="o">-</span> <span class="n">now</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Input logs for comparison.</p>
<p><strong>Original log output:</strong></p>
<p>37351:M 06 Mar 2021 16:11:39.313 * cluster slots cost time:2061 us.</p>
<p><strong>Optimized version log output:</strong></p>
<p>35562:M 06 Mar 2021 16:11:27.862 * cluster slots cost time:168 us.</p>
<p>This is a significant drop in time consumption: from 2000+us to 200-us; the time consumption in a cluster of 100 master nodes is reduced to 8.2% of the original; the optimization results are basically as expected.</p>
<h2 id="5-summary">5. Summary</h2>
<p>Here it is possible to briefly describe the above actions of the article leading to such a conclusion: a performance defect.</p>
<p>To briefly summarize the above troubleshooting and optimization process.</p>
<ul>
<li>A large Redis cluster was experiencing significant access latency on some nodes due to the CLUSTER command.</li>
<li>Using the perf top command to troubleshoot Redis instances, the clusterReplyMultiBulkSlots command was found to be using an unusual amount of CPU resources.</li>
<li>Analysis of clusterReplyMultiBulkSlots revealed significant performance issues with this function.</li>
<li>Optimization of clusterReplyMultiBulkSlots resulted in significant performance improvements.</li>
</ul>
<p>From the above troubleshooting and optimization process, it can be concluded that the current Redis has a performance flaw in the CLUSTER SLOT instruction.</p>
<p>Because of Redis' data slicing mechanism, the key access method in Redis cluster mode is to cache the topology of the slots. The only place to start is with CLUSTER SLOTS. The number of nodes in a Redis cluster is generally not as large, and the problem is not as obvious.</p>
<p>In fact, the logic of Hiredis-vip is also somewhat problematic. As mentioned in <strong>2.2.1</strong>, Hiredis-vip&rsquo;s method of updating the slot topology is to traverse all the nodes one by one to perform CLUSTER SLOTS, which can have a knock-on effect if the Redis cluster is large and the business-side clients are large.</p>
<ol>
<li>
<p>if the Redis cluster is large, the CLUSTER SLOTS response is slower.</p>
</li>
<li>
<p>if a node does not respond or returns an error, the Hiredis-vip client will continue the request to the next node.</p>
</li>
<li>
<p>the same method of iterative traversal of the Redis cluster nodes in the Hiredis-vip client (since the information about the cluster is essentially the same across clients), when the client size is large, there may be blocking on a Redis node, which will cause the hiredis-vip client to traverse the next Redis node.</p>
</li>
<li>
<p>A large number of Hiredis-vip clients accessing a number of Redis nodes one by one, which can lead to Redis nodes being requested one by one under the &ldquo;traversal&rdquo; of a large number of Hiredis-vip clients if the Redis nodes cannot cope with such requests.</p>
</li>
</ol>
<blockquote>
<p>In conjunction with point 3 above, imagine that there are 1w clients accessing the Redis cluster. Because there is a migration operation for a key with a high hit rate, all the clients need to update the slot topology. Since all clients have the same cluster node information cached, the order of traversal is the same across all nodes. Redis nodes are accessed by most of the clients (e.g. 9k+ clients) in order of traversal. Executing the CLUSTER SLOTS command causes Redis nodes to block one by one.</p>
</blockquote>
<ol start="5">
<li>The end result is that the CPU load on most Redis nodes skyrockets, and many Hiredis-vip clients continue to be unable to update the slot topology.</li>
</ol>
<p>The end result is that after a large scale Redis cluster undergoes a slot migration operation, the business side perception is that common command latency becomes high and the Redis instance CPU resource usage is high under large scale Hiredis-vip client access. This logic can be optimised to some extent.</p>
<p>The optimizations in subsection 3 above have now been committed and merged into Redis version 6.2.2.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/redis/">redis</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-01/cpp-http-client/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">High Performance C&#43;&#43; HTTP Client Principles and Implementation</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-01/promise/">
            <span class="next-text nav-default">Everything you need to know about Promise</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
