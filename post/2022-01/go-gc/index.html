<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Go language GC implementation principle and source code analysis - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="20,000 words long article takes you from the source code to dissect the Go language GC implementation. Introduction Three-color marking method The three-color marking method divides the color of the object into three colors: black, gray, and white. Black: the object has been marked and all the properties under the object have been marked (the object required by the program). gray: the object has been marked, but the properties under" /><meta name="keywords" content="golang, Gc" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-01/go-gc/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Go language GC implementation principle and source code analysis" />
<meta property="og:description" content="20,000 words long article takes you from the source code to dissect the Go language GC implementation. Introduction Three-color marking method The three-color marking method divides the color of the object into three colors: black, gray, and white. Black: the object has been marked and all the properties under the object have been marked (the object required by the program). gray: the object has been marked, but the properties under" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-01/go-gc/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-01-23T16:02:01+08:00" />
<meta property="article:modified_time" content="2022-01-23T16:02:01+08:00" />

<meta itemprop="name" content="Go language GC implementation principle and source code analysis">
<meta itemprop="description" content="20,000 words long article takes you from the source code to dissect the Go language GC implementation. Introduction Three-color marking method The three-color marking method divides the color of the object into three colors: black, gray, and white. Black: the object has been marked and all the properties under the object have been marked (the object required by the program). gray: the object has been marked, but the properties under"><meta itemprop="datePublished" content="2022-01-23T16:02:01+08:00" />
<meta itemprop="dateModified" content="2022-01-23T16:02:01+08:00" />
<meta itemprop="wordCount" content="13853">
<meta itemprop="keywords" content="golang," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go language GC implementation principle and source code analysis"/>
<meta name="twitter:description" content="20,000 words long article takes you from the source code to dissect the Go language GC implementation. Introduction Three-color marking method The three-color marking method divides the color of the object into three colors: black, gray, and white. Black: the object has been marked and all the properties under the object have been marked (the object required by the program). gray: the object has been marked, but the properties under"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Go language GC implementation principle and source code analysis</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-01-23 16:02:01 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 13853 words </span>
          <span class="more-meta"> 28 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#introduction">Introduction</a>
          <ul>
            <li><a href="#three-color-marking-method">Three-color marking method</a></li>
            <li><a href="#problems-with-the-three-color-markup-method">Problems with the three-color markup method</a></li>
            <li><a href="#memory-barrier">Memory Barrier</a></li>
          </ul>
        </li>
        <li><a href="#analysis">Analysis</a>
          <ul>
            <li><a href="#gc-phase-garbage-collection-phase">GC phase Garbage collection phase</a></li>
            <li><a href="#next-gc-timing">Next GC timing</a></li>
            <li><a href="#trigger-gc-condition">Trigger GC condition</a></li>
            <li><a href="#start-gc">Start GC</a></li>
            <li><a href="#gc-startup">GC startup</a></li>
            <li><a href="#create-a-background-tag-worker">Create a background tag worker</a></li>
            <li><a href="#concurrent-scan-markers">Concurrent scan markers</a></li>
            <li><a href="#mark-completion">Mark completion</a></li>
            <li><a href="#mark-termination">Mark Termination</a></li>
            <li><a href="#backend-cleanup">Backend cleanup</a></li>
          </ul>
        </li>
        <li><a href="#summary">Summary</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>20,000 words long article takes you from the source code to dissect the Go language GC implementation.</p>
<h2 id="introduction">Introduction</h2>
<h3 id="three-color-marking-method">Three-color marking method</h3>
<p>The three-color marking method divides the color of the object into three colors: black, gray, and white.</p>
<ul>
<li>Black: the object has been marked and all the properties under the object have been marked (the object required by the program).</li>
<li>gray: the object has been marked, but the properties under the object are not all marked (the GC needs to find garbage from this object).</li>
<li>white: the object has not been marked (object garbage).</li>
</ul>
<p>When the garbage collector starts working, traversal access is made from GC Roots, and the access steps can be divided into the following steps.</p>
<ol>
<li>the GC Roots object will be marked in gray.</li>
<li>the object is then fetched from the gray collection, marked as black, and the object to which it refers is marked as gray</li>
<li>repeating step 2 until there are no more grey collections to mark.</li>
<li>when finished, the remaining white objects that are not marked are GC Roots unreachable and can be recycled.</li>
</ol>
<p>The process is roughly as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/23/9df56746a56241f287c9e18ccbdee560.png" alt="go gc"></p>
<p>Let&rsquo;s talk about the problems that can exist with the three-color marking method.</p>
<h3 id="problems-with-the-three-color-markup-method">Problems with the three-color markup method</h3>
<h4 id="multi-tagging---floating-garbage-problem">Multi-tagging - floating garbage problem</h4>
<p>Suppose E has already been marked (grayed out), and D and E are disconnected from each other, the objects E/F/G should be recycled, but since E has been grayed out, it will still be treated as a living object and continue to be traversed. The result is that this part of the object will still be marked as alive, i.e., this part of memory will not be reclaimed in this GC round.</p>
<p>The memory that should have been recovered but was not recovered is called &ldquo;floating garbage&rdquo;. The process is shown in the figure below.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/23/9a53533ebcf94bd18357860d0b822590.png" alt="sobyte"></p>
<h4 id="missing-marker---hanging-pointer-problem">Missing marker - hanging pointer problem</h4>
<p>In addition to the above multi-labeling problem, there is also the missing-labeling problem. When the GC thread has traversed until E becomes gray and D becomes black, gray E breaks the reference to white G and black D references white G. At this point, it cuts back to the GC thread and continues running because E no longer has a reference to G, so it does not place G in the gray collection. Even though D has re-referenced G, it will not be re-traversed because D is already black.</p>
<p>The end result is that G stays in the white collection and is eventually purged as garbage. This has a direct impact on the correctness of the application and is unacceptable, and is something Go needs to address at GC time.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/23/88c6884dccc84ca1aae315d906a1b6e7.png" alt="sobyte"></p>
<h3 id="memory-barrier">Memory Barrier</h3>
<p>In order to <strong>solve</strong> the hanging pointer problem above, we need to introduce barrier techniques to guarantee data consistency.</p>
<p>A <strong>memory barrier</strong> , is a type of <a href="https://en.wikipedia.org/wiki/Barrier_(computer_science)">barrier</a> <a href="https://en.wikipedia.org/wiki/Instruction_(computer_science)">instruction</a> that causes a <a href="https://en.wikipedia.org/wiki/Central_processing_unit">central processing unit</a> (CPU) or <a href="https://en.wikipedia.org/wiki/Compiler">compiler</a> to enforce an <a href="https://en.wikipedia.org/wiki/Memory_ordering">ordering</a> constraint on <a href="https://en.wikipedia.org/wiki/Random-access_memory">memory</a> operations issued before and after the barrier instruction. This typically means that operations issued prior to the barrier are guaranteed to be performed before operations issued after the barrier.</p>
<p>Then in order to guarantee correctness in the marking algorithm, then we need to meet any of the following conditions.</p>
<ul>
<li>strong tri-color invariant: the black object does not point to the white object, but only to the gray object or to the black object.</li>
<li>weak tri-color invariant: even if a black object points to a white object, there is always a path from the gray object to that white object.</li>
</ul>
<p>Depending on the type of operation, we can divide memory barriers into Read barriers and Write barriers. In Go, the Write barrier is used.</p>
<p>The reason for this is also mentioned in &ldquo;Uniprocessor Garbage Collection Techniques&rdquo;.</p>
<blockquote>
<p>If a non copying collector is used the use of a read barrier is an unnecessary expense.there is no need to protect the mutator from seeing an invalid version of a pointer. Write barrier techniques are cheaper, because heap writes are several times less common than heap reads</p>
</blockquote>
<p>The Read barrier is costly for a garbage collector that does not require object copies because there is no need to preserve the version pointer problem for read operations for this type of garbage collector. The Write barrier code is comparatively smaller, because the write operations in the heap are much smaller than the read operations in the heap.</p>
<p>Let&rsquo;s see how the Write barrier does this.</p>
<h4 id="dijkstra-write-barrier">Dijkstra Write barrier</h4>
<p>Prior to Go 1.7, the Dijkstra Write barrier was used, using an implementation similar to the following pseudo-code.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nf">writePointer</span><span class="p">(</span><span class="nx">slot</span><span class="p">,</span> <span class="nx">ptr</span><span class="p">):</span>
    <span class="nf">shade</span><span class="p">(</span><span class="nx">ptr</span><span class="p">)</span>
    <span class="o">*</span><span class="nx">slot</span> <span class="p">=</span> <span class="nx">ptr</span>
</code></pre></td></tr></table>
</div>
</div><p>If the object is white, <code>shade(ptr)</code> will mark the object as gray. This ensures strong tricolor invariance, and it ensures that the object pointed to by the ptr pointer is not white until it is assigned to <code>*slot</code>.</p>
<p>As follows, the D object pointed to by the root object is marked black and the E object pointed to by the D object is marked gray; if D breaks its reference to E and refers to the B object instead, then the write barrier is triggered to mark the B object gray.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/23/835d165b3c8b440ebb3b6350068587f8.png" alt="sobyte"></p>
<p>The Dijkstra Write barrier is very simple to implement and guarantees strong tricolor invariance. However, it has some drawbacks as presented in &ldquo;Proposal: Eliminate STW stack re-scanning&rdquo;.</p>
<blockquote>
<p>In particular, it presents a trade-off for pointers on stacks: either writes to pointers on the stack must have write barriers, which is prohibitively expensive, or stacks must be permagrey.</p>
</blockquote>
<p>The Go 1.7 option is to mark the stacks as constant gray, but these stacks need to be rescanned (re-scan) during the mark termination phase STW. The reason for this is described below.</p>
<blockquote>
<p>without stack write barriers, we can&rsquo;t ensure that the stack won&rsquo;t later contain a reference to a white object, so a scanned stack is only black until its goroutine executes again, at which point it conservatively reverts to grey. Thus, at the end of the cycle, the garbage collector must re-scan grey stacks to blacken them and finish marking any remaining heap pointers.</p>
</blockquote>
<h4 id="yuasa-write-barrier">Yuasa Write barrier</h4>
<p>Yuasa Write barrier is a deletion barrier technique proposed by Yuasa in &ldquo;Real-time garbage collection on general-purpose machines&rdquo;. The idea is to notify the concurrently executing collector through the write barrier when the assignor deletes a white pointer from a gray or white object.</p>
<p>The algorithm guarantees the correctness of the program when garbage collection is performed incrementally or concurrently using a write barrier as shown below, with the following pseudo-code implementation.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nf">writePointer</span><span class="p">(</span><span class="nx">slot</span><span class="p">,</span> <span class="nx">ptr</span><span class="p">)</span>
    <span class="nf">shade</span><span class="p">(</span><span class="o">*</span><span class="nx">slot</span><span class="p">)</span>
    <span class="o">*</span><span class="nx">slot</span> <span class="p">=</span> <span class="nx">ptr</span>
</code></pre></td></tr></table>
</div>
</div><p>To prevent losing the path from the gray object to the white object, it should be assumed that <em>slot may turn black. To ensure that ptr does not turn white before being assigned to</em> slot, shade( <em>slot) first marks</em> slot as gray, and the write operation always creates a path from gray to gray or gray to white objects, so that removing the write barrier ensures weak tricolor invariance and that downstream objects referenced by the old object must be referenced by the gray object.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/23/112eac4c0e244f83b6e185e7b6d1a279.png" alt="sobyte"></p>
<h4 id="hybrid-write-barrier">Hybrid write barrier</h4>
<p>As mentioned above, prior to Go 1.7, the Dijkstra Write barrier was used to ensure tricolor invariance. Go must ensure that object references do not change during rescans, so it performs a pause procedure (STW), marks all stack objects as gray, and rescans, which typically takes 10-100 milliseconds.</p>
<p>The Proposal: Eliminate STW stack rescanning <a href="https://go.googlesource.com/proposal/+/master/design/17503-eliminate-rescan.md">https://go.googlesource.com/proposal/+/master/design/17503-eliminate-rescan.md</a> shows that in order to eliminate re-scanning, Go used a Hybrid write barrier in 1.8, combining the Yuasa write barrier and the Dijkstra write barrier, with the following pseudo-code implementation.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nf">writePointer</span><span class="p">(</span><span class="nx">slot</span><span class="p">,</span> <span class="nx">ptr</span><span class="p">):</span>
    <span class="nf">shade</span><span class="p">(</span><span class="o">*</span><span class="nx">slot</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">current</span> <span class="nx">stack</span> <span class="nx">is</span> <span class="nx">grey</span><span class="p">:</span>
        <span class="nf">shade</span><span class="p">(</span><span class="nx">ptr</span><span class="p">)</span>
    <span class="o">*</span><span class="nx">slot</span> <span class="p">=</span> <span class="nx">ptr</span>
</code></pre></td></tr></table>
</div>
</div><p>This not only simplifies the GC process, but also reduces the cost of rescanning during the mark termination phase. The basic idea of the hybrid write barrier is:</p>
<blockquote>
<p>the write barrier shades the object whose reference is being overwritten, and, if the current goroutine&rsquo;s stack has not yet been scanned, also shades the reference being installed.</p>
</blockquote>
<p>Also, during GC all newly allocated objects immediately turn black, as seen in the mallocgc function in <code>go\src\runtime\malloc.go</code> during memory allocation.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">size</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">typ</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">needzero</span> <span class="kt">bool</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span> 
    <span class="o">...</span>  
    <span class="nx">dataSize</span> <span class="o">:=</span> <span class="nx">size</span>
    <span class="c1">// 获取mcache，用于处理微对象和小对象的分配
</span><span class="c1"></span>    <span class="nx">c</span> <span class="o">:=</span> <span class="nf">gomcache</span><span class="p">()</span>
    <span class="kd">var</span> <span class="nx">x</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
    <span class="c1">// 表示对象是否包含指针，true表示对象里没有指针
</span><span class="c1"></span>    <span class="nx">noscan</span> <span class="o">:=</span> <span class="nx">typ</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">typ</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="c1">// maxSmallSize=32768 32k
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">size</span> <span class="o">&lt;=</span> <span class="nx">maxSmallSize</span> <span class="p">{</span>
        <span class="c1">// maxTinySize= 16 bytes 
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">noscan</span> <span class="o">&amp;&amp;</span> <span class="nx">size</span> <span class="p">&lt;</span> <span class="nx">maxTinySize</span> <span class="p">{</span>
            <span class="o">...</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="o">...</span>
        <span class="p">}</span>
        <span class="c1">// 大于 32 Kb 的内存分配,通过 mheap 分配
</span><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="o">...</span>
    <span class="p">}</span> 
    <span class="o">...</span>
    <span class="c1">// 在 GC 期间分配的新对象都会被标记成黑色
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">gcphase</span> <span class="o">!=</span> <span class="nx">_GCoff</span> <span class="p">{</span>
        <span class="nf">gcmarknewobject</span><span class="p">(</span><span class="nx">span</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">x</span><span class="p">),</span> <span class="nx">size</span><span class="p">,</span> <span class="nx">scanSize</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="nx">x</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>During the marking phase of garbage collection, newly created objects are marked black to prevent objects in newly allocated stack memory and heap memory from being reclaimed incorrectly.</p>
<h2 id="analysis">Analysis</h2>
<h3 id="gc-phase-garbage-collection-phase">GC phase Garbage collection phase</h3>
<p>The GC-related code is in the <code>runtime/mgc.go</code> file. As we can see from the comments, there are 4 phases of GC.</p>
<ul>
<li>sweep termination
<ul>
<li>STW will be triggered and all P&rsquo;s (processors) will go to safe-point.</li>
<li>the cleanup of the uncleared span.</li>
</ul>
</li>
<li>the mark phase
<ul>
<li>Changing the <code>_GCoff</code> GC state to <code>_GCmark</code>, turning on the Write Barrier, mutator assists, and queuing the root object.</li>
<li>Resume program execution, mark workers (mark processes) and mutator assists (assist threads) will start concurrently marking objects in memory. for any pointer writes and new pointer values, which are overwritten by the write barrier, and all newly created objects are marked directly in black.</li>
<li>GC performs root node marking, which includes scanning all stacks, global objects, and runtime data structures that are not in the heap. Scanning the goroutine stack draws causes the goroutine to stop and greys out all pointers found on the stack, and then the execution of the goroutine continues.</li>
<li>GC turns the gray object black and greys out the object it points to as it traverses the gray object queue.</li>
<li>The GC uses the distributed termination algorithm to detect when there are no more root mark jobs or gray objects, and if there are none left the GC switches to mark termination.</li>
</ul>
</li>
<li>mark termination
<ul>
<li>STW, which then turns the GC phase to <code>_GCmarktermination</code> , closing the GC worker threads as well as mutator assists (assist threads).</li>
<li>performing cleanup, such as flush mcache.</li>
</ul>
</li>
<li>the sweep phase
<ul>
<li>transitioning the GC state to <code>_GCoff</code>, initializing the cleanup state and closing the Write Barrier</li>
<li>resuming program execution, with newly created objects from then on being white.</li>
<li>Concurrently clean up all memory management units in the background</li>
</ul>
</li>
</ul>
<p>It is important to note that mutator assists is mentioned above, as there is a case:</p>
<p>during the collection that the Goroutine dedicated to GC will not finish the Marking work before the heap memory in-use reaches its limit</p>
<p>If the collector determines that it needs to slow down allocations, it will recruit the application Goroutines to assist with the Marking work. This is called a Mutator Assist. One positive side effect of Mutator Assist is that it helps to finish the collection faster.</p>
<h3 id="next-gc-timing">Next GC timing</h3>
<p>The timing of the next GC can be controlled by an environment variable, GOGC, which defaults to 100, i.e. a 100% increase in heap memory before triggering a GC.</p>
<p>This value represents a ratio of how much new heap memory can be allocated before the next collection has to start.</p>
<p>The official explanation is that if 4M of memory is currently used, the next GC will be when the memory reaches 8M. Let&rsquo;s look at a concrete example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;start.&#34;</span><span class="p">)</span>

    <span class="nx">container</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;&gt; loop.&#34;</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">32</span><span class="o">*</span><span class="mi">1000</span><span class="o">*</span><span class="mi">1000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">container</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">container</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;&lt; loop.&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Note that it is recommended to use a Linux environment when doing experiments. If you don&rsquo;t have a Linux environment, you can run a virtual machine under win10 like I did. Then you can use vscode to remote to Linux for experimentation.</p>
<p>After compiling, you can use gctrace to track the GC situation.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">[root@localhost gotest]# go build main.go 
[root@localhost gotest]# GODEBUG=gctrace=1 ./main
start.
&gt; loop.
gc 1 @0.004s 4%: 0.22+1.4+0.021 ms clock, 1.7+0.009/0.40/0.073+0.16 ms cpu, 4-&gt;5-&gt;1 MB, 5 MB goal, 8 P
gc 2 @0.006s 4%: 0.10+1.6+0.020 ms clock, 0.83+0.12/0/0+0.16 ms cpu, 4-&gt;6-&gt;1 MB, 5 MB goal, 8 P
gc 3 @0.009s 16%: 0.035+5.5+2.2 ms clock, 0.28+0/0.47/0.007+18 ms cpu, 4-&gt;15-&gt;15 MB, 5 MB goal, 8 P
...
&lt; loop.
</code></pre></td></tr></table>
</div>
</div><p>The above shows the case of 3 GCs, let&rsquo;s see what it means exactly.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">gc 1 @0.004s 4%: 0.22+1.4+0.021 ms clock, 1.7+0.009/0.40/0.073+0.16 ms cpu, 4-&gt;5-&gt;1 MB, 5 MB goal, 8 P

gc 1 ：程序启动以来第1次GC
@0.004s：距离程序启动到现在的时间
4%：当目前为止，GC 的标记工作所用的CPU时间占总CPU的百分比

垃圾回收的时间
0.22 ms：标记开始 STW 时间
1.4 ms：并发标记时间
0.021 ms：标记终止 STW 时间

垃圾回收占用cpu时间
1.7 ms：标记开始 STW 时间
0.009 ms：mutator assists占用的时间
0.40 ms：标记线程占用的时间
0.073 ms：idle mark workers占用的时间
0.16 ms：标记终止 STW 时间

内存
4 MB：标记开始前堆占用大小
5 MB：标记结束后堆占用大小
1 MB：标记完成后存活堆的大小
5 MB goal：标记完成后正在使用的堆内存的目标大小

8 P：使用了多少处理器
</code></pre></td></tr></table>
</div>
</div><p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/23/5fc4534cc76d42059f8dccbd665207f7.png" alt="sobyte"></p>
<p>From the GC memory information above, we can see that the heap size is 4MB before the GC tagging starts, and since the tagging is done concurrently, the size of the heap used when the tagging is done is 5MB, which means that 1MB of memory allocation happens during the GC. Finally, we can see that the heap size that survives after the GC marking is only 1MB, which means that the next round of GC can be started when the heap occupies 2MB of memory.</p>
<p>From the above, we can see that the memory size of the Goal section is 5MB, which is equal to the actual memory usage of the In-Use After section, but it is not equal in many complex cases because the memory size of the Goal section is projected based on the current memory usage.</p>
<blockquote>
<p>the goal is calculated based on the current amount of the heap memory in-use, the amount of heap memory marked as live, and timing calculations about the additional allocations that will occur while the collection is running.</p>
</blockquote>
<h3 id="trigger-gc-condition">Trigger GC condition</h3>
<p>The trigger GC condition is verified by <code>gcTrigger.test</code>, let&rsquo;s see how <code>gcTrigger.test</code> determines if garbage collection should be triggered.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">gcTrigger</span><span class="p">)</span> <span class="nf">test</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">enablegc</span> <span class="o">||</span> <span class="nx">panicking</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">gcphase</span> <span class="o">!=</span> <span class="nx">_GCoff</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>
    <span class="k">switch</span> <span class="nx">t</span><span class="p">.</span><span class="nx">kind</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">gcTriggerHeap</span><span class="p">:</span> 
        <span class="c1">// 堆内存的分配达到达控制器计算的触发堆大小
</span><span class="c1"></span>        <span class="k">return</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_live</span> <span class="o">&gt;=</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">gc_trigger</span>
    <span class="k">case</span> <span class="nx">gcTriggerTime</span><span class="p">:</span>
        <span class="k">if</span> <span class="nx">gcpercent</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="p">}</span>
        <span class="nx">lastgc</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">last_gc_nanotime</span><span class="p">))</span>
        <span class="c1">// 如果一定时间内没有触发，就会触发新的循环
</span><span class="c1"></span>        <span class="k">return</span> <span class="nx">lastgc</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">t</span><span class="p">.</span><span class="nx">now</span><span class="o">-</span><span class="nx">lastgc</span> <span class="p">&gt;</span> <span class="nx">forcegcperiod</span>
    <span class="k">case</span> <span class="nx">gcTriggerCycle</span><span class="p">:</span>
        <span class="c1">// 要求启动新一轮的GC, 已启动则跳过
</span><span class="c1"></span>        <span class="k">return</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">n</span><span class="o">-</span><span class="nx">work</span><span class="p">.</span><span class="nx">cycles</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The trigger time of gcTriggerTime is determined by forcegcperiod, which is 2 minutes by default. Let&rsquo;s take a look at the heap memory size triggering GC.</p>
<p>The gcTriggerHeap heap memory allocation reaches the trigger heap size calculated by the controller, the heap_live value is calculated at the time of memory allocation, and the gc_trigger calculation is done in the <code>runtime.gcSetTriggerRatio</code> function.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gcSetTriggerRatio</span><span class="p">(</span><span class="nx">triggerRatio</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span> 
    <span class="c1">// gcpercent 由环境变量 GOGC 决定
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">gcpercent</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="c1">// 默认是 1
</span><span class="c1"></span>        <span class="nx">scalingFactor</span> <span class="o">:=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">gcpercent</span><span class="p">)</span> <span class="o">/</span> <span class="mi">100</span> 
        <span class="c1">// 最大的 maxTriggerRatio 是 0.95
</span><span class="c1"></span>        <span class="nx">maxTriggerRatio</span> <span class="o">:=</span> <span class="mf">0.95</span> <span class="o">*</span> <span class="nx">scalingFactor</span>
        <span class="k">if</span> <span class="nx">triggerRatio</span> <span class="p">&gt;</span> <span class="nx">maxTriggerRatio</span> <span class="p">{</span>
            <span class="nx">triggerRatio</span> <span class="p">=</span> <span class="nx">maxTriggerRatio</span>
        <span class="p">}</span>

        <span class="c1">// 最大的 minTriggerRatio 是 0.6
</span><span class="c1"></span>        <span class="nx">minTriggerRatio</span> <span class="o">:=</span> <span class="mf">0.6</span> <span class="o">*</span> <span class="nx">scalingFactor</span>
        <span class="k">if</span> <span class="nx">triggerRatio</span> <span class="p">&lt;</span> <span class="nx">minTriggerRatio</span> <span class="p">{</span>
            <span class="nx">triggerRatio</span> <span class="p">=</span> <span class="nx">minTriggerRatio</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">triggerRatio</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span> 
        <span class="nx">triggerRatio</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="p">}</span>
    <span class="nx">memstats</span><span class="p">.</span><span class="nx">triggerRatio</span> <span class="p">=</span> <span class="nx">triggerRatio</span>

    <span class="nx">trigger</span> <span class="o">:=</span> <span class="p">^</span><span class="nb">uint64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">gcpercent</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="c1">// 当前标记存活的大小乘以1+系数triggerRatio
</span><span class="c1"></span>        <span class="nx">trigger</span> <span class="p">=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_marked</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="nx">triggerRatio</span><span class="p">))</span>
        <span class="o">...</span>
    <span class="p">}</span>
    <span class="nx">memstats</span><span class="p">.</span><span class="nx">gc_trigger</span> <span class="p">=</span> <span class="nx">trigger</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The gcSetTriggerRatio function gets the heap size for the next GC trigger based on the calculated triggerRatio. triggerRatio is adjusted after each GC, and the triggerRatio is calculated in <code>gcControllerState.endCycle</code>, which is called in <code>gcControllerState.endCycle</code>. gcControllerState.endCycle` is called in MarkDone.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gcControllerState</span><span class="p">)</span> <span class="nf">endCycle</span><span class="p">()</span> <span class="kt">float64</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">triggerGain</span> <span class="p">=</span> <span class="mf">0.5</span>
    <span class="c1">// 目标Heap增长率 = （下次 GC 完后堆大小 - 堆存活大小）/ 堆存活大小
</span><span class="c1"></span>    <span class="nx">goalGrowthRatio</span> <span class="o">:=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">next_gc</span><span class="o">-</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_marked</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_marked</span><span class="p">)</span>
    <span class="c1">// 实际Heap增长率, 等于总大小/存活大小-1
</span><span class="c1"></span>    <span class="nx">actualGrowthRatio</span> <span class="o">:=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_live</span><span class="p">)</span><span class="o">/</span><span class="nb">float64</span><span class="p">(</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_marked</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="c1">// GC标记阶段的使用时间
</span><span class="c1"></span>    <span class="nx">assistDuration</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span> <span class="o">-</span> <span class="nx">c</span><span class="p">.</span><span class="nx">markStartTime</span>
    <span class="c1">// GC标记阶段的CPU占用率, 目标值是0.25
</span><span class="c1"></span>    <span class="nx">utilization</span> <span class="o">:=</span> <span class="nx">gcBackgroundUtilization</span>
    <span class="c1">// Add assist utilization; avoid divide by zero.
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">assistDuration</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="c1">// assistTime 是G辅助GC标记对象所使用的时间合计
</span><span class="c1"></span>        <span class="c1">// 额外的CPU占用率 = 辅助GC标记对象的总时间 / (GC标记使用时间 * P的数量)// 额外的CPU占用率 = 辅助GC标记对象的总时间 / (GC标记使用时间 * P的数量)
</span><span class="c1"></span>        <span class="nx">utilization</span> <span class="o">+=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">assistTime</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">assistDuration</span><span class="o">*</span><span class="nb">int64</span><span class="p">(</span><span class="nx">gomaxprocs</span><span class="p">))</span>
    <span class="p">}</span>
    <span class="c1">// 触发系数偏移值 = 目标增长率 - 原触发系数 - CPU占用率 / 目标CPU占用率 * (实际增长率 - 原触发系数)
</span><span class="c1"></span>    <span class="nx">triggerError</span> <span class="o">:=</span> <span class="nx">goalGrowthRatio</span> <span class="o">-</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">triggerRatio</span> <span class="o">-</span> <span class="nx">utilization</span><span class="o">/</span><span class="nx">gcGoalUtilization</span><span class="o">*</span><span class="p">(</span><span class="nx">actualGrowthRatio</span><span class="o">-</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">triggerRatio</span><span class="p">)</span>

    <span class="c1">// 根据偏移值调整触发系数, 每次只调整偏移值的一半
</span><span class="c1"></span>    <span class="nx">triggerRatio</span> <span class="o">:=</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">triggerRatio</span> <span class="o">+</span> <span class="nx">triggerGain</span><span class="o">*</span><span class="nx">triggerError</span>

    <span class="k">return</span> <span class="nx">triggerRatio</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>For triggerRatio in general is still complicated, we can know according to the offset value.</p>
<ul>
<li>the larger the actual growth rate, the smaller the triggerRatio offset value is, and the next trigger GC will be earlier when it is smaller than 0.</li>
<li>the larger the CPU occupancy, the smaller the offset value of the trigger factor, and the next GC trigger will be earlier when it is smaller than 0.</li>
<li>the larger the original trigger factor, the smaller the trigger factor offset value, the earlier the next trigger GC will be triggered when it is smaller than 0.</li>
</ul>
<p>The above analysis also explains why the <code>GODEBUG=gctrace=1</code> analysis is executed early even though the heap memory has not yet reached 2 times, mainly due to the influence of triggerError offset.</p>
<h3 id="start-gc">Start GC</h3>
<p>We can call <code>runtime.GC</code> to trigger a GC manually when testing, but in practice, the entry point to trigger a GC is not normally called manually. The normal trigger would be to call <code>runtime.mallocgc</code> when memory is requested or to call <code>runtime.forcegchelper</code> when the Go background monitor thread sysmon checks in regularly.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">GC</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 获取 GC 循环次数
</span><span class="c1"></span>    <span class="nx">n</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">cycles</span><span class="p">)</span>
    <span class="c1">// 等待上一个循环的标记终止、标记和清除终止阶段完成
</span><span class="c1"></span>    <span class="nf">gcWaitOnMark</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
    <span class="c1">// 触发新一轮的 GC
</span><span class="c1"></span>    <span class="nf">gcStart</span><span class="p">(</span><span class="nx">gcTrigger</span><span class="p">{</span><span class="nx">kind</span><span class="p">:</span> <span class="nx">gcTriggerCycle</span><span class="p">,</span> <span class="nx">n</span><span class="p">:</span> <span class="nx">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">})</span>
    <span class="c1">// 同上
</span><span class="c1"></span>    <span class="nf">gcWaitOnMark</span><span class="p">(</span><span class="nx">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> 
    <span class="c1">// 等待清理全部待处理的内存管理单元
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">cycles</span><span class="p">)</span> <span class="o">==</span> <span class="nx">n</span><span class="o">+</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nf">sweepone</span><span class="p">()</span> <span class="o">!=</span> <span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">sweep</span><span class="p">.</span><span class="nx">nbgsweep</span><span class="o">++</span>
        <span class="c1">// 让出 P
</span><span class="c1"></span>        <span class="nf">Gosched</span><span class="p">()</span>
    <span class="p">}</span> 

    <span class="k">for</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">cycles</span><span class="p">)</span> <span class="o">==</span> <span class="nx">n</span><span class="o">+</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepers</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nf">Gosched</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="nx">mp</span> <span class="o">:=</span> <span class="nf">acquirem</span><span class="p">()</span>
    <span class="nx">cycle</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">cycles</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">cycle</span> <span class="o">==</span> <span class="nx">n</span><span class="o">+</span><span class="mi">1</span> <span class="o">||</span> <span class="p">(</span><span class="nx">gcphase</span> <span class="o">==</span> <span class="nx">_GCmark</span> <span class="o">&amp;&amp;</span> <span class="nx">cycle</span> <span class="o">==</span> <span class="nx">n</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 将该阶段的堆内存状态快照发布出来（ heap profile）
</span><span class="c1"></span>        <span class="nf">mProf_PostSweep</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>gcWaitOnMark will be called to wait for the completion of the mark-terminate, mark-clear-terminate phase of the previous cycle.</li>
<li>gcStart is called to trigger a new round of GC and gcWaitOnMark is called to wait for the mark termination, mark and clear termination phases of the current loop to complete.</li>
<li>call sweepone to wait for all pending memory management units to be cleared, and then call Gosched to let out P.</li>
<li>calls mProf_PostSweep to post a snapshot of the heap memory state for that phase after completing the current round of garbage collection cleanup.</li>
</ol>
<h3 id="gc-startup">GC startup</h3>
<p>The following diagram is a more complete GC flow and can be used as a navigation when looking at the source code.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/23/ac05eb29d0ec417cb05081d846dd172f.png" alt="sobyte"></p>
<p>The gcStart function is rather long, so here&rsquo;s a look at gcStart in sections.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gcStart</span><span class="p">(</span><span class="nx">trigger</span> <span class="nx">gcTrigger</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="c1">// 验证垃圾收集条件 ,并清理已经被标记的内存单元
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">trigger</span><span class="p">.</span><span class="nf">test</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nf">sweepone</span><span class="p">()</span> <span class="o">!=</span> <span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">sweep</span><span class="p">.</span><span class="nx">nbgsweep</span><span class="o">++</span>
    <span class="p">}</span> 
    <span class="c1">// 获取全局的 startSema信号量
</span><span class="c1"></span>    <span class="nf">semacquire</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">startSema</span><span class="p">)</span> 
    <span class="c1">// 再次验证垃圾收集条件
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">!</span><span class="nx">trigger</span><span class="p">.</span><span class="nf">test</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">startSema</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="c1">// 检查是不是手动调用了 runtime.GC
</span><span class="c1"></span>    <span class="nx">work</span><span class="p">.</span><span class="nx">userForced</span> <span class="p">=</span> <span class="nx">trigger</span><span class="p">.</span><span class="nx">kind</span> <span class="o">==</span> <span class="nx">gcTriggerCycle</span> 

    <span class="nf">semacquire</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcsema</span><span class="p">)</span>
    <span class="nf">semacquire</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">worldsema</span><span class="p">)</span> 
    <span class="c1">// 启动后台标记任务
</span><span class="c1"></span>    <span class="nf">gcBgMarkStartWorkers</span><span class="p">()</span>
    <span class="c1">// 重置标记相关的状态
</span><span class="c1"></span>    <span class="nf">systemstack</span><span class="p">(</span><span class="nx">gcResetMarkState</span><span class="p">)</span>

    <span class="c1">// work 初始化工作
</span><span class="c1"></span>    <span class="nx">work</span><span class="p">.</span><span class="nx">stwprocs</span><span class="p">,</span> <span class="nx">work</span><span class="p">.</span><span class="nx">maxprocs</span> <span class="p">=</span> <span class="nx">gomaxprocs</span><span class="p">,</span> <span class="nx">gomaxprocs</span>
    <span class="k">if</span> <span class="nx">work</span><span class="p">.</span><span class="nx">stwprocs</span> <span class="p">&gt;</span> <span class="nx">ncpu</span> <span class="p">{</span> 
        <span class="nx">work</span><span class="p">.</span><span class="nx">stwprocs</span> <span class="p">=</span> <span class="nx">ncpu</span>
    <span class="p">}</span> 
    <span class="nx">work</span><span class="p">.</span><span class="nx">heap0</span> <span class="p">=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_live</span><span class="p">)</span>
    <span class="nx">work</span><span class="p">.</span><span class="nx">pauseNS</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="nx">work</span><span class="p">.</span><span class="nx">mode</span> <span class="p">=</span> <span class="nx">mode</span> 
    <span class="c1">// 记录开始时间
</span><span class="c1"></span>    <span class="nx">now</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span>
    <span class="nx">work</span><span class="p">.</span><span class="nx">tSweepTerm</span> <span class="p">=</span> <span class="nx">now</span>
    <span class="nx">work</span><span class="p">.</span><span class="nx">pauseStart</span> <span class="p">=</span> <span class="nx">now</span>
    <span class="c1">// 暂停程序 STW
</span><span class="c1"></span>    <span class="nf">systemstack</span><span class="p">(</span><span class="nx">stopTheWorldWithSema</span><span class="p">)</span> 
    <span class="c1">// 在并发标记前，确保清理结束
</span><span class="c1"></span>    <span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">finishsweep_m</span><span class="p">()</span>
    <span class="p">})</span>
    <span class="c1">// 清理sched.sudogcache 以及 sync.Pools
</span><span class="c1"></span>    <span class="nf">clearpools</span><span class="p">()</span>
    <span class="c1">// GC 次数
</span><span class="c1"></span>    <span class="nx">work</span><span class="p">.</span><span class="nx">cycles</span><span class="o">++</span>
    <span class="c1">// 在开始 GC 之前清理控制器的状态,标记新一轮GC已开始
</span><span class="c1"></span>    <span class="nx">gcController</span><span class="p">.</span><span class="nf">startCycle</span><span class="p">()</span>
    <span class="nx">work</span><span class="p">.</span><span class="nx">heapGoal</span> <span class="p">=</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">next_gc</span> 
    <span class="c1">// 设置全局变量中的GC状态为_GCmark
</span><span class="c1"></span>    <span class="c1">// 然后启用写屏障
</span><span class="c1"></span>    <span class="nf">setGCPhase</span><span class="p">(</span><span class="nx">_GCmark</span><span class="p">)</span>
    <span class="c1">// 初始化后台扫描需要的状态
</span><span class="c1"></span>    <span class="nf">gcBgMarkPrepare</span><span class="p">()</span> <span class="c1">// Must happen before assist enable.
</span><span class="c1"></span>    <span class="c1">// 扫描栈上、全局变量等根对象并将它们加入队列
</span><span class="c1"></span>    <span class="nf">gcMarkRootPrepare</span><span class="p">()</span> 
    <span class="c1">// 标记所有tiny alloc等待合并的对象
</span><span class="c1"></span>    <span class="nf">gcMarkTinyAllocs</span><span class="p">()</span> 
    <span class="c1">// 启用 mutator  assists（协助线程）
</span><span class="c1"></span>    <span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcBlackenEnabled</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1">// 记录标记开始的时间
</span><span class="c1"></span>    <span class="nx">gcController</span><span class="p">.</span><span class="nx">markStartTime</span> <span class="p">=</span> <span class="nx">now</span>
    <span class="nx">mp</span> <span class="p">=</span> <span class="nf">acquirem</span><span class="p">()</span>
    <span class="c1">// 启动程序，后台任务也会开始标记堆中的对象
</span><span class="c1"></span>    <span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">now</span> <span class="p">=</span> <span class="nf">startTheWorldWithSema</span><span class="p">(</span><span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span><span class="p">)</span>
        <span class="c1">// 记录停止了多久, 和标记阶段开始的时间
</span><span class="c1"></span>        <span class="nx">work</span><span class="p">.</span><span class="nx">pauseNS</span> <span class="o">+=</span> <span class="nx">now</span> <span class="o">-</span> <span class="nx">work</span><span class="p">.</span><span class="nx">pauseStart</span>
        <span class="nx">work</span><span class="p">.</span><span class="nx">tMark</span> <span class="p">=</span> <span class="nx">now</span>
    <span class="p">})</span> 
    <span class="nf">semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">worldsema</span><span class="p">)</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>two calls to <code>trigger.test</code> to check if the conditions for garbage collection are met, a function we talked about above.</li>
<li>call <code>semacquire(&amp;work.startSema)</code> to lock and <code>gcBgMarkStartWorkers</code> to start the background marker task, which we will focus on later.</li>
<li>initialize the work structure, set the number of Goroutines needed for garbage collection and the number of GCs completed, etc.</li>
<li>call <code>gcController.startCycle</code> to clear the state of the controller and mark the start of a new GC cycle before starting the GC.</li>
<li>call setGCPhase to set the GC state in the global variable to _GCmark, and then enable the write barrier.</li>
<li>call gcBgMarkPrepare to initialize the state needed for the background scan.</li>
<li>call gcMarkRootPrepare to scan the root objects on the stack, global variables, etc. and add them to the queue.</li>
<li>call gcMarkTinyAllocs to mark all tiny alloc memory blocks.</li>
<li>set gcBlackenEnabled to enable mutator assists (assisted threads).</li>
<li>call startTheWorldWithSema to start the program after recording the start time of the marker, and the background task will also start marking objects in the heap.</li>
</ol>
<p>The following diagram shows the state change during gcStart and the method of STW stopping, with the writing barrier enabled period.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/23/0997b37fba8649e0b102af2b5a074fa4.png" alt="sobyte"></p>
<p>The above is just a rough description of the role of each function, the following to analyze some important functions.</p>
<h4 id="startcycle">startCycle</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gcControllerState</span><span class="p">)</span> <span class="nf">startCycle</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">c</span><span class="p">.</span><span class="nx">scanWork</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="nx">c</span><span class="p">.</span><span class="nx">bgScanCredit</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="nx">c</span><span class="p">.</span><span class="nx">assistTime</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="nx">c</span><span class="p">.</span><span class="nx">dedicatedMarkTime</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="nx">c</span><span class="p">.</span><span class="nx">fractionalMarkTime</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="nx">c</span><span class="p">.</span><span class="nx">idleMarkTime</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="c1">// 设置 next_gc 最小值 
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">next_gc</span> <span class="p">&lt;</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_live</span><span class="o">+</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span> <span class="p">{</span>
        <span class="nx">memstats</span><span class="p">.</span><span class="nx">next_gc</span> <span class="p">=</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_live</span> <span class="o">+</span> <span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span>
    <span class="p">}</span>
    <span class="c1">// gcBackgroundUtilization 默认是 0.25
</span><span class="c1"></span>    <span class="c1">// 是GC所占的P的目标值
</span><span class="c1"></span>    <span class="nx">totalUtilizationGoal</span> <span class="o">:=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">gomaxprocs</span><span class="p">)</span> <span class="o">*</span> <span class="nx">gcBackgroundUtilization</span>
    <span class="c1">// dedicatedMarkWorkersNeeded 等于P的数量的25% 加上 0.5 去掉小数点
</span><span class="c1"></span>    <span class="nx">c</span><span class="p">.</span><span class="nx">dedicatedMarkWorkersNeeded</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">totalUtilizationGoal</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span>
    <span class="nx">utilError</span> <span class="o">:=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">dedicatedMarkWorkersNeeded</span><span class="p">)</span><span class="o">/</span><span class="nx">totalUtilizationGoal</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="kd">const</span> <span class="nx">maxUtilError</span> <span class="p">=</span> <span class="mf">0.3</span>
    <span class="k">if</span> <span class="nx">utilError</span> <span class="p">&lt;</span> <span class="o">-</span><span class="nx">maxUtilError</span> <span class="o">||</span> <span class="nx">utilError</span> <span class="p">&gt;</span> <span class="nx">maxUtilError</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">dedicatedMarkWorkersNeeded</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">totalUtilizationGoal</span> <span class="p">{</span>
            <span class="nx">c</span><span class="p">.</span><span class="nx">dedicatedMarkWorkersNeeded</span><span class="o">--</span>
        <span class="p">}</span>
        <span class="c1">// 是 gcMarkWorkerFractionalMode 的任务所占的P的目标值(
</span><span class="c1"></span>        <span class="nx">c</span><span class="p">.</span><span class="nx">fractionalUtilizationGoal</span> <span class="p">=</span> <span class="p">(</span><span class="nx">totalUtilizationGoal</span> <span class="o">-</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">dedicatedMarkWorkersNeeded</span><span class="p">))</span> <span class="o">/</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">gomaxprocs</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">c</span><span class="p">.</span><span class="nx">fractionalUtilizationGoal</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">gcstoptheworld</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">c</span><span class="p">.</span><span class="nx">dedicatedMarkWorkersNeeded</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">gomaxprocs</span><span class="p">)</span>
        <span class="nx">c</span><span class="p">.</span><span class="nx">fractionalUtilizationGoal</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allp</span> <span class="p">{</span>
        <span class="nx">p</span><span class="p">.</span><span class="nx">gcAssistTime</span> <span class="p">=</span> <span class="mi">0</span>
        <span class="nx">p</span><span class="p">.</span><span class="nx">gcFractionalMarkTime</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="p">}</span>
    <span class="c1">// 计算协助GC的参数
</span><span class="c1"></span>    <span class="nx">c</span><span class="p">.</span><span class="nf">revise</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Note here the process of calculating dedicatedMarkWorkersNeeded and fractionalUtilizationGoal, which will be used in the calculation of work work patterns.</p>
<h4 id="marks-tiny-alloc">marks tiny alloc</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gcMarkTinyAllocs</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allp</span> <span class="p">{</span>
        <span class="c1">// 标记各个 P 中的 mcache 中的 tiny
</span><span class="c1"></span>        <span class="nx">c</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">mcache</span>
        <span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">c</span><span class="p">.</span><span class="nx">tiny</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">continue</span>
        <span class="p">}</span>
        <span class="nx">_</span><span class="p">,</span> <span class="nx">span</span><span class="p">,</span> <span class="nx">objIndex</span> <span class="o">:=</span> <span class="nf">findObject</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">tiny</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="nx">gcw</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">p</span><span class="p">.</span><span class="nx">gcw</span>
        <span class="c1">// 标记存活对象，并把它加到 gcwork 标记队列
</span><span class="c1"></span>        <span class="nf">greyobject</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">tiny</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">span</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">,</span> <span class="nx">objIndex</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The tiny block data structure is also talked about in the section on memory allocation. Here we will mainly find and mark the tiny in the mcache of all the P&rsquo;s and add it to the gcwork marker queue, as for what is the gcwork marker queue, we will talk about it below in the section on performing markers.</p>
<h4 id="write-barrier-write-barrier">write Barrier Write Barrier</h4>
<p>When setting the GC stage marker, it will determine if the write barrier needs to be turned on based on the currently set value.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">setGCPhase</span><span class="p">(</span><span class="nx">x</span> <span class="kt">uint32</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcphase</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span>
    <span class="nx">writeBarrier</span><span class="p">.</span><span class="nx">needed</span> <span class="p">=</span> <span class="nx">gcphase</span> <span class="o">==</span> <span class="nx">_GCmark</span> <span class="o">||</span> <span class="nx">gcphase</span> <span class="o">==</span> <span class="nx">_GCmarktermination</span>
    <span class="nx">writeBarrier</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">=</span> <span class="nx">writeBarrier</span><span class="p">.</span><span class="nx">needed</span> <span class="o">||</span> <span class="nx">writeBarrier</span><span class="p">.</span><span class="nx">cgo</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The compiler will call the writebarrier function in <code>src\cmd\compile\internal\ssa\writebarrier.go</code>, just as its comment says.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// writebarrier pass inserts write barriers for store ops (Store, Move, Zero)
</span><span class="c1">// when necessary (the condition above). It rewrites store ops to branches
</span><span class="c1">// and runtime calls, like
</span><span class="c1">//
</span><span class="c1">// if writeBarrier.enabled {
</span><span class="c1">// gcWriteBarrier(ptr, val) // Not a regular Go call
</span><span class="c1">// } else {
</span><span class="c1">// *ptr = val
</span><span class="c1">// }
</span></code></pre></td></tr></table>
</div>
</div><p>Add a write barrier to the execution of Store, Move, Zero, etc. assembly operations.</p>
<p>We can find the location of the gcWriteBarrier assembly code in <code>go/src/runtime/asm_amd64.s:1395</code> via the dlv breakpoint. This assembly function calls <code>runtime.wbBufFlush</code> to add the write barrier&rsquo;s cache tasks to the GC&rsquo;s work queue for processing.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">wbBufFlush</span><span class="p">(</span><span class="nx">dst</span> <span class="o">*</span><span class="kt">uintptr</span><span class="p">,</span> <span class="nx">src</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="o">...</span>
        <span class="nf">wbBufFlush1</span><span class="p">(</span><span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>
    <span class="p">})</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">wbBufFlush1</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 获取缓存的指针
</span><span class="c1"></span>    <span class="nx">start</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">wbBuf</span><span class="p">.</span><span class="nx">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="nx">n</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">wbBuf</span><span class="p">.</span><span class="nx">next</span> <span class="o">-</span> <span class="nx">start</span><span class="p">)</span> <span class="o">/</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">wbBuf</span><span class="p">.</span><span class="nx">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="nx">ptrs</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">wbBuf</span><span class="p">.</span><span class="nx">buf</span><span class="p">[:</span><span class="nx">n</span><span class="p">]</span>

    <span class="nx">_p_</span><span class="p">.</span><span class="nx">wbBuf</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="mi">0</span>

    <span class="nx">gcw</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">gcw</span>
    <span class="nx">pos</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ptr</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ptrs</span> <span class="p">{</span>
        <span class="c1">// 查找到对象
</span><span class="c1"></span>        <span class="nx">obj</span><span class="p">,</span> <span class="nx">span</span><span class="p">,</span> <span class="nx">objIndex</span> <span class="o">:=</span> <span class="nf">findObject</span><span class="p">(</span><span class="nx">ptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">obj</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">continue</span>
        <span class="p">}</span> 
        <span class="nx">mbits</span> <span class="o">:=</span> <span class="nx">span</span><span class="p">.</span><span class="nf">markBitsForIndex</span><span class="p">(</span><span class="nx">objIndex</span><span class="p">)</span>
        <span class="c1">// 判断是否已被标记
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">mbits</span><span class="p">.</span><span class="nf">isMarked</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">continue</span>
        <span class="p">}</span>
        <span class="c1">// 进行标记
</span><span class="c1"></span>        <span class="nx">mbits</span><span class="p">.</span><span class="nf">setMarked</span><span class="p">()</span>

        <span class="c1">// 标记 span.
</span><span class="c1"></span>        <span class="nx">arena</span><span class="p">,</span> <span class="nx">pageIdx</span><span class="p">,</span> <span class="nx">pageMask</span> <span class="o">:=</span> <span class="nf">pageIndexOf</span><span class="p">(</span><span class="nx">span</span><span class="p">.</span><span class="nf">base</span><span class="p">())</span>
        <span class="k">if</span> <span class="nx">arena</span><span class="p">.</span><span class="nx">pageMarks</span><span class="p">[</span><span class="nx">pageIdx</span><span class="p">]</span><span class="o">&amp;</span><span class="nx">pageMask</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nx">atomic</span><span class="p">.</span><span class="nf">Or8</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">arena</span><span class="p">.</span><span class="nx">pageMarks</span><span class="p">[</span><span class="nx">pageIdx</span><span class="p">],</span> <span class="nx">pageMask</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="nx">span</span><span class="p">.</span><span class="nx">spanclass</span><span class="p">.</span><span class="nf">noscan</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">gcw</span><span class="p">.</span><span class="nx">bytesMarked</span> <span class="o">+=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">span</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="p">}</span>
        <span class="nx">ptrs</span><span class="p">[</span><span class="nx">pos</span><span class="p">]</span> <span class="p">=</span> <span class="nx">obj</span>
        <span class="nx">pos</span><span class="o">++</span>
    <span class="p">}</span>

    <span class="c1">// 将对象加入到 gcWork队列中
</span><span class="c1"></span>    <span class="nx">gcw</span><span class="p">.</span><span class="nf">putBatch</span><span class="p">(</span><span class="nx">ptrs</span><span class="p">[:</span><span class="nx">pos</span><span class="p">])</span> 
    <span class="c1">// 重置 write barrier 缓存
</span><span class="c1"></span>    <span class="nx">_p_</span><span class="p">.</span><span class="nx">wbBuf</span><span class="p">.</span><span class="nf">reset</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The write barrier is actually the same as the concurrency marker, so you can read the concurrency marker and come back to it. wbBufFlush1 iterates through the write barrier cache, then calls findObject to find the object and mark it with a flag bit, and finally adds the object to the gcWork queue for scanning and resets the write barrier cache.</p>
<h4 id="stoptheworldwithsema-and-starttheworldwithsema">stopTheWorldWithSema and startTheWorldWithSema</h4>
<p>stopTheWorldWithSema and startTheWorldWithSema are a pair of core functions used to pause and resume programs.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">stopTheWorldWithSema</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span> 

    <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
    <span class="nx">sched</span><span class="p">.</span><span class="nx">stopwait</span> <span class="p">=</span> <span class="nx">gomaxprocs</span>
    <span class="c1">// 标记 gcwaiting，调度时看见此标记会进入等待
</span><span class="c1"></span>    <span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1">// 发送抢占信号
</span><span class="c1"></span>    <span class="nf">preemptall</span><span class="p">()</span> 
    <span class="c1">// 暂停当前 P
</span><span class="c1"></span>    <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Pgcstop</span> <span class="c1">// Pgcstop is only diagnostic.
</span><span class="c1"></span>    <span class="nx">sched</span><span class="p">.</span><span class="nx">stopwait</span><span class="o">--</span>
    <span class="c1">// 遍历所有的 P ，修改 P 的状态为 _Pgcstop 停止运行
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allp</span> <span class="p">{</span>
        <span class="nx">s</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">status</span>
        <span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="nx">_Psyscall</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">_Pgcstop</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
                <span class="nf">traceGoSysBlock</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
                <span class="nf">traceProcStop</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="nx">p</span><span class="p">.</span><span class="nx">syscalltick</span><span class="o">++</span>
            <span class="nx">sched</span><span class="p">.</span><span class="nx">stopwait</span><span class="o">--</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 停止空闲的 P 列表
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">{</span>
        <span class="nx">p</span> <span class="o">:=</span> <span class="nf">pidleget</span><span class="p">()</span>
        <span class="k">if</span> <span class="nx">p</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">break</span>
        <span class="p">}</span>
        <span class="nx">p</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Pgcstop</span>
        <span class="nx">sched</span><span class="p">.</span><span class="nx">stopwait</span><span class="o">--</span>
    <span class="p">}</span>
    <span class="nx">wait</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">stopwait</span> <span class="p">&gt;</span> <span class="mi">0</span>
    <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">wait</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">{</span>
            <span class="c1">//  等待 100 us
</span><span class="c1"></span>            <span class="k">if</span> <span class="nf">notetsleep</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">stopnote</span><span class="p">,</span> <span class="mi">100</span><span class="o">*</span><span class="mi">1000</span><span class="p">)</span> <span class="p">{</span>
                <span class="nf">noteclear</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">stopnote</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="p">}</span>
            <span class="c1">// 再次进行发送抢占信号
</span><span class="c1"></span>            <span class="nf">preemptall</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 安全检测
</span><span class="c1"></span>    <span class="nx">bad</span> <span class="o">:=</span> <span class="s">&#34;&#34;</span>
    <span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">stopwait</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">bad</span> <span class="p">=</span> <span class="s">&#34;stopTheWorld: not stopped (stopwait != 0)&#34;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allp</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">status</span> <span class="o">!=</span> <span class="nx">_Pgcstop</span> <span class="p">{</span>
                <span class="nx">bad</span> <span class="p">=</span> <span class="s">&#34;stopTheWorld: not stopped (status != _Pgcstop)&#34;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">freezing</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">deadlock</span><span class="p">)</span>
        <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">deadlock</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">bad</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
        <span class="nf">throw</span><span class="p">(</span><span class="nx">bad</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>This method will check if all P&rsquo;s have been suspended by calling <code>sched.stopwait</code>. First, it sends a preempt signal to preempt all running Gs by calling preemptall, then it goes through the P&rsquo;s and suspends all idle P&rsquo;s with status _Psyscall, and waits for them to stop if there are still P&rsquo;s that need to be stopped.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">startTheWorldWithSema</span><span class="p">(</span><span class="nx">emitTraceEvent</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">int64</span> <span class="p">{</span>
    <span class="nx">mp</span> <span class="o">:=</span> <span class="nf">acquirem</span><span class="p">()</span> <span class="c1">// disable preemption because it can be holding p in a local var
</span><span class="c1"></span>    <span class="c1">// 判断收到的 netpoll 事件并添加对应的G到待运行队列
</span><span class="c1"></span>    <span class="k">if</span> <span class="nf">netpollinited</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">list</span> <span class="o">:=</span> <span class="nf">netpoll</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// non-blocking
</span><span class="c1"></span>        <span class="nf">injectglist</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">list</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

    <span class="nx">procs</span> <span class="o">:=</span> <span class="nx">gomaxprocs</span>
    <span class="k">if</span> <span class="nx">newprocs</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">procs</span> <span class="p">=</span> <span class="nx">newprocs</span>
        <span class="nx">newprocs</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="p">}</span>
  <span class="c1">// 扩容或者缩容全局的处理器
</span><span class="c1"></span>    <span class="nx">p1</span> <span class="o">:=</span> <span class="nf">procresize</span><span class="p">(</span><span class="nx">procs</span><span class="p">)</span>
    <span class="c1">// 取消GC等待标记
</span><span class="c1"></span>    <span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="c1">// 如果 sysmon （后台监控线程） 在等待则唤醒它
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonwait</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonwait</span> <span class="p">=</span> <span class="mi">0</span>
        <span class="nf">notewakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sysmonnote</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
    <span class="c1">// 唤醒有可运行任务的P
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">p1</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">p</span> <span class="o">:=</span> <span class="nx">p1</span>
        <span class="nx">p1</span> <span class="p">=</span> <span class="nx">p1</span><span class="p">.</span><span class="nx">link</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
        <span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">m</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nx">mp</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
            <span class="nx">p</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">nextp</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;startTheWorld: inconsistent mp-&gt;nextp&#34;</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="nx">mp</span><span class="p">.</span><span class="nx">nextp</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
            <span class="nf">notewakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mp</span><span class="p">.</span><span class="nx">park</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// Start M to run P 
</span><span class="c1"></span>            <span class="nf">newm</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="nx">p</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span> 
    <span class="nx">startTime</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">emitTraceEvent</span> <span class="p">{</span>
        <span class="nf">traceGCSTWDone</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="c1">// 如果有空闲的P，并且没有自旋中的M则唤醒或者创建一个M
</span><span class="c1"></span>    <span class="nf">wakep</span><span class="p">()</span> 
    <span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span> 
    <span class="k">return</span> <span class="nx">startTime</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>startTheWorldWithSema is much simpler, first fetching the pending task from the netpoller and adding it to the global queue; then traversing the P chain to wake up the P with a runnable task.</p>
<h3 id="create-a-background-tag-worker">Create a background tag worker</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gcBgMarkStartWorkers</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 遍历所有 P
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allp</span> <span class="p">{</span>
        <span class="c1">// 如果已启动则不重复启动
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">gcBgMarkWorker</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="c1">// 为全局每个处理器创建用于执行后台标记任务的 Goroutine
</span><span class="c1"></span>            <span class="k">go</span> <span class="nf">gcBgMarkWorker</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
            <span class="c1">// 启动后等待该任务通知信号量 bgMarkReady 再继续
</span><span class="c1"></span>            <span class="nf">notetsleepg</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">bgMarkReady</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="nf">noteclear</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">bgMarkReady</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>gcBgMarkStartWorkers creates a Goroutine for each P globally to perform background marker tasks. Each Goroutine runs gcBgMarkWorker, and notetsleepg waits for gcBgMarkWorker to notify the semaphore bgMarkReady before continuing.</p>
<p>Here, although a background marker task is started for each P, only 25% of them can work at the same time. The scheduler controls this by calling the <code>gcController.findRunnableGCWorker</code> method in the scheduling loop <code>runtime.schedule</code>.</p>
<p>Before we look at this method, let&rsquo;s understand a concept, Mark Worker Mode There are currently three types of Mark Worker Modes, which are designed to ensure the utilization of the marker threads in the background.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">gcMarkWorkerMode</span> <span class="kt">int</span>

<span class="kd">const</span> <span class="p">(</span>
    <span class="c1">// gcMarkWorkerDedicatedMode indicates that the P of a mark
</span><span class="c1"></span>    <span class="c1">// worker is dedicated to running that mark worker. The mark
</span><span class="c1"></span>    <span class="c1">// worker should run without preemption.
</span><span class="c1"></span>    <span class="nx">gcMarkWorkerDedicatedMode</span> <span class="nx">gcMarkWorkerMode</span> <span class="p">=</span> <span class="kc">iota</span>

    <span class="c1">// gcMarkWorkerFractionalMode indicates that a P is currently
</span><span class="c1"></span>    <span class="c1">// running the &#34;fractional&#34; mark worker. The fractional worker
</span><span class="c1"></span>    <span class="c1">// is necessary when GOMAXPROCS*gcBackgroundUtilization is not
</span><span class="c1"></span>    <span class="c1">// an integer. The fractional worker should run until it is
</span><span class="c1"></span>    <span class="c1">// preempted and will be scheduled to pick up the fractional
</span><span class="c1"></span>    <span class="c1">// part of GOMAXPROCS*gcBackgroundUtilization.
</span><span class="c1"></span>    <span class="nx">gcMarkWorkerFractionalMode</span>

    <span class="c1">// gcMarkWorkerIdleMode indicates that a P is running the mark
</span><span class="c1"></span>    <span class="c1">// worker because it has nothing else to do. The idle worker
</span><span class="c1"></span>    <span class="c1">// should run until it is preempted and account its time
</span><span class="c1"></span>    <span class="c1">// against gcController.idleMarkTime.
</span><span class="c1"></span>    <span class="nx">gcMarkWorkerIdleMode</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>From the code comments you can know that.</p>
<ul>
<li>gcMarkWorkerDedicatedMode : P is exclusively responsible for marking objects that will not be preempted by the scheduler.</li>
<li>gcMarkWorkerFractionalMode : mainly because now the default marker thread occupancy to be 25%, so if the number of CPU cores is not a multiple of 4, it can not divide the integer, start this type of work mode to help garbage collection to achieve the goal of utilization.</li>
<li>gcMarkWorkerIdleMode: indicates that P currently has only the marker thread running and no other G that can be executed, it will run the marker task of garbage collection until it is preempted.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gcControllerState</span><span class="p">)</span> <span class="nf">findRunnableGCWorker</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="o">*</span><span class="nx">g</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="c1">// 原子减少对应的值, 如果减少后大于等于0则返回true, 否则返回false
</span><span class="c1"></span>    <span class="nx">decIfPositive</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ptr</span> <span class="o">*</span><span class="kt">int64</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
        <span class="k">if</span> <span class="o">*</span><span class="nx">ptr</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="nx">ptr</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="k">return</span> <span class="kc">true</span>
            <span class="p">}</span>
            <span class="c1">// We lost a race
</span><span class="c1"></span>            <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="nx">ptr</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>
    <span class="c1">// 减少dedicatedMarkWorkersNeeded, 成功时后台标记任务的模式是Dedicated
</span><span class="c1"></span>    <span class="k">if</span> <span class="nf">decIfPositive</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">dedicatedMarkWorkersNeeded</span><span class="p">)</span> <span class="p">{</span> 
        <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcMarkWorkerMode</span> <span class="p">=</span> <span class="nx">gcMarkWorkerDedicatedMode</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">fractionalUtilizationGoal</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="c1">// No need for fractional workers.
</span><span class="c1"></span>        <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// 执行标记任务的时间
</span><span class="c1"></span>        <span class="nx">delta</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span> <span class="o">-</span> <span class="nx">gcController</span><span class="p">.</span><span class="nx">markStartTime</span> 
        <span class="k">if</span> <span class="nx">delta</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">gcFractionalMarkTime</span><span class="p">)</span><span class="o">/</span><span class="nb">float64</span><span class="p">(</span><span class="nx">delta</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">fractionalUtilizationGoal</span> <span class="p">{</span>
            <span class="c1">// Nope. No need to run a fractional worker.
</span><span class="c1"></span>            <span class="k">return</span> <span class="kc">nil</span>
        <span class="p">}</span>
        <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcMarkWorkerMode</span> <span class="p">=</span> <span class="nx">gcMarkWorkerFractionalMode</span>
    <span class="p">}</span>

    <span class="nx">gp</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcBgMarkWorker</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
    <span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span> 
    <span class="k">return</span> <span class="nx">gp</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>In findRunnableGCWorker, the Mark Worker Mode of gcMarkWorkerDedicatedMode is used to determine if the Mark Worker Mode of gcMarkWorkerDedicatedMode is used. dedicatedMarkWorkersNeeded is initialized in <code>gcControllerState.startCycle</code>.</p>
<p>I won&rsquo;t write the formula, it&rsquo;s already mentioned in <code>gcControllerState.startCycle</code>, in layman&rsquo;s terms if the current CPU is 8 cores, then dedicatedMarkWorkersNeeded is 2, if it&rsquo;s 6 cores, because it can&rsquo;t be divided by 4, the calculation is dedicatedMarkWorkersNeeded is 1, so the above gcMarkWorkerFractionalMode is needed to ensure CPU utilization.</p>
<p>gcMarkWorkerIdleMode is called when the scheduler executes a findrunnable preemption: gcMarkWorkerIdleMode is called when the scheduler executes a findrunnable preemption.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">findrunnable</span><span class="p">()</span> <span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">inheritTime</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">...</span>
<span class="nx">stop</span><span class="p">:</span>
    <span class="c1">// 处于 GC 阶段的话，获取执行GC标记任务的G
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">gcBlackenEnabled</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcBgMarkWorker</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nf">gcMarkWorkAvailable</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcMarkWorkerMode</span> <span class="p">=</span> <span class="nx">gcMarkWorkerIdleMode</span>
        <span class="nx">gp</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcBgMarkWorker</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
        <span class="c1">//将本地 P 的 GC 标记专用 G 职位 Grunnable
</span><span class="c1"></span>        <span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span> 
        <span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span>
    <span class="p">}</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>When the preemption scheduling runs here, usually P can&rsquo;t preempt G anymore and wants to hibernate, so it is safe to perform the marker task before hibernating.</p>
<h3 id="concurrent-scan-markers">Concurrent scan markers</h3>
<p>The concurrent scan marker can be roughly summarized as follows.</p>
<ol>
<li>wrapping the current incoming P into parkInfo, then calling gopark to put the current G into hibernation, before hibernating it will bind the P&rsquo;s gcBgMarkWorker to the G and wait for it to wake up.</li>
<li>calling gcDrain to execute the marker with different policies according to Mark Worker Mode.</li>
<li>determine if all background marker tasks are completed, and if there are no more tasks, call gcMarkDone to prepare for the completion of the marker phase.</li>
</ol>
<h4 id="background-marking-hibernation-waiting">Background Marking Hibernation Waiting</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gcBgMarkWorker</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

    <span class="kd">type</span> <span class="nx">parkInfo</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">m</span>      <span class="nx">muintptr</span>  
        <span class="nx">attach</span> <span class="nx">puintptr</span>  
    <span class="p">}</span>  
    <span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">preemptoff</span> <span class="p">=</span> <span class="s">&#34;GC worker init&#34;</span>
    <span class="c1">// 初始化 park
</span><span class="c1"></span>    <span class="nx">park</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">parkInfo</span><span class="p">)</span>
    <span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">preemptoff</span> <span class="p">=</span> <span class="s">&#34;&#34;</span>
    <span class="c1">// 设置当前的M并禁止抢占
</span><span class="c1"></span>    <span class="nx">park</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nf">acquirem</span><span class="p">())</span>
    <span class="c1">// 设置当前的P
</span><span class="c1"></span>    <span class="nx">park</span><span class="p">.</span><span class="nx">attach</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> 
    <span class="c1">// 通知gcBgMarkStartWorkers可以继续处理
</span><span class="c1"></span>    <span class="nf">notewakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">bgMarkReady</span><span class="p">)</span>

    <span class="k">for</span> <span class="p">{</span> 
        <span class="c1">// 让当前 G 进入休眠
</span><span class="c1"></span>        <span class="nf">gopark</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">g</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">parkp</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
            <span class="nx">park</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">parkInfo</span><span class="p">)(</span><span class="nx">parkp</span><span class="p">)</span>

            <span class="nf">releasem</span><span class="p">(</span><span class="nx">park</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span> 
            <span class="c1">// 设置关联的 P
</span><span class="c1"></span>            <span class="k">if</span> <span class="nx">park</span><span class="p">.</span><span class="nx">attach</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="nx">p</span> <span class="o">:=</span> <span class="nx">park</span><span class="p">.</span><span class="nx">attach</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
                <span class="nx">park</span><span class="p">.</span><span class="nx">attach</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span> 
                <span class="c1">// 把当前的G设到P的gcBgMarkWorker成员
</span><span class="c1"></span>                <span class="k">if</span> <span class="p">!</span><span class="nx">p</span><span class="p">.</span><span class="nx">gcBgMarkWorker</span><span class="p">.</span><span class="nf">cas</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">guintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">g</span><span class="p">)))</span> <span class="p">{</span> 
                    <span class="k">return</span> <span class="kc">false</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="kc">true</span>
        <span class="p">},</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">park</span><span class="p">),</span> <span class="nx">waitReasonGCWorkerIdle</span><span class="p">,</span> <span class="nx">traceEvGoBlock</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="o">...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>In gcBgMarkStartWorkers we see that it will iterate through all the P&rsquo;s and then create a G responsible for Mark Work for each P. Although a background marker task is started for each P, it is not possible for each P to perform the marker task, the default resource usage of the background marker task is 25%, so the gcBgMarkWorker initializes the park and binds the G to the P&rsquo;s gcBgMarkWorker and then hibernates it.</p>
<p>The scheduler controls which Mark Work can be executed by calling the <code>gcController.findRunnableGCWorker</code> method in the scheduling loop <code>runtime.schedule</code>, the code above has already been posted, so I won&rsquo;t repeat it here.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/23/af771a02e65f448ea1219b7b2d3ec2de.png" alt="sobyte"></p>
<h4 id="background-markers">Background markers</h4>
<p>After waking up, we will choose a different marker execution strategy based on gcMarkWorkerMode, and different execution strategies will call <code>runtime.gcDrain</code> :</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gcBgMarkWorker</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
    <span class="o">...</span>
    <span class="k">for</span> <span class="p">{</span> 
        <span class="o">...</span>
        <span class="c1">// 检查P的gcBgMarkWorker是否和当前的G一致, 不一致时结束当前的任务
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcBgMarkWorker</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">gp</span> <span class="p">{</span>
            <span class="k">break</span>
        <span class="p">}</span>
        <span class="c1">// 禁止G被抢占
</span><span class="c1"></span>        <span class="nx">park</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nf">acquirem</span><span class="p">())</span>

        <span class="c1">// 记录开始时间
</span><span class="c1"></span>        <span class="nx">startTime</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span>
        <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcMarkWorkerStartTime</span> <span class="p">=</span> <span class="nx">startTime</span>

        <span class="nx">decnwait</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">nwait</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span> 
            <span class="c1">// 设置G的状态为等待中这样它的栈可以被扫描
</span><span class="c1"></span>            <span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">)</span>
            <span class="c1">// 判断后台标记任务的模式
</span><span class="c1"></span>            <span class="k">switch</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcMarkWorkerMode</span> <span class="p">{</span>
            <span class="k">default</span><span class="p">:</span>
                <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;gcBgMarkWorker: unexpected gcMarkWorkerMode&#34;</span><span class="p">)</span>
            <span class="k">case</span> <span class="nx">gcMarkWorkerDedicatedMode</span><span class="p">:</span>
                <span class="c1">// 这个模式下P应该专心执行标记
</span><span class="c1"></span>                <span class="nf">gcDrain</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">gcw</span><span class="p">,</span> <span class="nx">gcDrainUntilPreempt</span><span class="p">|</span><span class="nx">gcDrainFlushBgCredit</span><span class="p">)</span>
                <span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">preempt</span> <span class="p">{</span> 
                    <span class="c1">// 被抢占时把本地运行队列中的所有G都踢到全局运行队列
</span><span class="c1"></span>                    <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
                    <span class="k">for</span> <span class="p">{</span>
                        <span class="nx">gp</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nf">runqget</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
                            <span class="k">break</span>
                        <span class="p">}</span>
                        <span class="nf">globrunqput</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
                    <span class="p">}</span>
                    <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
                <span class="p">}</span>
                <span class="c1">// 继续执行标记
</span><span class="c1"></span>                <span class="nf">gcDrain</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">gcw</span><span class="p">,</span> <span class="nx">gcDrainFlushBgCredit</span><span class="p">)</span>
            <span class="k">case</span> <span class="nx">gcMarkWorkerFractionalMode</span><span class="p">:</span>
                <span class="c1">// 执行标记
</span><span class="c1"></span>                <span class="nf">gcDrain</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">gcw</span><span class="p">,</span> <span class="nx">gcDrainFractional</span><span class="p">|</span><span class="nx">gcDrainUntilPreempt</span><span class="p">|</span><span class="nx">gcDrainFlushBgCredit</span><span class="p">)</span>
            <span class="k">case</span> <span class="nx">gcMarkWorkerIdleMode</span><span class="p">:</span>
                <span class="c1">// 执行标记, 直到被抢占或者达到一定的量
</span><span class="c1"></span>                <span class="nf">gcDrain</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">gcw</span><span class="p">,</span> <span class="nx">gcDrainIdle</span><span class="p">|</span><span class="nx">gcDrainUntilPreempt</span><span class="p">|</span><span class="nx">gcDrainFlushBgCredit</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="c1">// 恢复G的状态到运行中
</span><span class="c1"></span>            <span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">)</span>
        <span class="p">})</span> 
        <span class="o">...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The difference between the different Mark Worker Modes has been described above, so if you don&rsquo;t remember, you can turn up the page. The main part of the marker execution is in the switch judgment, where different parameters are passed into the gcDrain function according to the different modes.</p>
<p>Note that what is passed into gcDrain is a gcWork structure, which is equivalent to a private cache space for each P that holds the objects to be scanned, providing an abstraction for the garbage collector to produce and consume tasks, and which holds two important work buffers <code>wbuf1</code> and <code>wbuf2</code>: <code>wbuf1</code> and <code>wbuf2</code>.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/23/5c709eac0a1347aeaf30fc7c5b70b3ba.png" alt="sobyte"></p>
<p>When we add or remove objects to this structure, it always operates the <code>wbuf1</code> buffer first, and triggers a buffer switch once the <code>wbuf1</code> buffer runs out of space or is empty. And when both buffers are running low or empty, it will insert or fetch objects from the global working buffer.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">gcWork</span><span class="p">)</span> <span class="nf">tryGet</span><span class="p">()</span> <span class="kt">uintptr</span> <span class="p">{</span>
    <span class="nx">wbuf</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.</span><span class="nx">wbuf1</span>
    <span class="o">...</span>
    <span class="c1">// wbuf1缓冲区无数据时
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">wbuf</span><span class="p">.</span><span class="nx">nobj</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="c1">// wbuf1 与 wbuf2 进行对象互换
</span><span class="c1"></span>        <span class="nx">w</span><span class="p">.</span><span class="nx">wbuf1</span><span class="p">,</span> <span class="nx">w</span><span class="p">.</span><span class="nx">wbuf2</span> <span class="p">=</span> <span class="nx">w</span><span class="p">.</span><span class="nx">wbuf2</span><span class="p">,</span> <span class="nx">w</span><span class="p">.</span><span class="nx">wbuf1</span>
        <span class="nx">wbuf</span> <span class="p">=</span> <span class="nx">w</span><span class="p">.</span><span class="nx">wbuf1</span>
        <span class="k">if</span> <span class="nx">wbuf</span><span class="p">.</span><span class="nx">nobj</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nx">owbuf</span> <span class="o">:=</span> <span class="nx">wbuf</span>
            <span class="c1">// 从 work 的 full 队列中获取
</span><span class="c1"></span>            <span class="nx">wbuf</span> <span class="p">=</span> <span class="nf">trygetfull</span><span class="p">()</span>
            <span class="o">...</span>
        <span class="p">}</span>
    <span class="p">}</span> 
    <span class="nx">wbuf</span><span class="p">.</span><span class="nx">nobj</span><span class="o">--</span>
    <span class="k">return</span> <span class="nx">wbuf</span><span class="p">.</span><span class="nx">obj</span><span class="p">[</span><span class="nx">wbuf</span><span class="p">.</span><span class="nx">nobj</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Continuing with the gcBgMarkWorker method above, you have to perform mark completion after marking.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gcBgMarkWorker</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
    <span class="o">...</span>
    <span class="k">for</span> <span class="p">{</span> 
        <span class="o">...</span>  
        <span class="c1">// 累加所用时间
</span><span class="c1"></span>        <span class="nx">duration</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span> <span class="o">-</span> <span class="nx">startTime</span>
        <span class="k">switch</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcMarkWorkerMode</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nx">gcMarkWorkerDedicatedMode</span><span class="p">:</span>
            <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">dedicatedMarkTime</span><span class="p">,</span> <span class="nx">duration</span><span class="p">)</span>
            <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">dedicatedMarkWorkersNeeded</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">case</span> <span class="nx">gcMarkWorkerFractionalMode</span><span class="p">:</span>
            <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">fractionalMarkTime</span><span class="p">,</span> <span class="nx">duration</span><span class="p">)</span>
            <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">gcFractionalMarkTime</span><span class="p">,</span> <span class="nx">duration</span><span class="p">)</span>
        <span class="k">case</span> <span class="nx">gcMarkWorkerIdleMode</span><span class="p">:</span>
            <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">idleMarkTime</span><span class="p">,</span> <span class="nx">duration</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="nx">incnwait</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">nwait</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1">// 判断是否所有后台标记任务都完成, 并且没有更多的任务
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">incnwait</span> <span class="o">==</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nproc</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nf">gcMarkWorkAvailable</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span> <span class="p">{</span> 
            <span class="c1">// 取消和P的关联
</span><span class="c1"></span>            <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcBgMarkWorker</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span>
            <span class="c1">// 允许G被抢占
</span><span class="c1"></span>            <span class="nf">releasem</span><span class="p">(</span><span class="nx">park</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>
            <span class="c1">// 准备进入完成标记阶段
</span><span class="c1"></span>            <span class="nf">gcMarkDone</span><span class="p">()</span>

            <span class="c1">// 休眠之前会重新关联P
</span><span class="c1"></span>            <span class="c1">// 因为上面允许被抢占, 到这里的时候可能就会变成其他P
</span><span class="c1"></span>            <span class="c1">// 如果重新关联P失败则这个任务会结束
</span><span class="c1"></span>            <span class="nx">park</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nf">acquirem</span><span class="p">())</span>
            <span class="nx">park</span><span class="p">.</span><span class="nx">attach</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>gcBgMarkWorker checks if it is the last worker based on incnwait, then calls the gcMarkWorkAvailable function to verify that all gcwork tasks and global tasks have been processed, and if both are confirmed to be OK, then calls gcMarkDone to enter the completion marking phase.</p>
<h4 id="marker-scanning">Marker Scanning</h4>
<p>Let&rsquo;s take a look at gcDrain.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gcDrain</span><span class="p">(</span><span class="nx">gcw</span> <span class="o">*</span><span class="nx">gcWork</span><span class="p">,</span> <span class="nx">flags</span> <span class="nx">gcDrainFlags</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span>
    <span class="c1">// 看到抢占标志时是否要返回
</span><span class="c1"></span>    <span class="nx">preemptible</span> <span class="o">:=</span> <span class="nx">flags</span><span class="o">&amp;</span><span class="nx">gcDrainUntilPreempt</span> <span class="o">!=</span> <span class="mi">0</span>
    <span class="c1">// 是否计算后台的扫描量来减少协助线程和唤醒等待中的G
</span><span class="c1"></span>    <span class="nx">flushBgCredit</span> <span class="o">:=</span> <span class="nx">flags</span><span class="o">&amp;</span><span class="nx">gcDrainFlushBgCredit</span> <span class="o">!=</span> <span class="mi">0</span>
    <span class="c1">// 是否只执行一定量的工作
</span><span class="c1"></span>    <span class="nx">idle</span> <span class="o">:=</span> <span class="nx">flags</span><span class="o">&amp;</span><span class="nx">gcDrainIdle</span> <span class="o">!=</span> <span class="mi">0</span>
    <span class="c1">// 记录初始的已扫描数量
</span><span class="c1"></span>    <span class="nx">initScanWork</span> <span class="o">:=</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span>

    <span class="nx">checkWork</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">63</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="kd">var</span> <span class="nx">check</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">bool</span>
    <span class="k">if</span> <span class="nx">flags</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">gcDrainIdle</span><span class="p">|</span><span class="nx">gcDrainFractional</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="c1">// drainCheckThreshold 默认 100000
</span><span class="c1"></span>        <span class="nx">checkWork</span> <span class="p">=</span> <span class="nx">initScanWork</span> <span class="o">+</span> <span class="nx">drainCheckThreshold</span>
        <span class="k">if</span> <span class="nx">idle</span> <span class="p">{</span>
            <span class="nx">check</span> <span class="p">=</span> <span class="nx">pollWork</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">flags</span><span class="o">&amp;</span><span class="nx">gcDrainFractional</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nx">check</span> <span class="p">=</span> <span class="nx">pollFractionalWorkerExit</span>
        <span class="p">}</span>
    <span class="p">}</span> 
    <span class="c1">// 如果根对象未扫描完, 则先扫描根对象
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">work</span><span class="p">.</span><span class="nx">markrootNext</span> <span class="p">&lt;</span> <span class="nx">work</span><span class="p">.</span><span class="nx">markrootJobs</span> <span class="p">{</span>
        <span class="c1">// 一直循环直到被抢占或 STW
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">!(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">preempt</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">preemptible</span> <span class="o">||</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
            <span class="c1">// 从根对象扫描队列取出一个值
</span><span class="c1"></span>            <span class="nx">job</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">markrootNext</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="nx">job</span> <span class="o">&gt;=</span> <span class="nx">work</span><span class="p">.</span><span class="nx">markrootJobs</span> <span class="p">{</span>
                <span class="k">break</span>
            <span class="p">}</span>
            <span class="c1">// 执行根对象扫描工作
</span><span class="c1"></span>            <span class="nf">markroot</span><span class="p">(</span><span class="nx">gcw</span><span class="p">,</span> <span class="nx">job</span><span class="p">)</span>
            <span class="k">if</span> <span class="nx">check</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nf">check</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">goto</span> <span class="nx">done</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span> 
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The gcDrain function starts with a different strategy depending on the flags.</p>
<ul>
<li>gcDrainUntilPreempt: returns when G is preempted.</li>
<li>gcDrainIdle: calls <code>runtime.pollWork</code> and returns when P contains other pending G executions.</li>
<li>gcDrainFractional: calls <code>runtime.pollFractionalWorkerExit</code> and returns when the CPU usage exceeds 20% of <code>fractionalUtilizationGoal</code>.</li>
</ul>
<p>After setting the check variable, you can execute <code>runtime.markroot</code> to scan for root objects, and after each scan, the check function will be called to check if the marker task should be exited, and if so, it will jump to the done block to exit the marker.</p>
<p>When the marker is finished, the pending task is retrieved.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gcDrain</span><span class="p">(</span><span class="nx">gcw</span> <span class="o">*</span><span class="nx">gcWork</span><span class="p">,</span> <span class="nx">flags</span> <span class="nx">gcDrainFlags</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="c1">// 根对象已经在标记队列中, 消费标记队列
</span><span class="c1"></span>    <span class="c1">// 一直循环直到被抢占或 STW
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">!(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">preempt</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">preemptible</span> <span class="o">||</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">gcwaiting</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span> 
        <span class="c1">// 将本地一部分工作放回全局队列中
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">work</span><span class="p">.</span><span class="nx">full</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nx">gcw</span><span class="p">.</span><span class="nf">balance</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="c1">// 获取任务
</span><span class="c1"></span>        <span class="nx">b</span> <span class="o">:=</span> <span class="nx">gcw</span><span class="p">.</span><span class="nf">tryGetFast</span><span class="p">()</span>
        <span class="k">if</span> <span class="nx">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nx">b</span> <span class="p">=</span> <span class="nx">gcw</span><span class="p">.</span><span class="nf">tryGet</span><span class="p">()</span>
            <span class="k">if</span> <span class="nx">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> 
                <span class="nf">wbBufFlush</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="nx">b</span> <span class="p">=</span> <span class="nx">gcw</span><span class="p">.</span><span class="nf">tryGet</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// 获取不到对象, 标记队列已为空, 跳出循环
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> 
            <span class="k">break</span>
        <span class="p">}</span>
        <span class="c1">// 扫描获取到的对象
</span><span class="c1"></span>        <span class="nf">scanobject</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">)</span>

        <span class="c1">// 如果已经扫描了一定数量的对象，gcCreditSlack值是2000
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span> <span class="o">&gt;=</span> <span class="nx">gcCreditSlack</span> <span class="p">{</span>
            <span class="c1">// 把扫描的对象数量添加到全局
</span><span class="c1"></span>            <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">scanWork</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span><span class="p">)</span>
            <span class="k">if</span> <span class="nx">flushBgCredit</span> <span class="p">{</span>
                <span class="c1">// 记录这次扫描的内存字节数用于减少辅助标记的工作量
</span><span class="c1"></span>                <span class="nf">gcFlushBgCredit</span><span class="p">(</span><span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span> <span class="o">-</span> <span class="nx">initScanWork</span><span class="p">)</span>
                <span class="nx">initScanWork</span> <span class="p">=</span> <span class="mi">0</span>
            <span class="p">}</span>
            <span class="nx">checkWork</span> <span class="o">-=</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span>
            <span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span> <span class="p">=</span> <span class="mi">0</span>

            <span class="k">if</span> <span class="nx">checkWork</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="nx">checkWork</span> <span class="o">+=</span> <span class="nx">drainCheckThreshold</span>
                <span class="k">if</span> <span class="nx">check</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nf">check</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">break</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="nx">done</span><span class="p">:</span>
    <span class="c1">// 把扫描的对象数量添加到全局
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">scanWork</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">flushBgCredit</span> <span class="p">{</span>
            <span class="c1">// 记录这次扫描的内存字节数用于减少辅助标记的工作量
</span><span class="c1"></span>            <span class="nf">gcFlushBgCredit</span><span class="p">(</span><span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span> <span class="o">-</span> <span class="nx">initScanWork</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Here before fetching the cache queue <code>runtime.gcWork.balance</code> will be called, which will cache part of the work of gcWork back into the global queue, this method is mainly used to balance the load situation of different P&rsquo;s.</p>
<p>Then fetch gcWork&rsquo;s cached tasks and give the fetched tasks to scanobject to execute. This function will start scanning from the passed location and will color the active objects it finds. <code>runtime.gcFlushBgCredit</code> will record the number of memory bytes scanned this time to reduce the workload of auxiliary markers.</p>
<p>Here I&rsquo;ll summarize the gcWork outgoing and incoming queues. gcWork&rsquo;s outgoing queue is our scanobject method above, which fetches the gcWork cache object and executes it, but also queues the active object into gcWork again if it is found.</p>
<p>In addition to scanobject, the write barrier, root object scan, and stack scan all add additional gray objects to gcWork waiting to be processed.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/23/7771a1f97c7a48ccb7ea18aafcdd2874.png" alt="sobyte"></p>
<p><strong>root marker</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">markroot</span><span class="p">(</span><span class="nx">gcw</span> <span class="o">*</span><span class="nx">gcWork</span><span class="p">,</span> <span class="nx">i</span> <span class="kt">uint32</span><span class="p">)</span> <span class="p">{</span> 
    <span class="nx">baseFlushCache</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">fixedRootCount</span><span class="p">)</span>
    <span class="nx">baseData</span> <span class="o">:=</span> <span class="nx">baseFlushCache</span> <span class="o">+</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">nFlushCacheRoots</span><span class="p">)</span>
    <span class="nx">baseBSS</span> <span class="o">:=</span> <span class="nx">baseData</span> <span class="o">+</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">nDataRoots</span><span class="p">)</span>
    <span class="nx">baseSpans</span> <span class="o">:=</span> <span class="nx">baseBSS</span> <span class="o">+</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">nBSSRoots</span><span class="p">)</span>
    <span class="nx">baseStacks</span> <span class="o">:=</span> <span class="nx">baseSpans</span> <span class="o">+</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">nSpanRoots</span><span class="p">)</span>
    <span class="nx">end</span> <span class="o">:=</span> <span class="nx">baseStacks</span> <span class="o">+</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">nStackRoots</span><span class="p">)</span>

    <span class="k">switch</span> <span class="p">{</span>
        <span class="c1">// 释放mcache中的所有span, 要求STW
</span><span class="c1"></span>    <span class="k">case</span> <span class="nx">baseFlushCache</span> <span class="o">&lt;=</span> <span class="nx">i</span> <span class="o">&amp;&amp;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">baseData</span><span class="p">:</span>
        <span class="nf">flushmcache</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nx">i</span> <span class="o">-</span> <span class="nx">baseFlushCache</span><span class="p">))</span> 
        <span class="c1">// 扫描可读写的全局变量
</span><span class="c1"></span>    <span class="k">case</span> <span class="nx">baseData</span> <span class="o">&lt;=</span> <span class="nx">i</span> <span class="o">&amp;&amp;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">baseBSS</span><span class="p">:</span>
        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">datap</span> <span class="o">:=</span> <span class="k">range</span> <span class="nf">activeModules</span><span class="p">()</span> <span class="p">{</span>
            <span class="nf">markrootBlock</span><span class="p">(</span><span class="nx">datap</span><span class="p">.</span><span class="nx">data</span><span class="p">,</span> <span class="nx">datap</span><span class="p">.</span><span class="nx">edata</span><span class="o">-</span><span class="nx">datap</span><span class="p">.</span><span class="nx">data</span><span class="p">,</span> <span class="nx">datap</span><span class="p">.</span><span class="nx">gcdatamask</span><span class="p">.</span><span class="nx">bytedata</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nx">i</span><span class="o">-</span><span class="nx">baseData</span><span class="p">))</span>
        <span class="p">}</span>
        <span class="c1">// 扫描未初始化的全局变量  
</span><span class="c1"></span>    <span class="k">case</span> <span class="nx">baseBSS</span> <span class="o">&lt;=</span> <span class="nx">i</span> <span class="o">&amp;&amp;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">baseSpans</span><span class="p">:</span>
        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">datap</span> <span class="o">:=</span> <span class="k">range</span> <span class="nf">activeModules</span><span class="p">()</span> <span class="p">{</span>
            <span class="nf">markrootBlock</span><span class="p">(</span><span class="nx">datap</span><span class="p">.</span><span class="nx">bss</span><span class="p">,</span> <span class="nx">datap</span><span class="p">.</span><span class="nx">ebss</span><span class="o">-</span><span class="nx">datap</span><span class="p">.</span><span class="nx">bss</span><span class="p">,</span> <span class="nx">datap</span><span class="p">.</span><span class="nx">gcbssmask</span><span class="p">.</span><span class="nx">bytedata</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nx">i</span><span class="o">-</span><span class="nx">baseBSS</span><span class="p">))</span>
        <span class="p">}</span>
        <span class="c1">// 扫描 finalizers 队列
</span><span class="c1"></span>    <span class="k">case</span> <span class="nx">i</span> <span class="o">==</span> <span class="nx">fixedRootFinalizers</span><span class="p">:</span>
        <span class="k">for</span> <span class="nx">fb</span> <span class="o">:=</span> <span class="nx">allfin</span><span class="p">;</span> <span class="nx">fb</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">fb</span> <span class="p">=</span> <span class="nx">fb</span><span class="p">.</span><span class="nx">alllink</span> <span class="p">{</span>
            <span class="nx">cnt</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">fb</span><span class="p">.</span><span class="nx">cnt</span><span class="p">))</span>
            <span class="nf">scanblock</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">fb</span><span class="p">.</span><span class="nx">fin</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="nx">cnt</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">fb</span><span class="p">.</span><span class="nx">fin</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="o">&amp;</span><span class="nx">finptrmask</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">gcw</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="c1">// 释放已中止的 G 的栈
</span><span class="c1"></span>    <span class="k">case</span> <span class="nx">i</span> <span class="o">==</span> <span class="nx">fixedRootFreeGStacks</span><span class="p">:</span> 
        <span class="nf">systemstack</span><span class="p">(</span><span class="nx">markrootFreeGStacks</span><span class="p">)</span>
        <span class="c1">// 扫描 MSpan.specials
</span><span class="c1"></span>    <span class="k">case</span> <span class="nx">baseSpans</span> <span class="o">&lt;=</span> <span class="nx">i</span> <span class="o">&amp;&amp;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">baseStacks</span><span class="p">:</span> 
        <span class="nf">markrootSpans</span><span class="p">(</span><span class="nx">gcw</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nx">i</span><span class="o">-</span><span class="nx">baseSpans</span><span class="p">))</span>
    <span class="c1">// 扫描各个 G 的栈
</span><span class="c1"></span>    <span class="k">default</span><span class="p">:</span> 
        <span class="c1">// 获取需要扫描的 G
</span><span class="c1"></span>        <span class="kd">var</span> <span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span>
        <span class="k">if</span> <span class="nx">baseStacks</span> <span class="o">&lt;=</span> <span class="nx">i</span> <span class="o">&amp;&amp;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">end</span> <span class="p">{</span>
            <span class="nx">gp</span> <span class="p">=</span> <span class="nx">allgs</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="nx">baseStacks</span><span class="p">]</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;markroot: bad index&#34;</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="c1">// 记录等待开始的时间
</span><span class="c1"></span>        <span class="nx">status</span> <span class="o">:=</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span> <span class="c1">// We are not in a scan state
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="nx">status</span> <span class="o">==</span> <span class="nx">_Gwaiting</span> <span class="o">||</span> <span class="nx">status</span> <span class="o">==</span> <span class="nx">_Gsyscall</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">waitsince</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nx">gp</span><span class="p">.</span><span class="nx">waitsince</span> <span class="p">=</span> <span class="nx">work</span><span class="p">.</span><span class="nx">tstart</span>
        <span class="p">}</span>

        <span class="c1">// 转交给g0进行扫描
</span><span class="c1"></span>        <span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span> 
            <span class="nx">userG</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span>
            <span class="nx">selfScan</span> <span class="o">:=</span> <span class="nx">gp</span> <span class="o">==</span> <span class="nx">userG</span> <span class="o">&amp;&amp;</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">userG</span><span class="p">)</span> <span class="o">==</span> <span class="nx">_Grunning</span>
            <span class="c1">// 如果是扫描自己的，则转换自己的g的状态
</span><span class="c1"></span>            <span class="k">if</span> <span class="nx">selfScan</span> <span class="p">{</span>
                <span class="nf">casgstatus</span><span class="p">(</span><span class="nx">userG</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">)</span>
                <span class="nx">userG</span><span class="p">.</span><span class="nx">waitreason</span> <span class="p">=</span> <span class="nx">waitReasonGarbageCollectionScan</span>
            <span class="p">}</span>

            <span class="c1">// 挂起 G，让对应的 G 停止运行
</span><span class="c1"></span>            <span class="nx">stopped</span> <span class="o">:=</span> <span class="nf">suspendG</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
            <span class="k">if</span> <span class="nx">stopped</span><span class="p">.</span><span class="nx">dead</span> <span class="p">{</span>
                <span class="nx">gp</span><span class="p">.</span><span class="nx">gcscandone</span> <span class="p">=</span> <span class="kc">true</span>
                <span class="k">return</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">gcscandone</span> <span class="p">{</span>
                <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;g already scanned&#34;</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="c1">// 扫描g的栈
</span><span class="c1"></span>            <span class="nf">scanstack</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">)</span>
            <span class="nx">gp</span><span class="p">.</span><span class="nx">gcscandone</span> <span class="p">=</span> <span class="kc">true</span>
            <span class="nf">resumeG</span><span class="p">(</span><span class="nx">stopped</span><span class="p">)</span>

            <span class="k">if</span> <span class="nx">selfScan</span> <span class="p">{</span>
                <span class="nf">casgstatus</span><span class="p">(</span><span class="nx">userG</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">})</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>When I saw the above scanned BSS and Date related memory blocks I was also very puzzled, we can see with the explanation of the Wikipedia Data segment <a href="https://en.wikipedia.org/wiki/Data_segment">https://en.wikipedia.org/wiki/Data_segment</a> that:</p>
<blockquote>
<p>The .data segment contains any global or static variables which have a pre-defined value and can be modified.</p>
<p>The BSS segment, also known as uninitialized data, is usually adjacent to the data segment.</p>
</blockquote>
<p>Data segments are usually global variables that are initialized in advance, and BSS segments are usually data that are not initialized.</p>
<p>Because there are too many caches, data segments, stack memory sweeps, many bit operations and pointer operations involved, the code implementation is rather complicated. Here is a brief look at scanblock, scanstack.</p>
<p><strong>scanblock</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">scanblock</span><span class="p">(</span><span class="nx">b0</span><span class="p">,</span> <span class="nx">n0</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">ptrmask</span> <span class="o">*</span><span class="kt">uint8</span><span class="p">,</span> <span class="nx">gcw</span> <span class="o">*</span><span class="nx">gcWork</span><span class="p">,</span> <span class="nx">stk</span> <span class="o">*</span><span class="nx">stackScanState</span><span class="p">)</span> <span class="p">{</span>

    <span class="nx">b</span> <span class="o">:=</span> <span class="nx">b0</span>
    <span class="nx">n</span> <span class="o">:=</span> <span class="nx">n0</span>
    <span class="c1">// 遍历扫描的地址
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="p">{</span>
        <span class="c1">// 找到bitmap中对应的byte
</span><span class="c1"></span>        <span class="nx">bits</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="o">*</span><span class="nf">addb</span><span class="p">(</span><span class="nx">ptrmask</span><span class="p">,</span> <span class="nx">i</span><span class="o">/</span><span class="p">(</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="o">*</span><span class="mi">8</span><span class="p">)))</span>
        <span class="k">if</span> <span class="nx">bits</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nx">i</span> <span class="o">+=</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span> <span class="o">*</span> <span class="mi">8</span>
            <span class="k">continue</span>
        <span class="p">}</span>
        <span class="c1">// 遍历 byte
</span><span class="c1"></span>        <span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="mi">8</span> <span class="o">&amp;&amp;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
            <span class="c1">// 如果该地址包含指针
</span><span class="c1"></span>            <span class="k">if</span> <span class="nx">bits</span><span class="o">&amp;</span><span class="mi">1</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span> 
                <span class="nx">p</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span> <span class="o">+</span> <span class="nx">i</span><span class="p">))</span>
                <span class="k">if</span> <span class="nx">p</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
                    <span class="c1">// 标记在该地址的对象存活, 并把它加到标记队列
</span><span class="c1"></span>                    <span class="k">if</span> <span class="nx">obj</span><span class="p">,</span> <span class="nx">span</span><span class="p">,</span> <span class="nx">objIndex</span> <span class="o">:=</span> <span class="nf">findObject</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">i</span><span class="p">);</span> <span class="nx">obj</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
                        <span class="nf">greyobject</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">span</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">,</span> <span class="nx">objIndex</span><span class="p">)</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">stk</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">p</span> <span class="o">&gt;=</span> <span class="nx">stk</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">&amp;&amp;</span> <span class="nx">p</span> <span class="p">&lt;</span> <span class="nx">stk</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span> <span class="p">{</span>
                        <span class="nx">stk</span><span class="p">.</span><span class="nf">putPtr</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="nx">bits</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
            <span class="nx">i</span> <span class="o">+=</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>scanstack</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">scanstack</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">gcw</span> <span class="o">*</span><span class="nx">gcWork</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="c1">// 判断是否可以安全的进行 收缩栈
</span><span class="c1"></span>    <span class="k">if</span> <span class="nf">isShrinkStackSafe</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Shrink the stack if not much of it is being used.
</span><span class="c1"></span>        <span class="c1">// 收缩栈
</span><span class="c1"></span>        <span class="nf">shrinkstack</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// Otherwise, shrink the stack at the next sync safe point.
</span><span class="c1"></span>        <span class="c1">// 否则下次安全点再进行收缩栈
</span><span class="c1"></span>        <span class="nx">gp</span><span class="p">.</span><span class="nx">preemptShrink</span> <span class="p">=</span> <span class="kc">true</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nx">state</span> <span class="nx">stackScanState</span>
    <span class="nx">state</span><span class="p">.</span><span class="nx">stack</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span>

    <span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">ctxt</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nf">scanblock</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">ctxt</span><span class="p">)),</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">oneptrmask</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">gcw</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">state</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">scanframe</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">frame</span> <span class="o">*</span><span class="nx">stkframe</span><span class="p">,</span> <span class="nx">unused</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
        <span class="nf">scanframeworker</span><span class="p">(</span><span class="nx">frame</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">state</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">true</span>
    <span class="p">}</span>
    <span class="c1">// 枚举所有调用帧
</span><span class="c1"></span>    <span class="nf">gentraceback</span><span class="p">(^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">gp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="mh">0x7fffffff</span><span class="p">,</span> <span class="nx">scanframe</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="c1">// 枚举所有defer的调用帧
</span><span class="c1"></span>    <span class="nf">tracebackdefers</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">scanframe</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
    <span class="c1">// Find and trace other pointers in defer records.
</span><span class="c1"></span>    <span class="c1">// 扫描defer中的代码块
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">d</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span><span class="p">;</span> <span class="nx">d</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="nx">d</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">link</span> <span class="p">{</span>
        <span class="o">...</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">state</span><span class="p">.</span><span class="nf">putPtr</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span><span class="p">)),</span> <span class="kc">false</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// 扫描并找到所有可达的栈对象
</span><span class="c1"></span>    <span class="nx">state</span><span class="p">.</span><span class="nf">buildIndex</span><span class="p">()</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="nx">p</span><span class="p">,</span> <span class="nx">conservative</span> <span class="o">:=</span> <span class="nx">state</span><span class="p">.</span><span class="nf">getPtr</span><span class="p">()</span>
        <span class="k">if</span> <span class="nx">p</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">break</span>
        <span class="p">}</span>
        <span class="nx">obj</span> <span class="o">:=</span> <span class="nx">state</span><span class="p">.</span><span class="nf">findObject</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">obj</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">continue</span>
        <span class="p">}</span>
        <span class="nx">t</span> <span class="o">:=</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">typ</span>
        <span class="c1">// 已被扫描过
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">t</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">continue</span>
        <span class="p">}</span>
        <span class="c1">// 标记扫描
</span><span class="c1"></span>        <span class="nx">obj</span><span class="p">.</span><span class="nf">setType</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span> 
        <span class="nx">gcdata</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">gcdata</span>
        <span class="kd">var</span> <span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span>
        <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">kind</span><span class="o">&amp;</span><span class="nx">kindGCProg</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nx">s</span> <span class="p">=</span> <span class="nf">materializeGCProg</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">ptrdata</span><span class="p">,</span> <span class="nx">gcdata</span><span class="p">)</span>
            <span class="nx">gcdata</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">startAddr</span><span class="p">))</span>
        <span class="p">}</span>

        <span class="nx">b</span> <span class="o">:=</span> <span class="nx">state</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">+</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">off</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">conservative</span> <span class="p">{</span>
            <span class="nf">scanConservative</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">ptrdata</span><span class="p">,</span> <span class="nx">gcdata</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">state</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nf">scanblock</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">ptrdata</span><span class="p">,</span> <span class="nx">gcdata</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">state</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="nx">s</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nf">dematerializeGCProg</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="nx">state</span><span class="p">.</span><span class="nx">head</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">x</span> <span class="o">:=</span> <span class="nx">state</span><span class="p">.</span><span class="nx">head</span>
        <span class="nx">state</span><span class="p">.</span><span class="nx">head</span> <span class="p">=</span> <span class="nx">x</span><span class="p">.</span><span class="nx">next</span>

        <span class="nx">x</span><span class="p">.</span><span class="nx">nobj</span> <span class="p">=</span> <span class="mi">0</span>
        <span class="nf">putempty</span><span class="p">((</span><span class="o">*</span><span class="nx">workbuf</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">x</span><span class="p">)))</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">state</span><span class="p">.</span><span class="nx">buf</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">state</span><span class="p">.</span><span class="nx">cbuf</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">state</span><span class="p">.</span><span class="nx">freeBuf</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;remaining pointer buffers&#34;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>greyobject</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">greyobject</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">base</span><span class="p">,</span> <span class="nx">off</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">span</span> <span class="o">*</span><span class="nx">mspan</span><span class="p">,</span> <span class="nx">gcw</span> <span class="o">*</span><span class="nx">gcWork</span><span class="p">,</span> <span class="nx">objIndex</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// obj should be start of allocation, and so must be at least pointer-aligned.
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">obj</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;greyobject: obj not pointer-aligned&#34;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">mbits</span> <span class="o">:=</span> <span class="nx">span</span><span class="p">.</span><span class="nf">markBitsForIndex</span><span class="p">(</span><span class="nx">objIndex</span><span class="p">)</span>
    <span class="c1">// 检查是否所有可到达的对象都被正确标记的机制, 仅除错使用
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">useCheckmark</span> <span class="p">{</span>
        <span class="o">...</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="o">...</span>
        <span class="c1">// 被标记过了直接返回
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">mbits</span><span class="p">.</span><span class="nf">isMarked</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span>
        <span class="p">}</span>
        <span class="c1">// 设置标记
</span><span class="c1"></span>        <span class="nx">mbits</span><span class="p">.</span><span class="nf">setMarked</span><span class="p">()</span>

        <span class="c1">// 标记 span
</span><span class="c1"></span>        <span class="nx">arena</span><span class="p">,</span> <span class="nx">pageIdx</span><span class="p">,</span> <span class="nx">pageMask</span> <span class="o">:=</span> <span class="nf">pageIndexOf</span><span class="p">(</span><span class="nx">span</span><span class="p">.</span><span class="nf">base</span><span class="p">())</span>
        <span class="k">if</span> <span class="nx">arena</span><span class="p">.</span><span class="nx">pageMarks</span><span class="p">[</span><span class="nx">pageIdx</span><span class="p">]</span><span class="o">&amp;</span><span class="nx">pageMask</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nx">atomic</span><span class="p">.</span><span class="nf">Or8</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">arena</span><span class="p">.</span><span class="nx">pageMarks</span><span class="p">[</span><span class="nx">pageIdx</span><span class="p">],</span> <span class="nx">pageMask</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="c1">// span的类型是noscan, 则不需要把对象放入标记队列
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">span</span><span class="p">.</span><span class="nx">spanclass</span><span class="p">.</span><span class="nf">noscan</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">gcw</span><span class="p">.</span><span class="nx">bytesMarked</span> <span class="o">+=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">span</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 尝试存入gcwork的缓存中，或全局队列中
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">!</span><span class="nx">gcw</span><span class="p">.</span><span class="nf">putFast</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">gcw</span><span class="p">.</span><span class="nf">put</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>Object scanning</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">scanobject</span><span class="p">(</span><span class="nx">b</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">gcw</span> <span class="o">*</span><span class="nx">gcWork</span><span class="p">)</span> <span class="p">{</span> 
    <span class="c1">// 获取 b 的 heapBits 对象
</span><span class="c1"></span>    <span class="nx">hbits</span> <span class="o">:=</span> <span class="nf">heapBitsForAddr</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
    <span class="c1">// 获取 span
</span><span class="c1"></span>    <span class="nx">s</span> <span class="o">:=</span> <span class="nf">spanOfUnchecked</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
    <span class="c1">// span 对应的对象大小
</span><span class="c1"></span>    <span class="nx">n</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span>
    <span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;scanobject n == 0&#34;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// 每次最大只扫描128KB
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="nx">maxObletBytes</span> <span class="p">{</span>
        <span class="c1">// Large object. Break into oblets for better
</span><span class="c1"></span>        <span class="c1">// parallelism and lower latency.
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">b</span> <span class="o">==</span> <span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span> <span class="p">{</span> 
            <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">spanclass</span><span class="p">.</span><span class="nf">noscan</span><span class="p">()</span> <span class="p">{</span>
                <span class="c1">// Bypass the whole scan.
</span><span class="c1"></span>                <span class="nx">gcw</span><span class="p">.</span><span class="nx">bytesMarked</span> <span class="o">+=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="p">}</span>
            <span class="c1">// 把多于128KB的对象重新放回gcworker中，下次再扫描
</span><span class="c1"></span>            <span class="k">for</span> <span class="nx">oblet</span> <span class="o">:=</span> <span class="nx">b</span> <span class="o">+</span> <span class="nx">maxObletBytes</span><span class="p">;</span> <span class="nx">oblet</span> <span class="p">&lt;</span> <span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span><span class="o">+</span><span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">;</span> <span class="nx">oblet</span> <span class="o">+=</span> <span class="nx">maxObletBytes</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">!</span><span class="nx">gcw</span><span class="p">.</span><span class="nf">putFast</span><span class="p">(</span><span class="nx">oblet</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nx">gcw</span><span class="p">.</span><span class="nf">put</span><span class="p">(</span><span class="nx">oblet</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="nx">n</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span> <span class="o">+</span> <span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span> <span class="o">-</span> <span class="nx">b</span>
        <span class="k">if</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="nx">maxObletBytes</span> <span class="p">{</span>
            <span class="nx">n</span> <span class="p">=</span> <span class="nx">maxObletBytes</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nx">i</span> <span class="kt">uintptr</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span> <span class="o">+=</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span> <span class="p">{</span>
        <span class="c1">// 获取对应的bit
</span><span class="c1"></span>        <span class="c1">// Find bits for this word.
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span> 
            <span class="nx">hbits</span> <span class="p">=</span> <span class="nx">hbits</span><span class="p">.</span><span class="nf">next</span><span class="p">()</span>
        <span class="p">}</span> 
        <span class="nx">bits</span> <span class="o">:=</span> <span class="nx">hbits</span><span class="p">.</span><span class="nf">bits</span><span class="p">()</span> 
        <span class="c1">// 检查scan bit判断是否继续扫描
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">i</span> <span class="o">!=</span> <span class="mi">1</span><span class="o">*</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span> <span class="o">&amp;&amp;</span> <span class="nx">bits</span><span class="o">&amp;</span><span class="nx">bitScan</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">break</span> <span class="c1">// no more pointers in this object
</span><span class="c1"></span>        <span class="p">}</span>
        <span class="c1">// 如果不是指针则继续
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">bits</span><span class="o">&amp;</span><span class="nx">bitPointer</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">continue</span> <span class="c1">// not a pointer
</span><span class="c1"></span>        <span class="p">}</span>

        <span class="c1">// 取出指针的值
</span><span class="c1"></span>        <span class="nx">obj</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span> <span class="o">+</span> <span class="nx">i</span><span class="p">))</span>

        <span class="k">if</span> <span class="nx">obj</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">obj</span><span class="o">-</span><span class="nx">b</span> <span class="o">&gt;=</span> <span class="nx">n</span> <span class="p">{</span> 
            <span class="c1">// 根据地址值去堆中查找对象
</span><span class="c1"></span>            <span class="k">if</span> <span class="nx">obj</span><span class="p">,</span> <span class="nx">span</span><span class="p">,</span> <span class="nx">objIndex</span> <span class="o">:=</span> <span class="nf">findObject</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">i</span><span class="p">);</span> <span class="nx">obj</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="c1">// 调用 greyobject 标记对象并把对象放到标记队列中
</span><span class="c1"></span>                <span class="nf">greyobject</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">span</span><span class="p">,</span> <span class="nx">gcw</span><span class="p">,</span> <span class="nx">objIndex</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nx">gcw</span><span class="p">.</span><span class="nx">bytesMarked</span> <span class="o">+=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
    <span class="nx">gcw</span><span class="p">.</span><span class="nx">scanWork</span> <span class="o">+=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="assist-marker-mutator-assists">Assist marker mutator assists</h4>
<p>The role of mutator assists was mentioned at the beginning of the analysis, mainly to prevent the heap from growing too fast, if a G running at the same time allocates memory during GC execution, then the G will be asked to assist the GC to do part of the work, it follows a very simple and plain principle, <strong>allocate as much memory as you need to complete the tagging task</strong>.</p>
<p>The entry point for mutator assists is in the mallocgc function in <code>go\src\runtime\malloc.go</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">size</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">typ</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">needzero</span> <span class="kt">bool</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="kd">var</span> <span class="nx">assistG</span> <span class="o">*</span><span class="nx">g</span>
    <span class="k">if</span> <span class="nx">gcBlackenEnabled</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">assistG</span> <span class="p">=</span> <span class="nf">getg</span><span class="p">()</span>
        <span class="k">if</span> <span class="nx">assistG</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">assistG</span> <span class="p">=</span> <span class="nx">assistG</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span>
        <span class="p">}</span>
        <span class="c1">// 减去内存值
</span><span class="c1"></span>        <span class="nx">assistG</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="o">-=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span>

        <span class="k">if</span> <span class="nx">assistG</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="c1">// This G is in debt.
</span><span class="c1"></span>            <span class="nf">gcAssistAlloc</span><span class="p">(</span><span class="nx">assistG</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="nx">x</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Each time mallocgc allocates memory it checks for a negative value in the gcAssistBytes field, which stores the number of bytes of the object currently marked by the Goroutine auxiliary. If it is negative, then gcAssistAlloc is called to fetch it from the global credit bgScanCredit.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gcAssistAlloc</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
     <span class="o">...</span>
<span class="nx">retry</span><span class="p">:</span>  
    <span class="c1">// 计算需要完成的标记任务数量
</span><span class="c1"></span>    <span class="nx">debtBytes</span> <span class="o">:=</span> <span class="o">-</span><span class="nx">gp</span><span class="p">.</span><span class="nx">gcAssistBytes</span>
    <span class="nx">scanWork</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">assistWorkPerByte</span> <span class="o">*</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">debtBytes</span><span class="p">))</span>
    <span class="k">if</span> <span class="nx">scanWork</span> <span class="p">&lt;</span> <span class="nx">gcOverAssistWork</span> <span class="p">{</span>
        <span class="nx">scanWork</span> <span class="p">=</span> <span class="nx">gcOverAssistWork</span>
        <span class="nx">debtBytes</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">assistBytesPerWork</span> <span class="o">*</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">scanWork</span><span class="p">))</span>
    <span class="p">}</span>

    <span class="c1">// 获取全局辅助标记的字节数
</span><span class="c1"></span>    <span class="nx">bgScanCredit</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Loadint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">bgScanCredit</span><span class="p">)</span>
    <span class="nx">stolen</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">bgScanCredit</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">bgScanCredit</span> <span class="p">&lt;</span> <span class="nx">scanWork</span> <span class="p">{</span>
            <span class="nx">stolen</span> <span class="p">=</span> <span class="nx">bgScanCredit</span>
            <span class="nx">gp</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">assistBytesPerWork</span><span class="o">*</span><span class="nb">float64</span><span class="p">(</span><span class="nx">stolen</span><span class="p">))</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">stolen</span> <span class="p">=</span> <span class="nx">scanWork</span>
            <span class="nx">gp</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="o">+=</span> <span class="nx">debtBytes</span>
        <span class="p">}</span>
        <span class="c1">// 全局信用扣除stolen点数
</span><span class="c1"></span>        <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">bgScanCredit</span><span class="p">,</span> <span class="o">-</span><span class="nx">stolen</span><span class="p">)</span> 
        <span class="nx">scanWork</span> <span class="o">-=</span> <span class="nx">stolen</span> 
        <span class="c1">// 减到 0 说明 bgScanCredit 是由足够的信用可以处理 scanWork
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">scanWork</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> 
            <span class="k">return</span>
        <span class="p">}</span>
    <span class="p">}</span> 
    <span class="c1">// 到这里说明 bgScanCredit 小于 scanWork
</span><span class="c1"></span>    <span class="c1">// 需要调用 gcDrainN 完成指定数量的标记任务并返回
</span><span class="c1"></span>    <span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 执行标记任务
</span><span class="c1"></span>        <span class="nf">gcAssistAlloc1</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">scanWork</span><span class="p">)</span> 
    <span class="p">})</span>

    <span class="nx">completed</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="o">!=</span> <span class="kc">nil</span>
    <span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
    <span class="k">if</span> <span class="nx">completed</span> <span class="p">{</span>
        <span class="nf">gcMarkDone</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span> 
        <span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">preempt</span> <span class="p">{</span>
            <span class="nf">Gosched</span><span class="p">()</span>
            <span class="k">goto</span> <span class="nx">retry</span>
        <span class="p">}</span>
        <span class="c1">// 如果全局信用仍然不足将当前 Goroutine 陷入休眠 
</span><span class="c1"></span>        <span class="c1">// 加入全局的辅助标记队列并等待后台标记任务的唤醒
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">!</span><span class="nf">gcParkAssist</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">goto</span> <span class="nx">retry</span>
        <span class="p">}</span> 
    <span class="p">}</span>  
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>If the global credit is still insufficient, the current Goroutine is put into hibernation, added to the global auxiliary marker queue and waits for the background marker task to wake up.</p>
<p>The call to gcFlushBgCredit when scanning memory is responsible for waking up the secondary tagging Goroutine.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gcFlushBgCredit</span><span class="p">(</span><span class="nx">scanWork</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 辅助队列中不存在等待的 Goroutine 
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">work</span><span class="p">.</span><span class="nx">assistQueue</span><span class="p">.</span><span class="nx">q</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 当前的信用会直接加到全局信用 bgScanCredit
</span><span class="c1"></span>        <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">bgScanCredit</span><span class="p">,</span> <span class="nx">scanWork</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>

    <span class="nx">scanBytes</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">scanWork</span><span class="p">)</span> <span class="o">*</span> <span class="nx">gcController</span><span class="p">.</span><span class="nx">assistBytesPerWork</span><span class="p">)</span>

    <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">assistQueue</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
    <span class="c1">// 如果辅助队列不为空
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">!</span><span class="nx">work</span><span class="p">.</span><span class="nx">assistQueue</span><span class="p">.</span><span class="nx">q</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nx">scanBytes</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">gp</span> <span class="o">:=</span> <span class="nx">work</span><span class="p">.</span><span class="nx">assistQueue</span><span class="p">.</span><span class="nx">q</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
        <span class="c1">// 唤醒 Goroutine
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">scanBytes</span><span class="o">+</span><span class="nx">gp</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span> 
            <span class="nx">scanBytes</span> <span class="o">+=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">gcAssistBytes</span>
            <span class="nx">gp</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="p">=</span> <span class="mi">0</span> 
            <span class="nf">ready</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> 
            <span class="nx">gp</span><span class="p">.</span><span class="nx">gcAssistBytes</span> <span class="o">+=</span> <span class="nx">scanBytes</span>
            <span class="nx">scanBytes</span> <span class="p">=</span> <span class="mi">0</span> 
            <span class="nx">work</span><span class="p">.</span><span class="nx">assistQueue</span><span class="p">.</span><span class="nx">q</span><span class="p">.</span><span class="nf">pushBack</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
            <span class="k">break</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 标记任务量仍然有剩余，这些标记任务都会加入全局信用
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">scanBytes</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span> 
        <span class="nx">scanWork</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">scanBytes</span><span class="p">)</span> <span class="o">*</span> <span class="nx">gcController</span><span class="p">.</span><span class="nx">assistWorkPerByte</span><span class="p">)</span>
        <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xaddint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcController</span><span class="p">.</span><span class="nx">bgScanCredit</span><span class="p">,</span> <span class="nx">scanWork</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">assistQueue</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>gcFlushBgCredit fetches the sleeping auxiliary queue Goroutine, wakes up the auxiliary Goroutine if there is enough credit currently available, and if there is any left, then all these marker tasks will be added to the global credit.</p>
<p>The overall set of mechanisms is as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/23/de3f670853b04fbaa76600e6cd6f5edb.png" alt="sobyte"></p>
<h3 id="mark-completion">Mark completion</h3>
<p>As we analyzed above in gcBgMarkWorker, gcMarkDone will be called to perform the marker completion operation after the marker is completed.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gcMarkDone</span><span class="p">()</span> <span class="p">{</span>

    <span class="nf">semacquire</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">markDoneSema</span><span class="p">)</span>

<span class="nx">top</span><span class="p">:</span> 
    <span class="c1">// 再次检查任务是否已执行完毕
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">!(</span><span class="nx">gcphase</span> <span class="o">==</span> <span class="nx">_GCmark</span> <span class="o">&amp;&amp;</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nwait</span> <span class="o">==</span> <span class="nx">work</span><span class="p">.</span><span class="nx">nproc</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nf">gcMarkWorkAvailable</span><span class="p">(</span><span class="kc">nil</span><span class="p">))</span> <span class="p">{</span>
        <span class="nf">semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">markDoneSema</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>

    <span class="nf">semacquire</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">worldsema</span><span class="p">)</span>

    <span class="nx">gcMarkDoneFlushed</span> <span class="p">=</span> <span class="mi">0</span> 
    <span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span> 
        <span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">)</span>
        <span class="c1">// 遍历所有的 P
</span><span class="c1"></span>        <span class="nf">forEachP</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 将 P 对应的write barrier buffer 中的对象加入到 gcWork 中
</span><span class="c1"></span>            <span class="nf">wbBufFlush1</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
            <span class="c1">// 将 gcWork 中的缓存对象加入到全局队列中
</span><span class="c1"></span>            <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcw</span><span class="p">.</span><span class="nf">dispose</span><span class="p">()</span>
            <span class="c1">// 表示 gcWork 的数据都已迁移到 全局队列中
</span><span class="c1"></span>            <span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcw</span><span class="p">.</span><span class="nx">flushedWork</span> <span class="p">{</span>
                <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcMarkDoneFlushed</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="nx">_p_</span><span class="p">.</span><span class="nx">gcw</span><span class="p">.</span><span class="nx">flushedWork</span> <span class="p">=</span> <span class="kc">false</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">debugCachedWork</span> <span class="p">{</span>
                <span class="o">...</span>
            <span class="p">}</span>
            <span class="o">...</span>
        <span class="p">})</span>
        <span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">)</span>
    <span class="p">})</span>

    <span class="k">if</span> <span class="nx">gcMarkDoneFlushed</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">debugCachedWork</span> <span class="p">{</span>
            <span class="c1">// Release paused gcWorks.
</span><span class="c1"></span>            <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcWorkPauseGen</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nf">semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">worldsema</span><span class="p">)</span>
        <span class="k">goto</span> <span class="nx">top</span>
    <span class="p">}</span>
    <span class="c1">// 记录完成标记阶段开始的时间和STW开始的时间
</span><span class="c1"></span>    <span class="nx">now</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span>
    <span class="nx">work</span><span class="p">.</span><span class="nx">tMarkTerm</span> <span class="p">=</span> <span class="nx">now</span>
    <span class="nx">work</span><span class="p">.</span><span class="nx">pauseStart</span> <span class="p">=</span> <span class="nx">now</span>
    <span class="c1">// 禁止G被抢占
</span><span class="c1"></span>    <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">preemptoff</span> <span class="p">=</span> <span class="s">&#34;gcing&#34;</span> 
    <span class="c1">// STW
</span><span class="c1"></span>    <span class="nf">systemstack</span><span class="p">(</span><span class="nx">stopTheWorldWithSema</span><span class="p">)</span> 
    <span class="o">...</span>   
    <span class="c1">// 禁止辅助GC和后台标记任务的运行
</span><span class="c1"></span>    <span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcBlackenEnabled</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> 
    <span class="c1">// 唤醒所有因为辅助GC而休眠的G
</span><span class="c1"></span>    <span class="nf">gcWakeAllAssists</span><span class="p">()</span> 
    <span class="nf">semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">markDoneSema</span><span class="p">)</span> 
    <span class="nf">schedEnableUser</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> 
    <span class="c1">// 计算下一次触发gc需要的heap大小
</span><span class="c1"></span>    <span class="nx">nextTriggerRatio</span> <span class="o">:=</span> <span class="nx">gcController</span><span class="p">.</span><span class="nf">endCycle</span><span class="p">()</span> 
    <span class="c1">// 执行标记终止
</span><span class="c1"></span>    <span class="nf">gcMarkTermination</span><span class="p">(</span><span class="nx">nextTriggerRatio</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>gcMarkDone will call the forEachP function to iterate through all P&rsquo;s and move the tasks in the corresponding P&rsquo;s gcWork to the global queue, adding 1 to gcMarkDoneFlushed if there are tasks in the gcWork, and after iterating through all P&rsquo;s it will determine that if gcMarkDoneFlushed is not 0, then it will jump to the top marker and continue cycling until there are no tasks in the local queue.</p>
<p>Next, gcBlackenEnabled is set to 0, which means that the auxiliary marker and background marker are closed; the blocked auxiliary marker is woken up; schedEnableUser is called to resume the scheduling of the user&rsquo;s Goroutine; note that it is currently in the STW phase, so the woken up Goroutine will not be executed immediately, but will wait until STW is finished.</p>
<p>Finally, gcMarkTermination is called to perform mark termination.</p>
<h3 id="mark-termination">Mark Termination</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gcMarkTermination</span><span class="p">(</span><span class="nx">nextTriggerRatio</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span> 
    <span class="c1">// 禁止辅助GC和后台标记任务的运行
</span><span class="c1"></span>    <span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcBlackenEnabled</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="c1">// 将 GC 阶段切换到 _GCmarktermination
</span><span class="c1"></span>    <span class="nf">setGCPhase</span><span class="p">(</span><span class="nx">_GCmarktermination</span><span class="p">)</span>
    <span class="nx">work</span><span class="p">.</span><span class="nx">heap1</span> <span class="p">=</span> <span class="nx">memstats</span><span class="p">.</span><span class="nx">heap_live</span>
    <span class="c1">// 记录开始时间
</span><span class="c1"></span>    <span class="nx">startTime</span> <span class="o">:=</span> <span class="nf">nanotime</span><span class="p">()</span>
    <span class="nx">mp</span> <span class="o">:=</span> <span class="nf">acquirem</span><span class="p">()</span>
    <span class="nx">mp</span><span class="p">.</span><span class="nx">preemptoff</span> <span class="p">=</span> <span class="s">&#34;gcing&#34;</span>
    <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
    <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">traceback</span> <span class="p">=</span> <span class="mi">2</span>
    <span class="nx">gp</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span>
    <span class="c1">// 设置 G 的状态为等待中
</span><span class="c1"></span>    <span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">)</span>
    <span class="nx">gp</span><span class="p">.</span><span class="nx">waitreason</span> <span class="p">=</span> <span class="nx">waitReasonGarbageCollection</span> 
    <span class="c1">// 切换到 g0 运行
</span><span class="c1"></span>    <span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 开始 STW 中的标记
</span><span class="c1"></span>        <span class="nf">gcMark</span><span class="p">(</span><span class="nx">startTime</span><span class="p">)</span> 
    <span class="p">})</span>

    <span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">work</span><span class="p">.</span><span class="nx">heap2</span> <span class="p">=</span> <span class="nx">work</span><span class="p">.</span><span class="nx">bytesMarked</span>
        <span class="o">...</span>
        <span class="c1">// 设置当前GC阶段到关闭, 并禁用写屏障
</span><span class="c1"></span>        <span class="nf">setGCPhase</span><span class="p">(</span><span class="nx">_GCoff</span><span class="p">)</span>
        <span class="c1">// 唤醒后台清扫任务
</span><span class="c1"></span>        <span class="nf">gcSweep</span><span class="p">(</span><span class="nx">work</span><span class="p">.</span><span class="nx">mode</span><span class="p">)</span>
    <span class="p">})</span> 
    <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">traceback</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">)</span> 
    <span class="c1">// 统计以及重置清扫状态相关代码 
</span><span class="c1"></span>    <span class="o">...</span> 
    <span class="c1">// 统计执行GC的次数然后唤醒等待清扫的G
</span><span class="c1"></span>    <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">sweepWaiters</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
    <span class="nx">memstats</span><span class="p">.</span><span class="nx">numgc</span><span class="o">++</span>
    <span class="nf">injectglist</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">sweepWaiters</span><span class="p">.</span><span class="nx">list</span><span class="p">)</span>
    <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">work</span><span class="p">.</span><span class="nx">sweepWaiters</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
    <span class="c1">// 性能统计 
</span><span class="c1"></span>    <span class="nf">mProf_NextCycle</span><span class="p">()</span>
    <span class="c1">// 重新  start The World
</span><span class="c1"></span>    <span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nf">startTheWorldWithSema</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">})</span>
    <span class="c1">// 性能统计 
</span><span class="c1"></span>    <span class="nf">mProf_Flush</span><span class="p">()</span> 
    <span class="c1">// 移动标记队列使用的 workbuf 到 free list, 使得它们可以被回收
</span><span class="c1"></span>    <span class="nf">prepareFreeWorkbufs</span><span class="p">()</span>
    <span class="c1">// 释放未使用的栈
</span><span class="c1"></span>    <span class="nf">systemstack</span><span class="p">(</span><span class="nx">freeStackSpans</span><span class="p">)</span> 
    <span class="c1">// 确保每个 P 的 mcache 都被 flush 
</span><span class="c1"></span>    <span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">forEachP</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">_p_</span><span class="p">.</span><span class="nx">mcache</span><span class="p">.</span><span class="nf">prepareForSweep</span><span class="p">()</span>
        <span class="p">})</span>
    <span class="p">})</span> 
    <span class="o">...</span>
    <span class="nf">semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">worldsema</span><span class="p">)</span>
    <span class="nf">semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gcsema</span><span class="p">)</span> 
    <span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
    <span class="nx">mp</span> <span class="p">=</span> <span class="kc">nil</span> 
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>gcMarkTermination is mainly to do some confirmation work and statistics. This method first sets the GC phase to <code>_GCmarktermination</code> and then calls the gcMark method to confirm that all GC marking has been completed. Then the GC phase is set to <code>_GCoff</code> and gcSweep is called to start the cleanup. Then comes the omitted code related to statistics, including the amount of memory being used, GC time, CPU utilization, etc. Finally, some confirmation work is done, such as making sure that the mcache of each P is flushed, the stack is freed, the workbuf is transferred to the free list for recycling, etc.</p>
<h3 id="backend-cleanup">Backend cleanup</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gcSweep</span><span class="p">(</span><span class="nx">mode</span> <span class="nx">gcMode</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">gcphase</span> <span class="o">!=</span> <span class="nx">_GCoff</span> <span class="p">{</span>
        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;gcSweep being done but phase is not GCoff&#34;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
    <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">+=</span> <span class="mi">2</span>
    <span class="c1">// 重置标记位
</span><span class="c1"></span>    <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepdone</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="o">...</span>
    <span class="nx">mheap_</span><span class="p">.</span><span class="nx">pagesSwept</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepArenas</span> <span class="p">=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">allArenas</span>
    <span class="nx">mheap_</span><span class="p">.</span><span class="nx">reclaimIndex</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="nx">mheap_</span><span class="p">.</span><span class="nx">reclaimCredit</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

    <span class="k">if</span> <span class="nx">go115NewMCentralImpl</span> <span class="p">{</span>
        <span class="nx">sweep</span><span class="p">.</span><span class="nx">centralIndex</span><span class="p">.</span><span class="nf">clear</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="c1">// 如果非并行GC 
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">!</span><span class="nx">_ConcurrentSweep</span> <span class="o">||</span> <span class="nx">mode</span> <span class="o">==</span> <span class="nx">gcForceBlockMode</span> <span class="p">{</span>
        <span class="o">...</span>
        <span class="k">return</span>
    <span class="p">}</span>

    <span class="c1">// 唤醒后台清扫任务
</span><span class="c1"></span>    <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sweep</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">sweep</span><span class="p">.</span><span class="nx">parked</span> <span class="p">{</span>
        <span class="nx">sweep</span><span class="p">.</span><span class="nx">parked</span> <span class="p">=</span> <span class="kc">false</span>
        <span class="nf">ready</span><span class="p">(</span><span class="nx">sweep</span><span class="p">.</span><span class="nx">g</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sweep</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>What gcSweep does is to reset the state associated with the cleanup phase and then wake up sweep to sweep the Goroutine. The background sweep task is set by calling bgsweep when initializing the main Goroutine at</p>
<p><strong>gcenable</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gcenable</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Kick off sweeping and scavenging.
</span><span class="c1"></span>    <span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="c1">// 设置异步清扫
</span><span class="c1"></span>    <span class="k">go</span> <span class="nf">bgsweep</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> 
    <span class="o">&lt;-</span><span class="nx">c</span> 
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>bgsweep</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">bgsweep</span><span class="p">(</span><span class="nx">c</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 设置清扫 Goroutine 
</span><span class="c1"></span>    <span class="nx">sweep</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="nf">getg</span><span class="p">()</span>
    <span class="c1">// 等待唤醒 
</span><span class="c1"></span>    <span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sweep</span><span class="p">.</span><span class="nx">lock</span><span class="p">,</span> <span class="nx">lockRankSweep</span><span class="p">)</span>
    <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sweep</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
    <span class="nx">sweep</span><span class="p">.</span><span class="nx">parked</span> <span class="p">=</span> <span class="kc">true</span>
    <span class="nx">c</span> <span class="o">&lt;-</span> <span class="mi">1</span>
    <span class="nf">goparkunlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sweep</span><span class="p">.</span><span class="nx">lock</span><span class="p">,</span> <span class="nx">waitReasonGCSweepWait</span><span class="p">,</span> <span class="nx">traceEvGoBlock</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1">// 循环清扫
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">{</span>
        <span class="c1">// 清扫一个span, 然后进入调度
</span><span class="c1"></span>        <span class="k">for</span> <span class="nf">sweepone</span><span class="p">()</span> <span class="o">!=</span> <span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">sweep</span><span class="p">.</span><span class="nx">nbgsweep</span><span class="o">++</span>
            <span class="nf">Gosched</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="c1">// 释放一些未使用的标记队列缓冲区到heap
</span><span class="c1"></span>        <span class="k">for</span> <span class="nf">freeSomeWbufs</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">Gosched</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sweep</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
        <span class="c1">// 判断 sweepdone 标志位是否等于 0
</span><span class="c1"></span>        <span class="c1">// 如果清扫未完成则继续循环
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">!</span><span class="nf">isSweepDone</span><span class="p">()</span> <span class="p">{</span> 
            <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sweep</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="p">}</span>
        <span class="c1">// 否则让后台清扫任务进入休眠
</span><span class="c1"></span>        <span class="nx">sweep</span><span class="p">.</span><span class="nx">parked</span> <span class="p">=</span> <span class="kc">true</span>
        <span class="nf">goparkunlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sweep</span><span class="p">.</span><span class="nx">lock</span><span class="p">,</span> <span class="nx">waitReasonGCSweepWait</span><span class="p">,</span> <span class="nx">traceEvGoBlock</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The sweeping task of bgsweep is actually performed by sweepone, which looks for the span to be cleaned in heap memory and returns how many pages were swept into the heap, returning <code>^uintptr(0)</code> to indicate that there is nothing to sweep</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">sweepone</span><span class="p">()</span> <span class="kt">uintptr</span> <span class="p">{</span>
    <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
    <span class="nx">sweepRatio</span> <span class="o">:=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepPagesPerByte</span> <span class="c1">// For debugging 
</span><span class="c1"></span>    <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">++</span>
    <span class="c1">// 校验是否清扫已完成
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepdone</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">--</span>
        <span class="k">return</span> <span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepers</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1">//查找一个 span 并释放
</span><span class="c1"></span>    <span class="kd">var</span> <span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span>
    <span class="nx">sg</span> <span class="o">:=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">go115NewMCentralImpl</span> <span class="p">{</span>
            <span class="nx">s</span> <span class="p">=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nf">nextSpanForSweep</span><span class="p">()</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">s</span> <span class="p">=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepSpans</span><span class="p">[</span><span class="mi">1</span><span class="o">-</span><span class="nx">sg</span><span class="o">/</span><span class="mi">2</span><span class="o">%</span><span class="mi">2</span><span class="p">].</span><span class="nf">pop</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepdone</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">break</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nx">state</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nf">get</span><span class="p">();</span> <span class="nx">state</span> <span class="o">!=</span> <span class="nx">mSpanInUse</span> <span class="p">{</span> 
            <span class="k">continue</span>
        <span class="p">}</span>
        <span class="c1">// span 的 sweepgen 等于 mheap.sweepgen - 2，那么意味着当前单元需要清理
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span> <span class="o">==</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">,</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="nx">sg</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">break</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 清理 span
</span><span class="c1"></span>    <span class="nx">npages</span> <span class="o">:=</span> <span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">s</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">npages</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">npages</span>
        <span class="c1">// 回收内存
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nf">sweep</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span> <span class="p">{</span> 
            <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadduintptr</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">reclaimCredit</span><span class="p">,</span> <span class="nx">npages</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

            <span class="nx">npages</span> <span class="p">=</span> <span class="mi">0</span>
        <span class="p">}</span>
    <span class="p">}</span> 
    <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">--</span>
    <span class="k">return</span> <span class="nx">npages</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>When finding a span, the state and whether sweepgen is equal to <code>mheap.sweepgen - 2</code> are used to determine if the span needs to be swept.</p>
<p>Here is a brief look at the sweep implementation.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span><span class="p">)</span> <span class="nf">sweep</span><span class="p">(</span><span class="nx">preserve</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">go115NewMCentralImpl</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nf">oldSweep</span><span class="p">(</span><span class="nx">preserve</span><span class="p">)</span>
    <span class="p">}</span> 
    <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span> 
    <span class="nx">sweepgen</span> <span class="o">:=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nx">sweepgen</span>
    <span class="c1">// 统计已清理的页数
</span><span class="c1"></span>    <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">pagesSwept</span><span class="p">,</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">npages</span><span class="p">))</span>

    <span class="nx">spc</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">spanclass</span>
    <span class="nx">size</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span>

    <span class="nx">c</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">mcache</span>  
    <span class="o">...</span>
    <span class="c1">// 计算释放的对象数量 
</span><span class="c1"></span>    <span class="nx">nalloc</span> <span class="o">:=</span> <span class="nb">uint16</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">countAlloc</span><span class="p">())</span>
    <span class="nx">nfreed</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span> <span class="o">-</span> <span class="nx">nalloc</span>

    <span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span> <span class="p">=</span> <span class="nx">nalloc</span>
    <span class="nx">s</span><span class="p">.</span><span class="nx">freeindex</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// reset allocation index to start of span.
</span><span class="c1"></span>
    <span class="nx">s</span><span class="p">.</span><span class="nx">allocBits</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">gcmarkBits</span>
    <span class="nx">s</span><span class="p">.</span><span class="nx">gcmarkBits</span> <span class="p">=</span> <span class="nf">newMarkBits</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span><span class="p">)</span>

    <span class="nx">s</span><span class="p">.</span><span class="nf">refillAllocCache</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> 
    <span class="c1">// 设置 span.sweepgen 和 mheap.sweepgen 相等
</span><span class="c1"></span>    <span class="nx">atomic</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">.</span><span class="nx">sweepgen</span><span class="p">,</span> <span class="nx">sweepgen</span><span class="p">)</span>

    <span class="k">if</span> <span class="nx">spc</span><span class="p">.</span><span class="nf">sizeclass</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="c1">// 处理小对象的回收
</span><span class="c1"></span>        <span class="c1">// Handle spans for small objects.
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">nfreed</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span> 
            <span class="nx">s</span><span class="p">.</span><span class="nx">needzero</span> <span class="p">=</span> <span class="mi">1</span>
            <span class="nx">c</span><span class="p">.</span><span class="nx">local_nsmallfree</span><span class="p">[</span><span class="nx">spc</span><span class="p">.</span><span class="nf">sizeclass</span><span class="p">()]</span> <span class="o">+=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">nfreed</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">!</span><span class="nx">preserve</span> <span class="p">{</span> 
            <span class="k">if</span> <span class="nx">nalloc</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> 
                <span class="c1">// 直接释放 span 到堆中
</span><span class="c1"></span>                <span class="nx">mheap_</span><span class="p">.</span><span class="nf">freeSpan</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">true</span>
            <span class="p">}</span> 
            <span class="c1">// 将 span 释放到 mcentral 中
</span><span class="c1"></span>            <span class="k">if</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">nalloc</span><span class="p">)</span> <span class="o">==</span> <span class="nx">s</span><span class="p">.</span><span class="nx">nelems</span> <span class="p">{</span>
                <span class="nx">mheap_</span><span class="p">.</span><span class="nx">central</span><span class="p">[</span><span class="nx">spc</span><span class="p">].</span><span class="nx">mcentral</span><span class="p">.</span><span class="nf">fullSwept</span><span class="p">(</span><span class="nx">sweepgen</span><span class="p">).</span><span class="nf">push</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nx">mheap_</span><span class="p">.</span><span class="nx">central</span><span class="p">[</span><span class="nx">spc</span><span class="p">].</span><span class="nx">mcentral</span><span class="p">.</span><span class="nf">partialSwept</span><span class="p">(</span><span class="nx">sweepgen</span><span class="p">).</span><span class="nf">push</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">!</span><span class="nx">preserve</span> <span class="p">{</span> 
        <span class="c1">// 处理大对象的回收
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">nfreed</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="c1">// Free large object span to heap. 
</span><span class="c1"></span>            <span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">efence</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="nx">s</span><span class="p">.</span><span class="nx">limit</span> <span class="p">=</span> <span class="mi">0</span> <span class="c1">// prevent mlookup from finding this span
</span><span class="c1"></span>                <span class="nf">sysFault</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()),</span> <span class="nx">size</span><span class="p">)</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="c1">// 直接释放 span 到堆中
</span><span class="c1"></span>                <span class="nx">mheap_</span><span class="p">.</span><span class="nf">freeSpan</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="nx">c</span><span class="p">.</span><span class="nx">local_nlargefree</span><span class="o">++</span>
            <span class="nx">c</span><span class="p">.</span><span class="nx">local_largefree</span> <span class="o">+=</span> <span class="nx">size</span>
            <span class="k">return</span> <span class="kc">true</span>
        <span class="p">}</span>

        <span class="c1">// Add a large span directly onto the full+swept list.
</span><span class="c1"></span>        <span class="nx">mheap_</span><span class="p">.</span><span class="nx">central</span><span class="p">[</span><span class="nx">spc</span><span class="p">].</span><span class="nx">mcentral</span><span class="p">.</span><span class="nf">fullSwept</span><span class="p">(</span><span class="nx">sweepgen</span><span class="p">).</span><span class="nf">push</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="summary">Summary</h2>
<p>I only had a cursory understanding of the marker clearing algorithm when I was using java, but this is the first time I&rsquo;ve had a deeper understanding of the Go language&rsquo;s three-color algorithm, which has brought me tremendous benefits. It took me a long time to write this article because it is very much related to memory allocation and loop scheduling, so I had to understand the first two articles to understand the principle of GC.</p>
<p>Due to my own work and study time, I did not explain the code related to root marking very clearly, so if you are interested, you may want to study it from gcBgMarkWorker.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/golang/">golang</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-01/java-on-vs-code-2022-roadmap/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Microsoft Announces VSCode Java 2022 Roadmap</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-01/go-scheduling/">
            <span class="next-text nav-default">Signal-based preemptive scheduling in Go dissected from source code</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
