<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Three new concepts related to interfaces since Go 1.18 - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="The meaning of Go&amp;rsquo;s interfaces has changed since Go 1.18, and there are three new concepts related to Go interfaces that many people are not aware of: type set, specific type and structural type. type set The type set is called a type set and is a new concept added to Go 1.18 for those who follow Go generics. Unlike Java, which requires a class to be defined explicitly to" /><meta name="keywords" content="golang, Interface" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-01/three-new-concepts-of-go-interface-since-1-18/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Three new concepts related to interfaces since Go 1.18" />
<meta property="og:description" content="The meaning of Go&rsquo;s interfaces has changed since Go 1.18, and there are three new concepts related to Go interfaces that many people are not aware of: type set, specific type and structural type. type set The type set is called a type set and is a new concept added to Go 1.18 for those who follow Go generics. Unlike Java, which requires a class to be defined explicitly to" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-01/three-new-concepts-of-go-interface-since-1-18/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-01-18T13:48:39+08:00" />
<meta property="article:modified_time" content="2022-01-18T13:48:39+08:00" />

<meta itemprop="name" content="Three new concepts related to interfaces since Go 1.18">
<meta itemprop="description" content="The meaning of Go&rsquo;s interfaces has changed since Go 1.18, and there are three new concepts related to Go interfaces that many people are not aware of: type set, specific type and structural type. type set The type set is called a type set and is a new concept added to Go 1.18 for those who follow Go generics. Unlike Java, which requires a class to be defined explicitly to"><meta itemprop="datePublished" content="2022-01-18T13:48:39+08:00" />
<meta itemprop="dateModified" content="2022-01-18T13:48:39+08:00" />
<meta itemprop="wordCount" content="2356">
<meta itemprop="keywords" content="golang," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Three new concepts related to interfaces since Go 1.18"/>
<meta name="twitter:description" content="The meaning of Go&rsquo;s interfaces has changed since Go 1.18, and there are three new concepts related to Go interfaces that many people are not aware of: type set, specific type and structural type. type set The type set is called a type set and is a new concept added to Go 1.18 for those who follow Go generics. Unlike Java, which requires a class to be defined explicitly to"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Three new concepts related to interfaces since Go 1.18</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-01-18 13:48:39 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 2356 words </span>
          <span class="more-meta"> 5 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#type-set">type set</a></li>
        <li><a href="#specific-type-and-specific-type-set">specific type and specific type set</a></li>
        <li><a href="#type-set-vs-specific-type-set">type set vs specific type set</a></li>
        <li><a href="#application-of-specific-types">Application of specific types</a></li>
        <li><a href="#structural-type">structural type</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>The meaning of Go&rsquo;s interfaces has changed since Go 1.18, and there are three new concepts related to Go interfaces that many people are not aware of: <code>type set</code>, <code>specific type</code> and <code>structural type</code>.</p>
<h2 id="type-set">type set</h2>
<p>The type set is called a type set and is a new concept added to Go 1.18 for those who follow Go generics.</p>
<p>Unlike Java, which requires a class to be defined explicitly to implement an interface, Go does not require this. In Go, as long as a type implements all the methods defined by an interface, it implements that interface and can be assigned to variables of that interface type, or as real or return values of methods of that interface type, a design sometimes referred to as `duck typing'. As long as it walks like a duck and quacks like a duck, then it is a duck, which is a classic description of duck typing.</p>
<p>In Go 1.18, interfaces no longer represent a collection of methods, but a collection of types (type set). Whenever a type is in the type set of an interface, then we say that this type implements the interface. If the interface is used as a type constraint, then any element in the type set defined by the interface can instantiate the type parameter.</p>
<p>So, in effect, the Go language specification has had to redefine the meaning of interfaces in order to support the extension of interfaces as type constraints, which is why type collections have emerged.</p>
<p>In fact, the concept of an interface&rsquo;s method set is also in The method set of an interface is the <strong>intersection</strong> of the set of methods of all elements in the set of types of that interface.</p>
<p>rThis article assumes that you have some knowledge of Go generics. If you don&rsquo;t, you must know that Go 1.18 supports the inclusion of type elements in addition to the original method elements, which can be a type <code>T</code>, or an approximate type <code>~T</code>, or a union of them <code>int|int8|int16|int32|int64|~string</code>.</p>
<p>If an interface <code>I</code> is embedded in another interface <code>E</code>, then the type set of <code>I</code> is the intersection of the set of types it displays and the set of types of the embedded interface <code>E</code>. This is equivalent to <code>E</code> narrowing the type set of interface <code>I</code>.</p>
<p>How do you determine the type set of an interface? Follow these principles:</p>
<ul>
<li>The type set of an empty interface <code>any</code>, <code>interface{}</code> is the set of all types
So things like <code>int</code>, <code>string</code>, <code>strcut{}</code>, <code>MyStruct</code>, <code>func foobar()</code>, <code>chan int</code>, <code>map[int]string</code>, <code>[]int</code> and so on are in the set of types of the empty interface</li>
<li>The set of types of a non-empty interface is the intersection of the set of types of the interface elements
So what is the set of types of interface elements? See the following four articles.
We have already mentioned that interface elements contain type elements and method elements.
<ul>
<li>A method&rsquo;s type set is the set of all types that define the method, i.e. as long as the set of methods of a certain type contains the method, then it belongs to the method&rsquo;s type set
For example, if an interface has a method such as <code>String() string</code>, then all types that implement the method belong to the set of types defined by <code>String() string</code>, e.g. <code>net.IP</code>.</li>
<li>A collection of types that is not an interface type is a collection of types that contains only that type
For example, a type collection of <code>int</code> contains only one element like <code>int</code>.</li>
<li>The set of types of a close element <code>~T</code> is the set of all types whose underlying type is <code>T</code> e.g. <code>MyInt</code> in <code>type MyInt int</code> is the set of types of <code>~int</code></li>
<li>The set of types of the union element <code>t1|t2|...|tn</code> is the <strong>merge set</strong> of the set of types of these union elements</li>
</ul>
</li>
</ul>
<p>The following examples enumerate sets of types.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 这个集合的类型集合只有int这一种类型
</span><span class="c1"></span><span class="kd">interface</span> <span class="p">{</span>
	<span class="kt">int</span>
<span class="p">}</span>
<span class="c1">// 这个接口代表所有底层为int类型的所有类型
</span><span class="c1"></span><span class="kd">interface</span> <span class="p">{</span>
	<span class="err">~</span><span class="kt">int</span>
<span class="p">}</span>
<span class="c1">// 这个接口代表底层为int，并且实现了String方法的所有类型
</span><span class="c1"></span><span class="kd">interface</span> <span class="p">{</span>
	<span class="err">~</span><span class="kt">int</span>
	<span class="nf">String</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
<span class="c1">// 这个接口的类型集合是空集，因为不可能一个元素既是int又是string类型
</span><span class="c1"></span><span class="kd">interface</span> <span class="p">{</span>
	<span class="kt">int</span>
	<span class="kt">string</span>
<span class="p">}</span>
<span class="c1">// Floats代表所有底层是浮点数的类型 (底层为float32或者float64)
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Floats</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="err">~</span><span class="kt">float32</span> <span class="p">|</span> <span class="err">~</span><span class="kt">float64</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="specific-type-and-specific-type-set">specific type and specific type set</h2>
<p>Another important concept of an interface is <code>specific type</code>.</p>
<p>Only interfaces containing a type element define a specific type (which may be an empty type).</p>
<p>If not strictly speaking, specific types are those types that appear in the type elements defined in <code>T</code>, <code>~T</code>, <code>t1|t2|... |tn</code> in <code>t1</code>, <code>t2</code>, <code>... </code> , <code>tn</code> .</p>
<p>More precisely, for a given interface <code>I</code>, the set of specific types corresponds to the set of types represented by that interface <strong>𝑅</strong>, where <strong>𝑅</strong> is required to be non-empty and finite. Otherwise, if <strong>𝑅</strong> is empty or infinite, the interface has no specific type.</p>
<p>For a given interface, type element or type, the set of types it represents <strong>𝑅</strong> is defined as follows.</p>
<ul>
<li>For an interface without any type elements, its <strong>𝑅</strong> is all elements (infinite).
So it does not have a specific type.</li>
<li>If an interface has a type element, its <strong>𝑅</strong> is the intersection of the types represented by its elements
Whether or not it has a specific type depends on whether <strong>𝑅</strong> is non-empty and finite.</li>
<li>For a non-interface type <code>T</code>, or <code>~T</code>, its <strong>𝑅</strong> is the set containing the type <code>T</code></li>
<li>For a union element <code>t1|t2|...|tn</code> , its <strong>𝑅</strong> is the <strong>merge set</strong> of the types represented by these items</li>
</ul>
<p>Here is an example of a particular type:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Celsius</span> <span class="kt">float32</span>
<span class="kd">type</span> <span class="nx">Kelvin</span>  <span class="kt">float32</span>
<span class="kd">interface</span><span class="p">{}</span>                    <span class="c1">// 无限，所以没有特定类型
</span><span class="c1"></span><span class="kd">interface</span><span class="p">{</span> <span class="kt">int</span> <span class="p">}</span>               <span class="c1">// 特定类型是int
</span><span class="c1"></span><span class="kd">interface</span><span class="p">{</span> <span class="err">~</span><span class="kt">string</span> <span class="p">}</span>           <span class="c1">// 特定类型是string
</span><span class="c1"></span><span class="kd">interface</span><span class="p">{</span> <span class="kt">int</span><span class="p">|</span><span class="err">~</span><span class="kt">string</span> <span class="p">}</span>       <span class="c1">// 特定类型是int, string
</span><span class="c1"></span><span class="kd">interface</span><span class="p">{</span> <span class="nx">Celsius</span><span class="p">|</span><span class="nx">Kelvin</span> <span class="p">}</span>    <span class="c1">// 特定类型是Celsius, Kelvin
</span><span class="c1"></span><span class="kd">interface</span><span class="p">{</span> <span class="kt">float64</span><span class="p">|</span><span class="nx">any</span> <span class="p">}</span>       <span class="c1">// 没有特定类型，因为联合类型的代表类型是无限的
</span><span class="c1"></span><span class="kd">interface</span><span class="p">{</span> <span class="kt">int</span><span class="p">;</span> <span class="nf">m</span><span class="p">()</span> <span class="p">}</span>          <span class="c1">// 特定类型是int
</span><span class="c1"></span><span class="kd">interface</span><span class="p">{</span> <span class="err">~</span><span class="kt">int</span><span class="p">;</span> <span class="nf">m</span><span class="p">()</span> <span class="p">}</span>         <span class="c1">// 特定类型是int
</span><span class="c1"></span><span class="kd">interface</span><span class="p">{</span> <span class="kt">int</span><span class="p">;</span> <span class="nx">any</span> <span class="p">}</span>          <span class="c1">// 特定类型是int，int和any的交集
</span><span class="c1"></span><span class="kd">interface</span><span class="p">{</span> <span class="kt">int</span><span class="p">;</span> <span class="kt">string</span> <span class="p">}</span>       <span class="c1">// 没有特定类型
</span></code></pre></td></tr></table>
</div>
</div><h2 id="type-set-vs-specific-type-set">type set vs specific type set</h2>
<p>There is a difference between a type set and a specific type set, as can be seen from their definitions above.</p>
<p><strong>An interface may have a specific type set that is not empty, even if the type is empty.</strong>
For example, <code>interface{ int; m() }</code> , its type set is empty (int does not implement the m method), but its specific type is <code>int</code> .</p>
<p><strong>An interface may have an infinite set of types even if it has a finite number of specific types</strong>
For example, <code>interface{ ~int; m() }</code> , its specific type is int, but its set of types is infinite (any type that has an underlying int and implements method m is part of its set of types).</p>
<p>So what is the point of defining a specific type?</p>
<h2 id="application-of-specific-types">Application of specific types</h2>
<p>Specific types are used to determine whether a type argument supports indexing, such as <code>a[x]</code>.</p>
<p>For example, an expression <code>a[x]</code> , an instance of <code>a</code> could be of type array, pointer to an array, slice, string, map.</p>
<p>If the type of <code>a</code> is that of the type parameter <code>P</code>, under what conditions will our code <code>a[x]</code> not compile with an error?</p>
<p>The required conditions would be related to the specific type.</p>
<ul>
<li>P must be of a particular type</li>
<li>the indexing of <code>a[x]</code> is supported for the value a of a particular type of P</li>
<li>All specific types of P must be the same. In this case, the element type of the string type is byte (<a href="https://github.com/golang/go/issues/49551">https://github.com/golang/go/issues/49551</a>)</li>
<li>If the specific type of P contains the type map, then all of its specific types must be map, and all of its keys must be of the same type
So sometimes if you define a joint element interface with map, slice, string, you can&rsquo;t use the <code>a[x]</code> index type for instances of this interface, the elements are all of type int</li>
<li><code>a[x]</code> is an element of array, slice, string with index x, or an element of type map with key x. The type of a<input checked="" disabled="" type="checkbox"> must be the same</li>
<li>if the specific type of P contains the string type, then <code>a[x]</code> cannot be assigned to it (strings are immutable)</li>
</ul>
<p>The specific type is also used on the type conversion definition.
For a variable <code>x</code>, if its type is <code>V</code> and the type to be converted is <code>T</code>, x can be converted to type <code>T</code> provided that the following clause is satisfied:</p>
<ul>
<li>every value of a particular type of <code>V</code> can be converted to every particular type of <code>T</code></li>
<li>only if <code>V</code> is a type parameter and <code>T</code> is not, then every value of a particular type of <code>V</code> can be converted to <code>T</code></li>
<li>only if <code>T</code> is a type parameter, <code>x</code> can be converted to every specific type of T</li>
</ul>
<p>In a nutshell, every specific type is satisfied if it is a type parameter, and this type is satisfied if it is not.</p>
<p>Also, for type arguments to call the built-in functions <code>len</code>, <code>cap</code>, their specific types must be required to allow the use of these built-in functions.</p>
<h2 id="structural-type">structural type</h2>
<p>For an interface <code>T</code> to be structural, one of the following conditions must be satisfied:</p>
<ul>
<li>there exists a single type <code>U</code>, which is the same underlying type as every element in the type set of <code>T</code></li>
<li>the set of types of <code>T</code> contains only chan types, and their element types are all <code>E</code> , and all chans have the same orientation (not necessarily identical)</li>
</ul>
<p>A structured type contains a structure type which, depending on the conditions above, may be:</p>
<ul>
<li>type <code>U</code> , or</li>
<li>if <code>T</code> contains only bidirectional chan, the structure type is <code>chan E</code> , otherwise it may be <code>chan&lt;- E</code> or <code>&lt;-chan E</code></li>
</ul>
<p>The following is a structured interface containing structure types:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">interface</span><span class="p">{</span> <span class="kt">int</span> <span class="p">}</span>                          <span class="c1">// 结构类型为 int
</span><span class="c1"></span><span class="kd">interface</span><span class="p">{</span> <span class="nx">Celsius</span><span class="p">|</span><span class="nx">Kelvin</span> <span class="p">}</span>               <span class="c1">// 结构类型为 float32
</span><span class="c1"></span><span class="kd">interface</span><span class="p">{</span> <span class="err">~</span><span class="kd">chan</span> <span class="kt">int</span> <span class="p">}</span>                    <span class="c1">// 结构类型为 chan int
</span><span class="c1"></span><span class="kd">interface</span><span class="p">{</span> <span class="err">~</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">|</span><span class="err">~</span><span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">int</span> <span class="p">}</span>        <span class="c1">// 结构类型为 chan&lt;- int
</span><span class="c1"></span><span class="kd">interface</span><span class="p">{</span> <span class="err">~</span><span class="p">[]</span><span class="o">*</span><span class="nx">data</span><span class="p">;</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">}</span>    <span class="c1">// 结构类型为 *data
</span><span class="c1">// 下面的例子不包含结构类型，所以是非结构化接口
</span><span class="c1"></span><span class="kd">interface</span><span class="p">{}</span>                               <span class="c1">// 没有固定单一的底层类型
</span><span class="c1"></span><span class="kd">interface</span><span class="p">{</span> <span class="nx">Celsius</span><span class="p">|</span><span class="kt">float64</span> <span class="p">}</span>              <span class="c1">// 底层类型不相同
</span><span class="c1"></span><span class="kd">interface</span><span class="p">{</span> <span class="kd">chan</span> <span class="kt">int</span> <span class="p">|</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">string</span> <span class="p">}</span>     <span class="c1">// channel的元素类型不相同
</span><span class="c1"></span><span class="kd">interface</span><span class="p">{</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">int</span> <span class="p">|</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">int</span> <span class="p">}</span>      <span class="c1">// channel没有相同的方向
</span></code></pre></td></tr></table>
</div>
</div><p>The Go language specification doesn&rsquo;t have much more to say about the structured interface and how to use it, it&rsquo;s more about it getting the underlying structural type internally and doing type checking, like the example below which throws a <code>no structural type</code> compiler error:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">myByte1</span> <span class="p">[]</span><span class="kt">byte</span>
<span class="kd">func</span> <span class="nx">_</span><span class="p">[</span><span class="nx">T</span> <span class="kd">interface</span><span class="p">{</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">|</span> <span class="nx">myByte1</span> <span class="p">|</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">}]</span> <span class="p">(</span><span class="nx">x</span> <span class="nx">T</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">,</span> <span class="nx">k</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> 
    <span class="kd">var</span> <span class="nx">_</span> <span class="nx">T</span> <span class="p">=</span> <span class="nx">x</span><span class="p">[</span><span class="nx">i</span><span class="p">:</span><span class="nx">j</span><span class="p">:</span><span class="nx">k</span><span class="p">]</span> <span class="c1">// 底层类型不一致
</span><span class="c1"></span><span class="p">}</span>
<span class="kd">func</span> <span class="nx">_</span><span class="p">[</span><span class="nx">T</span> <span class="kd">interface</span><span class="p">{</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">|</span> <span class="nx">myByte1</span> <span class="p">|</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">|</span> <span class="kt">string</span> <span class="p">}]</span> <span class="p">(</span><span class="nx">x</span> <span class="nx">T</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">,</span> <span class="nx">k</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> 
    <span class="kd">var</span> <span class="nx">_</span> <span class="nx">T</span> <span class="p">=</span> <span class="nx">x</span><span class="p">[</span><span class="nx">i</span><span class="p">:</span><span class="nx">j</span><span class="p">]</span> 
<span class="p">}</span>
<span class="c1">// 下面这个函数没问题，因为string的底层页被看做[]byte
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">_</span><span class="p">[</span><span class="nx">T</span> <span class="kd">interface</span><span class="p">{</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">|</span> <span class="nx">myByte1</span> <span class="p">|</span> <span class="nx">myByte2</span> <span class="p">|</span> <span class="kt">string</span> <span class="p">}]</span> <span class="p">(</span><span class="nx">x</span> <span class="nx">T</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">,</span> <span class="nx">k</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> 
    <span class="kd">var</span> <span class="nx">_</span> <span class="nx">T</span> <span class="p">=</span> <span class="nx">x</span><span class="p">[</span><span class="nx">i</span><span class="p">:</span><span class="nx">j</span><span class="p">]</span> 
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The following code also throws a <code>M has no structural type</code> compiler error</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">multiMapOfInt</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span> <span class="p">|</span> <span class="kd">map</span><span class="p">[</span><span class="kt">float64</span><span class="p">]</span><span class="kt">int</span> <span class="p">|</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span> <span class="p">|</span> <span class="kd">map</span><span class="p">[</span><span class="kt">complex64</span><span class="p">]</span><span class="kt">int</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nx">arraySummer</span><span class="p">[</span><span class="nx">M</span> <span class="nx">multiMapOfInt</span><span class="p">](</span><span class="nx">mp</span> <span class="nx">M</span><span class="p">)</span> <span class="p">(</span><span class="nx">sum</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">mp</span> <span class="p">{</span>
		<span class="nx">sum</span> <span class="o">+=</span> <span class="nx">v</span>
	<span class="p">}</span>
	<span class="k">return</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>For example, the following mistake is often made when using Go generics, although <code>[]byte</code>, <code>map[int]byte</code> and <code>string</code> can all range, and the key(index) and value types are the same, it also throws the error <code>R has no structural type</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
<span class="kd">type</span> <span class="nx">rangeType</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="p">[]</span><span class="kt">byte</span> <span class="p">|</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">byte</span> <span class="p">|</span> <span class="kt">string</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nx">rangeIt</span><span class="p">[</span><span class="nx">R</span> <span class="nx">rangeType</span><span class="p">](</span><span class="nx">r</span> <span class="nx">R</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">r</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">rangeIt</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">byte</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">3</span><span class="p">})</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div>
    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/golang/">golang</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-01/python-asyncio/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Understanding python asynchronous programming and simple implementation of asyncio</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-01/timingwheel/">
            <span class="next-text nav-default">Time Wheel for Timed Tasks</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
