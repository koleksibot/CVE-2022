<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Iptables And Docker Container Network Analysis - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="This article is only for ipv4 networks This article first introduces the basic concept and common commands of iptables, and then analyzes how docker/podman is a standalone container network implemented with iptables and Linux virtual network interface. iptables iptables provides packet filtering, NAT and other packet handling capabilities. iptables is most used in firewall and NAT scenarios. Both iptables and the new nftables are based on netfilter and are subprojects" /><meta name="keywords" content="iptables, docker" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-01/iptables-and-container-networks/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Iptables And Docker Container Network Analysis" />
<meta property="og:description" content="This article is only for ipv4 networks This article first introduces the basic concept and common commands of iptables, and then analyzes how docker/podman is a standalone container network implemented with iptables and Linux virtual network interface. iptables iptables provides packet filtering, NAT and other packet handling capabilities. iptables is most used in firewall and NAT scenarios. Both iptables and the new nftables are based on netfilter and are subprojects" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-01/iptables-and-container-networks/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-01-08T13:49:27+08:00" />
<meta property="article:modified_time" content="2022-01-08T13:49:27+08:00" />

<meta itemprop="name" content="Iptables And Docker Container Network Analysis">
<meta itemprop="description" content="This article is only for ipv4 networks This article first introduces the basic concept and common commands of iptables, and then analyzes how docker/podman is a standalone container network implemented with iptables and Linux virtual network interface. iptables iptables provides packet filtering, NAT and other packet handling capabilities. iptables is most used in firewall and NAT scenarios. Both iptables and the new nftables are based on netfilter and are subprojects"><meta itemprop="datePublished" content="2022-01-08T13:49:27+08:00" />
<meta itemprop="dateModified" content="2022-01-08T13:49:27+08:00" />
<meta itemprop="wordCount" content="6486">
<meta itemprop="keywords" content="iptables,docker," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Iptables And Docker Container Network Analysis"/>
<meta name="twitter:description" content="This article is only for ipv4 networks This article first introduces the basic concept and common commands of iptables, and then analyzes how docker/podman is a standalone container network implemented with iptables and Linux virtual network interface. iptables iptables provides packet filtering, NAT and other packet handling capabilities. iptables is most used in firewall and NAT scenarios. Both iptables and the new nftables are based on netfilter and are subprojects"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Iptables And Docker Container Network Analysis</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-01-08 13:49:27 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 6486 words </span>
          <span class="more-meta"> 13 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#iptables">iptables</a></li>
        <li><a href="#iptables-basic-concepts---four-tables-and-five-chains">iptables Basic Concepts - Four Tables and Five Chains</a></li>
        <li><a href="#common-commands">Common Commands</a></li>
        <li><a href="#conntrack-connection-tracing-and-nat">conntrack connection tracing and NAT</a>
          <ul>
            <li><a href="#actual-test-conntrack">Actual test conntrack</a></li>
            <li><a href="#how-does-nat-assign-ports">How does NAT assign ports?</a></li>
          </ul>
        </li>
        <li><a href="#how-to-persist-the-iptables-configuration">How to persist the iptables configuration</a></li>
        <li><a href="#how-to-implement-a-container-network-using-iptables--bridge--veth">How to implement a container network using iptables + bridge + veth</a>
          <ul>
            <li><a href="#running-containers-via-docker-run">Running containers via docker run</a></li>
          </ul>
        </li>
        <li><a href="#macvlanipvlan-mode-for-dockerpodman">macvlan/ipvlan mode for Docker/Podman</a></li>
        <li><a href="#network-implementation-for-rootless-containers">Network implementation for Rootless containers</a></li>
        <li><a href="#nftables">nftables</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <blockquote>
<p>This article is only for ipv4 networks</p>
</blockquote>
<p>This article first introduces the basic concept and common commands of iptables, and then analyzes how docker/podman is a standalone container network implemented with iptables and Linux virtual network interface.</p>
<h2 id="iptables">iptables</h2>
<p><a href="https://www.netfilter.org/projects/iptables/index.html">iptables</a> provides packet filtering, NAT and other packet handling capabilities. iptables is most used in firewall and NAT scenarios.</p>
<p>Both iptables and the new nftables are based on netfilter and are subprojects of netfilter.</p>
<p>But the eBPF community is currently working on a new project designed to replace netfilter, bpfilter, and one of their goals is to be compatible with iptables/nftables rules, so let&rsquo;s wait and see.</p>
<h2 id="iptables-basic-concepts---four-tables-and-five-chains">iptables Basic Concepts - Four Tables and Five Chains</h2>
<blockquote>
<p>There is actually a security table related to SELinux (I think it was added in a newer kernel, but it is not clear which version), but I have not touched it, so I skipped it.</p>
</blockquote>
<p>By default, iptables provides four tables (not considering security) and five chains, and the data processing flow in these four tables and five chains is shown in the following diagram.</p>
<blockquote>
<p>In this introduction, we can ignore the links in the link layer layer of the diagram for now, it belongs to the ebtables category. In addition, <code>conntrack</code> is also ignored for now, and the function of conntrack will be introduced in detail in the next sub-section.</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/08/f0cc7f1b175b4fc281f1fee7a7d75fcb.png" alt="image"></p>
<p>Comparing the above diagram, for data sent to a particular user-level program, the traffic sequence is as follows.</p>
<ul>
<li>First into the PREROUTING chain, which goes through these three tables in order: raw -&gt; mangle -&gt; nat</li>
<li>Then it enters the INPUT chain, which also has three tables, and the processing order is: mangle -&gt; nat -&gt; filter</li>
<li>After passing through the INPUT chain, the data enters the kernel stack and finally reaches the user layer program.</li>
</ul>
<p>The messages sent by the user layer programs go through these tables in order: OUTPUT -&gt; POSTROUTING</p>
<p>It is also easy to see from the diagram that if the data dst ip is not the ip of any of the local interfaces, then the chains it passes through are: PREROUTEING -&gt; FORWARD -&gt; POSTROUTING</p>
<p>The functions and names of the five chains are identical and should be easy to understand. The four tables in the chain are described below in order of priority.</p>
<ul>
<li>raw: Processing of received packets before connection tracking. Generally not used and can be ignored
<ul>
<li>Once the user has used the RAW table, the NAT table and ip_conntrack processing will be skipped after the RAW table is processed, i.e., no more address translation and packet link tracking will be done.</li>
</ul>
</li>
<li>mangle: Used to modify messages, tag messages</li>
<li>nat: mainly used to do network address translation, SNAT or DNAT</li>
<li>filter: mainly used to filter packets</li>
</ul>
<p>Once a rule A is matched in a table, the next processing rule is specified by the target parameter of rule A. All subsequent tables** are ignored. targets are of the following types.</p>
<ul>
<li>ACCEPT: Directly allow packets to pass</li>
<li>DROP: Discard packets directly, which means 100% packet loss for the program</li>
<li>This is more friendly to the program, but there are security risks, so it is usually not used.</li>
<li>MASQUERADE: (Masquerade) rewrites src ip to NIC ip, the difference with SNAT is that it automatically reads NIC ip. Required for routing devices.</li>
<li>SNAT/DNAT: As the name implies, does network address translation.</li>
<li>REDIRECT: Do port mapping on local machine.</li>
<li>LOG: Record log information in /var/log/messages file, then pass the packet to the next rule, that is, do not do anything to the packet other than logging, still let the next rule to match.
<ul>
<li>Only this target is special in that the data matching it can still match the next rule and will not be skipped.</li>
</ul>
</li>
<li>Other types, you can check when you need them.</li>
</ul>
<p>After understanding the above diagram and the purpose of the four tables, it is easy to understand the iptables command.</p>
<h2 id="common-commands">Common Commands</h2>
<blockquote>
<p><strong>Note</strong> : The changes made by the iptables command provided below are unpersistent and will be lost upon reboot! The method of persistent configuration will be briefly described in the next section.</p>
</blockquote>
<p>Command Format.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">iptables <span class="o">[</span>-t table<span class="o">]</span> <span class="o">{</span>-A<span class="p">|</span>-C<span class="p">|</span>-D<span class="o">}</span> chain <span class="o">[</span>-m matchname <span class="o">[</span>per-match-options<span class="o">]]</span> -j targetname <span class="o">[</span>per-target-options<span class="o">]</span>
</code></pre></td></tr></table>
</div>
</div><p>The table defaults to the <code>filter</code> table, but it feels like the INPUT table is actually used most by system administrators to set up the firewall.</p>
<p>The following is a brief description of adding and modifying rules on the INPUT table to set up the firewall.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># --add 允许 80 端口通过</span>
iptables -A INPUT -p tcp --dport <span class="m">80</span> -j ACCEPT

<span class="c1"># --list-rules 查看所有规则</span>
iptables -S

<span class="c1"># --list-rules 查看 INPUT 表中的所有规则</span>
iptables -S INPUT
<span class="c1"># 查看 iptables 中的所有规则（比 -L 更详细）</span>

<span class="c1"># ---delete 通过编号删除规则</span>
iptables -D <span class="m">1</span>
<span class="c1"># 或者通过完整的规则参数来删除规则</span>
iptables -D INPUT -p tcp --dport <span class="m">80</span> -j ACCEPT

<span class="c1"># --replace 通过编号来替换规则内容</span>
iptables -R INPUT <span class="m">1</span> -s 192.168.0.1 -j DROP

<span class="c1"># --insert 在指定的位置插入规则，可类比链表的插入</span>
iptables -I INPUT <span class="m">1</span> -p tcp --dport <span class="m">80</span> -j ACCEPT

<span class="c1"># 在匹配条件前面使用感叹号表示取反</span>
<span class="c1"># 如下规则表示接受所有来自 docker0，但是目标接口不是 docker0 的流量</span>
iptables -A FORWARD -i docker0 ! -o docker0 -j ACCEPT

<span class="c1"># --policy 设置某个链的默认规则</span>
<span class="c1"># 很多系统管理员会习惯将连接公网的服务器，默认规则设为 DROP，提升安全性，避免错误地开放了端口。</span>
<span class="c1"># 但是也要注意，默认规则设为 DROP 前，一定要先把允许 ssh 端口的规则加上，否则就尴尬了。</span>
iptables -P INPUT DROP

<span class="c1"># --flush 清空 INPUT 表上的所有规则</span>
iptables -F INPUT
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>For the rest of the analysis, it is assumed that the user is already familiar with linux bridge, veth, and other virtual network interfaces.</p>
</blockquote>
<h2 id="conntrack-connection-tracing-and-nat">conntrack connection tracing and NAT</h2>
<p>In between the conntrack talk, let&rsquo;s review the netfilter data processing flowchart given earlier.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/08/f0cc7f1b175b4fc281f1fee7a7d75fcb.png" alt="image"></p>
<p>In the previous section we ignored the conntrack in the diagram, which is the star of this section - the connection tracking module of netfilter.</p>
<p>The flowchart above shows that conntrack takes effect after the raw chain of PREROUTEING and OUTPUT tables.</p>
<p>The following is an example of the default bridge network of docker to introduce the function of conntrack.</p>
<p>First, here is the docker0 network architecture I gave in the article &ldquo;Virtual Network Interfaces for Linux&rdquo;:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">+-----------------------------------------------+-----------------------------------+-----------------------------------+
|                      Host                     |           Container A             |           Container B             |
|                                               |                                   |                                   |
|   +---------------------------------------+   |    +-------------------------+    |    +-------------------------+    |
|   |       Network Protocol Stack          |   |    |  Network Protocol Stack |    |    |  Network Protocol Stack |    |
|   +----+-------------+--------------------+   |    +-----------+-------------+    |    +------------+------------+    |
|        ^             ^                        |                ^                  |                 ^                 |
|........|.............|........................|................|..................|.................|.................|
|        v             v  ↓                     |                v                  |                 v                 |
|   +----+----+  +-----+------+                 |          +-----+-------+          |           +-----+-------+         |
|   | .31.101 |  | 172.17.0.1 |      +------+   |          | 172.17.0.2  |          |           |  172.17.0.3 |         |
|   +---------+  +-------------&lt;----&gt;+ veth |   |          +-------------+          |           +-------------+         |
|   |  eth0   |  |   docker0  |      +--+---+   |          | eth0(veth)  |          |           | eth0(veth)  |         |
|   +----+----+  +-----+------+         ^       |          +-----+-------+          |           +-----+-------+         |
|        ^             ^                |       |                ^                  |                 ^                 |
|        |             |                +------------------------+                  |                 |                 |
|        |             v                        |                                   |                 |                 |
|        |          +--+---+                    |                                   |                 |                 |
|        |          | veth |                    |                                   |                 |                 |
|        |          +--+---+                    |                                   |                 |                 |
|        |             ^                        |                                   |                 |                 |
|        |             +------------------------------------------------------------------------------+                 |
|        |                                      |                                   |                                   |
|        |                                      |                                   |                                   |
+-----------------------------------------------+-----------------------------------+-----------------------------------+
         v
    Physical Network  (192.168.31.0/24)

</code></pre></td></tr></table>
</div>
</div><p>docker adds the following rules to iptables for the docker0 bridge.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">-t nat -A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE

-t filter -P DROP
-t filter -A FORWARD -o docker0 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
</code></pre></td></tr></table>
</div>
</div><p>These lines enable the docker container to access the external network properly. <code>MASQUERADE</code> automatically does a <code>SNAT</code> to replace src ip with the egress NIC&rsquo;s ip when requesting outbound access. This allows the packets to exit the network properly, and the packets returned by the other side now go back to the egress NIC properly.</p>
<p>Now the question arises: <strong>Can the egress NIC receive the returned packets and then forward them to the original source of the data, a docker container</strong>? Does docker additionally add a dst ip reverse translation rule that corresponds to MASQUERADE?</p>
<p>In fact, this step relies on the conntrack connection tracking feature provided by iptables, which is described in detail in the &ldquo;Reference&rdquo; article.</p>
<p>The contribution of conntrack to NAT is that when doing NAT conversion, there is no need to manually add additional rules to perform <strong>reverse conversion</strong> to enable bidirectional data transfer. netfilter/conntrack system will record the connection status of NAT, and the reverse conversion of NAT addresses is done automatically based on this status.</p>
<p>For example, in the above figure, <code>Container A</code> initiates N connections to baidu.com through the bridge network, and then the data is processed as follows.</p>
<ul>
<li>First, the packet sent by <code>Container A</code> is processed by MASQUERADE rule, replacing src ip with eth0 ip, and then sent to physical network <code>192..168.31.0/24</code>.
<ul>
<li>The conntrack system records the status of this connection before and after it is processed by NAT, and sets its status to NEW, indicating that it is a newly initiated connection</li>
</ul>
</li>
<li>The packet returned by the other side baidu.com will reach the eth0 NIC first.</li>
<li>conntrack checks the table and finds that the connection returning the packet is already recorded in the table and its status is NEW, so it changes the status of the connection to ESTABLISHED and changes the dst_ip to <code>172.17.0.2</code> and sends it out
<ul>
<li>Note that this has nothing to do with ESTABLISHED of tcp</li>
</ul>
</li>
<li>After the route matching, the packet will enter docker0, and then match the iptables rule: <code>-t filter -A FORWARD -o docker0 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT</code>, the data will be released directly.</li>
<li>The data goes through veth and ends up in <code>Container A</code> and is handed over to the container&rsquo;s kernel stack for processing.</li>
<li>The data is sent by <code>Container A</code>&rsquo;s kernel stack to the &ldquo;application that initiated the connection&rdquo;.</li>
</ul>
<h3 id="actual-test-conntrack">Actual test conntrack</h3>
<p>Now let&rsquo;s actually test to see if this is the case.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 使用 tcpdump 分别在出口网卡 wlp4s0 （相当于 eth0）和 dcoker0 网桥上抓包，后面会用来分析</span>
❯ sudo tcpdump -i wlp4s0 -n &gt; wlp4s0.dump   <span class="c1"># 窗口一，抓 wlp4s0 的包</span>
❯ sudo tcpdump -i docker0 -n &gt; docker0.dump  <span class="c1"># 窗口二，抓 docker0 的包</span>
</code></pre></td></tr></table>
</div>
</div><p>Now create a new window three, start a container, and download a video file at low speed via the curl command.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">❯ docker run --rm --name curl -it curlimages/curl <span class="s2">&#34;https://media.w3.org/2010/05/sintel/trailer.mp4&#34;</span> -o /tmp/video.mp4 --limit-rate 100k
</code></pre></td></tr></table>
</div>
</div><p>Then create a new window four and check the conntrack status on the host</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">❯ sudo zypper in conntrack-tools  <span class="c1"># 这个记得先提前安装好</span>
❯ sudo conntrack -L <span class="p">|</span> grep 172.17
<span class="c1"># curl 通过 NAT 网络发起了一个 dns 查询请求，DNS 服务器是网关上的 192.168.31.1</span>
udp      <span class="m">17</span> <span class="m">22</span> <span class="nv">src</span><span class="o">=</span>172.17.0.4 <span class="nv">dst</span><span class="o">=</span>192.168.31.1 <span class="nv">sport</span><span class="o">=</span><span class="m">59423</span> <span class="nv">dport</span><span class="o">=</span><span class="m">53</span> <span class="nv">src</span><span class="o">=</span>192.168.31.1 <span class="nv">dst</span><span class="o">=</span>192.168.31.228 <span class="nv">sport</span><span class="o">=</span><span class="m">53</span> <span class="nv">dport</span><span class="o">=</span><span class="m">59423</span> <span class="o">[</span>ASSURED<span class="o">]</span> <span class="nv">mark</span><span class="o">=</span><span class="m">0</span> <span class="nv">use</span><span class="o">=</span><span class="m">1</span>
<span class="c1"># curl 通过 NAT 网络向 media.w3.org 发起了 tcp 连接</span>
tcp      <span class="m">6</span> <span class="m">298</span> ESTABLISHED <span class="nv">src</span><span class="o">=</span>172.17.0.4 <span class="nv">dst</span><span class="o">=</span>198.18.5.130 <span class="nv">sport</span><span class="o">=</span><span class="m">54636</span> <span class="nv">dport</span><span class="o">=</span><span class="m">443</span> <span class="nv">src</span><span class="o">=</span>198.18.5.130 <span class="nv">dst</span><span class="o">=</span>192.168.31.228 <span class="nv">sport</span><span class="o">=</span><span class="m">443</span> <span class="nv">dport</span><span class="o">=</span><span class="m">54636</span> <span class="o">[</span>ASSURED<span class="o">]</span> <span class="nv">mark</span><span class="o">=</span><span class="m">0</span> <span class="nv">use</span><span class="o">=</span><span class="m">1</span>
</code></pre></td></tr></table>
</div>
</div><p>Wait for the curl command to run for 10 seconds or so, then close all windows and applications, and proceed with the data analysis.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"># 前面查到的，本地发起请求的端口是 54636，下面以此为过滤条件查询数据

# 首先查询 wlp4s0/eth0 进来的数据，可以看到本机的 dst_ip 为 192.168.31.228.54636
❯ cat wlp4s0.dump | grep 54636 | head -n 15
18:28:28.349321 IP 192.168.31.228.54636 &gt; 198.18.5.130.443: Flags [S], seq 750859357, win 64240, options [mss 1460,sackOK,TS val 3365688110 ecr 0,nop,wscale 7], length 0
18:28:28.350757 IP 198.18.5.130.443 &gt; 192.168.31.228.54636: Flags [S.], seq 2381759932, ack 750859358, win 28960, options [mss 1460,sackOK,TS val 22099541 ecr 3365688110,nop,wscale 5], length 0
18:28:28.350814 IP 192.168.31.228.54636 &gt; 198.18.5.130.443: Flags [.], ack 1, win 502, options [nop,nop,TS val 3365688111 ecr 22099541], length 0
18:28:28.357345 IP 192.168.31.228.54636 &gt; 198.18.5.130.443: Flags [P.], seq 1:518, ack 1, win 502, options [nop,nop,TS val 3365688118 ecr 22099541], length 517
18:28:28.359253 IP 198.18.5.130.443 &gt; 192.168.31.228.54636: Flags [.], ack 518, win 939, options [nop,nop,TS val 22099542 ecr 3365688118], length 0
18:28:28.726544 IP 198.18.5.130.443 &gt; 192.168.31.228.54636: Flags [P.], seq 1:2622, ack 518, win 939, options [nop,nop,TS val 22099579 ecr 3365688118], length 2621
18:28:28.726616 IP 192.168.31.228.54636 &gt; 198.18.5.130.443: Flags [.], ack 2622, win 482, options [nop,nop,TS val 3365688487 ecr 22099579], length 0
18:28:28.727652 IP 192.168.31.228.54636 &gt; 198.18.5.130.443: Flags [P.], seq 518:598, ack 2622, win 501, options [nop,nop,TS val 3365688488 ecr 22099579], length 80
18:28:28.727803 IP 192.168.31.228.54636 &gt; 198.18.5.130.443: Flags [P.], seq 598:644, ack 2622, win 501, options [nop,nop,TS val 3365688488 ecr 22099579], length 46
18:28:28.727828 IP 192.168.31.228.54636 &gt; 198.18.5.130.443: Flags [P.], seq 644:693, ack 2622, win 501, options [nop,nop,TS val 3365688488 ecr 22099579], length 49
18:28:28.727850 IP 192.168.31.228.54636 &gt; 198.18.5.130.443: Flags [P.], seq 693:728, ack 2622, win 501, options [nop,nop,TS val 3365688488 ecr 22099579], length 35
18:28:28.727875 IP 192.168.31.228.54636 &gt; 198.18.5.130.443: Flags [P.], seq 728:812, ack 2622, win 501, options [nop,nop,TS val 3365688488 ecr 22099579], length 84
18:28:28.729241 IP 198.18.5.130.443 &gt; 192.168.31.228.54636: Flags [.], ack 598, win 939, options [nop,nop,TS val 22099579 ecr 3365688488], length 0
18:28:28.729245 IP 198.18.5.130.443 &gt; 192.168.31.228.54636: Flags [.], ack 644, win 939, options [nop,nop,TS val 22099579 ecr 3365688488], length 0
18:28:28.729247 IP 198.18.5.130.443 &gt; 192.168.31.228.54636: Flags [.], ack 693, win 939, options [nop,nop,TS val 22099579 ecr 3365688488], length 0


# 然后再查询 docker0 上的数据，能发现本地的地址为 172.17.0.4.54636
❯ cat docker0.dump | grep 54636 | head -n 20
18:28:28.349299 IP 172.17.0.4.54636 &gt; 198.18.5.130.443: Flags [S], seq 750859357, win 64240, options [mss 1460,sackOK,TS val 3365688110 ecr 0,nop,wscale 7], length 0
18:28:28.350780 IP 198.18.5.130.443 &gt; 172.17.0.4.54636: Flags [S.], seq 2381759932, ack 750859358, win 28960, options [mss 1460,sackOK,TS val 22099541 ecr 3365688110,nop,wscale 5], length 0
18:28:28.350812 IP 172.17.0.4.54636 &gt; 198.18.5.130.443: Flags [.], ack 1, win 502, options [nop,nop,TS val 3365688111 ecr 22099541], length 0
18:28:28.357328 IP 172.17.0.4.54636 &gt; 198.18.5.130.443: Flags [P.], seq 1:518, ack 1, win 502, options [nop,nop,TS val 3365688118 ecr 22099541], length 517
18:28:28.359281 IP 198.18.5.130.443 &gt; 172.17.0.4.54636: Flags [.], ack 518, win 939, options [nop,nop,TS val 22099542 ecr 3365688118], length 0
18:28:28.726578 IP 198.18.5.130.443 &gt; 172.17.0.4.54636: Flags [P.], seq 1:2622, ack 518, win 939, options [nop,nop,TS val 22099579 ecr 3365688118], length 2621
18:28:28.726610 IP 172.17.0.4.54636 &gt; 198.18.5.130.443: Flags [.], ack 2622, win 482, options [nop,nop,TS val 3365688487 ecr 22099579], length 0
18:28:28.727633 IP 172.17.0.4.54636 &gt; 198.18.5.130.443: Flags [P.], seq 518:598, ack 2622, win 501, options [nop,nop,TS val 3365688488 ecr 22099579], length 80
18:28:28.727798 IP 172.17.0.4.54636 &gt; 198.18.5.130.443: Flags [P.], seq 598:644, ack 2622, win 501, options [nop,nop,TS val 3365688488 ecr 22099579], length 46
18:28:28.727825 IP 172.17.0.4.54636 &gt; 198.18.5.130.443: Flags [P.], seq 644:693, ack 2622, win 501, options [nop,nop,TS val 3365688488 ecr 22099579], length 49
18:28:28.727847 IP 172.17.0.4.54636 &gt; 198.18.5.130.443: Flags [P.], seq 693:728, ack 2622, win 501, options [nop,nop,TS val 3365688488 ecr 22099579], length 35
18:28:28.727871 IP 172.17.0.4.54636 &gt; 198.18.5.130.443: Flags [P.], seq 728:812, ack 2622, win 501, options [nop,nop,TS val 3365688488 ecr 22099579], length 84
18:28:28.729308 IP 198.18.5.130.443 &gt; 172.17.0.4.54636: Flags [.], ack 598, win 939, options [nop,nop,TS val 22099579 ecr 3365688488], length 0
18:28:28.729324 IP 198.18.5.130.443 &gt; 172.17.0.4.54636: Flags [.], ack 644, win 939, options [nop,nop,TS val 22099579 ecr 3365688488], length 0
18:28:28.729328 IP 198.18.5.130.443 &gt; 172.17.0.4.54636: Flags [.], ack 693, win 939, options [nop,nop,TS val 22099579 ecr 3365688488], length 0
</code></pre></td></tr></table>
</div>
</div><p>You can see that the dst_ip was indeed changed from <code>192.168.31.228</code> (wlp4s0&rsquo;s ip) to <code>172.17.0.4</code> (<code>Container A</code>&rsquo;s ip) before it entered the docker0 bridge.</p>
<h3 id="how-does-nat-assign-ports">How does NAT assign ports?</h3>
<p>In the previous section, we actually tested that after the MASQUERADE rule of iptables, only the src ip is modified, but the port is still the same.</p>
<p>However, if NAT does not modify the port of the connection, there is actually a problem. If two containers make requests to <code>ip: 198.18.5.130, port: 443</code> at the same time, and they happen to use the same src port, there will be a port conflict on the host! Because when these two requests are SNATted, if only the src ip is modified, they will map to the same connection on the host!</p>
<p>How is this problem solved by NAT? I think if you encounter this situation, NAT should choose a different port by certain rules.</p>
<p>You can look through the source code to see this sometime, to be continued&hellip;</p>
<h2 id="how-to-persist-the-iptables-configuration">How to persist the iptables configuration</h2>
<p>The first thing to note is that centos7/opensuse 15 have switched to firewalld as the firewall configuration software, and ubuntu18.04 lts have switched to ufw for firewall configuration.</p>
<p>Including docker should also dynamically add iptables configuration at boot time.</p>
<p>For the new systems mentioned above, it is recommended to use firewalld/ufw to configure the firewall directly, or search online for solutions to turn off ufw/firewalld and enable iptables persistence.</p>
<p>The main purpose of this article is to understand the principle of docker container networking, and to lay a good foundation for understanding the kubernetes network plugin calico/flannel later, so I won&rsquo;t introduce persistence much.</p>
<h2 id="how-to-implement-a-container-network-using-iptables--bridge--veth">How to implement a container network using iptables + bridge + veth</h2>
<p>Docker/Podman both use bridge networks by default, and their underlying implementations are exactly similar. Here&rsquo;s an example of docker (Podman&rsquo;s analysis process is basically the same).</p>
<h3 id="running-containers-via-docker-run">Running containers via docker run</h3>
<p>First, run a few containers with <code>docker run</code> to check the network status.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 运行一个 debian 容器和一个 nginx</span>
❯ docker run -dit --name debian --rm debian:buster sleep <span class="m">1000000</span>
❯ docker run -dit --name nginx --rm nginx:1.19-alpine 

<span class="c1">#　查看网络接口，有两个 veth 接口（而且都没设 ip 地址），分别连接到两个容器的 eth0（dcoker0 网络架构图前面给过了，可以往前面翻翻对照下）</span>
❯ ip addr ls
...
5: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue state UP group default 
    link/ether 02:42:42:c7:12:ba brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0
       valid_lft forever preferred_lft forever
    inet6 fe80::42:42ff:fec7:12ba/64 scope link 
       valid_lft forever preferred_lft forever
100: veth16b37ea@if99: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue master docker0 state UP group default 
    link/ether 42:af:34:ae:74:ae brd ff:ff:ff:ff:ff:ff link-netnsid <span class="m">0</span>
    inet6 fe80::40af:34ff:feae:74ae/64 scope link 
       valid_lft forever preferred_lft forever
102: veth4b4dada@if101: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue master docker0 state UP group default 
    link/ether 9e:f1:58:1a:cf:ae brd ff:ff:ff:ff:ff:ff link-netnsid <span class="m">1</span>
    inet6 fe80::9cf1:58ff:fe1a:cfae/64 scope link 
       valid_lft forever preferred_lft forever

<span class="c1"># 两个 veth 接口都连接到了 docker0 上面，说明两个容器都使用了 docker 默认的 bridge 网络</span>
❯ sudo brctl show
bridge name     bridge id               STP enabled     interfaces
docker0         8000.024242c712ba       no              veth16b37ea
                                                        veth4b4dada

<span class="c1"># 查看路由规则</span>
❯ ip route ls
default via 192.168.31.1 dev wlp4s0 proto dhcp metric <span class="m">600</span>
<span class="c1">#下列路由规则将 `172.17.0.0/16` 网段的所有流量转发到 docker0</span>
172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1 linkdown 
192.168.31.0/24 dev wlp4s0 proto kernel scope link src 192.168.31.228 metric <span class="m">600</span> 

<span class="c1"># 查看　iptables 规则</span>
<span class="c1"># NAT 表</span>
❯ sudo iptables -t nat -S
-P PREROUTING ACCEPT
-P INPUT ACCEPT
-P OUTPUT ACCEPT
-P POSTROUTING ACCEPT
-N DOCKER
<span class="c1"># 所有目的地址在本机的，都先交给 DOCKER 链处理一波</span>
-A PREROUTING -m addrtype --dst-type LOCAL -j DOCKER
-A OUTPUT ! -d 127.0.0.0/8 -m addrtype --dst-type LOCAL -j DOCKER
<span class="c1"># （容器访问外部网络）所有出口不为 docker0 的流量，都做下 SNAT，把 src ip 换成出口接口的 ip 地址</span>
-A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE
-A DOCKER -i docker0 -j RETURN

<span class="c1"># filter 表</span>
❯ sudo iptables -t filter -S
-P INPUT ACCEPT
-P FORWARD DROP
-P OUTPUT ACCEPT
-N DOCKER
-N DOCKER-ISOLATION-STAGE-1
-N DOCKER-ISOLATION-STAGE-2
-N DOCKER-USER
<span class="c1"># 所有流量都必须先经过如下两个表处理，没问题才能继续往下走</span>
-A FORWARD -j DOCKER-ISOLATION-STAGE-1
-A FORWARD -j DOCKER-USER
<span class="c1"># （容器访问外部网络）出去的流量走了 MASQUERADE，回来的流量会被 conntrack 识别并转发回来，这里允许返回的数据包通过。</span>
<span class="c1"># 这里直接 ACCEPT 被 conntrack 识别到的流量</span>
-A FORWARD -o docker0 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
<span class="c1"># 将所有访问 docker0 的流量都转给自定义链 DOCKER 处理</span>
-A FORWARD -o docker0 -j DOCKER
<span class="c1"># 允许所有来自 docker0 的流量通过，不论下一跳是否是 docker0</span>
-A FORWARD -i docker0 ! -o docker0 -j ACCEPT
-A FORWARD -i docker0 -o docker0 -j ACCEPT
<span class="c1"># 下面三个表目前啥规则也没有，就是简单的 RETURN，交给后面的表继续处理</span>
-A DOCKER-ISOLATION-STAGE-1 -j RETURN
-A DOCKER-ISOLATION-STAGE-2 -j RETURN
-A DOCKER-USER -j RETURN

</code></pre></td></tr></table>
</div>
</div><p>Next, start a caddy container with the following docker-compose configuration, add a custom network and port mapping, and later verify how docker implements these two networks.</p>
<p><code>docker-compose.yml</code> reads.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;3.3&#34;</span><span class="w">
</span><span class="w"></span><span class="nt">services</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">caddy</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;caddy:2.2.1-alpine&#34;</span><span class="w">
</span><span class="w">    </span><span class="nt">container_name</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;caddy&#34;</span><span class="w">
</span><span class="w">    </span><span class="nt">restart</span><span class="p">:</span><span class="w"> </span><span class="l">always</span><span class="w">
</span><span class="w">    </span><span class="nt">command</span><span class="p">:</span><span class="w"> </span><span class="l">caddy file-server --browse --root /data/static</span><span class="w">
</span><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="s2">&#34;8081:80&#34;</span><span class="w">
</span><span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="s2">&#34;/home/ryan/Downloads:/data/static&#34;</span><span class="w">
</span><span class="w">    </span><span class="nt">networks</span><span class="p">:</span><span class="w">
</span><span class="w">    </span>- <span class="l">caddy-1</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="nt">networks</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">caddy-1</span><span class="p">:</span><span class="w">
</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>Now start the caddy container with the above configuration, and then check the network status.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 启动 caddy</span>
❯ docker-compose up -d
<span class="c1"># 查下 caddy 容器的 ip</span>
&gt; docker inspect caddy <span class="p">|</span> grep IPAddress
...
    <span class="s2">&#34;IPAddress&#34;</span>: <span class="s2">&#34;172.18.0.2&#34;</span>,

<span class="c1"># 查看网络接口，可以看到多了一个网桥，它就是上一行命令创建的 caddy-1 网络</span>
<span class="c1"># 还多了一个 veth，它连接到了 caddy 容器的 eth0(veth) 接口</span>
❯ ip addr ls
...
5: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue state UP group default 
    link/ether 02:42:42:c7:12:ba brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0
       valid_lft forever preferred_lft forever
    inet6 fe80::42:42ff:fec7:12ba/64 scope link 
       valid_lft forever preferred_lft forever
100: veth16b37ea@if99: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue master docker0 state UP group default 
    link/ether 42:af:34:ae:74:ae brd ff:ff:ff:ff:ff:ff link-netnsid <span class="m">0</span>
    inet6 fe80::40af:34ff:feae:74ae/64 scope link 
       valid_lft forever preferred_lft forever
102: veth4b4dada@if101: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue master docker0 state UP group default 
    link/ether 9e:f1:58:1a:cf:ae brd ff:ff:ff:ff:ff:ff link-netnsid <span class="m">1</span>
    inet6 fe80::9cf1:58ff:fe1a:cfae/64 scope link 
       valid_lft forever preferred_lft forever
103: br-ac3e0514d837: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue state UP group default 
    link/ether 02:42:7d:95:ba:7e brd ff:ff:ff:ff:ff:ff
    inet 172.18.0.1/16 brd 172.18.255.255 scope global br-ac3e0514d837
       valid_lft forever preferred_lft forever
    inet6 fe80::42:7dff:fe95:ba7e/64 scope link 
       valid_lft forever preferred_lft forever
105: veth0c25c6f@if104: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue master br-ac3e0514d837 state UP group default 
    link/ether 9a:03:e1:f0:26:ea brd ff:ff:ff:ff:ff:ff link-netnsid <span class="m">2</span>
    inet6 fe80::9803:e1ff:fef0:26ea/64 scope link 
       valid_lft forever preferred_lft forever


<span class="c1"># 查看网桥，能看到 caddy 容器的 veth 接口连在了 caddy-1 这个网桥上，没有加入到 docker0 网络</span>
❯ sudo brctl show
bridge name     bridge id               STP enabled     interfaces
br-ac3e0514d837         8000.02427d95ba7e       no              veth0c25c6f
docker0         8000.024242c712ba       no              veth16b37ea
                                                        veth4b4dada

<span class="c1"># 查看路由，能看到新网桥使用的地址段是 172.18.0.0/16，是 docker0 递增上来的 </span>
❯ ip route ls
default via 192.168.31.1 dev wlp4s0 proto dhcp metric <span class="m">600</span> 
172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1 
<span class="c1"># 多了一个网桥的</span>
172.18.0.0/16 dev br-ac3e0514d837 proto kernel scope link src 172.18.0.1 
192.168.31.0/24 dev wlp4s0 proto kernel scope link src 192.168.31.228 metric <span class="m">600</span> 

<span class="c1"># iptables 中也多了 caddy-1 网桥的 MASQUERADE 规则，以及端口映射的规则</span>
❯ sudo iptables -t nat -S
-P PREROUTING ACCEPT
-P INPUT ACCEPT
-P OUTPUT ACCEPT
-P POSTROUTING ACCEPT
-N DOCKER
-A PREROUTING -m addrtype --dst-type LOCAL -j DOCKER
-A OUTPUT ! -d 127.0.0.0/8 -m addrtype --dst-type LOCAL -j DOCKER
-A POSTROUTING -s 172.18.0.0/16 ! -o br-ac3e0514d837 -j MASQUERADE
-A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE
<span class="c1"># 端口映射过来的入网流量，都做下 SNAT，把 src ip 换成出口 docker0 的 ip 地址</span>
-A POSTROUTING -s 172.18.0.2/32 -d 172.18.0.2/32 -p tcp -m tcp --dport <span class="m">80</span> -j MASQUERADE
-A DOCKER -i br-ac3e0514d837 -j RETURN
-A DOCKER -i docker0 -j RETURN
<span class="c1"># 主机上所有其他接口进来的 tcp 流量，只要目标端口是 8081，就转发到 caddy 容器去（端口映射）</span>
<span class="c1"># DOCKER 是被 PREROUTEING 链的 target，因此这会导致流量直接走了 FORWARD 链，直接绕过了通常设置在 INPUT 链的主机防火墙规则！</span>
-A DOCKER ! -i br-ac3e0514d837 -p tcp -m tcp --dport <span class="m">8081</span> -j DNAT --to-destination 172.18.0.2:80

❯ sudo iptables -t filter -S
-P INPUT ACCEPT
-P FORWARD DROP
-P OUTPUT ACCEPT
-N DOCKER
-N DOCKER-ISOLATION-STAGE-1
-N DOCKER-ISOLATION-STAGE-2
-N DOCKER-USER
-A FORWARD -j DOCKER-USER
-A FORWARD -j DOCKER-ISOLATION-STAGE-1
<span class="c1"># 给 caddy-1 bridge 网络添加的转发规则，与 docker0 的规则完全一一对应，就不多介绍了。</span>
-A FORWARD -o br-ac3e0514d837 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A FORWARD -o br-ac3e0514d837 -j DOCKER
-A FORWARD -i br-ac3e0514d837 ! -o br-ac3e0514d837 -j ACCEPT
-A FORWARD -i br-ac3e0514d837 -o br-ac3e0514d837 -j ACCEPT
-A FORWARD -o docker0 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A FORWARD -o docker0 -j DOCKER
-A FORWARD -i docker0 ! -o docker0 -j ACCEPT
-A FORWARD -i docker0 -o docker0 -j ACCEPT
<span class="c1"># 这一条仍然是端口映射相关的规则，接受所有从其他接口过来的，请求 80 端口且出口是 caddy-1 网桥的流量</span>
-A DOCKER -d 172.18.0.2/32 ! -i br-ac3e0514d837 -o br-ac3e0514d837 -p tcp -m tcp --dport <span class="m">80</span> -j ACCEPT
<span class="c1"># 当存在多个 bridge 网络的时候，docker 就会在下面两个 STAGE 链中处理将它们隔离开，禁止互相访问</span>
-A DOCKER-ISOLATION-STAGE-1 -i br-ac3e0514d837 ! -o br-ac3e0514d837 -j DOCKER-ISOLATION-STAGE-2
-A DOCKER-ISOLATION-STAGE-1 -i docker0 ! -o docker0 -j DOCKER-ISOLATION-STAGE-2
-A DOCKER-ISOLATION-STAGE-1 -j RETURN
<span class="c1"># 这里延续上面 STAGE-1 的处理，彻底隔离两个网桥的流量</span>
-A DOCKER-ISOLATION-STAGE-2 -o br-ac3e0514d837 -j DROP
-A DOCKER-ISOLATION-STAGE-2 -o docker0 -j DROP
-A DOCKER-ISOLATION-STAGE-2 -j RETURN
-A DOCKER-USER -j RETURN

</code></pre></td></tr></table>
</div>
</div><p>Here, we have briefly analyzed how docker implements bridge networking and port mapping via iptables. With this foundation, you can try to analyze the kubernetes network plugin flannel/calico/cilium in depth later haha.</p>
<h2 id="macvlanipvlan-mode-for-dockerpodman">macvlan/ipvlan mode for Docker/Podman</h2>
<blockquote>
<p>Note: macvlan and wifi don&rsquo;t seem to be compatible, so don&rsquo;t use the wireless interface when testing!</p>
</blockquote>
<p>I have introduced the new virtual interfaces macvlan and ipvlan in my previous article on Linux virtual network interfaces.</p>
<p>Currently Podman/Docker support the use of macvlan to build a container network, this mode to create containers directly connected to the external network, containers can have independent external IP, no port mapping, and do not need to use iptables.</p>
<p>This is very similar to the Bridge mode of virtual machines, which is mainly used when you want containers to have independent external IPs.</p>
<p>Here is a detailed analysis of Docker&rsquo;s macvlan network (Podman should be exactly the same).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># 首先创建一个 macvlan 网络</span>
<span class="c1"># subnet/gateway 的参数需要和物理网络一致</span>
<span class="c1"># 通过 -o parent 设定父接口，我本机的以太网口名称为 eno1</span>
$ docker network create -d macvlan <span class="se">\
</span><span class="se"></span>  --subnet<span class="o">=</span>192.168.31.0/24 <span class="se">\
</span><span class="se"></span>  --gateway<span class="o">=</span>192.168.31.1 <span class="se">\
</span><span class="se"></span>  -o <span class="nv">parent</span><span class="o">=</span>eno1 <span class="se">\
</span><span class="se"></span>  macnet0

<span class="c1"># 现在使用 macvlan 启动一个容器试试</span>
<span class="c1"># 建议和我一样，通过 --ip 手动配置静态 ip 地址，当然不配也可以，DHCP 会自动分配 IP</span>
$ docker run --network macnet0 --ip<span class="o">=</span>192.168.31.233 --rm -it buildpack-deps:buster-curl /bin/bash
<span class="c1"># 在容器中查看网络接口状况，能看到 eth0 是一个 macvlan 接口</span>
root@4319488cb5e7:/# ip -d addr ls
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span class="m">65536</span> qdisc noqueue state UNKNOWN group default qlen <span class="m">1000</span>
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 promiscuity <span class="m">0</span> minmtu <span class="m">0</span> maxmtu <span class="m">0</span> numtxqueues <span class="m">1</span> numrxqueues <span class="m">1</span> gso_max_size <span class="m">65536</span> gso_max_segs <span class="m">65535</span> 
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
8: eth0@if2: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue state UP group default 
    link/ether 02:42:c0:a8:1f:e9 brd ff:ff:ff:ff:ff:ff link-netnsid <span class="m">0</span> promiscuity <span class="m">0</span> minmtu <span class="m">68</span> maxmtu <span class="m">9194</span> 
    macvlan mode bridge numtxqueues <span class="m">1</span> numrxqueues <span class="m">1</span> gso_max_size <span class="m">64000</span> gso_max_segs <span class="m">64</span> 
    inet 192.168.31.233/24 brd 192.168.31.255 scope global eth0
       valid_lft forever preferred_lft forever
<span class="c1"># 路由表，默认 gateway 被自动配置进来了</span>
root@4319488cb5e7:/# ip route ls
default via 192.168.31.1 dev eth0 
192.168.31.0/24 dev eth0 proto kernel scope link src 192.168.31.233 

<span class="c1"># 可以正常访问 baidu</span>
root@4319488cb5e7:/# curl baidu.com
&lt;html&gt;
&lt;meta http-equiv<span class="o">=</span><span class="s2">&#34;refresh&#34;</span> <span class="nv">content</span><span class="o">=</span><span class="s2">&#34;0;url=http://www.baidu.com/&#34;</span>&gt;
&lt;/html&gt;

</code></pre></td></tr></table>
</div>
</div><p>Another network mode supported by Docker is ipvlan (the difference between ipvlan and macvlan I covered in a previous article, so I won&rsquo;t go into it again), and the creation command is almost identical to macvlan.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># 首先创建一个 macvlan 网络</span>
<span class="c1"># subnet/gateway 的参数需要和物理网络一致</span>
<span class="c1"># 通过 -o parent 设定父接口，我本机的以太网口名称为 eno1</span>
<span class="c1"># ipvlan_mode 默认为 l2，表示工作在数据链路层。</span>
$ docker network create -d ipvlan <span class="se">\
</span><span class="se"></span>  --subnet<span class="o">=</span>192.168.31.0/24 <span class="se">\
</span><span class="se"></span>  --gateway<span class="o">=</span>192.168.31.1 <span class="se">\
</span><span class="se"></span>  -o <span class="nv">parent</span><span class="o">=</span>eno1 <span class="se">\
</span><span class="se"></span>  -o <span class="nv">ipvlan_mode</span><span class="o">=</span>l2 <span class="se">\
</span><span class="se"></span>  ipvnet0

<span class="c1"># 现在使用 macvlan 启动一个容器试试</span>
<span class="c1"># 建议和我一样，通过 --ip 手动配置静态 ip 地址，当然不配也可以，DHCP 会自动分配 IP</span>
$ docker run --network ipvnet0 --ip<span class="o">=</span>192.168.31.234 --rm -it buildpack-deps:buster-curl /bin/bash
<span class="c1"># 在容器中查看网络接口状况，能看到 eth0 是一个 ipvlan 接口</span>
root@d0764ebbbf42:/# ip -d addr ls
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span class="m">65536</span> qdisc noqueue state UNKNOWN group default qlen <span class="m">1000</span>
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 promiscuity <span class="m">0</span> minmtu <span class="m">0</span> maxmtu <span class="m">0</span> numtxqueues <span class="m">1</span> numrxqueues <span class="m">1</span> gso_max_size <span class="m">65536</span> gso_max_segs <span class="m">65535</span> 
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
12: eth0@if2: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue state UNKNOWN group default 
    link/ether 38:f3:ab:a3:e6:71 brd ff:ff:ff:ff:ff:ff link-netnsid <span class="m">0</span> promiscuity <span class="m">0</span> minmtu <span class="m">68</span> maxmtu <span class="m">65535</span> 
    ipvlan  mode l2 bridge numtxqueues <span class="m">1</span> numrxqueues <span class="m">1</span> gso_max_size <span class="m">64000</span> gso_max_segs <span class="m">64</span> 
    inet 192.168.31.234/24 brd 192.168.31.255 scope global eth0
       valid_lft forever preferred_lft forever
<span class="c1"># 路由表，默认 gateway 被自动配置进来了</span>
root@d0764ebbbf42:/# ip route ls
default via 192.168.31.1 dev eth0 
192.168.31.0/24 dev eth0 proto kernel scope link src 192.168.31.234 

<span class="c1"># 可以正常访问 baidu</span>
root@d0764ebbbf42:/# curl baidu.com
&lt;html&gt;
&lt;meta http-equiv<span class="o">=</span><span class="s2">&#34;refresh&#34;</span> <span class="nv">content</span><span class="o">=</span><span class="s2">&#34;0;url=http://www.baidu.com/&#34;</span>&gt;
&lt;/html&gt;

</code></pre></td></tr></table>
</div>
</div><h2 id="network-implementation-for-rootless-containers">Network implementation for Rootless containers</h2>
<p>If the container is also running in Rootless mode, it does not have permission to add virtual network interfaces such as bridge/veth to the host, in which case the container network we described earlier cannot be set up.</p>
<p>So how does podman/containerd(nerdctl) currently build a container network in Rootless mode?</p>
<p>Looking at the documentation, I found that they all use something related to rootlesskit, which provides several implementations of rootless networks, see <a href="https://github.com/rootless-containers/rootlesskit/blob/master/docs/network.md">rootlesskit/docs/network.md</a></p>
<p>The currently recommended and default solution for podman/containerd(nerdctl) is <a href="https://github.com/rootless-containers/slirp4netns">rootless-containers/slirp4netns</a></p>
<p>Take containerd(nerdctl) for example, after installing it according to the official documentation, start some random containers, then check <code>iptables</code> / <code>ip addr ls</code> on the host, you will find nothing. This is obviously because containerd in rootless mode cannot change the host&rsquo;s iptables configuration and virtual network interface. But you can see that the host slirp4netns is running in the background.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">❯ ps aux <span class="p">|</span> grep tap
ryan     <span class="m">11644</span>  0.0  0.0   <span class="m">5288</span>  <span class="m">3312</span> ?        S    00:01   0:02 slirp4netns --mtu <span class="m">65520</span> -r <span class="m">3</span> --disable-host-loopback --enable-sandbox --enable-seccomp <span class="m">11625</span> tap0

</code></pre></td></tr></table>
</div>
</div><p>But I&rsquo;ve been reading the documentation for a long time and I only see how to create a new namespace using <code>rootlesskit</code> / <code>slirp4netns</code>, but I don&rsquo;t see how to access an existing <code>slirp4netns</code> namespace&hellip;</p>
<p>Using <code>nsenter -a -t 11644</code> also keeps reporting errors, any program is <code>no such binary</code> &hellip;</p>
<p>I&rsquo;ll revisit it later when I have time&hellip;</p>
<p>Anyway, what I can confirm is that it implements container networking by creating a <code>tap</code> virtual interface in a virtual namespace, and the performance is a little bit worse than the network introduced earlier.</p>
<h2 id="nftables">nftables</h2>
<p>The previous section describes iptables and its application to docker and firewalls. But in fact the major Linux distributions no longer recommend using iptables, and have even renamed iptables to <code>iptables-leagacy</code> .</p>
<p>nftables is now pre-installed and recommended in opensuse/debian/opensuse, <strong>and firewalld already uses nftables as its backend by default</strong>.</p>
<p>I tested it on opensuse tumbleweed and firewalld added nftables, while docker is still using the old iptables, which means I have two sets of netfilter tools on my machine.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># 查看 iptables 数据</span>
&gt; iptables -S
-P INPUT ACCEPT
-P FORWARD DROP
-P OUTPUT ACCEPT
-N DOCKER
-N DOCKER-ISOLATION-STAGE-1
-N DOCKER-ISOLATION-STAGE-2
-N DOCKER-USER
-A FORWARD -j DOCKER-ISOLATION-STAGE-1
-A FORWARD -o br-e3fbbb7a1b3a -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A FORWARD -o br-e3fbbb7a1b3a -j DOCKER
...

<span class="c1"># 确认下是否使用了 nftables 的兼容层，结果提示请我使用 iptables-legacy</span>
&gt; iptables-nft -S
<span class="c1"># Warning: iptables-legacy tables present, use iptables-legacy to see them</span>
-P INPUT ACCEPT
-P FORWARD ACCEPT
-P OUTPUT ACCEPT

<span class="c1"># 查看 nftables 规则，能看到三张 firewalld 生成的 table</span>
&gt; nft list ruleset
table inet firewalld <span class="o">{</span>
    ...
<span class="o">}</span>
table ip firewalld <span class="o">{</span>
    ...
<span class="o">}</span>
table ip6 firewalld <span class="o">{</span>
    ...
<span class="o">}</span>

</code></pre></td></tr></table>
</div>
</div><p>But now kubernetes/docker are still using iptables, nftables I learned is not very useful, I will have time to add later.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/iptables/">iptables</a>
          <a href="/tags/docker/">docker</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-01/linux-virtual-network-interfaces/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Virtual Network Interface in Linux</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-01/different-from-ctrl-c-and-kill/">
            <span class="next-text nav-default">The difference between Ctrl&#43;C and Kill to kill a process</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
