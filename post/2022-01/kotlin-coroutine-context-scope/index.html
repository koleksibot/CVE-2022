<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Talking about the Context and Scope of Kotlin Coroutine - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Intro Opening a Kotlin Coroutine requires calling the launch or async methods on the CoroutineScope. These extension methods defined on the CoroutineScope are called coroutine builder. 1 2 3 lifecycleScope.launch(Dispatchers.IO) { delay(1000) } In addition to the suspend block, additional parameters can be passed to the coroutine builder. For example, the above Dispatchers.IO specifies that the Coroutine block of launch is dispatched to the IO thread pool for execution. Signature" /><meta name="keywords" content="kotlin, Coroutine Context Scope" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-01/kotlin-coroutine-context-scope/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Talking about the Context and Scope of Kotlin Coroutine" />
<meta property="og:description" content="Intro Opening a Kotlin Coroutine requires calling the launch or async methods on the CoroutineScope. These extension methods defined on the CoroutineScope are called coroutine builder. 1 2 3 lifecycleScope.launch(Dispatchers.IO) { delay(1000) } In addition to the suspend block, additional parameters can be passed to the coroutine builder. For example, the above Dispatchers.IO specifies that the Coroutine block of launch is dispatched to the IO thread pool for execution. Signature" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-01/kotlin-coroutine-context-scope/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-01-15T13:01:02+08:00" />
<meta property="article:modified_time" content="2022-01-15T13:01:02+08:00" />

<meta itemprop="name" content="Talking about the Context and Scope of Kotlin Coroutine">
<meta itemprop="description" content="Intro Opening a Kotlin Coroutine requires calling the launch or async methods on the CoroutineScope. These extension methods defined on the CoroutineScope are called coroutine builder. 1 2 3 lifecycleScope.launch(Dispatchers.IO) { delay(1000) } In addition to the suspend block, additional parameters can be passed to the coroutine builder. For example, the above Dispatchers.IO specifies that the Coroutine block of launch is dispatched to the IO thread pool for execution. Signature"><meta itemprop="datePublished" content="2022-01-15T13:01:02+08:00" />
<meta itemprop="dateModified" content="2022-01-15T13:01:02+08:00" />
<meta itemprop="wordCount" content="5270">
<meta itemprop="keywords" content="kotlin," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Talking about the Context and Scope of Kotlin Coroutine"/>
<meta name="twitter:description" content="Intro Opening a Kotlin Coroutine requires calling the launch or async methods on the CoroutineScope. These extension methods defined on the CoroutineScope are called coroutine builder. 1 2 3 lifecycleScope.launch(Dispatchers.IO) { delay(1000) } In addition to the suspend block, additional parameters can be passed to the coroutine builder. For example, the above Dispatchers.IO specifies that the Coroutine block of launch is dispatched to the IO thread pool for execution. Signature"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Talking about the Context and Scope of Kotlin Coroutine</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-01-15 13:01:02 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 5270 words </span>
          <span class="more-meta"> 11 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#intro">Intro</a></li>
        <li><a href="#context-is-used-to-configure-the-properties-of-the-coroutine">Context is used to configure the properties of the Coroutine</a>
          <ul>
            <li><a href="#context-is-a-specially-customized-data-structure">Context is a specially customized data structure</a></li>
            <li><a href="#get-context-anywhere-in-the-coroutine-call-chain">Get Context anywhere in the Coroutine call chain</a></li>
            <li><a href="#a-core-element-the-continuationinterceptor">A core element: the ContinuationInterceptor</a></li>
          </ul>
        </li>
        <li><a href="#coroutinescope-and-structured-concurrency">CoroutineScope and &lsquo;structured concurrency&rsquo;</a>
          <ul>
            <li><a href="#trouble-with-global-top-level-coroutine-builder">Trouble with global top-level coroutine builder</a></li>
            <li><a href="#structured-concurrency">Structured Concurrency</a></li>
            <li><a href="#job-and-cancellation">Job and cancellation</a></li>
            <li><a href="#job-and-coroutine-parent-child-relationship">Job and Coroutine parent-child relationship</a></li>
            <li><a href="#structured-concurrent-design-of-kotlin-coroutine">Structured concurrent design of Kotlin Coroutine</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="intro">Intro</h2>
<p>Opening a Kotlin Coroutine requires calling the <code>launch</code> or <code>async</code> methods on the <code>CoroutineScope</code>. These extension methods defined on the <code>CoroutineScope</code> are called coroutine builder.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="n">lifecycleScope</span><span class="p">.</span><span class="n">launch</span><span class="p">(</span><span class="n">Dispatchers</span><span class="p">.</span><span class="n">IO</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">delay</span><span class="p">(</span><span class="m">1000</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>In addition to the <code>suspend</code> block, additional parameters can be passed to the coroutine builder. For example, the above <code>Dispatchers.IO</code> specifies that the Coroutine block of <code>launch</code> is dispatched to the IO thread pool for execution. Signature of <code>launch</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="k">public</span> <span class="k">fun</span> <span class="nf">CoroutineScope</span><span class="p">.</span><span class="n">launch</span><span class="p">(</span>
  <span class="n">context</span><span class="p">:</span> <span class="n">CoroutineContext</span> <span class="p">=</span> <span class="n">EmptyCoroutineContext</span><span class="p">,</span>
  <span class="c1">// 忽略了与本文无关的 CoroutineStart 参数
</span><span class="c1"></span>  <span class="n">block</span><span class="p">:</span> <span class="k">suspend</span> <span class="n">CoroutineScope</span><span class="p">.()</span> <span class="o">-&gt;</span> <span class="n">Unit</span>
<span class="p">):</span> <span class="n">Job</span>
</code></pre></td></tr></table>
</div>
</div><p>You can see that opening a Kotlin Coroutine involves at least three concepts: <code>CoroutineScope</code>, <code>CoroutineContext</code> and <code>Job</code>. Scope and Context seem to have very similar meanings when taken literally. In addition, Coroutine&rsquo;s Scope contains only one property, <code>CoroutineContext</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="k">public</span> <span class="k">interface</span> <span class="nc">CoroutineScope</span> <span class="p">{</span>
  <span class="k">public</span> <span class="k">val</span> <span class="py">coroutineContext</span><span class="p">:</span> <span class="n">CoroutineContext</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Why does Kotlin&rsquo;s Coroutine need a concept of Scope? Can we reduce the complexity of the API by eliminating the Scope and leaving only the Context? It seems that everyone has been confused about this (e.g. <a href="https://github.com/Kotlin/kotlinx.coroutines/issues/410#issuecomment-419506486">discussion here</a>). Elizarov also has a <a href="https://medium.com/@elizarov/coroutine-context-and-scope-c8b255d59055">dedicated article</a> about it. This paper will document the author&rsquo;s understanding.</p>
<h2 id="context-is-used-to-configure-the-properties-of-the-coroutine">Context is used to configure the properties of the Coroutine</h2>
<h3 id="context-is-a-specially-customized-data-structure">Context is a specially customized data structure</h3>
<p><strong>Context is like a collection (Set)</strong> : This collection consists of <code>Element</code> of different types. Elements can be added via the operator overloaded add, or overwritten if an element of an already existing type is added.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="n">CoroutineName</span><span class="p">(</span><span class="s2">&#34;foo&#34;</span><span class="p">)</span> <span class="p">+</span> <span class="n">CoroutineName</span><span class="p">(</span><span class="s2">&#34;bar&#34;</span><span class="p">)</span> 
  <span class="o">==</span> <span class="n">CoroutineName</span><span class="p">(</span><span class="s2">&#34;bar&#34;</span><span class="p">)</span> <span class="c1">// true
</span></code></pre></td></tr></table>
</div>
</div><p>The type returned when the two Contexts are &ldquo;+&rdquo; together is <code>CombinedContext</code>. Since the collection itself and the elements inside <code>CoroutineContext.Element</code> are both <code>CoroutineContext</code>, we can pass either a single element or a combined Context when calling a function like <code>launch</code> that receives a Context, without the need to add an extra <code>listOf</code>, or use vararg, which is very simple and elegant.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/15/00b47388e551493f95b0b535895c690e.png" alt="image"></p>
<p><strong>Context is immutable</strong> . Adding or removing elements to or from a Context returns a new Context object. This property is needed for Coroutine concurrency scenarios.</p>
<p><strong>Context is also like a Map</strong>: each type of <code>Element</code> has a corresponding <code>CoroutineContext.Key</code>, which can be used to safely access the corresponding type of Element.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="p">(</span><span class="n">CoroutineName</span><span class="p">(</span><span class="s2">&#34;Coco&#34;</span><span class="p">)</span> <span class="p">+</span> <span class="n">Dispatchers</span><span class="p">.</span><span class="n">IO</span><span class="p">).</span><span class="n">also</span> <span class="p">{</span> <span class="k">it</span><span class="p">:</span> <span class="n">CoroutineContext</span> <span class="o">-&gt;</span>
    <span class="n">println</span><span class="p">(</span><span class="k">it</span><span class="p">[</span><span class="n">CoroutineName</span><span class="p">]</span> <span class="o">==</span> <span class="n">CoroutineName</span><span class="p">(</span><span class="s2">&#34;Coco&#34;</span><span class="p">))</span> <span class="c1">// true
</span><span class="c1"></span>    <span class="n">println</span><span class="p">(</span><span class="k">it</span><span class="p">[</span><span class="n">ContinuationInterceptor</span><span class="p">]</span> <span class="o">==</span> <span class="n">Dispatchers</span><span class="p">.</span><span class="n">IO</span><span class="p">)</span> <span class="c1">// true
</span><span class="c1"></span>  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The <code>CoroutineName</code> used to get the element in the sample code is actually a companion object of the class <code>CoroutineName</code>. It is also more concise and elegant than using <code>CoroutineName::class</code> as the Key of the dictionary.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="k">public</span> <span class="k">data</span> <span class="k">class</span> <span class="nc">CoroutineName</span><span class="p">(</span>
  <span class="k">val</span> <span class="py">name</span><span class="p">:</span> <span class="n">String</span>
<span class="p">)</span> <span class="p">:</span> <span class="n">AbstractCoroutineContextElement</span><span class="p">(</span><span class="n">CoroutineName</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">public</span> <span class="k">companion</span> <span class="k">object</span> <span class="n">Key</span> <span class="p">:</span> <span class="n">CoroutineContext</span><span class="p">.</span><span class="n">Key</span><span class="p">&lt;</span><span class="n">CoroutineName</span><span class="p">&gt;</span>  <span class="k">override</span> <span class="k">fun</span> <span class="nf">toString</span><span class="p">():</span> <span class="n">String</span> <span class="p">=</span> <span class="s2">&#34;CoroutineName(</span><span class="si">$name</span><span class="s2">)&#34;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The nature of Context collections and dictionaries ensures the uniqueness of <strong>each type of Element</strong> in the collection <code>CombinedContext</code>.</p>
<p>Although Context is used like a dictionary and a collection, its <strong>implementation is a LikedList</strong>.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/15/c77dc6cc55c74a578b0dee931dab56be.png" alt="image"></p>
<p>Since each type of Element in Context is unique and the number of Element types is defined inside the Kotlin Coroutine library (kotlinx.coroutines) is fixed, there is an upper bound on the time complexity of chaining table operations. Implementing Context using a custom linked table avoids some additional overhead compared to using an off-the-shelf data structure and makes sense for a framework implementation.</p>
<h3 id="get-context-anywhere-in-the-coroutine-call-chain">Get Context anywhere in the Coroutine call chain</h3>
<p>Context is generally used to store certain state that is global in nature. For example, React.js describes the shape of a component tree through a declarative API. Sometimes it can be tricky to pass some data across component layers. If this data is global in nature (e.g., the theme of a page), React&rsquo;s <a href="https://zh-hans.reactjs.org/docs/context.html">Context API</a> allows us to pass values deep into the component tree without explicitly passing through each component.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="c1">// 为当前的 theme 创建一个 context（“light”为默认值）。
</span><span class="c1"></span><span class="k">const</span> <span class="n">ThemeContext</span> <span class="p">=</span> <span class="n">React</span><span class="p">.</span><span class="n">createContext</span><span class="p">(</span><span class="err">&#39;</span><span class="n">light</span><span class="err">&#39;</span><span class="p">);</span><span class="k">class</span> <span class="nc">App</span> <span class="n">extends</span> <span class="n">React</span><span class="p">.</span><span class="n">Component</span> <span class="p">{</span>
  <span class="n">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 使用一个 Provider 来将当前的 theme 传递给以下的组件树。
</span><span class="c1"></span>    <span class="c1">// 无论多深，任何组件都能读取这个值。
</span><span class="c1"></span>    <span class="c1">// 在这个例子中，我们将 “dark” 作为当前的值传递下去。
</span><span class="c1"></span>    <span class="k">return</span> <span class="p">(</span>
      <span class="p">&lt;</span><span class="n">ThemeContext</span><span class="p">.</span><span class="n">Provider</span> <span class="n">value</span><span class="p">=</span><span class="s2">&#34;dark&#34;</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="n">Toolbar</span> <span class="p">/&gt;</span>
      <span class="p">&lt;/</span><span class="n">ThemeContext</span><span class="p">.</span><span class="n">Provider</span><span class="p">&gt;</span>
    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 中间的组件再也不必指明往下传递 theme 了。
</span><span class="c1"></span><span class="n">function</span> <span class="n">Toolbar</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="p">&lt;</span><span class="n">div</span><span class="p">&gt;&lt;</span><span class="n">ThemedButton</span> <span class="p">/&gt;&lt;/</span><span class="n">div</span><span class="p">&gt;</span>
  <span class="p">);</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">ThemedButton</span> <span class="n">extends</span> <span class="n">React</span><span class="p">.</span><span class="n">Component</span> <span class="p">{</span>
  <span class="c1">// 指定 contextType 读取当前的 theme context。
</span><span class="c1"></span>  <span class="c1">// React 会往上找到最近的 theme Provider，然后使用它的值。
</span><span class="c1"></span>  <span class="c1">// 在这个例子中，当前的 theme 值为 “dark”。
</span><span class="c1"></span>  <span class="n">static</span> <span class="n">contextType</span> <span class="p">=</span> <span class="n">ThemeContext</span><span class="p">;</span>
  <span class="n">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">&lt;</span><span class="n">Button</span> <span class="n">theme</span><span class="p">={</span><span class="k">this</span><span class="p">.</span><span class="n">context</span><span class="p">}</span> <span class="p">/&gt;;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>A block of code that can be executed as a whole can be called a &ldquo;subroutine routine&rdquo;, such as a function, method, lambda, conditional block, loop block, etc. A Kotlin Coroutine is a block of code that can be suspended. For the purpose of abstraction and reuse, we extracted a part of the code containing asynchrony and wrapped it into a suspend function.</p>
<p>Function calls are also similar to UI components and can be seen as a tree structure. In Kotlin&rsquo;s suspend function, we can get the Context (Context propagation) at any level of the call chain.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="n">runBlocking</span> <span class="p">{</span>
  <span class="c1">// 在 Context 中添加 CoroutineName[Coco] 元素
</span><span class="c1"></span>  <span class="n">launch</span><span class="p">(</span><span class="n">CoroutineName</span><span class="p">(</span><span class="s2">&#34;Coco&#34;</span><span class="p">))</span> <span class="p">{</span>    <span class="n">foo</span><span class="p">()</span>
  <span class="p">}</span>
  <span class="n">Unit</span>
<span class="p">}</span>

<span class="c1">// 调用链：foo-&gt;bar-&gt;baz
</span><span class="c1"></span><span class="k">suspend</span> <span class="k">fun</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">=</span> <span class="n">bar</span><span class="p">()</span>
<span class="k">suspend</span> <span class="k">fun</span> <span class="nf">bar</span><span class="p">()</span> <span class="p">=</span> <span class="n">baz</span><span class="p">()</span>
<span class="k">suspend</span> <span class="k">fun</span> <span class="nf">baz</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// 在调用链中获取 Context 中的元素
</span><span class="c1"></span>  <span class="n">println</span><span class="p">(</span><span class="n">coroutineContext</span><span class="p">[</span><span class="n">CoroutineName</span><span class="p">])}</span>
</code></pre></td></tr></table>
</div>
</div><p>This <code>coroutineContext</code> is added by Kotlin at compile time and can be seen as the compiler passing the caller&rsquo;s Context <strong>implicitly</strong> to the calling suspend function. In the article &ldquo;Understanding Kotlin&rsquo;s suspend function&rdquo;], we described that the essence of <code>suspend</code> is Continuation. In addition to the <code>resumeWith</code> method that corresponds to the callback, the other property of Continuation is the <code>CoroutineContext</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="k">public</span> <span class="k">interface</span> <span class="nc">Continuation</span><span class="p">&lt;</span><span class="k">in</span> <span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
  <span class="c1">// 每个 suspend 的代码块都有一个 Context
</span><span class="c1"></span>  <span class="k">public</span> <span class="k">val</span> <span class="py">context</span><span class="p">:</span> <span class="n">CoroutineContext</span>
  <span class="k">public</span> <span class="k">fun</span> <span class="nf">resumeWith</span><span class="p">(</span><span class="n">result</span><span class="p">:</span> <span class="n">Result</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The <code>coroutineContext</code> in the suspend function is the same as the caller&rsquo;s Context without updating the Context via <code>withContext</code>. It is useful to understand that it is conceivable to inline the calling suspend function into this suspend block and the behavior of the program does not change. The following example checks that the Context of the caller, the suspend function&rsquo;s internals, and the Continuation are all the same.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="k">suspend</span> <span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">println</span><span class="p">(</span><span class="n">checkCallerContext</span><span class="p">(</span><span class="n">coroutineContext</span><span class="p">))</span> <span class="c1">// true
</span><span class="c1"></span>  <span class="n">println</span><span class="p">(</span><span class="n">checkContinuationContext</span><span class="p">())</span> <span class="c1">// true
</span><span class="c1"></span><span class="p">}</span>

<span class="k">suspend</span> <span class="k">fun</span> <span class="nf">checkCallerContext</span><span class="p">(</span><span class="n">callerContext</span><span class="p">:</span> <span class="n">CoroutineContext</span><span class="p">):</span> <span class="n">Boolean</span> <span class="p">=</span>
  <span class="c1">// 不更新 Context 的情况下和调用方的 Context 相同
</span><span class="c1"></span>  <span class="n">callerContext</span> <span class="o">===</span> <span class="n">coroutineContext</span>

<span class="k">suspend</span> <span class="k">fun</span> <span class="nf">checkContinuationContext</span><span class="p">():</span> <span class="n">Boolean</span> <span class="p">{</span>

  <span class="c1">// suspendCoroutine 是连接 suspend 和回调的桥梁。
</span><span class="c1"></span>  <span class="c1">// 传给它的 lambda 属于桥回调的那一边，不是 suspend 的 block，
</span><span class="c1"></span>  <span class="c1">// 所以没有 coroutineContext。因此我们在桥的 suspend 这一边的时候
</span><span class="c1"></span>  <span class="c1">// 保存一下这个 suspend 的 Context
</span><span class="c1"></span>  <span class="k">val</span> <span class="py">currentContext</span> <span class="p">=</span> <span class="n">coroutineContext</span>

  <span class="c1">// 通过 suspendCoroutine 获取当前 Continuation
</span><span class="c1"></span>  <span class="k">return</span> <span class="n">suspendCoroutine</span> <span class="p">{</span> <span class="n">cont</span> <span class="o">-&gt;</span>
    <span class="k">val</span> <span class="py">contContext</span> <span class="p">=</span> <span class="n">cont</span><span class="p">.</span><span class="n">context</span>

    <span class="c1">// 两个 Context 是相同的
</span><span class="c1"></span>    <span class="k">val</span> <span class="py">isTheSame</span> <span class="p">=</span> <span class="n">contContext</span> <span class="o">===</span> <span class="n">currentContext</span>
    <span class="n">cont</span><span class="p">.</span><span class="n">resume</span><span class="p">(</span><span class="n">isTheSame</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>So is the Context mechanism provided by Kotlin just to facilitate passing some global state?</p>
<h3 id="a-core-element-the-continuationinterceptor">A core element: the ContinuationInterceptor</h3>
<p>We know that Context is for Coroutine. A Coroutine is when a programming language &ldquo;collaboratively&rdquo; dispatches subroutines to threads for execution at runtime.</p>
<p>The <code>ContinuationInterceptor</code> element provides the infrastructure for Coroutine scheduling. The familiar <code>CoroutineDispatcher</code>, such as <code>Dispatchers.IO</code>, which specifies the threads to execute Coroutines, is the <code>ContinuationInterceptor</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="k">object</span> <span class="nc">CommonPoolContext</span> <span class="p">:</span> 
  <span class="n">AbstractCoroutineContextElement</span><span class="p">(</span><span class="n">ContinuationInterceptor</span><span class="p">),</span> 
  <span class="n">ContinuationInterceptor</span> <span class="p">{</span>

  <span class="k">val</span> <span class="py">pool</span><span class="p">:</span> <span class="n">ForkJoinPool</span> <span class="p">=</span> <span class="n">ForkJoinPool</span><span class="p">()</span>
  <span class="k">override</span> <span class="k">fun</span> <span class="p">&lt;</span><span class="nc">T</span><span class="p">&gt;</span> <span class="nf">interceptContinuation</span><span class="p">(</span><span class="n">continuation</span><span class="p">:</span> <span class="n">Continuation</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;):</span> <span class="n">Continuation</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">=</span>
    <span class="k">object</span> <span class="err">: </span><span class="nc">Continuation</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
      <span class="k">override</span> <span class="k">val</span> <span class="py">context</span><span class="p">:</span> <span class="n">CoroutineContext</span> <span class="p">=</span> <span class="n">continuation</span><span class="p">.</span><span class="n">context</span>

      <span class="k">override</span> <span class="k">fun</span> <span class="nf">resumeWith</span><span class="p">(</span><span class="n">result</span><span class="p">:</span> <span class="n">Result</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;)</span> <span class="p">{</span>
        <span class="n">pool</span><span class="p">.</span><span class="n">submit</span> <span class="p">{</span> <span class="n">continuation</span><span class="p">.</span><span class="n">resumeWith</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">}</span>      <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="coroutinescope-and-structured-concurrency">CoroutineScope and &lsquo;structured concurrency&rsquo;</h2>
<p>A major milestone was reached on September 12, 2018 with the release of version 0.26.0 of the Coroutine library kotlinx.coroutines. Prior to this coroutine builders were global top-level functions that did not require a <code>CoroutineScope</code> to enable Coroutine, such as <code>async</code> in the example below.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="c1">// ⚠️ 使用了已废弃、过时的 API
</span><span class="c1"></span><span class="k">suspend</span> <span class="k">fun</span> <span class="nf">loadAndCombineImage</span><span class="p">(</span><span class="n">name1</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="n">name2</span><span class="p">:</span> <span class="n">String</span><span class="p">):</span> <span class="n">Image</span> <span class="p">{</span>
  <span class="k">val</span> <span class="py">image1</span> <span class="p">=</span> <span class="n">async</span> <span class="p">{</span> <span class="n">loadImage</span><span class="p">(</span><span class="n">name1</span><span class="p">)</span> <span class="p">}</span>  <span class="k">val</span> <span class="py">image2</span> <span class="p">=</span> <span class="n">async</span> <span class="p">{</span> <span class="n">loadImage</span><span class="p">(</span><span class="n">name2</span><span class="p">)</span> <span class="p">}</span>  <span class="k">return</span> <span class="n">combineImages</span><span class="p">(</span><span class="n">image1</span><span class="p">.</span><span class="n">await</span><span class="p">(),</span> <span class="n">image2</span><span class="p">.</span><span class="n">await</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="trouble-with-global-top-level-coroutine-builder">Trouble with global top-level coroutine builder</h3>
<p>What are the problems with such a design? Let&rsquo;s look at a few simple examples.</p>
<p>Example: Passing a file stream to a <code>process</code> function for processing</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="k">fun</span> <span class="nf">process</span><span class="p">(</span><span class="n">stream</span><span class="p">:</span> <span class="n">InputStream</span><span class="p">):</span> <span class="n">Unit</span> <span class="p">{</span> <span class="cm">/**/</span> <span class="p">}</span>

<span class="n">File</span><span class="p">(</span><span class="s2">&#34;foo.txt&#34;</span><span class="p">).</span><span class="n">inputStream</span><span class="p">().</span><span class="n">use</span> <span class="p">{</span>
  <span class="n">process</span><span class="p">(</span><span class="k">it</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>As a result, the exception <code>java.io.IOException</code> : Stream closed is thrown when it runs, and we open the function <code>process</code> to see.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="k">fun</span> <span class="nf">process</span><span class="p">(</span><span class="n">stream</span><span class="p">:</span> <span class="n">InputStream</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">GlobalScope</span><span class="p">.</span><span class="n">launch</span> <span class="p">{</span>    <span class="n">delay</span><span class="p">(</span><span class="m">1000</span><span class="p">)</span>
    <span class="n">stream</span><span class="p">.</span><span class="n">reader</span><span class="p">().</span><span class="n">readText</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>It turns out that <code>use</code> in the Kotlin standard library closes the file stream (encapsulating finally) after the accepted lambda has finished executing. Since the asynchronous task opened by the <code>process</code> function is still executing after it returns, but the file is closed, an exception is thrown.</p>
<p>Example: Suppose we call a <code>writeData</code> function to write some data to storage, and this function opens a Coroutine that is scheduled to execute in the IO thread with <code>launch(Dispatchers.IO)</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">writeData</span><span class="p">()</span>
  <span class="c1">// 🤔 数据写完了吗？可以读这个数据了吗？
</span><span class="c1"></span><span class="p">}</span>

<span class="k">fun</span> <span class="nf">writeData</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">GlobalScope</span><span class="p">.</span><span class="n">launch</span><span class="p">(</span><span class="n">Dispatchers</span><span class="p">.</span><span class="n">IO</span><span class="p">)</span> <span class="p">{</span>    <span class="c1">// doing some work
</span><span class="c1"></span>    <span class="c1">// before writing data
</span><span class="c1"></span>  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>After <code>writeData</code> returns, has the data been written? We can&rsquo;t be sure. The Coroutine inside <code>writeData</code> that <code>launches</code> can even throw an exception, but as the caller we can&rsquo;t catch this exception (we can&rsquo;t catch the exception thrown inside the Coroutine opened by <code>writeData</code> by try catching outside <code>writeData</code>).</p>
<p>Example: Android&rsquo;s Activity</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="k">class</span> <span class="nc">MyActivity</span><span class="p">:</span> <span class="n">Activity</span> <span class="p">{</span>
  <span class="k">val</span> <span class="py">binding</span> <span class="p">=</span> <span class="n">MyActivityBinding</span><span class="p">.</span><span class="n">inflate</span><span class="p">(</span><span class="n">layoutInflater</span><span class="p">)</span>

  <span class="k">override</span> <span class="k">fun</span> <span class="nf">onCreate</span><span class="p">(</span><span class="n">savedInstanceState</span><span class="p">:</span> <span class="n">Bundle</span><span class="p">?)</span> <span class="p">{</span>
    <span class="n">GlobalScope</span><span class="p">.</span><span class="n">launch</span> <span class="p">{</span>      <span class="k">val</span> <span class="py">result</span> <span class="p">=</span> <span class="err">🏹</span> <span class="n">someNetworkRequest</span><span class="p">()</span>
      <span class="n">binding</span><span class="p">.</span><span class="n">resultView</span><span class="p">.</span><span class="n">text</span> <span class="p">=</span> <span class="n">result</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Suppose <code>someNetworkRequest</code> becomes slow due to network problems, and the user may get impatient and close the page. Since the Coroutine block of <code>launch</code> refers to the properties of the Activity, this Coroutine will leak together with the whole Activity.</p>
<p>Analyzing the above examples, we can see that the problem is that we have opened the Coroutine and then abandoned it, not canceling it in time or not <code>join</code> to wait for the result of the Coroutine. In fact, not only Kotlin&rsquo;s <code>GlobalScope</code>, but almost all asynchronous APIs (thread, promise, callback, goroutine, etc.) allow us to enable asynchronous tasks without lifecycle qualification. When the function that started the asynchronous task returns, the asynchronous task may not have finished yet and continue to execute in the background. The caller has no way of knowing when the asynchronous task has finished and whether an exception has been thrown.</p>
<p>You may have experienced that when using some APIs, you have to manually delay the execution of the logic for a few seconds, otherwise strange problems will occur. Maybe the API forgot to join a thread.</p>
<h3 id="structured-concurrency">Structured Concurrency</h3>
<p>So it seems like a better choice for asynchronous APIs to make join wait for asynchronous tasks to complete the default behavior - that&rsquo;s the core idea of Structured Concurrency.</p>
<p>Nathaniel J. Smith, author of Trio, an asynchronous concurrency library for Python, published a blog post in 2018 <a href="https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/">Notes on structured concurrency, or: Go statement considered harmful</a>, which is a thorough exposition of Structured Concurrency, and is worth a read. Coroutine&rsquo;s <code>GlobalScope.launch</code>. It is argued that the existing asynchronous API, typified by the <code>go</code> keyword, is akin to the goto statement that Dijkstra argued against half a century ago.</p>
<p>In his famous article <a href="https://homepages.cwi.nl/~storm/teaching/reader/Dijkstra68.pdf">Go To Statement Considered Harmful (1968)</a>, Dijkstra pointed out that people are better at grasping the static relationships between things static relationships, whereas when a program is running, the flow of state of the process is a very dynamic process. Therefore, it is difficult to draw a complete picture in one&rsquo;s mind of how the state of a program changes while it is running. Programming languages should be designed to <strong>shorten the difference between the code text and the runtime program</strong> as much as possible, so that the programmer can look at a line of code and deduce the state of the program.</p>
<p>The goto statement, which was very popular at the time, allowed the process to jump to any position in the corresponding code text. This way we can only simulate the execution of the program in our minds from the beginning, and it is difficult to infer the running state of the program at the local location of the code, which makes it difficult to guarantee the correctness of the program.</p>
<p>Dijkstra believes that high-level languages should abandon goto statements and promote &ldquo;Structured Programming&rdquo; - that is, programmers use conditional, loops, function blocks, and other structural blocks to combine program logic.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/15/baee5b0f057c4b96a0def020817ef5ec.png" alt="image"></p>
<p>As you can see, the program always goes from top to bottom (sequential) when it passes through these control structures: one entrance, one exit. The middle part of the different control structures is like a &ldquo;black box&rdquo;. When we read this piece of code, we can be sure that there is some logic in this block, and when this logic is done, the control flow will eventually come out of one exit and go to the next line of code. And once the programming language supports goto statements, this encapsulation is broken.</p>
<p>In structured concurrency, all asynchronous tasks are bound inside a scope that is similar to the conditional, loop, and function control bodies in structured programming, and although there may be multiple tasks executing concurrently, they all eventually come out of a single exit, conforming to the nature of a &ldquo;black box&rdquo;. Assuming the programmer reads the dotted line shown in the figure, he can be sure that if the code goes here, the three concurrent tasks above must have completed successfully.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/15/7ca53e56ace74c3a9827a85fb89ae721.png" alt="image"></p>
<p>More and more languages are absorbing the idea of structured concurrency, such as Java&rsquo;s <a href="https://wiki.openjdk.java.net/display/loom/Structured+Concurrency">Project Loom</a> and [Swift&rsquo;s Coroutine](https ://forums.swift.org/t/swift-concurrency-roadmap/41611).</p>
<h3 id="job-and-cancellation">Job and cancellation</h3>
<p>Before we discuss how Kotlin implements structured concurrency, let&rsquo;s look at Coroutine&rsquo;s Cancellation.</p>
<p>First, as you can see from the Android Activity example above, if the user leaves the interface, the Coroutine should support cancellation for the sake of recycling system resources in a timely manner. Also on the server side, if a connection is broken or a key asynchronous task fails, other asynchronous tasks should be stopped in time to avoid unnecessary waste of resources.</p>
<p>The fact that Kotlin&rsquo;s Coroutine, Java&rsquo;s threads and Goroutine are all collaborative means that to truly support cancellation, the Coroutine needs to actively check if the current Job is active in between tasks. This is because if a subroutine can be abruptly aborted, there is a high probability that things will go halfway, damaging data structures or file resources, etc.</p>
<p>The Go language implements Coroutine cancellation through channels, and the following example passes a channel named <code>done</code> to all functions in the call chain that contain asynchronous tasks. The caller &ldquo;notifies&rdquo; all open Coroutines of the end of the ongoing task by closing the channel. We don&rsquo;t send data to this channel, we just &ldquo;broadcast&rdquo; the side effects of closing it.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="n">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// 创建 channel
</span><span class="c1"></span>  <span class="n">done</span> <span class="p">:=</span> <span class="n">make</span><span class="p">(</span><span class="n">chan</span> <span class="n">struct</span><span class="p">{})</span>
  <span class="c1">// 开启Coroutine
</span><span class="c1"></span>  <span class="n">go</span> <span class="n">work</span><span class="p">(</span><span class="n">done</span><span class="p">)</span>
  <span class="n">go</span> <span class="n">work</span><span class="p">(</span><span class="n">done</span><span class="p">)</span>

  <span class="n">time</span><span class="p">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">5000</span> <span class="p">*</span> <span class="n">time</span><span class="p">.</span><span class="n">Millisecond</span><span class="p">)</span>
  <span class="n">close</span><span class="p">(</span><span class="n">done</span><span class="p">)}</span>

<span class="n">func</span> <span class="n">work</span><span class="p">(</span><span class="n">done</span> <span class="n">chan</span> <span class="n">struct</span><span class="p">{})</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">{</span>
    <span class="c1">// 在任务执行「间隙」检查 channel 是否被关闭
</span><span class="c1"></span>    <span class="k">if</span> <span class="n">cancelled</span><span class="p">(</span><span class="n">done</span><span class="p">)</span> <span class="p">{</span>      <span class="k">return</span>
    <span class="p">}</span>

    <span class="n">time</span><span class="p">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">1000</span> <span class="p">*</span> <span class="n">time</span><span class="p">.</span><span class="n">Millisecond</span><span class="p">)</span>
    <span class="n">println</span><span class="p">(</span><span class="s2">&#34;working...&#34;</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">cancelled</span><span class="p">(</span><span class="n">done</span> <span class="n">chan</span> <span class="n">struct</span><span class="p">{})</span> <span class="n">bool</span> <span class="p">{</span>
  <span class="n">select</span> <span class="p">{</span>
  <span class="c1">// channel 关闭之后 receive 会立即返回零值
</span><span class="c1"></span>  <span class="n">case</span> <span class="p">&lt;-</span><span class="n">done</span><span class="p">:</span>    <span class="k">return</span> <span class="k">true</span>  <span class="n">default</span><span class="p">:</span>
    <span class="k">return</span> <span class="k">false</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Based on this approach to Coroutine cancellation, the Go standard library provides a <code>Context</code> whose <code>Done</code> method returns such a channel. if you use a <code>Context</code>, all functions in the call chain need to explicitly pass in this <code>Context</code> object and listen to this <code>Done</code> channel inside each function.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="n">type</span> <span class="n">Context</span> <span class="k">interface</span> <span class="err">{</span>
  <span class="c1">// Done returns a channel 
</span><span class="c1"></span>  <span class="c1">// that is closed when this Context is canceled
</span><span class="c1"></span>  <span class="c1">// or times out.
</span><span class="c1"></span>  <span class="n">Done</span><span class="p">()</span> <span class="p">&lt;-</span><span class="n">chan</span> <span class="n">struct</span><span class="p">{}</span>  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>If you are used to using ThreadLocal, you may find this explicit passing of values cumbersome (e.g. <a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-context/#61-%E4%B8%8A%E4%B8%8B%E6%96%87-context">this introductory Go context Context article</a> under the comments).</p>
<p>In Kotlin Coroutine, we cancel the Coroutine via a Job object passed implicitly in <code>CoroutineContext</code>. The return value of the Coroutine builder <code>launch</code> is a Job object representing the Coroutine, which can be called <code>.cancel</code> to cancel the Coroutine and <code>.join</code> to wait for the Coroutine to finish. Since <code>Job</code> is a <code>CoroutineContext.Element</code>, the Job corresponding to the current Coroutine can be obtained from the <code>coroutineContext</code> property at any point in the suspend function call chain.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="k">suspend</span> <span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span>
  <span class="n">GlobalScope</span><span class="p">.</span><span class="n">launch</span> <span class="p">{</span>
    <span class="n">foo</span><span class="p">()</span>
  <span class="p">}.</span><span class="n">join</span><span class="p">()</span>

<span class="k">suspend</span> <span class="k">fun</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">=</span>
  <span class="n">bar</span><span class="p">()</span>

<span class="k">suspend</span> <span class="k">fun</span> <span class="nf">bar</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// true
</span><span class="c1"></span>  <span class="n">println</span><span class="p">(</span><span class="n">coroutineContext</span><span class="p">.</span><span class="n">isActive</span><span class="p">)</span>  <span class="n">delay</span><span class="p">(</span><span class="m">1000</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// CoroutineContext.isActive is just a shortcut
</span><span class="c1"></span><span class="k">public</span> <span class="k">val</span> <span class="py">CoroutineContext</span><span class="p">.</span><span class="n">isActive</span><span class="p">:</span> <span class="n">Boolean</span>
    <span class="k">get</span><span class="p">()</span> <span class="p">=</span> <span class="k">this</span><span class="p">[</span><span class="n">Job</span><span class="p">]</span><span class="o">?.</span><span class="n">isActive</span> <span class="o">==</span> <span class="k">true</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>How do we make the Kotlin Coroutine code we write support cancellation?</strong> Inside the Coroutine block opened by the coroutine builder, you can use <code>Job.isActive</code> to determine if the current Coroutine is cancelled. If it is cancelled, you can return it directly or throw <code>CancellationException</code>. This exception is different from other exceptions in the Coroutine library and has a special meaning. It is a special flag used to cancel a Coroutine, and after it is thrown, the call stack reverts back to the <code>launch</code> Coroutine and the whole Coroutine <strong>ends normally</strong> and the exception does not continue to propagate.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="k">suspend</span> <span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">val</span> <span class="py">job</span> <span class="p">=</span> <span class="n">GlobalScope</span><span class="p">.</span><span class="n">launch</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="m">0.</span><span class="p">.</span><span class="m">50</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 除了 return 之外还可以抛 `CancellationException`
</span><span class="c1"></span>      <span class="c1">// Coroutine库提供的 `ensureActive` 封装了这一方法
</span><span class="c1"></span>      <span class="c1">// 另外也可以使用 `yield`
</span><span class="c1"></span>      <span class="k">if</span> <span class="p">(</span><span class="o">!is</span><span class="n">Active</span><span class="p">)</span> <span class="k">return</span><span class="nd">@launch</span>
      <span class="c1">// 下面这些写法也可以
</span><span class="c1"></span>      <span class="c1">// if (!isActive) throw CancellationException()
</span><span class="c1"></span>      <span class="c1">// ensureActive()
</span><span class="c1"></span>      <span class="c1">// yield()
</span><span class="c1"></span>
      <span class="n">println</span><span class="p">(</span><span class="n">fibonacci</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">delay</span><span class="p">(</span><span class="m">100</span><span class="p">)</span>
  <span class="c1">// 取消 job 并等待，避免 jvm 直接退出
</span><span class="c1"></span>  <span class="n">job</span><span class="p">.</span><span class="n">cancelAndJoin</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// ⚠️ deliberately slow fibonacci
</span><span class="c1"></span><span class="k">fun</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">Int</span> <span class="p">=</span> <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="m">1</span><span class="p">)</span>
  <span class="n">n</span> <span class="k">else</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">n</span> <span class="p">-</span> <span class="m">1</span><span class="p">)</span> <span class="p">+</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">n</span> <span class="p">-</span> <span class="m">2</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>Cancellation is supported inside the wrapped suspend function, return does not work and <code>CancellationException</code></strong> must be thrown. Because after return, the control flow returns to the upper level function normally and may continue to execute the synchronous statements that follow. When the Coroutine is cancelled, the entire call chain should immediately fall back. The Coroutine block of <code>launch</code>, on the other hand, is different from inside the suspend function and is the root node of the Coroutine call tree, so you can just return to end the Coroutine.</p>
<p>If we call a suspend function that supports cancellation, it means that this suspend function will check if the current Coroutine is cancelled and throw a <code>CancellationException</code>. All the suspend functions in <code>kotlinx.coroutines</code> support cancellation. By calling a suspend function that supports cancellation, we automatically support cancellation and need to do very little specialized processing.</p>
<p>Suppose we wrap the code that outputs the fibonacci numbers in the example above into a suspend function, inside which we can use the <code>yield</code> method to ensure that only the Coroutine in the active state will continue to compute.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="k">suspend</span> <span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">val</span> <span class="py">job</span> <span class="p">=</span> <span class="n">GlobalScope</span><span class="p">.</span><span class="n">launch</span> <span class="p">{</span>
    <span class="n">printFibonacciSlowly</span><span class="p">(</span><span class="m">50</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="n">delay</span><span class="p">(</span><span class="m">100</span><span class="p">)</span>
  <span class="n">job</span><span class="p">.</span><span class="n">cancelAndJoin</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">suspend</span> <span class="k">fun</span> <span class="nf">printFibonacciSlowly</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="m">0.</span><span class="p">.</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="err">🏹</span> <span class="n">yield</span><span class="p">()</span>    <span class="n">println</span><span class="p">(</span><span class="n">fibonacci</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>When wrapping the callback API as a suspend function, you can use <code>suspendCancellableCoroutine</code> to support the cancel operation, as described in <a href="https://blog.yujinyan.me/posts/understanding-kotlin-suspend-functions/#android-view-api">Understanding Kotlin&rsquo;s suspend function</a> for an example.</p>
<p>There are advantages and disadvantages to passing context implicitly like Kotlin and explicitly like Go. Kotlin makes use of the <code>CoroutineContext</code> integrated into the language for cleaner code; at the same time, we can make use of the Coroutine library in the Coroutine call tree At the same time, we can use the <code>yield</code> and <code>suspendCancellableCoroutine</code> functions provided in the Coroutine library to automatically insert a check of the Coroutine state in the <code>gap</code> of the asynchronous task, and back out the whole Coroutine call stack through the exception mechanism to make it more convenient to cancel Coroutine, but there may be some learning cost.</p>
<h3 id="job-and-coroutine-parent-child-relationship">Job and Coroutine parent-child relationship</h3>
<p>In the Coroutine call tree, it is possible to open a new Coroutine in addition to calling the suspend function. Coroutine.</p>
<p>Kotlin Coroutine recommended this way of writing before 0.26.0.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="k">suspend</span> <span class="k">fun</span> <span class="nf">sayHelloWorldInContext</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">GlobalScope</span><span class="p">.</span><span class="n">launch</span><span class="p">(</span><span class="n">coroutineContext</span><span class="p">)</span> <span class="p">{</span>    <span class="n">delay</span><span class="p">(</span><span class="m">500</span><span class="p">)</span>
    <span class="n">print</span><span class="p">(</span><span class="s2">&#34;Hello &#34;</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="n">GlobalScope</span><span class="p">.</span><span class="n">launch</span><span class="p">(</span><span class="n">coroutineContext</span><span class="p">)</span> <span class="p">{</span>    <span class="n">delay</span><span class="p">(</span><span class="m">1000</span><span class="p">)</span>
    <span class="n">print</span><span class="p">(</span><span class="s2">&#34;World!&#34;</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The above example will pass the <code>coroutineContext</code> added by the compiler in the suspend function into <code>launch</code>, so that the newly opened Coroutine will run in the external Coroutine Job that executes the suspend function. If the external Job is cancelled, the Coroutine in <code>sayHelloWorldInContext</code> with <code>launch</code> will also be cancelled, which can solve the problem of Coroutine leakage after the Android Activity with lifecycle is finished. But the other problem is not solved, the function to open Coroutine doesn&rsquo;t wait for the end of asynchronous task, and the asynchronous task may still be executed after returning. So a better way to write it is like this.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="k">suspend</span> <span class="k">fun</span> <span class="nf">sayHelloWorld</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">val</span> <span class="py">job</span> <span class="p">=</span> <span class="n">Job</span><span class="p">(</span><span class="n">parent</span> <span class="p">=</span> <span class="n">coroutineContext</span><span class="p">[</span><span class="n">Job</span><span class="p">])</span>  <span class="n">GlobalScope</span><span class="p">.</span><span class="n">launch</span><span class="p">(</span><span class="n">job</span><span class="p">)</span> <span class="p">{</span>    <span class="n">delay</span><span class="p">(</span><span class="m">500</span><span class="p">)</span>
    <span class="n">print</span><span class="p">(</span><span class="s2">&#34;Hello &#34;</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="n">GlobalScope</span><span class="p">.</span><span class="n">launch</span><span class="p">(</span><span class="n">job</span><span class="p">)</span> <span class="p">{</span>    <span class="n">delay</span><span class="p">(</span><span class="m">1000</span><span class="p">)</span>
    <span class="n">print</span><span class="p">(</span><span class="s2">&#34;World!&#34;</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="n">job</span><span class="p">.</span><span class="n">complete</span><span class="p">()</span>
  <span class="n">job</span><span class="p">.</span><span class="n">join</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>In this example, we create a new Job instance inside the suspend function <code>sayHelloWorld</code>, and manually join the Job inside the function, which is a bit cumbersome to write, easy to forget, and not much better than Java&rsquo;s thread API. The Kotlin veterans may realize that they can encapsulate the internal Job-related logic into a higher-order function that takes a lambda with a Job instance as the receiver, such as</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="k">suspend</span> <span class="k">fun</span> <span class="nf">sayHelloWorld</span><span class="p">()</span> <span class="p">=</span> <span class="n">job</span> <span class="p">{</span>
  <span class="c1">// `this` is Job
</span><span class="c1"></span>  <span class="n">GlobalScope</span><span class="p">.</span><span class="n">launch</span><span class="p">(</span><span class="k">this</span><span class="p">)</span> <span class="p">{</span>    <span class="n">delay</span><span class="p">(</span><span class="m">500</span><span class="p">)</span>
    <span class="n">print</span><span class="p">(</span><span class="s2">&#34;Hello &#34;</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="n">GlobalScope</span><span class="p">.</span><span class="n">launch</span><span class="p">(</span><span class="k">this</span><span class="p">)</span> <span class="p">{</span>    <span class="n">delay</span><span class="p">(</span><span class="m">1000</span><span class="p">)</span>
    <span class="n">print</span><span class="p">(</span><span class="s2">&#34;World!&#34;</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>This is very Kotlin, but <code>launch(this)</code> is a bit awkward, and Kotlin veterans might think that if <code>launch</code> is defined on the Receiver of a <code>job</code> block, then we could just <code>launch</code> inside the block, and write it much like the global top-level functions before 0.26.0.</p>
<p>At this point we&rsquo;ve pretty much reinvented the two pillars of the Kotlin Coroutine library Structured Concurrency - the <code>coroutineScope</code> higher-order function and the <code>CoroutineScope</code> interface. <code>CoroutineScope</code> is similar to the <code>job</code> function we wrote (<a href="https://github.com/Kotlin/kotlinx.coroutines/issues/410#issuecomment-403054790">Kotlin officially considered using this name</a>). And <code>CoroutineScope</code> is the Receiver mentioned earlier.</p>
<h3 id="structured-concurrent-design-of-kotlin-coroutine">Structured concurrent design of Kotlin Coroutine</h3>
<p>Kotlin 0.26.0 deprecated all global top-level functions coroutine builder in favor of extended methods on <code>CoroutineScope</code>. This makes it mandatory to have a <code>CoroutineScope</code> to open a Coroutine. Dijkstra&rsquo;s point is not just that control bodies such as conditions, loops, and functions are recommended, but that goto&rsquo;s should be deprecated in programming languages, because as long as they exist, every function can have a goto inside, breaking the &ldquo;black box&rdquo; nature and breaking encapsulation. Similarly, structured concurrency argues for deprecating the &ldquo;unstructured&rdquo;, fire-and-forget asynchronous API. The introduction of <code>CoroutineScope</code> has made structured concurrency the default behavior in the Kotlin Coroutine API.</p>
<p>According to current best practices, if you need to open a new Coroutine in the suspend function, you need to first open a new block with the help of <code>coroutineScope</code>, which contains a new Job and limits the lifecycle of all Coroutines opened in it: if the code runs behind the <code>coroutineScope</code> block, it means that all asynchronous jobs inside this block have been successfully terminated; if any of the Coroutines in <code>coroutineScope</code> throws an exception, the call stack is rolled back and the exception is passed to the outer layer of <code>coroutineScope</code>. In the following example, if any of the <code>loadImage</code>s fails to throw an exception, the exception is passed to the caller of <code>loadAndCombineImage</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="k">suspend</span> <span class="k">fun</span> <span class="nf">loadAndCombineImage</span><span class="p">(</span><span class="n">name1</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="n">name2</span><span class="p">:</span> <span class="n">String</span><span class="p">):</span> <span class="n">Image</span> <span class="p">=</span>
  <span class="n">coroutineScope</span> <span class="p">{</span>    <span class="k">val</span> <span class="py">image1</span> <span class="p">=</span> <span class="n">async</span> <span class="p">{</span> <span class="n">loadImage</span><span class="p">(</span><span class="n">name1</span><span class="p">)</span> <span class="p">}</span>
    <span class="k">val</span> <span class="py">image2</span> <span class="p">=</span> <span class="n">async</span> <span class="p">{</span> <span class="n">loadImage</span><span class="p">(</span><span class="n">name2</span><span class="p">)</span> <span class="p">}</span>
    <span class="k">return</span> <span class="n">combineImages</span><span class="p">(</span><span class="n">image1</span><span class="p">.</span><span class="n">await</span><span class="p">(),</span> <span class="n">image2</span><span class="p">.</span><span class="n">await</span><span class="p">())</span>
  <span class="p">}</span>

<span class="c1">// ⚠️ 使用了已废弃的全局顶层 coroutine builder
</span><span class="c1"></span><span class="k">suspend</span> <span class="k">fun</span> <span class="nf">loadAndCombineImage</span><span class="p">(</span><span class="n">name1</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="n">name2</span><span class="p">:</span> <span class="n">String</span><span class="p">):</span> <span class="n">Image</span> <span class="p">{</span>
  <span class="k">val</span> <span class="py">image1</span> <span class="p">=</span> <span class="n">async</span> <span class="p">{</span> <span class="n">loadImage</span><span class="p">(</span><span class="n">name1</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">val</span> <span class="py">image2</span> <span class="p">=</span> <span class="n">async</span> <span class="p">{</span> <span class="n">loadImage</span><span class="p">(</span><span class="n">name2</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">return</span> <span class="n">combineImages</span><span class="p">(</span><span class="n">image1</span><span class="p">.</span><span class="n">await</span><span class="p">(),</span> <span class="n">image2</span><span class="p">.</span><span class="n">await</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The top-level Coroutine is the &ldquo;end of the world&rdquo; and generally needs to be integrated with a framework component that has a lifecycle, configured with a <code>CoroutineScope</code>. Example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="k">class</span> <span class="nc">MyActivity</span> <span class="p">:</span> <span class="n">CoroutineScope</span> <span class="p">{</span>  <span class="k">val</span> <span class="py">job</span> <span class="p">=</span> <span class="n">SupervisorJob</span><span class="p">()</span>
  <span class="k">override</span> <span class="k">val</span> <span class="py">coroutineContext</span> <span class="p">=</span> <span class="n">Dispatchers</span><span class="p">.</span><span class="n">Main</span> <span class="p">+</span> <span class="n">job</span>
  <span class="k">fun</span> <span class="nf">doSomethingInBackground</span><span class="p">()</span> <span class="p">=</span> <span class="n">launch</span> <span class="p">{</span> <span class="o">..</span><span class="p">.</span> <span class="p">}</span>
  <span class="k">fun</span> <span class="nf">onDestroy</span><span class="p">()</span> <span class="p">{</span> <span class="n">job</span><span class="p">.</span><span class="n">cancel</span><span class="p">()</span> <span class="p">}</span>    
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>In this example, the Context, Scope and Job parts of the Kotlin Coroutine are elegantly stitched together: we have the system component with the lifecycle implement <code>CoroutineScope</code>, which requires override <code>coroutineContext</code>, where we configure all the default properties of the Coroutine opened in this We need to override <code>CoroutineContext</code>, where we configure the default properties of all the Coroutines opened in this scope. Since <code>MyActivity</code> &ldquo;is&rdquo; a <code>CoroutineScope</code>, you can omit <code>this</code> when opening the Coroutine, and the API calls look like global top-level functions, but with lifecycle constraints.</p>
<p>However, the familiar androidx provides Scope through the <code>LifecycleOwner.lifecycleScope</code> extension property. Android community. Using the above manual integration approach requires a base class like <code>BaseActivity</code> in the project, and requires the developer to understand the concepts of Context, Scope, and Job, which is a bit more expensive to learn.</p>
<p>For unstructured, traditional fire-and-forget concurrency, Kotlin provides the <code>GlobalScope</code> that was used as an example earlier. Reading this, I believe you can imagine the implementation of <code>GlobalScope</code> as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="k">public</span> <span class="k">object</span> <span class="nc">GlobalScope</span> <span class="p">:</span> <span class="n">CoroutineScope</span> <span class="p">{</span>
  <span class="k">override</span> <span class="k">val</span> <span class="py">coroutineContext</span><span class="p">:</span> <span class="n">CoroutineContext</span>
    <span class="k">get</span><span class="p">()</span> <span class="p">=</span> <span class="n">EmptyCoroutineContext</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The use of <code>GlobalScope</code> in applications is generally not recommended. Based on the idea of structured concurrency, <code>GlobalScope</code> may eventually be deprecated in the long run. Some &ldquo;backend&rdquo; asynchronous tasks may consider defining <code>CoroutineScope</code> on components with a longer lifecycle, such as Android&rsquo;s <code>Application</code> and Spring&rsquo;s <code>singleton</code> scope components. A more convenient approach could be.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="k">val</span> <span class="py">appScope</span> <span class="p">=</span> <span class="n">GlobalScope</span>
</code></pre></td></tr></table>
</div>
</div><p>Reference your own defined <code>appScope</code> in your business logic code to facilitate configuration of the Coroutine in a single location.</p>
<p>Two conventions of ## Kotlin Coroutine</p>
<p>How Kotlin structured concurrency solves <a href="https://blog.yujinyan.me/posts/kotlin-coroutine-context-scope/#%E5%85%A8%E5%B1%80%E9%A1%B6%E5%B1%82-coroutine-builder-%E7%9A%84%E9%BA%BB%E7%83%A6">&ldquo;the trouble caused by the global top-level coroutine builder function&rdquo;</a> under this heading? As an example of a problem dealing with file streams.</p>
<p>To turn on Coroutine you must have <code>CoroutineScope</code>. We can pass this <code>CoroutineScope</code> explicitly into the wrapped function, or we can define it as an extension method of <code>CoroutineScope</code> like the coroutine builder. The difference is only formal, but the substance is the same, but the latter seems to be more in line with the Kotlin style.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="k">fun</span> <span class="nf">CoroutineScope</span><span class="p">.</span><span class="n">process</span><span class="p">(</span><span class="n">stream</span><span class="p">:</span> <span class="n">InputStream</span><span class="p">)</span> <span class="p">{</span>  <span class="n">launch</span> <span class="p">{</span>
    <span class="n">delay</span><span class="p">(</span><span class="m">1000</span><span class="p">)</span>
    <span class="n">stream</span><span class="p">.</span><span class="n">reader</span><span class="p">().</span><span class="n">readText</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">suspend</span> <span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">File</span><span class="p">(</span><span class="s2">&#34;foo.txt&#34;</span><span class="p">).</span><span class="n">inputStream</span><span class="p">().</span><span class="n">use</span> <span class="p">{</span>
    <span class="n">coroutineScope</span> <span class="p">{</span>      <span class="n">process</span><span class="p">(</span><span class="k">it</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// 🚩 程序运行到这里 process 一定正常结束了
</span><span class="c1"></span>  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Using structured concurrency, wrapping a <code>coroutineScope</code> block around <code>process</code> allows the caller to control the lifecycle of the Coroutine opened within the called function. We can be sure that the end of the <code>coroutineScope</code> block means that all the asynchronous tasks started by <code>process</code> have been successfully completed.</p>
<p>In addition to the extended functions on <code>CoroutineScope</code>, the mechanism for reusing the Kotlin Coroutine abstraction is described in the sister article &ldquo;Understanding Kotlin&rsquo;s suspend function&rdquo;. There are important differences between the two.</p>
<ul>
<li>The extension function defined on <code>CoroutineScope</code> provides the convention that this function returns immediately, but the function opens an asynchronous task, which can be interpreted as concurrent execution of the subroutine inside this function and the caller&rsquo;s code.</li>
<li>The suspend function provides the convention that calling the function will not block the thread, but the function will return when the subroutine inside the function is finished and control flows back to the caller. suspend should not have the side effect of opening an asynchronous task.</li>
</ul>
<blockquote>
<p>Suspend functions are sequential by default. Concurrency is hard, and its launch must be explicit.</p>
<p>Roman Elizarov, Project Lead for Kotlin</p>
</blockquote>
<p>As you can see, Kotlin makes a distinction between these two different properties of functions in the type system.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="c1">// slow work but does not block caller&#39;s thread
</span><span class="c1"></span><span class="k">suspend</span> <span class="n">foo</span><span class="p">(</span><span class="n">params</span><span class="p">:</span> <span class="n">Params</span><span class="p">):</span> <span class="n">Response</span>

<span class="c1">// launch concurrent subprogram with surrounding code 
</span><span class="c1"></span><span class="k">fun</span> <span class="nf">CoroutineScope</span><span class="p">.</span><span class="n">foo</span><span class="p">(</span><span class="n">params</span><span class="p">:</span> <span class="n">Params</span><span class="p">):</span> <span class="n">Response</span>
</code></pre></td></tr></table>
</div>
</div><p>理解和遵循这两个约定是用好 Kotlin Coroutine的关键。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="c1">// ❌ 反面示例：违背了 Kotlin Coroutine的设计约定
</span><span class="c1"></span><span class="k">suspend</span> <span class="k">fun</span> <span class="nf">CoroutineScope</span><span class="p">.</span><span class="n">foo</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div>
    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/kotlin/">kotlin</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-01/understanding-kotlin-suspend-functions/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Understanding Kotlin Suspend Functions</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-01/why-js-map-trim-do-not-work-together/">
            <span class="next-text nav-default">Why can&#39;t I use String.prototype.trim in a JS map?</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
