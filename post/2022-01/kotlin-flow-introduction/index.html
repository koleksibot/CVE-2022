<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Getting Started with Kotlin Flow - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Starting with Sequence Sequence is a Lazy List implementation provided by Kotlin. For example, the following Fibonacci list is implemented using Sequence. 1 2 3 4 5 6 7 8 9 10 val fibonacci = sequence { var terms = Pair(0L, 1L) while (true) { 🏹 yield(terms.first) terms = Pair( terms.second, terms.first &#43; terms.second ) } } The terminal operator We use an infinite loop in the Sequence builder block" /><meta name="keywords" content="kotlin, Flow" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-01/kotlin-flow-introduction/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Getting Started with Kotlin Flow" />
<meta property="og:description" content="Starting with Sequence Sequence is a Lazy List implementation provided by Kotlin. For example, the following Fibonacci list is implemented using Sequence. 1 2 3 4 5 6 7 8 9 10 val fibonacci = sequence { var terms = Pair(0L, 1L) while (true) { 🏹 yield(terms.first) terms = Pair( terms.second, terms.first &#43; terms.second ) } } The terminal operator We use an infinite loop in the Sequence builder block" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-01/kotlin-flow-introduction/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-01-15T12:33:44+08:00" />
<meta property="article:modified_time" content="2022-01-15T12:33:44+08:00" />

<meta itemprop="name" content="Getting Started with Kotlin Flow">
<meta itemprop="description" content="Starting with Sequence Sequence is a Lazy List implementation provided by Kotlin. For example, the following Fibonacci list is implemented using Sequence. 1 2 3 4 5 6 7 8 9 10 val fibonacci = sequence { var terms = Pair(0L, 1L) while (true) { 🏹 yield(terms.first) terms = Pair( terms.second, terms.first &#43; terms.second ) } } The terminal operator We use an infinite loop in the Sequence builder block"><meta itemprop="datePublished" content="2022-01-15T12:33:44+08:00" />
<meta itemprop="dateModified" content="2022-01-15T12:33:44+08:00" />
<meta itemprop="wordCount" content="3319">
<meta itemprop="keywords" content="kotlin," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Getting Started with Kotlin Flow"/>
<meta name="twitter:description" content="Starting with Sequence Sequence is a Lazy List implementation provided by Kotlin. For example, the following Fibonacci list is implemented using Sequence. 1 2 3 4 5 6 7 8 9 10 val fibonacci = sequence { var terms = Pair(0L, 1L) while (true) { 🏹 yield(terms.first) terms = Pair( terms.second, terms.first &#43; terms.second ) } } The terminal operator We use an infinite loop in the Sequence builder block"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Getting Started with Kotlin Flow</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-01-15 12:33:44 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 3319 words </span>
          <span class="more-meta"> 7 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#starting-with-sequence">Starting with Sequence</a>
          <ul>
            <li><a href="#the-terminal-operator">The terminal operator</a></li>
            <li><a href="#the-intermediate-operator">The intermediate operator</a></li>
            <li><a href="#--find-the-first-non-null-property">### : find the first non-null property</a></li>
            <li><a href="#use-case-flat-nested-list-iterator">Use Case: Flat Nested List Iterator</a></li>
          </ul>
        </li>
        <li><a href="#flow-suspendable-sequence">Flow: Suspendable Sequence</a></li>
        <li><a href="#a-toy-flow">A Toy Flow</a>
          <ul>
            <li><a href="#implementing-collect">Implementing collect</a></li>
            <li><a href="#intermediate-operators">Intermediate operators</a></li>
            <li><a href="#full-code">Full code</a></li>
          </ul>
        </li>
        <li><a href="#additional-guarantees-for-flow">Additional guarantees for Flow</a>
          <ul>
            <li><a href="#context-preservation">Context preservation</a></li>
            <li><a href="#exception-transparency-exception-transparency">Exception transparency (Exception transparency)</a></li>
          </ul>
        </li>
        <li><a href="#flow-in-android-client-application">Flow in Android client application</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="starting-with-sequence">Starting with Sequence</h2>
<p>Sequence is a Lazy List implementation provided by Kotlin. For example, the following Fibonacci list is implemented using Sequence.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="k">val</span> <span class="py">fibonacci</span> <span class="p">=</span> <span class="n">sequence</span> <span class="p">{</span>
  <span class="k">var</span> <span class="py">terms</span> <span class="p">=</span> <span class="n">Pair</span><span class="p">(</span><span class="m">0L</span><span class="p">,</span> <span class="m">1L</span><span class="p">)</span>
  <span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="err">🏹</span> <span class="n">yield</span><span class="p">(</span><span class="n">terms</span><span class="p">.</span><span class="n">first</span><span class="p">)</span>
    <span class="n">terms</span> <span class="p">=</span> <span class="n">Pair</span><span class="p">(</span>
      <span class="n">terms</span><span class="p">.</span><span class="n">second</span><span class="p">,</span>
      <span class="n">terms</span><span class="p">.</span><span class="n">first</span> <span class="p">+</span> <span class="n">terms</span><span class="p">.</span><span class="n">second</span>
    <span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="the-terminal-operator">The terminal operator</h3>
<p>We use an infinite loop in the Sequence builder block to continuously compute the elements of the sequence and send them to the consumer via <code>yield</code>. The consumers of Sequence are the so-called terminal operators, such as <code>forEach</code>, <code>sum</code>, etc.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="n">fibonacci</span><span class="p">.</span><span class="n">take</span><span class="p">(</span><span class="m">10</span><span class="p">).</span><span class="n">forEach</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="k">it</span><span class="p">)</span> <span class="p">}</span>
<span class="n">fibonacci</span><span class="p">.</span><span class="n">take</span><span class="p">(</span><span class="m">10</span><span class="p">).</span><span class="n">sum</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>In the case of <code>forEach</code>, whenever we <code>yield</code> a new element in the <code>sequence</code> block, we send that element to the <code>forEach</code> block for processing, and then go back to the <code>sequence</code> block to execute the subsequent logic and compute the next value. A normal list would first compute all the elements in memory. Because of this, we can use Sequence to represent an infinite sequence of elements. However, when consuming data, you must use the <code>take</code> intervening operator to limit the number of elements to be consumed.</p>
<h3 id="the-intermediate-operator">The intermediate operator</h3>
<p>Sequence has <code>map</code> and <code>filter</code> intermediate operators, just like List. Each call to an intermediate operator on a List returns a new List; a call to an operator on a Sequence is equivalent to building a pipeline of data. After an element is <code>yielded</code>, it travels through these defined data pipelines to the end consumer.</p>
<p>Assuming there is no end-consumer, then we have built the data pipeline, but the code in the Sequence builder does not run at runtime.</p>
<p>The following small example will output the string <code>&quot;AaBbCc&quot;</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="n">sequence</span> <span class="p">{</span>
  <span class="n">yield</span><span class="p">(</span><span class="s2">&#34;A&#34;</span><span class="p">.</span><span class="n">also</span> <span class="p">{</span> <span class="n">print</span><span class="p">(</span><span class="k">it</span><span class="p">)</span> <span class="p">})</span>
  <span class="n">yield</span><span class="p">(</span><span class="s2">&#34;B&#34;</span><span class="p">.</span><span class="n">also</span> <span class="p">{</span> <span class="n">print</span><span class="p">(</span><span class="k">it</span><span class="p">)</span> <span class="p">})</span>
  <span class="n">yield</span><span class="p">(</span><span class="s2">&#34;C&#34;</span><span class="p">.</span><span class="n">also</span> <span class="p">{</span> <span class="n">print</span><span class="p">(</span><span class="k">it</span><span class="p">)</span> <span class="p">})</span>
<span class="p">}.</span><span class="n">forEach</span> <span class="p">{</span>
  <span class="n">print</span><span class="p">(</span><span class="k">it</span><span class="p">.</span><span class="n">toLowerCase</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="--find-the-first-non-null-property">### : find the first non-null property</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="k">class</span> <span class="nc">Feedback</span><span class="p">(</span>
  <span class="k">val</span> <span class="py">rate</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span>
  <span class="k">val</span> <span class="py">message</span><span class="p">:</span> <span class="n">String</span><span class="p">?</span>
<span class="p">)</span>

<span class="k">val</span> <span class="py">feedbacks</span> <span class="p">=</span> <span class="n">listOf</span><span class="p">(</span>
  <span class="n">Feedback</span><span class="p">(</span><span class="m">4</span><span class="p">,</span> <span class="k">null</span><span class="p">),</span>
  <span class="n">Feedback</span><span class="p">(</span><span class="m">4</span><span class="p">,</span> <span class="s2">&#34;Cool and clear function&#34;</span><span class="p">),</span>
  <span class="n">Feedback</span><span class="p">(</span><span class="m">3</span><span class="p">,</span> <span class="k">null</span><span class="p">),</span>
  <span class="n">Feedback</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="s2">&#34;Hey, it&#39;s too much&#34;</span><span class="p">),</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Suppose we want to find the first <code>Feedback.message</code> in the list of <code>feedbacks</code> that is not null, i.e. <code>&quot;Cool and clear function&quot;</code>. There are several ways to do this.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="c1">// 方法1： 生成一个中间 Collection
</span><span class="c1"></span><span class="n">feedbacks</span>
  <span class="p">.</span><span class="n">mapNotNull</span> <span class="p">{</span> <span class="k">it</span><span class="p">.</span><span class="n">name</span> <span class="p">}</span>
  <span class="p">.</span><span class="n">firstOrNull</span><span class="p">()</span>

<span class="c1">// 方法2： 转换成 Sequence
</span><span class="c1"></span><span class="n">feedbacks</span>
  <span class="p">.</span><span class="n">asSequence</span><span class="p">()</span>
  <span class="p">.</span><span class="n">mapNotNull</span> <span class="p">{</span> <span class="k">it</span><span class="p">.</span><span class="n">name</span> <span class="p">}</span>
  <span class="p">.</span><span class="n">firstOrNull</span><span class="p">()</span>

<span class="c1">// 方法3： Kotlin 1.5 标准库方法
</span><span class="c1"></span><span class="n">feedbacks</span><span class="p">.</span><span class="n">firstNotNullOfOrNull</span> <span class="p">{</span> <span class="k">it</span><span class="p">.</span><span class="n">name</span> <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>If the set has a lot of elements or needs to be transformed by many operators, Method 1 creates a new set for each transformation and stores the intermediate results, which is a bit wasteful. It would be better to use Sequence for such scenarios.</p>
<h3 id="use-case-flat-nested-list-iterator">Use Case: Flat Nested List Iterator</h3>
<p>Suppose there is a nested list of integers. Design an iterator that iterates over all the integers in this integer list. The integer list is represented by this interface.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="k">interface</span> <span class="nc">NestedInteger</span> <span class="p">{</span>
  <span class="k">fun</span> <span class="nf">isInteger</span><span class="p">():</span> <span class="n">Boolean</span>
  <span class="k">fun</span> <span class="nf">getInteger</span><span class="p">():</span> <span class="n">Int</span><span class="p">?</span>
  <span class="k">fun</span> <span class="nf">getList</span><span class="p">():</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">NestedInteer</span><span class="p">&gt;?</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Each item in a list is either an integer or another list. The elements of the list may also be integers or other lists. Example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="n">输入</span><span class="p">:</span> <span class="p">[[</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">],</span><span class="m">2</span><span class="p">,[</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">]]</span>
<span class="n">输出</span><span class="p">:</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p>If all the elements are stored in a list, the problem can be easily solved using recursion.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="k">fun</span> <span class="nf">flatten</span><span class="p">(</span><span class="n">nestedList</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">NestedInteger</span><span class="p">&gt;):</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;</span> <span class="p">{</span>
  <span class="k">val</span> <span class="py">ans</span> <span class="p">=</span> <span class="n">mutableListOf</span><span class="p">()</span>

  <span class="k">fun</span> <span class="nf">walk</span><span class="p">(</span><span class="n">list</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">NestedInteger</span><span class="p">&gt;)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">item</span> <span class="k">in</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">isInteger</span><span class="p">())</span> <span class="n">ans</span> <span class="o">+=</span> <span class="n">item</span>
      <span class="k">else</span> <span class="n">walk</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">getList</span><span class="p">())</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">walk</span><span class="p">(</span><span class="n">nestedList</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">ans</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>After getting the list, it can be turned into an iterator. But the iterator should be &ldquo;lazy&rdquo;, meaning that the consumer consumes the data while the iterator traverses the data source. The advantages of this include.</p>
<ul>
<li>If the consumer only needs the first few pieces of data, and the data source is large, then pre-computing the entire List does a lot of useless work.</li>
<li>Consumers do not have to wait for the entire List to be computed before proceeding to the next step. The whole data processing process can be sped up by concurrency.</li>
</ul>
<p>However, this makes it inconvenient for us to recurse directly, and we need to maintain a stack manually by ourselves, which makes the original simple code much more complicated (you can see the full code at <a href="https://blog.yujinyan.me/leetcode/flatten-nested-list-iterator/#solution">here</a>) .</p>
<p>With Sequence, we can implement a lazy iterator using the recursive algorithm.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="c1">// 为了进行递归需要封装出一个函数
</span><span class="c1"></span><span class="k">suspend</span> <span class="k">tailrec</span> <span class="k">fun</span> <span class="nf">SequenceScope</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;.</span><span class="n">walk</span><span class="p">(</span>
  <span class="n">list</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">NestedInteger</span><span class="p">&gt;</span>
<span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">item</span> <span class="k">in</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">isInteger</span><span class="p">())</span> <span class="n">yield</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">getInteger</span><span class="p">())</span>
    <span class="k">else</span> <span class="n">walk</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">getList</span><span class="p">())</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="n">sequence</span> <span class="p">{</span> <span class="n">walk</span><span class="p">(</span><span class="n">nestedList</span><span class="p">)</span> <span class="p">}.</span><span class="n">iterator</span><span class="p">()</span> <span class="c1">// 题目所求
</span></code></pre></td></tr></table>
</div>
</div><h2 id="flow-suspendable-sequence">Flow: Suspendable Sequence</h2>
<p>The above example has only pure computation in the data flow. In real scenarios we may need to do some time-consuming operations in the middle or terminal operators (assuming they are encapsulated in suspend functions), such as interfacing, reading and writing data from the database.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="k">suspend</span> <span class="k">fun</span> <span class="nf">search</span><span class="p">(</span><span class="n">string</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span><span class="cm">/**/</span><span class="p">}</span>
<span class="k">suspend</span> <span class="k">fun</span> <span class="nf">saveToDB</span><span class="p">(</span><span class="n">string</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span><span class="cm">/**/</span><span class="p">}</span>

<span class="c1">// ❌ 无法编译
</span><span class="c1">// 不能在 Sequence 的操作符中调用 suspend 函数
</span><span class="c1"></span><span class="n">sequenceOf</span><span class="p">(</span><span class="s2">&#34;foo&#34;</span><span class="p">,</span> <span class="s2">&#34;bar&#34;</span><span class="p">)</span>
  <span class="p">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">search</span><span class="p">(</span><span class="k">it</span><span class="p">)</span> <span class="p">}</span> <span class="c1">// 调用远程 api
</span><span class="c1"></span>  <span class="p">.</span><span class="n">forEach</span> <span class="p">{</span> <span class="n">saveToDB</span><span class="p">(</span><span class="k">it</span><span class="p">)</span> <span class="p">}</span> <span class="c1">// 存至数据库
</span></code></pre></td></tr></table>
</div>
</div><p>In the above example, we want to call the interface to search for <code>&quot;foo&quot;</code> and <code>&quot;bar&quot;</code> in order, and then store the search results in the database, i.e. in this order.</p>
<ul>
<li>yield <code>&quot;foo&quot;</code></li>
<li>search <code>&quot;foo&quot;</code></li>
<li>saveToDB <code>&quot;foo&quot;</code></li>
<li>yield <code>&quot;bar&quot;</code></li>
<li>search <code>&quot;bar&quot;</code></li>
<li>saveToDB <code>&quot;bar&quot;</code></li>
</ul>
<p>However, Sequence&rsquo;s operators can only pass in regular (non-suspend) blocks, and cannot call suspend functions within them.</p>
<p>So we have Flow.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="k">suspend</span> <span class="k">fun</span> <span class="nf">search</span><span class="p">(</span><span class="n">string</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span><span class="cm">/**/</span><span class="p">}</span>
<span class="k">suspend</span> <span class="k">fun</span> <span class="nf">saveToDB</span><span class="p">(</span><span class="n">string</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span><span class="cm">/**/</span><span class="p">}</span>

<span class="n">scope</span><span class="p">.</span><span class="n">launch</span> <span class="p">{</span>
	<span class="n">flowOf</span><span class="p">(</span><span class="s2">&#34;foo&#34;</span><span class="p">,</span> <span class="s2">&#34;bar&#34;</span><span class="p">)</span>
    <span class="p">.</span><span class="n">map</span> <span class="p">{</span> <span class="err">🏹</span> <span class="n">search</span><span class="p">(</span><span class="k">it</span><span class="p">)</span> <span class="p">}</span> <span class="c1">// 调用远程 api
</span><span class="c1"></span> <span class="err">🏹</span> <span class="p">.</span><span class="n">collect</span> <span class="p">{</span> <span class="err">🏹</span> <span class="n">saveToDB</span><span class="p">(</span><span class="k">it</span> <span class="p">)}</span> <span class="c1">// 存至数据库
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Flow is designed to execute sequentially by default, as are Kotlin Coroutine, with no concurrency. The above example is equivalent to the following loop in terms of execution order.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="k">for</span> <span class="p">(</span><span class="n">item</span> <span class="k">in</span> <span class="n">listOf</span><span class="p">(</span><span class="s2">&#34;foo&#34;</span><span class="p">,</span> <span class="s2">&#34;bar&#34;</span><span class="p">))</span> <span class="p">{</span>
  <span class="k">val</span> <span class="py">result</span> <span class="p">=</span> <span class="err">🏹</span> <span class="n">search</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
  <span class="err">🏹</span> <span class="n">saveToDB</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The terminal operator represented by <code>collect</code> is a suspend function. Therefore, a CoroutineScope is required to consume Flow, while the terminal operators of Sequence are just normal functions.</p>
<p>In fact, like Sequence, the end operators of Flow are the &ldquo;driving force&rdquo; of the entire data flow. If there is no terminal operator, but only a number of map and filter intermediate operators are referenced, it is equivalent to building a data pipeline, the code in the Flow builder will not run and the data will not flow. This kind of Flow is called &ldquo;cold flow&rdquo;. <strong>A useful way to understand this Flow is to analogize its definition to a function definition, and the terminal operator to a (suspend) function call</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="k">val</span> <span class="py">myFlow</span><span class="p">:</span> <span class="n">Flow</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">flow</span> <span class="p">{</span><span class="cm">/**/</span><span class="p">}</span>
  <span class="p">.</span><span class="n">map</span> <span class="p">{</span><span class="cm">/**/</span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>The code in the <code>flow {}</code> block and <code>map {}</code> will only run and the data will flow if the terminal operator is called on <code>myFlow</code>.</li>
<li>If <code>collect</code> is called twice on <code>myFlow</code>, it is like calling the same function twice.</li>
<li><code>myFlow</code> contains a suspend block inside, and should be treated as a suspend function itself, and must provide a CoroutineScope when called.</li>
</ul>
<p>Flow implements asynchrony with the suspend infrastructure provided by the Kotlin language, while RxJava needs to reflect asynchrony in the data types in the flow. For example, using RxJava for network requests</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="k">fun</span> <span class="nf">callSearchApi</span><span class="p">(</span><span class="n">string</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span>
  <span class="p">:</span> <span class="n">Observable</span><span class="p">&lt;</span><span class="n">SeachResult</span><span class="p">&gt;</span>

<span class="n">Observable</span><span class="p">.</span><span class="n">just</span><span class="p">(</span><span class="s2">&#34;foo&#34;</span><span class="p">,</span> <span class="s2">&#34;bar&#34;</span><span class="p">)</span>
  <span class="p">.</span><span class="n">flatMap</span> <span class="p">{</span> <span class="n">callSearchApi</span><span class="p">(</span><span class="k">it</span><span class="p">)</span> <span class="p">}</span>
  <span class="p">.</span><span class="n">subscribe</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="k">it</span><span class="p">)</span> <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Notice that the return value of <code>callSearchApi</code> needs to be nested in an <code>Observable</code>, and the transformations in the data stream need to use <code>flatMap</code>. With Coroutine and Flow, asynchronous functions do not need to wear any nesting, and transforms in the data stream can be done directly using <code>map</code>, which is more natural.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="k">suspend</span> <span class="k">fun</span> <span class="nf">callSearchApi</span><span class="p">(</span><span class="n">string</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span>
  <span class="p">:</span> <span class="n">SeachResult</span>

<span class="n">scope</span><span class="p">.</span><span class="n">launch</span> <span class="p">{</span>
  <span class="n">flowOf</span><span class="p">(</span><span class="s2">&#34;foo&#34;</span><span class="p">,</span> <span class="s2">&#34;bar&#34;</span><span class="p">)</span>
    <span class="p">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">callSearchApi</span><span class="p">(</span><span class="k">it</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">.</span><span class="n">collect</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="k">it</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 或者使用 `launchIn`，减少嵌套
</span><span class="c1"></span><span class="n">flowOf</span><span class="p">(</span><span class="s2">&#34;foo&#34;</span><span class="p">,</span> <span class="s2">&#34;bar&#34;</span><span class="p">)</span>
  <span class="p">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">callSearchApi</span><span class="p">(</span><span class="k">it</span><span class="p">)</span> <span class="p">}</span>
  <span class="p">.</span><span class="n">onEach</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="k">it</span><span class="p">)</span> <span class="p">}</span>
  <span class="p">.</span><span class="n">launchIn</span><span class="p">(</span><span class="n">scope</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="a-toy-flow">A Toy Flow</h2>
<p>The design and implementation of Kotlin Flow is very simple and elegant, so let&rsquo;s try to implement a minimalist toy version.</p>
<p>The <code>Flow</code> interface has only a single <code>collect</code> method that takes a <code>FlowCollector</code> argument. The <code>FlowCollector</code> is a typical interface representing a consumer (e.g. <code>Comparator</code>, also using <code>&lt;in T&gt;</code>).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="k">interface</span> <span class="nc">Flow</span><span class="p">&lt;</span><span class="k">out</span> <span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
  <span class="k">suspend</span> <span class="k">fun</span> <span class="nf">collect</span><span class="p">(</span><span class="n">collector</span><span class="p">:</span> <span class="n">FlowCollector</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;)</span>
<span class="p">}</span>

<span class="k">interface</span> <span class="nc">FlowCollector</span><span class="p">&lt;</span><span class="k">in</span> <span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
  <span class="k">suspend</span> <span class="k">fun</span> <span class="nf">emit</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>This <code>collect</code> method can be seen as the link between the upstream and downstream of the reactive data flow.</p>
<ul>
<li>Upstream data sources, accessed via <code>this</code>.</li>
<li>Downstream consumers, accessed via <code>collector</code>.</li>
</ul>
<h3 id="implementing-collect">Implementing collect</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="k">class</span> <span class="nc">MyFlow</span><span class="p">:</span> <span class="n">Flow</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
  <span class="k">override</span> <span class="k">suspend</span> <span class="k">fun</span> <span class="nf">collect</span><span class="p">(</span><span class="n">collector</span><span class="p">:</span> <span class="n">FlowCollector</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;)</span> <span class="p">{</span>
    <span class="n">TODO</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>When we <code>collect</code> we need to send the data to the <code>FlowCollector</code> for consumption, so where does this data come from? We can use the Flow builder to create the flow</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="n">flow</span> <span class="p">{</span>
  <span class="err">🏹</span> <span class="n">emit</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
  <span class="err">🏹</span> <span class="n">emit</span><span class="p">(</span><span class="m">2</span><span class="p">)</span>
  <span class="err">🏹</span> <span class="n">emit</span><span class="p">(</span><span class="m">3</span><span class="p">)</span>
<span class="p">}</span> <span class="err">🏹</span><span class="p">.</span><span class="n">collect</span> <span class="p">{</span>
  <span class="n">println</span><span class="p">(</span><span class="k">it</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Hey, did you notice <code>emit</code>? It&rsquo;s none other than the <code>FlowCollector.exit</code> method. So this Flow builder function takes a block with <code>FlowCollector</code> as the receiver. Where does this <code>FlowCollector</code> come from? It&rsquo;s passed in during <code>Flow.collect</code>.</p>
<p>This creates a closed loop: the <code>emit</code> we call in the suspend block of the <code>flow</code> builder function is called on the downstream consumer that will appear when we collect Flow in the future. This reflects the &ldquo;lazy&rdquo; nature of Flow: we don&rsquo;t compute the data immediately when we create a Flow, but pass in a suspend function block, and when the Flow collects, we get the consumer <code>FlowCollector</code> and use it as a receiver to call the pre-saved suspend block. This design makes particularly clever use of Kotlin&rsquo;s receiver lambda feature.</p>
<p>Putting the above analysis into code, we get our toy implementation.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="k">class</span> <span class="nc">MyFlow</span><span class="p">(</span>
  <span class="k">private</span> <span class="k">val</span> <span class="py">builder</span><span class="p">:</span> <span class="k">suspend</span> <span class="n">FlowCollector</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;.()</span> <span class="o">-&gt;</span> <span class="n">Unit</span>
<span class="p">):</span> <span class="n">Flow</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
  <span class="k">override</span> <span class="k">suspend</span> <span class="k">fun</span> <span class="nf">collect</span><span class="p">(</span><span class="n">collector</span><span class="p">:</span> <span class="n">FlowCollector</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;)</span>
    <span class="p">=</span> <span class="n">collector</span><span class="p">.</span><span class="n">builder</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>To make it easier for the caller to be able to consume data using <code>collect {...}</code> to consume the data, you can define an extension function</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="c1">// 原封不动的协程库实现
</span><span class="c1"></span><span class="k">public</span> <span class="k">suspend</span> <span class="k">inline</span> <span class="k">fun</span> <span class="p">&lt;</span><span class="nc">T</span><span class="p">&gt;</span> <span class="nf">Flow</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;.</span><span class="n">collect</span><span class="p">(</span>
  <span class="k">crossinline</span> <span class="n">action</span><span class="p">:</span> <span class="k">suspend</span> <span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Unit</span>
<span class="p">):</span> <span class="n">Unit</span> <span class="p">=</span> <span class="n">collect</span><span class="p">(</span><span class="k">object</span> <span class="err">: </span><span class="nc">FlowCollector</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
  <span class="k">override</span> <span class="k">suspend</span> <span class="k">fun</span> <span class="nf">emit</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">=</span> <span class="n">action</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
<span class="p">})</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="intermediate-operators">Intermediate operators</h3>
<p>The intermediate operator collects the upstream flow, transforms the upstream data, and sends the transformed data to a new flow. for example, we can implement map like this</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="k">fun</span> <span class="p">&lt;</span><span class="nc">T</span><span class="p">,</span> <span class="nc">R</span><span class="p">&gt;</span> <span class="nf">Flow</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;.</span><span class="n">map</span><span class="p">(</span><span class="n">block</span><span class="p">:</span> <span class="k">suspend</span> <span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">R</span><span class="p">)</span> <span class="p">=</span>
  <span class="n">MyFlow</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="n">collect</span> <span class="p">{</span> <span class="n">emit</span><span class="p">(</span><span class="n">block</span><span class="p">(</span><span class="k">it</span><span class="p">))</span> <span class="p">}</span>
  <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Like Sequence and Iterable, Flow&rsquo;s intermediate operators are all extension functions. This allows Flow&rsquo;s interface to have only one method, keeping it lean and meanwhile making it easy for users to customize operators. There is no difference between calling custom operators and the standard library&rsquo;s own operators, unlike RxJava, which requires additional APIs like <code>compose</code> or <code>lift</code> (see <a href="https://www.baeldung.com/rxjava-custom-operators">Implementing Custom Operators in RxJava</a>).</p>
<p>The pattern &ldquo;transform the upstream data and return a new Flow&rdquo; is so common that the Kotlin library provides a <code>transform</code> method to implement map, filter, and many other operators. It is also recommended to use it when defining your own operators.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="c1">// Kotlin 协程库内 Flow.map 的实现
</span><span class="c1"></span><span class="k">public</span> <span class="k">inline</span> <span class="k">fun</span> <span class="p">&lt;</span><span class="nc">T</span><span class="p">,</span> <span class="nc">R</span><span class="p">&gt;</span> <span class="nf">Flow</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;.</span><span class="n">map</span><span class="p">(</span>
  <span class="k">crossinline</span> <span class="n">transform</span><span class="p">:</span> <span class="k">suspend</span> <span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">R</span>
<span class="p">):</span> <span class="n">Flow</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">transform</span> <span class="p">{</span> <span class="n">value</span> <span class="o">-&gt;</span>
   <span class="k">return</span><span class="nd">@transform</span> <span class="n">emit</span><span class="p">(</span><span class="n">transform</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="full-code">Full code</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="k">class</span> <span class="nc">MyFlow</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span>
  <span class="k">private</span> <span class="k">val</span> <span class="py">builder</span><span class="p">:</span> <span class="k">suspend</span> <span class="n">FlowCollector</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;.()</span> <span class="o">-&gt;</span> <span class="n">Unit</span>
<span class="p">)</span> <span class="p">:</span> <span class="n">Flow</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
  <span class="k">override</span> <span class="k">suspend</span> <span class="k">fun</span> <span class="nf">collect</span><span class="p">(</span><span class="n">collector</span><span class="p">:</span> <span class="n">FlowCollector</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;)</span> <span class="p">=</span> <span class="n">collector</span><span class="p">.</span><span class="n">builder</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="p">&lt;</span><span class="nc">T</span><span class="p">,</span> <span class="nc">R</span><span class="p">&gt;</span> <span class="nf">Flow</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;.</span><span class="n">map</span><span class="p">(</span><span class="n">block</span><span class="p">:</span> <span class="k">suspend</span> <span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">R</span><span class="p">)</span> <span class="p">=</span> <span class="n">MyFlow</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;</span> <span class="p">{</span>
  <span class="n">collect</span> <span class="p">{</span> <span class="n">emit</span><span class="p">(</span><span class="n">block</span><span class="p">(</span><span class="k">it</span><span class="p">))</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="p">&lt;</span><span class="nc">T</span><span class="p">&gt;</span> <span class="nf">Flow</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;.</span><span class="n">filter</span><span class="p">(</span><span class="n">block</span><span class="p">:</span> <span class="k">suspend</span> <span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Boolean</span><span class="p">)</span> <span class="p">=</span> <span class="n">MyFlow</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
  <span class="n">collect</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="n">block</span><span class="p">(</span><span class="k">it</span><span class="p">))</span> <span class="n">emit</span><span class="p">(</span><span class="k">it</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">suspend</span> <span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="n">MyFlow</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;</span> <span class="p">{</span> <span class="n">emit</span><span class="p">(</span><span class="m">1</span><span class="p">);</span> <span class="n">emit</span><span class="p">(</span><span class="m">2</span><span class="p">)</span> <span class="p">}</span>
  <span class="p">.</span><span class="n">map</span> <span class="p">{</span> <span class="k">it</span> <span class="p">*</span> <span class="k">it</span> <span class="p">}</span>
  <span class="p">.</span><span class="n">filter</span> <span class="p">{</span>
    <span class="err">🏹</span> <span class="n">delay</span><span class="p">(</span><span class="m">1000</span><span class="p">)</span>
    <span class="k">it</span> <span class="p">%</span> <span class="m">2</span> <span class="o">==</span> <span class="m">0</span>
  <span class="p">}</span>
  <span class="err">🏹</span> <span class="p">.</span><span class="n">collect</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="s2">&#34;collected </span><span class="si">$it</span><span class="s2">&#34;</span><span class="p">)</span> <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>As you can see, with Kotlin&rsquo;s existing suspend infrastructure, implementing a reactive dataflow with asynchronous support is just two or three lines. In fact, the Kotlin Coroutine Library Flow is stripped down to a core code that is not too different from our toy implementation, but provides two additional guarantees: Context preservation and Exception transparency.</p>
<h2 id="additional-guarantees-for-flow">Additional guarantees for Flow</h2>
<h3 id="context-preservation">Context preservation</h3>
<p>RxJava can switch threads with the <code>observeOn</code> and <code>subscribeOn</code> operators. But after we get an Observable, we can&rsquo;t determine which thread the consumer will be executed in just by looking at the function signature, so we usually call <code>observeOn(mainThread)</code> once manually. Sometimes the project will add the switch to the main thread in a global location (e.g. Retrofit&rsquo;s call adapter), but when it comes to the actual call, you may be unsure, or you may habitually say <code>observeOn(mainThread)</code> and the thread is cut again and again.</p>
<p>Flow provides a guarantee of ``context preservation'': Flow ensures at runtime that the upstream cannot change the downstream context. In other words, the threads consuming Flow depend on the CoroutineContext of the collect call. What you see is what you get, and where you collect is what you execute. Suppose we take a Flow from some API.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="k">fun</span> <span class="nf">magicFlow</span><span class="p">():</span> <span class="n">Flow</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;</span> <span class="p">=</span> <span class="p">{</span><span class="cm">/**/</span><span class="p">}</span>

<span class="n">lifecycleScope</span><span class="p">.</span><span class="n">launch</span> <span class="p">{</span>
  <span class="n">magicFlow</span><span class="p">().</span><span class="n">collect</span> <span class="p">{</span>
    <span class="c1">// 一定在主线程执行
</span><span class="c1"></span>    <span class="n">uiBinding</span><span class="p">.</span><span class="n">label</span><span class="p">.</span><span class="n">text</span> <span class="p">=</span> <span class="k">it</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>This <code>magicFlow</code> may be partially switched to some background thread, but these are internal implementation details of <code>magicFlow</code> for the caller, so don&rsquo;t care. The caller wants to consume the data in the main thread because he wants to update the UI. androidx provides a <code>LifecycleScope</code> that specifies the main thread as a Coroutine scheduler. We call the suspend <code>collect</code> method inside the <code>LifecycleScope</code>-opened Coroutine to make sure that the collect block will be executed in the main thread.</p>
<p>This design is in line with Kotlin&rsquo;s Coroutine. suspend function execution depends on the CoroutineScope of the suspend function and is entirely within the control of the caller. suspend function may internally switch to other threads (e.g. in IO scenarios where it is necessary to switch threads to avoid blocking the main thread), but the caller does not need to care. The details of the thread switch are also almost transparent to the caller of Flow. <strong>In Android client calls that expose Flow&rsquo;s API to update the UI, you can just <code>collect</code> Flow in the main thread, without having to manually switch threads.</strong></p>
<p>Looking back at our toy implementation does not provide such a guarantee</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="k">fun</span> <span class="nf">magicFlow</span><span class="p">()</span> <span class="p">=</span> <span class="n">MyFlow</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;</span> <span class="p">{</span>
  <span class="n">withContext</span><span class="p">(</span><span class="n">Dispatchers</span><span class="p">.</span><span class="n">IO</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">emit</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">suspend</span> <span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">magicFlow</span><span class="p">().</span><span class="n">collect</span> <span class="p">{</span>
    <span class="c1">// 会调度到 Dispatchers.IO 运行
</span><span class="c1"></span>    <span class="n">println</span><span class="p">(</span><span class="n">coroutineContext</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>In the above example, we are emitting data in a block that has switched the Coroutine scheduler. Recall that emit is actually a call to a lambda in collect, so that the internal implementation of the upstream flow &ldquo;secretly&rdquo; switches the downstream caller&rsquo;s CoroutineContext, making it difficult for the caller to know at a glance where the code of the consuming flow will be executed in the CoroutineContext.</p>
<p>So, the <strong>Kotlin library&rsquo;s Flow implementation checks that emit and collect are executed in the same Coroutine</strong>, otherwise it will simply throw an exception.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="n">Exception</span> <span class="k">in</span> <span class="n">thread</span> <span class="s2">&#34;main&#34;</span> <span class="n">java</span><span class="p">.</span><span class="n">lang</span><span class="p">.</span><span class="n">IllegalStateException</span><span class="p">:</span>
<span class="n">Flow</span> <span class="n">invariant</span> <span class="k">is</span> <span class="n">violated</span>
</code></pre></td></tr></table>
</div>
</div><p>Note that <strong>Flow prohibits emitting data in different Coroutine</strong>, not that you can&rsquo;t switch Contexts in a Flow block, as in the following example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="k">suspend</span> <span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">val</span> <span class="py">f</span> <span class="p">=</span> <span class="n">flow</span> <span class="p">{</span>
    <span class="n">emit</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
    <span class="k">val</span> <span class="py">value</span> <span class="p">=</span> <span class="n">withContext</span><span class="p">(</span><span class="n">Dispatchers</span><span class="p">.</span><span class="n">IO</span><span class="p">)</span> <span class="p">{</span> <span class="m">2</span> <span class="p">}</span>
    <span class="n">emit</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="n">f</span><span class="p">.</span><span class="n">collect</span> <span class="p">{</span>
    <span class="n">println</span><span class="p">(</span><span class="k">it</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>By the design of the Kotlin Coroutine, this is necessarily the way to write it. We can imagine abstracting the expression <code>withContext</code> block into a suspend function that is called from within the Flow builder. suspend is internally transparent to the external caller for switching Context.</p>
<h3 id="exception-transparency-exception-transparency">Exception transparency (Exception transparency)</h3>
<p>Another guarantee of Flow is exception transparency. However, in my current opinion, it is not recommended to throw exceptions when using Kotlin Coroutine. You can check the official documentation if you are interested in this part.</p>
<p><a href="https://kotlinlang.org/docs/flow.html#exception-transparency">Asynchronous Flow - Exception Transparency</a></p>
<h2 id="flow-in-android-client-application">Flow in Android client application</h2>
<p>To summarize, the advantages of Flow over RxJava include.</p>
<ul>
<li>Relying on Kotlin&rsquo;s suspend infrastructure, the design and implementation are simpler and more elegant, and the operators are more combinatorial.</li>
<li>Extends function-defined operators, and custom operators are called in the same way as the Coroutine library&rsquo;s own Flow operators.</li>
<li>Additional guarantees such as context preservation are provided, continuing the Coroutine design idea of making the details of thread switching almost completely transparent.</li>
</ul>
<p>However, on the Android client side, most asynchronous scenarios using Kotlin Coroutine (the suspend function) is sufficient. RxJava is very popular in the Android community, mainly to solve the problem of troublesome thread switching, a scenario that Kotlin Coroutine has been able to solve very elegantly.</p>
<p>Currently, more and more APIs in Android Jetpack use Flow, such as DataStore, Room, Paging 3 and so on. Establishing a proper understanding of Flow will enable better use of these libraries.</p>
<p>In addition, RxAndroid encapsulates common Android components as data sources, which is convenient for us to do function-responsive programming, and it works better in some simple scenarios, such as debounce the user&rsquo;s input and then call the asynchronous interface. flow can use <a href="https://github.com/ReactiveCircus/FlowBinding">ReactiveCircus/FlowBinding</a>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="n">lifecycleScope</span><span class="p">.</span><span class="n">launch</span> <span class="p">{</span>
  <span class="n">binding</span><span class="p">.</span><span class="n">editText</span><span class="p">.</span><span class="n">textChanges</span><span class="p">()</span>
    <span class="p">.</span><span class="n">debounce</span><span class="p">(</span><span class="m">300</span><span class="p">)</span>
    <span class="c1">// 根据 LifecycleOwner 生命周期自动取消
</span><span class="c1"></span>    <span class="p">.</span><span class="n">flowWithLifecycle</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">Lifecycle</span><span class="p">.</span><span class="n">State</span><span class="p">.</span><span class="n">STARTED</span><span class="p">)</span>
    <span class="p">.</span><span class="n">map</span> <span class="p">{</span>
      <span class="err">🏹</span> <span class="n">callSearchApi</span><span class="p">(</span><span class="k">it</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="p">.</span><span class="n">collectLatest</span> <span class="p">{</span>
      <span class="n">updateUi</span><span class="p">(</span><span class="k">it</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Corresponding RxJava versions.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-kt" data-lang="kt"><span class="n">RxTextView</span><span class="p">.</span><span class="n">textChanges</span><span class="p">(</span><span class="n">binding</span><span class="p">.</span><span class="n">editText</span><span class="p">)</span>
  <span class="p">.</span><span class="n">debounce</span><span class="p">(</span><span class="m">300</span><span class="p">,</span> <span class="n">TimeUnit</span><span class="p">.</span><span class="n">MILLISECONDS</span><span class="p">)</span>
  <span class="p">.</span><span class="n">switchMap</span> <span class="p">{</span>
    <span class="n">callApi</span><span class="p">()</span>
  <span class="p">}</span>
  <span class="p">.</span><span class="n">subscribeOn</span><span class="p">(</span><span class="n">io</span><span class="p">())</span>
  <span class="p">.</span><span class="n">observeOn</span><span class="p">(</span><span class="n">mainThread</span><span class="p">())</span>
  <span class="p">.</span><span class="n">subscribe</span> <span class="p">{</span>
    <span class="n">updateUi</span><span class="p">(</span><span class="k">it</span><span class="p">)</span>
  <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Notice that Flow&rsquo;s terminal operator uses <code>collectLatest</code>. Since Flow&rsquo;s producer and consumer can both suspend, when the consumer suspend is processing an element suspend, if the producer emits new data, the *Latest series of operators will cancel the Coroutine block that processed the previous element. This behavior is similar to the logic of RxJava using <code>switchMap</code>. In client-side scenarios, it seems that <code>collectLatest</code> should be used in most cases.</p>
<p>But doesn&rsquo;t Flow execute sequentially (Sequential), where the producer waits for the consumer? This is because the *Latest family of operators has an additional channel inside that listens and reacts upstream while suspend is going on downstream. Such a Flow always has an &ldquo;active&rdquo; part inside, which is different from the &ldquo;cold flow&rdquo; described in this article, and is a topic for another article.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/kotlin/">kotlin</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-01/why-js-map-trim-do-not-work-together/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Why can&#39;t I use String.prototype.trim in a JS map?</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-01/kotlin-coroutine-retrofit/">
            <span class="next-text nav-default">Kotlin Coroutine and Retrofit</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
