<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Understanding python asynchronous programming and simple implementation of asyncio - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Asynchronous programming Before we start to explain asynchronous programming, let&amp;rsquo;s first understand a few related concepts. Blocking The state in which a program is hung when it has not been given the computational resources it needs. A program is said to be blocking on an operation if it cannot do anything else on its own while waiting for that operation to complete. Common forms of blocking are: network I/O blocking," /><meta name="keywords" content="python, Asyncio" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-01/python-asyncio/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Understanding python asynchronous programming and simple implementation of asyncio" />
<meta property="og:description" content="Asynchronous programming Before we start to explain asynchronous programming, let&rsquo;s first understand a few related concepts. Blocking The state in which a program is hung when it has not been given the computational resources it needs. A program is said to be blocking on an operation if it cannot do anything else on its own while waiting for that operation to complete. Common forms of blocking are: network I/O blocking," />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-01/python-asyncio/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-01-18T13:59:10+08:00" />
<meta property="article:modified_time" content="2022-01-18T13:59:10+08:00" />

<meta itemprop="name" content="Understanding python asynchronous programming and simple implementation of asyncio">
<meta itemprop="description" content="Asynchronous programming Before we start to explain asynchronous programming, let&rsquo;s first understand a few related concepts. Blocking The state in which a program is hung when it has not been given the computational resources it needs. A program is said to be blocking on an operation if it cannot do anything else on its own while waiting for that operation to complete. Common forms of blocking are: network I/O blocking,"><meta itemprop="datePublished" content="2022-01-18T13:59:10+08:00" />
<meta itemprop="dateModified" content="2022-01-18T13:59:10+08:00" />
<meta itemprop="wordCount" content="11231">
<meta itemprop="keywords" content="python," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Understanding python asynchronous programming and simple implementation of asyncio"/>
<meta name="twitter:description" content="Asynchronous programming Before we start to explain asynchronous programming, let&rsquo;s first understand a few related concepts. Blocking The state in which a program is hung when it has not been given the computational resources it needs. A program is said to be blocking on an operation if it cannot do anything else on its own while waiting for that operation to complete. Common forms of blocking are: network I/O blocking,"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Understanding python asynchronous programming and simple implementation of asyncio</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-01-18 13:59:10 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 11231 words </span>
          <span class="more-meta"> 23 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#asynchronous-programming">Asynchronous programming</a>
          <ul>
            <li><a href="#blocking">Blocking</a></li>
            <li><a href="#non-blocking">Non-blocking</a></li>
            <li><a href="#synchronisation">Synchronisation</a></li>
            <li><a href="#asynchronous">Asynchronous</a></li>
            <li><a href="#concurrency">Concurrency</a></li>
            <li><a href="#parallel">Parallel</a></li>
            <li><a href="#concurrency-1">Concurrency</a></li>
            <li><a href="#parallel-1">Parallel</a></li>
            <li><a href="#in-summary">In summary</a></li>
            <li><a href="#asynchronous-programming-1">Asynchronous Programming</a></li>
          </ul>
        </li>
        <li><a href="#synchronous-asynchronous-io">Synchronous-&gt;asynchronous I/O</a>
          <ul>
            <li><a href="#synchronous-blocking-approach">Synchronous blocking approach</a></li>
            <li><a href="#improvements-multi-processing">Improvements: multi-processing</a></li>
            <li><a href="#improvements-multi-threading">Improvements: Multi-threading</a></li>
            <li><a href="#non-blocking-approach">Non-blocking approach</a></li>
            <li><a href="#non-blocking-improvements">Non-blocking improvements</a></li>
          </ul>
        </li>
        <li><a href="#coroutine-with-asyncio">coroutine with asyncio</a>
          <ul>
            <li><a href="#coroutine">coroutine</a></li>
            <li><a href="#yield-and-yield-from">yield and yield from</a></li>
            <li><a href="#generator-based-coroutine">Generator-based coroutine</a></li>
          </ul>
        </li>
        <li><a href="#asyncio">asyncio</a>
          <ul>
            <li><a href="#introduction-to-asyncio">Introduction to asyncio</a></li>
            <li><a href="#simple-implementation-of-asyncio">Simple implementation of asyncio</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="asynchronous-programming">Asynchronous programming</h2>
<p>Before we start to explain asynchronous programming, let&rsquo;s first understand a few related concepts.</p>
<h3 id="blocking">Blocking</h3>
<p>The state in which a program is hung when it has not been given the computational resources it needs.</p>
<p>A program is said to be blocking on an operation if it cannot do anything else on its own while waiting for that operation to complete.</p>
<p>Common forms of blocking are: network I/O blocking, disk I/O blocking, user input blocking, etc.</p>
<p>Blocking is ubiquitous, including when the CPU switches contexts and all processes cannot really do anything else, they will also be blocked. (In the case of multi-core CPUs, the core that is performing the context switch is not available.)</p>
<p>In simple terms, blocking means that <strong>A calls B, A hangs and waits for the result of B, and nothing can be done</strong> .</p>
<h3 id="non-blocking">Non-blocking</h3>
<p>A program is said to be non-blocking with respect to an operation if, while waiting for that operation, it is not blocking itself and can continue to run and do something else.</p>
<p>Non-blocking does not exist at any program level and under any circumstances.</p>
<p>It is only possible for a program to be non-blocking if it is encapsulated at a level that can encompass separate subroutine units.</p>
<p>Non-blocking exists because blocking exists, and it is because of the time consuming and inefficient nature of a blocking operation that we need to make it non-blocking.</p>
<p>In simple terms, non-blocking means <strong>A calls B, A doesn&rsquo;t have to be hung up waiting for the result of B, A can do something else</strong></p>
<h3 id="synchronisation">Synchronisation</h3>
<p>Different program units are said to be synchronous when they need to communicate in some way to coordinate their execution in order to complete a task.</p>
<p>For example, to update the inventory of a product in a shopping system, a &ldquo;line lock&rdquo; is used as a communication signal to force different update requests to be queued up and executed sequentially.</p>
<p>In short, synchronisation means order.</p>
<p>In simple terms, synchronisation means that <strong>A calls B and only returns</strong> when B has a result</p>
<h3 id="asynchronous">Asynchronous</h3>
<p>A way of completing a task without the need for communication and coordination between different program units in the process in order to complete the task.</p>
<p>It is possible for unrelated program units to be asynchronous with each other.</p>
<p>For example, a crawler downloads a web page. Once the scheduler has called the downloader, it can schedule other tasks without having to maintain communication with that downloading task to coordinate behaviour. Operations such as downloading and saving of different web pages are unrelated and do not need to be coordinated with mutual notifications. The moment of completion of these asynchronous operations is not determined.</p>
<p>In short, asynchrony means disorder.</p>
<p>In simple terms, asynchronous means that <strong>A calls B, which returns immediately without waiting. Wait for B to finish processing before telling A the result</strong></p>
<h3 id="concurrency">Concurrency</h3>
<p>Concurrency describes the organisation of a program. It refers to the fact that a program is to be designed as multiple subtasks that can be executed independently</p>
<p>The aim is to make use of limited computer resources so that multiple tasks can be executed in real time or near real time.</p>
<h3 id="parallel">Parallel</h3>
<p>Parallel describes the execution state of a program. It refers to the simultaneous execution of multiple tasks.</p>
<p>The aim is to use spare computing resources (multi-core CPUs) to accelerate the completion of multiple tasks.</p>
<p>Parallelism provides a way of organising a program so that solutions to problems can be executed in parallel, but parallel execution is not required.</p>
<p><strong>In summary, parallelism is intended to use multiple cores to speed up the completion of multiple tasks; concurrency is intended to allow independent subtasks to complete as quickly as possible; non-blocking is intended to improve the overall running efficiency of the program, and asynchrony is the way to organise non-blocking tasks.</strong></p>
<h3 id="concurrency-1">Concurrency</h3>
<p>is the organisation of a program in such a way that it is designed as a number of sub-tasks that can be executed independently. The aim is to use limited computer resources so that multiple tasks can be executed in real time or near real time.</p>
<h3 id="parallel-1">Parallel</h3>
<p>refers to the execution state of a program in which multiple tasks are executed simultaneously. This is done for the purpose of using spare computing resources (multi-core cpu) to speed up the completion of multiple tasks.</p>
<p>Concurrency provides a way to organise the structure so that problem solving can be executed in parallel, but it is not required.</p>
<h3 id="in-summary">In summary</h3>
<p>Parallelism is designed to use the spare computing resources of a multicore computer to speed up the completion of a multitasking program.</p>
<p>Concurrency is intended to give independent subtasks a chance to be executed as quickly as possible, but not necessarily to speed up overall progress.</p>
<p>Non-blocking is designed to improve the overall efficiency of program execution.</p>
<p>Asynchrony is the way to organise non-blocking tasks.</p>
<h3 id="asynchronous-programming-1">Asynchronous Programming</h3>
<p><strong>A programming style that uses processes, threads, concurrent threads, and functions/methods as the basic units for executing a task program, combined with mechanisms such as callbacks, event loops, and semaphores, in order to improve the overall execution efficiency and concurrency of the program.</strong></p>
<p>A program that executes asynchronously must be out of order. If you can tell exactly what operation it is going to perform next, based on the instructions that have been executed, then it is a synchronous program. This is the difference between ordered and disordered.</p>
<p>The difficulty with asynchronous programming is that it becomes more complex and difficult in parallel because of the unpredictable order of execution of asynchronous programs.</p>
<p>So almost all asynchronous frameworks simplify the asynchronous programming model: only one event is allowed to be processed at a time. The discussion of asynchrony has therefore largely focused on single threads.</p>
<p>If the processing of a particular event takes too long, then the rest of the process gets blocked.</p>
<p>Asynchronous scheduling in asynchronous programming must therefore be &ldquo;small enough&rdquo; and not take too long.</p>
<p>A sensible approach to asynchronous programming can improve cpu utilisation and increase program efficiency.</p>
<h2 id="synchronous-asynchronous-io">Synchronous-&gt;asynchronous I/O</h2>
<p>Take a crawler that downloads 10 web pages and use a few examples to show the move from synchronous -&gt; asynchronous.</p>
<h3 id="synchronous-blocking-approach">Synchronous blocking approach</h3>
<p>The synchronous blocking approach is also the easiest way to write this program, i.e. downloading all 10 pages in sequence.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="kn">import</span> <span class="nn">socket</span>

<span class="k">def</span> <span class="nf">blocking_way</span><span class="p">():</span>
    <span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
    <span class="c1"># 阻塞</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s1">&#39;example.com&#39;</span><span class="p">,</span> <span class="mi">80</span><span class="p">))</span>
    <span class="n">request</span> <span class="o">=</span> <span class="s1">&#39;GET / HTTP/1.0</span><span class="se">\r\n</span><span class="s1">Host: example.com</span><span class="se">\r\n\r\n</span><span class="s1">&#39;</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">))</span>
    <span class="n">response</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span>
    <span class="n">chunk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">rev</span><span class="p">(</span><span class="mi">4096</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">chunk</span><span class="p">:</span>
        <span class="n">response</span> <span class="o">+=</span> <span class="n">chunk</span>
        <span class="c1"># 阻塞</span>
        <span class="n">chunk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">rev</span><span class="p">(</span><span class="mi">4096</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">response</span>

<span class="k">def</span> <span class="nf">sync_way</span><span class="p">():</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">blocking_way</span><span class="p">())</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>The execution event for this code is approximately 4.5 seconds. (averaged over several times)</p>
<p>In the above code, the function blocking_way() is used to establish a connection, send an HTTP request, and then read the HTTP response from the socket to the request and return the data.</p>
<p>sync_way() executes blocking_way() 10 times, i.e. we execute 10 accesses download example.com</p>
<p>Since network conditions and server-side processing vary, it is unpredictable when the server returns the response data and it is received by the client for the program to read. So the sock.connect() and sock.recv() calls are blocking by default.</p>
<blockquote>
<p>Note: The sock.send() function does not block for long, it simply copies the request data into the system buffer of the TCP/IP stack and returns, and does not wait for an acknowledgement of the answer returned by the server.</p>
</blockquote>
<p>If the network environment is poor and the TCP/IP handshake to create a network connection takes 1 second, then sock.connect() will block for 1 second. This is a second of wasted CPU time. Similarly, sock.recv() must wait until the response from the server has been received by the client before proceeding. The current example only needs to download one web page, so blocking 10 times may not seem like a problem, but if the demand is for 1000w pages, this blocking method is silly and inefficient.</p>
<h3 id="improvements-multi-processing">Improvements: multi-processing</h3>
<p>It seems a bit time consuming to execute 10 programs in sequence in one program, so maybe it would be better if we used multiple processes and started 10 identical programs together? And so the first improvement comes: <strong>multiprocess programming</strong>. The development line was the same. In earlier operating systems (Linux 2.4) and before, processes were entities of the OS scheduling tasks, an OS designed for processes.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">from</span> <span class="nn">concurrent</span> <span class="kn">import</span> <span class="n">futures</span>

<span class="k">def</span> <span class="nf">blocking_way</span><span class="p">():</span>
    <span class="n">sock</span> <span class="o">=</span><span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
    <span class="c1"># 阻塞</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s1">&#39;example.com&#39;</span><span class="p">,</span> <span class="mi">80</span><span class="p">))</span>
    <span class="n">request</span> <span class="o">=</span> <span class="s1">&#39;GET /HTTP/1.0</span><span class="se">\r\n</span><span class="s1">Host: example.com</span><span class="se">\r\n\r\n</span><span class="s1">&#39;</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;acsii&#39;</span><span class="p">))</span>
    <span class="n">response</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span>
    <span class="n">chunk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">4096</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">chunk</span><span class="p">:</span>
        <span class="n">response</span> <span class="o">+=</span> <span class="n">chunk</span>
        <span class="n">chunk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">4096</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">response</span>

<span class="k">def</span> <span class="nf">process_way</span><span class="p">():</span>
    <span class="n">workers</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="k">with</span> <span class="n">futures</span><span class="o">.</span><span class="n">ProcessPoolExecutor</span><span class="p">(</span><span class="n">workers</span><span class="p">)</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
    <span class="n">futs</span> <span class="o">=</span> <span class="p">{</span><span class="n">executor</span><span class="o">.</span><span class="n">sumbit</span><span class="p">(</span><span class="n">blocking_way</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)}</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">([</span><span class="n">fut</span><span class="o">.</span><span class="n">result</span><span class="p">()</span> <span class="k">for</span> <span class="n">fut</span> <span class="ow">in</span> <span class="n">futs</span><span class="p">])</span>
</code></pre></td></tr></table>
</div>
</div><p>The execution time of this code is approximately 0.6 seconds.</p>
<p>It is reasonable to assume that using 10 identical processes to execute this program would reduce the execution time to 1/10th of the original time, but it doesn&rsquo;t. Some of this time is consumed by process switching.</p>
<p>When the CPU switches from one process to another, it needs to save all the register states and memory states of the old process when it was running, and then restore the data previously saved by the other process. <strong>Process switching is necessary when the number of processes is larger than the number of CPU cores.</strong></p>
<p>Generally speaking, the number of processes that a server can handle at the same time is in the scale of tens to hundreds, provided that it can run stably. If the number of processes is larger in size, the system will run unstably and there will often be insufficient memory resources available. In addition to the high switching overhead and the small size of the tasks that can be supported, there are other disadvantages to multi-processing, such as problems with state sharing.</p>
<h3 id="improvements-multi-threading">Improvements: Multi-threading</h3>
<p>The data structure of threads is more lightweight than processes, and the same process can accommodate several threads.</p>
<p>Later OS also shifted the scheduling unit from processes to threads, with processes acting only as containers for threads to manage the resources required by the process. And OS-level threads can be assigned to different CPU cores to run simultaneously.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">from</span> <span class="nn">concurrent</span> <span class="kn">import</span> <span class="n">futures</span>


<span class="k">def</span> <span class="nf">blocking_way</span><span class="p">():</span>
    <span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
    <span class="c1"># 阻塞</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s1">&#39;example.com&#39;</span><span class="p">,</span> <span class="mi">80</span><span class="p">))</span>
    <span class="n">request</span> <span class="o">=</span> <span class="s1">&#39;GET / HTTP/1.0</span><span class="se">\r\n</span><span class="s1">Host: example.com</span><span class="se">\r\n\r\n</span><span class="s1">&#39;</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;acsii&#39;</span><span class="p">))</span>
    <span class="n">response</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span>
    <span class="n">chunk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">4096</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">chunk</span><span class="p">:</span>
        <span class="n">response</span> <span class="o">+=</span> <span class="n">chunk</span>
        <span class="c1"># 阻塞</span>
        <span class="n">chunk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">4096</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">response</span>

<span class="k">def</span> <span class="nf">thread_way</span><span class="p">():</span>
    <span class="n">wokers</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="k">with</span> <span class="n">futures</span><span class="o">.</span><span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="n">workers</span><span class="p">)</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
        <span class="n">futs</span> <span class="o">=</span> <span class="p">{</span><span class="n">executor</span><span class="o">.</span><span class="n">sumbit</span><span class="p">(</span><span class="n">blocking_way</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)}</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">([</span><span class="n">fut</span><span class="o">.</span><span class="n">result</span><span class="p">(</span><span class="n">fut</span><span class="o">.</span><span class="n">result</span><span class="p">()</span> <span class="k">for</span> <span class="n">fut</span> <span class="ow">in</span> <span class="n">futs</span><span class="p">)])</span>
</code></pre></td></tr></table>
</div>
</div><p>The total running time is roughly 0.43 seconds.</p>
<p>In terms of runtime, multithreading seems to have solved the problem of high process switching overhead and the size of the number of tasks that can be supported, which has become hundreds to thousands.</p>
<p>However, because multithreading in CPython does not take advantage of CPU multicore because of GIL, only one thread is allowed to be running in a Python process.</p>
<p>When making blocking system calls, such as sock.connect(), sock.recv(), the current thread will release the GIL and allow another thread to have a chance to execute. But within a single thread, it is still blocking on blocking calls.</p>
<blockquote>
<p>Time.sleep is blocking in Python, and it is known to be used with caution, but in multi-threaded programming, time.sleep does not block other threads.</p>
</blockquote>
<p>There is a general problem with all multithreads except GIL. They are scheduled by the OS and the scheduling policy is preemptive to ensure that threads of equal priority have an equal chance of execution. So there could be a race condition. If in a complex crawler system the URLs to be crawled are taken by multiple crawler threads, then how are the URLs distributed, this requires the use of &ldquo;locks&rdquo; or &ldquo;synchronous queues&rdquo; to ensure that download tasks are not repeated. The main problem with <strong>multithreading is the race condition.</strong> The main problem with multithreading is the race condition.</p>
<h3 id="non-blocking-approach">Non-blocking approach</h3>
<p>The following example is the most primitive form of non-blocking.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="kn">import</span> <span class="nn">socket</span>

<span class="k">def</span> <span class="nf">noblock_way</span><span class="p">():</span>
    <span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">setblocking</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s1">&#39;example.com&#39;</span><span class="p">,</span> <span class="mi">80</span><span class="p">))</span>
    <span class="k">except</span> <span class="ne">BlockingIOError</span><span class="p">:</span>
        <span class="c1"># 非阻塞过程也会抛出异常</span>
        <span class="k">pass</span>
    
    <span class="n">request</span> <span class="o">=</span> <span class="s1">&#39;GET / HTTP /1.0</span><span class="se">\r\n</span><span class="s1">Host: example.com</span><span class="se">\r\n\r\n</span><span class="s1">&#39;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span>
    <span class="c1"># 不断重复尝试发送</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sock</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="c1"># send不出现异常，停止</span>
            <span class="k">break</span>
        <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="n">response</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">chunk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">4096</span><span class="p">)</span>
            <span class="k">while</span> <span class="n">chunk</span><span class="p">:</span>
                <span class="n">response</span> <span class="o">+=</span> <span class="n">chunk</span>
                <span class="n">chunk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">4096</span><span class="p">)</span>
            <span class="k">break</span>
        <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
            <span class="k">pass</span>
    
    <span class="k">return</span> <span class="n">response</span>

<span class="k">def</span> <span class="nf">sync_way</span><span class="p">():</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">noblock_way</span><span class="p">())</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>The total time taken by the program was about 4.3 seconds.</p>
<p>When I finished executing this code, I felt as if I had been cheated, the code took about the same amount of time to execute as the non-blocking method, and the program was more complex. What&rsquo;s the point of having non-blocking?</p>
<p>The code sock.setblocking(False) tells the OS to make all blocking calls on the socket non-blocking. Non-blocking means doing one thing without preventing the program calling it from doing something else. The above code does stop blocking after sock.connect() and sock.recv() are executed, so you can move on to the request preparation code or to the next read. Line 8 is placed within the try statement because the socket will also throw an exception when sending a non-blocking connection request. connect() can be called and the code in lines 12 and 13 can be executed immediately afterwards.</p>
<p><strong>Although connect() and recv() are no longer blocking the main program, and the CPU is not idle during the free time, it is not using the free time to do anything meaningful, but is instead looping around trying to read and write to the socket (constantly judging the state of the non-blocking call to be ready). It also has to handle ignorable exceptions from the underlying layer. Nor can it handle multiple sockets at once.</strong> So the overall execution time is comparable to synchronous blocking.</p>
<h3 id="non-blocking-improvements">Non-blocking improvements</h3>
<h4 id="epoll">epoll</h4>
<p>Actually determining if a non-blocking call is ready can be left to the OS, instead of the application having to wait and determine this itself, it can use this free time to do other things.</p>
<p>The OS encapsulates all O/I changes into events, such as readable events and writable events. It also provides a system module that can be called to receive event notifications. This module is select, which allows applications to register file descriptors and callback functions via select. When the state of the file descriptor changes, select calls the pre-registered callback function.</p>
<p>Due to the inefficiency of the select algorithm, it was later improved into poll, and then further improved into the kqueue module for the BSD kernel, and into the epoll module for the Linux kernel. All four modules serve the same purpose and expose almost the same API to the programmer, the difference being that kqueue and epoll are more efficient when dealing with large numbers of file descriptors. A typical Linux server uses epoll.</p>
<h4 id="callbacks">Callbacks</h4>
<p>Leave the listening for I/O events to the OS. What should the OS do when it knows that the I/O state has changed? Here it is generally done by way of a callback.</p>
<p>Wrap sending and reading data into separate functions, use epoll to listen to the socket state instead of the application, and tell epoll &ldquo;If the socket state becomes available to write to (connection established successfully), please call the HTTP request send function. If the socket becomes ready to read data (the client has received a response), call the response handler function.&rdquo;</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">from</span> <span class="nn">selectors</span> <span class="kn">import</span> <span class="n">DefaultSelector</span><span class="p">,</span> <span class="n">EVENT_WRITE</span><span class="p">,</span> <span class="n">EVENT_READ</span>
<span class="c1"># selectors模块是对底层select/poll/epoll/kqueue的封装</span>
<span class="c1"># DefaultSelector类会根据 OS 环境自动选择最佳的模块</span>

<span class="s2">&#34;&#34;&#34;
</span><span class="s2">创建Crawler 实例；
</span><span class="s2">调用fetch方法，会创建socket连接和在selector上注册可写事件；
</span><span class="s2">fetch内并无阻塞操作，该方法立即返回；
</span><span class="s2">重复上述3个步骤，将10个不同的下载任务都加入事件循环；
</span><span class="s2">启动事件循环，进入第1轮循环，阻塞在事件监听上；
</span><span class="s2">当某个下载任务EVENT_WRITE被触发，回调其connected方法，第一轮事件循环结束；
</span><span class="s2">进入第2轮事件循环，当某个下载任务有事件触发，执行其回调函数；此时已经不能推测是哪个事件发生，因为有可能是上次connected里的EVENT_READ先被触发，也可能是其他某个任务的EVENT_WRITE被触发；（此时，原来在一个下载任务上会阻塞的那段时间被利用起来执行另一个下载任务了）
</span><span class="s2">循环往复，直至所有下载任务被处理完成
</span><span class="s2">退出事件循环，结束整个下载程序
</span><span class="s2">&#34;&#34;&#34;</span>

<span class="n">selector</span> <span class="o">=</span> <span class="n">DefaultSelector</span><span class="p">()</span>
<span class="n">stopped</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">urls_todo</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="s1">&#39;/1&#39;</span><span class="p">,</span> <span class="s1">&#39;/2&#39;</span><span class="p">,</span> <span class="s1">&#39;/3&#39;</span><span class="p">,</span> <span class="s1">&#39;/4&#39;</span><span class="p">,</span> <span class="s1">&#39;/5&#39;</span><span class="p">,</span> <span class="s1">&#39;/6&#39;</span><span class="p">,</span> <span class="s1">&#39;/7&#39;</span><span class="p">,</span> <span class="s1">&#39;/8&#39;</span><span class="p">,</span> <span class="s1">&#39;/9&#39;</span><span class="p">}</span>


<span class="k">class</span> <span class="nc">Crawler</span><span class="p">:</span>
    <span class="s2">&#34;&#34;&#34;
</span><span class="s2">    如果用这种方法抓去，需要创建10个Crawler实例，这样就会有20个事件发生
</span><span class="s2">    &#34;&#34;&#34;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">url</span> <span class="o">=</span> <span class="n">url</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">response</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span>

    <span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">setblocking</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s1">&#39;example.com&#39;</span><span class="p">,</span> <span class="mi">80</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">BlockingIOError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="n">selector</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span> <span class="n">EVENT_WRITE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">connected</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">connected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
        <span class="n">selector</span><span class="o">.</span><span class="n">unregister</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">fd</span><span class="p">)</span>
        <span class="n">get</span> <span class="o">=</span> <span class="s1">&#39;GET </span><span class="si">{0}</span><span class="s1"> HTTP/1.0</span><span class="se">\r\n</span><span class="s1">Host: example.com</span><span class="se">\r\n\r\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">url</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">get</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">))</span>
        <span class="n">selector</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">fd</span><span class="p">,</span> <span class="n">EVENT_READ</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_response</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">read_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
        <span class="k">global</span> <span class="n">stopped</span>
        <span class="c1"># 如果响应大于4kb，下次循环继续</span>
        <span class="n">chunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">4096</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">chunk</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">response</span> <span class="o">+=</span> <span class="n">chunk</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">selector</span><span class="o">.</span><span class="n">unregister</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">fd</span><span class="p">)</span>
            <span class="n">urls_todo</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">url</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">urls_todo</span><span class="p">:</span>
                <span class="n">stopped</span> <span class="o">=</span><span class="kc">True</span>

<span class="k">def</span> <span class="nf">loop</span><span class="p">():</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">stopped</span><span class="p">:</span>
        <span class="c1"># 阻塞，直到一个事件发生</span>
        <span class="n">events</span> <span class="o">=</span> <span class="n">selector</span><span class="o">.</span><span class="n">select</span><span class="p">()</span>  <span class="c1"># 这是一个阻塞调用</span>
        <span class="k">for</span> <span class="n">event_key</span><span class="p">,</span> <span class="n">event_mask</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
            <span class="n">callback</span> <span class="o">=</span> <span class="n">event_key</span><span class="o">.</span><span class="n">data</span>
            <span class="n">callback</span><span class="p">(</span><span class="n">event_key</span><span class="p">,</span> <span class="n">event_mask</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&#34;__main__&#34;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">urls_todo</span><span class="p">:</span>
        <span class="n">crawler</span> <span class="o">=</span> <span class="n">Crawler</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
        <span class="n">crawler</span><span class="o">.</span><span class="n">fetch</span><span class="p">()</span>
    <span class="n">loop</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>The overall time taken is about 0.45 seconds.</p>
<p>What is less glancing than the previous function is that we will download 10 different URL interfaces and then store the relative paths to the URLs in urls_todo. The specific improvements are as follows.</p>
<p>Firstly, the loop of constantly trying to send() and recv() has been removed.</p>
<p>Secondly, the selectors module was imported and an instance of DefaultSelector was created. the selectors module provided by the Python standard library is a wrapper around the underlying select/poll/epoll/kqueue. the DefaultSelector class automatically selects the best module for the OS environment. That&rsquo;s epoll on Linux 2.5.44 and newer.</p>
<p>It then registers the callback functions that should be taken when a socket writable event (EVENT_WRITE) and a readable event (EVENT_READ) occur respectively.</p>
<p>But here is the problem, how can we know which of the 20 events created by these 10 Crawler instances is the current event that is happening, take it out of the selector and get the corresponding callback function to execute it?</p>
<h4 id="event-loop">event loop</h4>
<p>So we add an event loop at the end of the code, writing a function that loops through the selector module, waiting for it to tell us which event has occurred and which callback function should be the corresponding one.</p>
<p>In loop(), the event loop function uses a stopped global variable to control the stopping of the event loop, marking stopped as True when urls_todo has been consumed.</p>
<p>Inside the event loop there is a blocking call, selector.select(). If the event doesn&rsquo;t happen, then the application has no event to process, so it simply blocks here and waits for the event to happen. It can be inferred, then, that if only one web page is downloaded, it must connect() before it can send() and then recv(), which is the same efficiency as blocking. Because instead of blocking on connect()/recv(), you have to block on select() as well.</p>
<p>So, the selector mechanism (later referred to as epoll/kqueue) is designed to handle large numbers of concurrent connections. The selector mechanism is most powerful when there are a large number of non-blocking calls to the system that can generate events at any time.</p>
<p>The problem of downloading 10 web pages simultaneously was solved in a single thread using event loops + callbacks. This is already asynchronous programming. Although there is a for loop that sequentially creates the Crawler instance and calls the fetch method, there is only connect() and registration of writable events within fetch, and it is clear from the execution time that multiple downloads are indeed taking place at the same time!</p>
<p>The above code is executed asynchronously by.</p>
<ul>
<li>Create an instance of Crawler.</li>
<li>calling the fetch method, which creates a socket connection and registers writable events on the selector.</li>
<li>There is no blocking operation within fetch and the method returns immediately.</li>
<li>Repeat the 3 steps above, adding all 10 different download tasks to the event loop.</li>
<li>start the event loop and enter round 1, blocking on the event listener.</li>
<li>When a download task EVENT_WRITE is triggered, call back its CONNECTED method and the first round of the event loop ends.</li>
<li>Enter the 2nd event loop, when an event is triggered on a download task, execute its callback function; at this point it is no longer possible to speculate which event occurred, as it is possible that the EVENT_READ from the last connected was triggered first, or that the EVENT_WRITE from some other task was triggered; (at this point, the time that would have been blocked on one download task is used to execute another download task)</li>
<li>The loop repeats until all download tasks have been processed</li>
<li>Exit the event loop and end the download process</li>
</ul>
<p>In asynchronous programming, there is no escape from the &ldquo;event loop + callback&rdquo; pattern described above, even though it may not be an epoll or a while loop.</p>
<p>But what about some asynchronous programming where you don&rsquo;t see the CallBack pattern? In Python&rsquo;s asynchronous programming, for example, the main character is the coroutine.</p>
<h2 id="coroutine-with-asyncio">coroutine with asyncio</h2>
<h3 id="coroutine">coroutine</h3>
<p><strong>coroutine (Co-routine), which is a collaborative routine</strong></p>
<p>It is a generalisation of a non-preemptive multi-tasking subroutine that allows multiple entry points at defined locations in the routine to control the suspension and resumption of program execution.</p>
<p>What are routines? A programming language defines segments of code that can be called as a series of instructions encapsulated together in order to perform a particular function. Programming languages in general are represented by code structures called functions or methods.</p>
<p>Firstly, it is important to understand that both multi-processing, multi-threading and coroutines are designed to solve the problem of multi-tasking at the same time. The key to implementing a multitasking system is how to pause the current task, save the context of the current task, select the next task, resume the context of the next task and execute the next task.</p>
<p>Context means different things to different levels of the computer.</p>
<ul>
<li>For the CPU, context is the operand registers, stack registers, status registers, and other types of registers.</li>
<li>For processes, context is the hardware resources abstracted by the cpu, such as registers, signals, allocated memory space, file descriptors, etc.</li>
<li>For a thread, the context is, registers, thread stacks&hellip;</li>
<li>For a function, the context is the current namespace.</li>
</ul>
<p>Switching processes requires switching system resources and instructions and takes the longest time.</p>
<p>For thread switching, no system resources need to be switched, only instructions, thread stack. However, this process also requires a system call.</p>
<p>Coroutine switching is done in user space and does not require a system call.</p>
<p>In Python, thread switching is controlled by the python virtual machine, through a system call. coroutine switching is entirely controlled by the program itself.</p>
<p>The main advantages of coroutines over threads are</p>
<ul>
<li>python threads are scheduled in such a way that in python2.x they stop every 100 bytes of code or blocking, in python3 they use a fixed time, instead of a ticks count of 100 to release the GIL, and then a system call is made to let the os kernel pick the next thread. But coroutines only switch to the next coroutine when they are blocked. 100 bytes of code is not much, not much, and may be lost in two library calls, so there are many ineffective thread switches, and the larger the number of threads, the greater the performance loss due to this inherent deficiency in the scheduling strategy.</li>
<li>Threads need to make system calls, coroutines do not. System calls require access to the kernel state, and invalid scheduling makes this part of the overhead seem larger</li>
<li>A coroutine can be scheduled autonomously, whereas a thread can only decide that it is appropriate to exit, but who the next thread is depends on the OS.</li>
</ul>
<p>In Python, there are two kinds of coroutines, a stackless coroutine, represented by asyncio in python, and a stacked coroutine, represented by gevent in python.</p>
<h3 id="yield-and-yield-from">yield and yield from</h3>
<h4 id="yield">yield</h4>
<p>The latest Python doesn&rsquo;t use yield-based coroutines any more. But for a better understanding of coroutines, here&rsquo;s a small, simple example of a yield.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="k">def</span> <span class="nf">fun_e</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;yield 1&#39;</span><span class="p">)</span>
    <span class="k">yield</span> <span class="mi">1</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;yield 2&#39;</span><span class="p">)</span>
    <span class="k">yield</span> <span class="mi">2</span>

<span class="n">gen</span> <span class="o">=</span> <span class="n">fun_e</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;start&#39;</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">gen</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;生成器的第一个值&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">gen</span><span class="o">.</span><span class="n">next</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;生成器的第二个值&#39;</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>The output of the above code is</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="n">start</span>
<span class="k">yield</span> <span class="mi">1</span>
<span class="n">生成器的第一个值</span> <span class="mi">1</span>
<span class="k">yield</span> <span class="mi">2</span>
<span class="n">生成器的第二个值</span> <span class="mi">2</span>
</code></pre></td></tr></table>
</div>
</div><p>Here the program runs to the first yield, saves the context of the function and exits, then enters the function via the next method, restores the context of the function just saved and continues to run.</p>
<p>All a coroutine program does is: <strong>save context switch run program restore context re-enter program</strong> .</p>
<p>The context in Cpython is encapsulated in a PyFrameObject structure, which can also be called a stack frame.</p>
<p>Source code.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">_frame</span> <span class="p">{</span>
    <span class="n">PyObject_VAR_HEAD</span>
    <span class="k">struct</span> <span class="nc">_frame</span> <span class="o">*</span><span class="n">f_back</span><span class="p">;</span>      <span class="cm">/* previous frame, or NULL */</span>
    <span class="n">PyCodeObject</span> <span class="o">*</span><span class="n">f_code</span><span class="p">;</span>       <span class="cm">/* code segment */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">f_builtins</span><span class="p">;</span>       <span class="cm">/* builtin symbol table (PyDictObject) */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">f_globals</span><span class="p">;</span>        <span class="cm">/* global symbol table (PyDictObject) */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">f_locals</span><span class="p">;</span>         <span class="cm">/* local symbol table (any mapping) */</span>
    <span class="n">PyObject</span> <span class="o">**</span><span class="n">f_valuestack</span><span class="p">;</span>    <span class="cm">/* points after the last local */</span>
    <span class="cm">/* Next free slot in f_valuestack.  Frame creation sets to f_valuestack.
</span><span class="cm">       Frame evaluation usually NULLs it, but a frame that yields sets it
</span><span class="cm">       to the current stack top. */</span>
    <span class="n">PyObject</span> <span class="o">**</span><span class="n">f_stacktop</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">f_trace</span><span class="p">;</span>          <span class="cm">/* Trace function */</span>
    <span class="kt">char</span> <span class="n">f_trace_lines</span><span class="p">;</span>         <span class="cm">/* Emit per-line trace events? */</span>
    <span class="kt">char</span> <span class="n">f_trace_opcodes</span><span class="p">;</span>       <span class="cm">/* Emit per-opcode trace events? */</span>

    <span class="cm">/* Borrowed reference to a generator, or NULL */</span>
    <span class="cm">/* 生成器的指针 */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">f_gen</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">f_lasti</span><span class="p">;</span>                <span class="cm">/* 上一个运行的字节码位置 */</span>
    <span class="cm">/* Call PyFrame_GetLineNumber() instead of reading this field
</span><span class="cm">       directly.  As of 2.3 f_lineno is only valid when tracing is
</span><span class="cm">       active (i.e. when f_trace is set).  At other times we use
</span><span class="cm">       PyCode_Addr2Line to calculate the line from the current
</span><span class="cm">       bytecode index. */</span>
    <span class="kt">int</span> <span class="n">f_lineno</span><span class="p">;</span>               <span class="cm">/* 对应的Python源码行数 */</span>
    <span class="kt">int</span> <span class="n">f_iblock</span><span class="p">;</span>               <span class="cm">/* index in f_blockstack */</span>
    <span class="kt">char</span> <span class="n">f_executing</span><span class="p">;</span>           <span class="cm">/* whether the frame is still executing */</span>
    <span class="n">PyTryBlock</span> <span class="n">f_blockstack</span><span class="p">[</span><span class="n">CO_MAXBLOCKS</span><span class="p">];</span> <span class="cm">/* for try and loop blocks */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">f_localsplus</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>  <span class="cm">/* locals+stack, dynamically sized */</span>
<span class="p">}</span> <span class="n">PyFrameObject</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>In the actual execution of Python, a number of PyFrameObject objects are generated, which are then all linked together to form a chain.</p>
<p>The structure definition of a generator in Python is a macro that points to a PyFrameObject object that represents the context of this generator.</p>
<p>Within this structure of a generator there are 3 important things.</p>
<ol>
<li>a pointer to the generator context</li>
<li>a string indicating the state of the generator not started, stopped, running, finished</li>
<li>the generator&rsquo;s bytecode</li>
</ol>
<p>i.e. <strong>context + instruction sequence + state</strong></p>
<p>In generators, next and send have the same effect, but send can be passed an argument.</p>
<h4 id="yield-from">yield from</h4>
<p>In the generator, you can use return to return the value, but if send goes to the return statement it will report a StopIteration. The return value is in the value of the exception.</p>
<p>The following example is given.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="k">def</span> <span class="nf">test_fun1</span><span class="p">():</span>
    <span class="k">yield</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="mi">2</span>

<span class="n">gen</span> <span class="o">=</span> <span class="n">test_fun1</span><span class="p">()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">gen</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">gen</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">StopIteration</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>The output from executing the above code is <code>2</code></p>
<p>On the one hand, it is an expression, which naturally has a value, and its value is the value returned by the generator return after yield from. The key point is that the yield statement of the generator produces the value outwards, but the value of return does not. To get the return value of the return, either catch the exception with a try statement or get the value with a yield from expression.</p>
<p>Take a look at the following example</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="k">def</span> <span class="nf">test_fun1</span><span class="p">():</span>
    <span class="k">yield</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="mi">2</span>

<span class="k">def</span> <span class="nf">test_fun2</span><span class="p">():</span>
    <span class="n">a</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">test_fun1</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;yield from 表达式的值为 </span><span class="si">{</span><span class="n">a</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
    <span class="k">yield</span> <span class="kc">None</span>

<span class="n">gen</span> <span class="o">=</span> <span class="n">test_fun2</span><span class="p">()</span>
<span class="n">gen</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="n">gen</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Output result.</p>
<p><code>yield from expression has a value of 2</code></p>
<p>Another feature of yield from is the ability to pass the return value of the inner generator to the outer layer.</p>
<p>As in the following example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="k">def</span> <span class="nf">test_gen1</span><span class="p">():</span>
    <span class="k">yield</span> <span class="mi">1</span>
    <span class="k">yield</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="mi">3</span>

<span class="k">def</span> <span class="nf">test_gen2</span><span class="p">():</span>
    <span class="n">a</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">test_gen1</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;yield from </span><span class="si">{</span><span class="n">a</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">test_gen2</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>The output is.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">1
2
yield from 3
</code></pre></td></tr></table>
</div>
</div><p>The inner generator test_gen1() can be yielded from to get the value out at the outermost level.</p>
<p>This way we can link multiple generators together using yield from.</p>
<h4 id="understanding-yield-in-a-nutshell">Understanding yield in a nutshell</h4>
<p>When you first encounter yield, it&rsquo;s hard to understand how it&rsquo;s used, what generators are and what arguments are passed. In fact, you can simply think of yield as a return, and the program will stop when it reaches yield.</p>
<p>Let&rsquo;s look at a simple example</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="k">def</span> <span class="nf">example</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;开始...&#34;</span><span class="p">)</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="k">yield</span> <span class="mi">4</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;res:&#34;</span><span class="p">,</span><span class="n">res</span><span class="p">)</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">example</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&#34;*&#34;</span><span class="o">*</span><span class="mi">20</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>Output results:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">开始...
4
********************
res: None
4
</code></pre></td></tr></table>
</div>
</div><p>The order of execution of the above code is as follows</p>
<ol>
<li>Once the program starts executing, the foo function doesn&rsquo;t really execute because there is a yield keyword in the foo function, so the foo function doesn&rsquo;t really execute, but first gets a generator g (equivalent to an object)</li>
<li>until the next method is called, the foo function starts executing, first by executing the print method in the foo function, and then by entering the while loop</li>
<li>the program encounters the yield keyword, then think of yield as return, return a 4, the program stops, and does not perform the assignment to the res operation, at this point the next(g) statement is completed, so the first two lines of output (the first is the result of the while above the print, the second is the result of the return) is executed print(next(g)).</li>
<li>the program executes print(&quot;*&quot; *20), outputting 20 *&rsquo;s</li>
<li>the following print(next(g)) is executed again, which is similar to the one above, but the difference is that it starts from where the next program stopped, which means that the assignment of res is executed. So the assignment of res is None, so the following output is res:None.</li>
<li>the program will continue to execute in the while, and again encounter yield, this time also return 4, then the program stops, the print function output of 4 is this time return out of 4</li>
</ol>
<p>yield and return relationship and the difference between the function with yield is a generator, not a function, this generator has a function is the next function, next is equivalent to the &ldquo;next&rdquo; generation of which number, this time the next place to start is followed by the last next place to stop the execution, so the call to next, the generator does not start from the beginning of the example function execution, just followed by the previous step to stop the place to start, and then encounter yield, return the number to be generated, this step will end.</p>
<p>Another example of send.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;starting...&#34;</span><span class="p">)</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="k">yield</span> <span class="mi">4</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;res:&#34;</span><span class="p">,</span><span class="n">res</span><span class="p">)</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">foo</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&#34;*&#34;</span><span class="o">*</span><span class="mi">20</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>Output results</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">starting...
4
********************
res: 7
4
</code></pre></td></tr></table>
</div>
</div><p>First of all, let&rsquo;s talk about the concept of the send function: at this point you should notice the purple word above, and the value of the res above why is None, this becomes 7, in the end why, this is because, send is to send a parameter to the res, because the above mentioned, return, and did not assign the value of 4 to res, the next time when the implementation had to If we use send, we start the execution by following the previous one (after return 4) and assigning 7 to res, then we perform the role of next and meet the next yield, and end after return the result.</p>
<p>Picking up from the previous steps.</p>
<ol>
<li>the program executes g.send(7), which continues down the line from the yield keyword, and send assigns the value 7 to the res variable</li>
<li>since the send method contains the next() method, the program will continue down the print method and then enter the while loop again</li>
<li>when the program encounters the yield keyword again, the yield returns the value that follows and the program pauses again until the next method or send method is called again.</li>
</ol>
<h3 id="generator-based-coroutine">Generator-based coroutine</h3>
<p>Having said all that, why use a coroutine to solve asynchronous problems in Python. Let&rsquo;s look at the problems with the &ldquo;event loop + callback&rdquo; approach mentioned earlier.</p>
<h4 id="the-event-loop--callback-problem">The &ldquo;event loop + callback&rdquo; problem</h4>
<p>Using the asynchronous programming in the previous crawler example within a single thread does make the program run much more efficiently. However, in a production project, the complexity to deal with is much greater. Consider the following problem.</p>
<ul>
<li>What happens if the callback function doesn&rsquo;t execute properly?</li>
<li>What if there are nested callbacks inside the callback? What if there are many layers of nesting?</li>
<li>What happens if there are multiple layers, and something goes wrong in one of them?</li>
<li>What if there is data that needs to be processed by each callback?</li>
<li>&hellip;&hellip;</li>
</ul>
<p>In practice, these problems are not easy to avoid, and they do have some drawbacks.</p>
<ul>
<li><strong>Poor code readability when there are too many layers of callbacks</strong></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py">  <span class="k">def</span> <span class="nf">callback_1</span><span class="p">():</span>
  <span class="c1"># processing ...</span>
      <span class="k">def</span> <span class="nf">callback_2</span><span class="p">():</span>
          <span class="c1"># processing.....</span>
          <span class="k">def</span> <span class="nf">callback_3</span><span class="p">():</span>
              <span class="c1"># processing ....</span>
              <span class="k">def</span> <span class="nf">callback_4</span><span class="p">():</span>
                  <span class="c1">#processing .....</span>
                  <span class="k">def</span> <span class="nf">callback_5</span><span class="p">():</span>
                      <span class="c1"># processing ......</span>
                  <span class="n">async_function</span><span class="p">(</span><span class="n">callback_5</span><span class="p">)</span>
              <span class="n">async_function</span><span class="p">(</span><span class="n">callback_4</span><span class="p">)</span>
          <span class="n">async_function</span><span class="p">(</span><span class="n">callback_3</span><span class="p">)</span>
      <span class="n">async_function</span><span class="p">(</span><span class="n">callback_2</span><span class="p">)</span>
  <span class="n">async_function</span><span class="p">(</span><span class="n">callback_1</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>Breaking the code structure</strong> When writing a synchronous program, the code generally runs from the top down.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="n">fun_1</span><span class="p">()</span>
<span class="n">fun_2</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>In the above code, if the processing of fun_2 depends on the result of the processing of fun_1, but fun_1 is called asynchronously, then it is not known when fun_1 will return the value and the result of the subsequent processing needs to be returned to fun_1 in the form of a callback, so that fun_2 can be executed after fun_1 has finished executing, then the code becomes as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="n">fun_1</span><span class="p">(</span><span class="n">fun_2</span><span class="p">())</span>
</code></pre></td></tr></table>
</div>
</div><p>If the whole process is handled asynchronously and then the process is longer.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="n">fun_1</span><span class="p">(</span><span class="n">fun_2</span><span class="p">(</span><span class="n">fun_3</span><span class="p">(</span><span class="n">fun_4</span><span class="p">(</span><span class="o">......</span><span class="p">))))</span>
</code></pre></td></tr></table>
</div>
</div><p>In the case of a synchronously executing program, each step in the program is a flow controlled by the thread&rsquo;s instruction pointer, whereas in the callback version, the flow is what the person programming needs to be aware of and arrange.</p>
<ul>
<li>Shared state management difficulties Looking back at the previous crawler code, the synchronous blocking version uses the sock object from start to finish, whereas in the callback version we have to keep its own sock object in the object self after the Crawler is instantiated. If an OOP style of programming is not used, then the state to be shared needs to be passed to each callback in a relay-like fashion. Exactly which state is to be shared between multiple asynchronous calls would have to be thought out and carefully designed beforehand.</li>
<li>Error handling difficulties A sequence of callbacks forms a complete chain of calls. For example, a to f. What if d throws an exception? The entire call chain breaks and the state passed in succession is lost, a phenomenon known as call stack tearing. c doesn&rsquo;t know what to do and continues with the exception, then the b exception, then the a exception. Well, the error log tells you that the a call went wrong, but it was actually d that went wrong. So, to prevent stack tearing, exceptions have to be returned as data, not just thrown, and then the return value of the last call needs to be checked in each callback to prevent the error from swallowing it.</li>
</ul>
<p>The ugly style of the code is minor, but the two drawbacks of stack tearing and difficult state management can make callback-based asynchronous programming tough.</p>
<p>Python has derived coroutine-based solutions based on event loops + callbacks, represented by Tornado, Twisted, asyncio and others.</p>
<h4 id="future-objects">Future objects</h4>
<p>Python has a special kind of object, the generator, which is much like a coroutine. Between each iteration, execution is suspended, and the next iteration continues without losing the previous state.</p>
<p>To support simple coroutines with generators, Python 2.5 has an enhancement to generators (PEP 342), the proposed enhancement is titled &ldquo;Coroutines via Enhanced Generators&rdquo;. With the addition of PEP 342, generators can pause execution and return data outwards via yield, send data within the generator via send(), and throw exceptions within the generator via throw() to terminate the generator at any time.</p>
<p>We don&rsquo;t use callbacks here, how do we know the result of an asynchronous call? First, we design an object in which the result of the asynchronous call is placed when it is finished. This object is called a future object.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="k">class</span> <span class="nc">Future</span><span class="p">:</span>
    <span class="s2">&#34;&#34;&#34;
</span><span class="s2">    未来对象
</span><span class="s2">    异步调用执行完的时候，就把结果放在它里面。
</span><span class="s2">    &#34;&#34;&#34;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_callbacks</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">add_done_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_callbacks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_callbacks</span><span class="p">:</span>
            <span class="n">fn</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>The future object has a result property which holds the result of the future execution. There is also a set_result() method which is used to set the result and will run the callback added to the future after the value of the result has been bound. The callback is added via the future object&rsquo;s add_done_callback() method.</p>
<p>Although there is still a callback in this place, this callback is not quite the same as the previous one.</p>
<h4 id="refactoring-the-crawler-crawler">Refactoring the Crawler crawler</h4>
<p>Since we have the Future object, we start by refactoring the crawler with Future.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="k">class</span> <span class="nc">Crawler</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">url</span> <span class="o">=</span> <span class="n">url</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">response</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span>

    <span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">setblocking</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sock</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s1">&#39;example.com&#39;</span><span class="p">,</span> <span class="mi">80</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">BlockingIOError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">Future</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">on_connect</span><span class="p">():</span>
            <span class="n">f</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="n">selector</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span> <span class="n">EVENT_WRITE</span><span class="p">,</span> <span class="n">on_connect</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">f</span>
        <span class="n">selector</span><span class="o">.</span><span class="n">unregister</span><span class="p">(</span><span class="n">sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">())</span>
        <span class="n">get</span> <span class="o">=</span> <span class="s1">&#39;GET </span><span class="si">{0}</span><span class="s1"> HTTP/1.0 </span><span class="se">\r\n</span><span class="s1">Host: example.com</span><span class="se">\r\n\r\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">url</span><span class="p">)</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">get</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">))</span>

        <span class="k">global</span> <span class="n">stopped</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">Future</span><span class="p">()</span>

            <span class="k">def</span> <span class="nf">on_readable</span><span class="p">():</span>
                <span class="n">f</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">4096</span><span class="p">))</span>

            <span class="n">selector</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span> <span class="n">EVENT_READ</span><span class="p">,</span> <span class="n">on_readable</span><span class="p">)</span>
            <span class="n">chunk</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">f</span>
            <span class="n">selector</span><span class="o">.</span><span class="n">unregister</span><span class="p">(</span><span class="n">sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">chunk</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">response</span> <span class="o">+=</span> <span class="n">chunk</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">urls_todo</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">url</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">urls_todo</span><span class="p">:</span>
                    <span class="n">stopped</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>
</code></pre></td></tr></table>
</div>
</div><p>The fetch method here has a yield expression inside it, so it becomes a generator. The generator needs to be started by first calling next() to iterate once or send(None), and then paused when it encounters a yield. So how does the fetch generator resume execution again? But there is still code for starting the generator. Here we need to add a Task object to start it.</p>
<h4 id="task-object">Task object</h4>
<p>follows a programming rule: a single responsibility, with each role having its own role. At the moment there is no role for the execution of the generator and managing the state of the generator, so we will create one.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="k">class</span> <span class="nc">Task</span><span class="p">:</span>
    <span class="s2">&#34;&#34;&#34;任务对象&#34;&#34;&#34;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coro</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coro</span> <span class="o">=</span> <span class="n">coro</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">Future</span><span class="p">()</span>
        <span class="n">f</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">future</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># send放到coro执行，即fetch，直到下次yield</span>
            <span class="c1"># next_future为yield返回对象</span>
            <span class="n">next_future</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">future</span><span class="o">.</span><span class="n">result</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="k">return</span> 
        <span class="n">next_future</span><span class="o">.</span><span class="n">add_done_callback</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>The Task in the above code encapsulates the coro object, i.e. the object passed to it on initialisation, and the task being managed is the coroutine to be executed, so the coro here is the fetch() generator. It also has a step() method, which is executed once during initialisation. within step() the send() method of the generator is called, and the initialisation of the first send is None drives the first execution of coro i.e. fetch().</p>
<p>After send() finishes, the next future is obtained, and then a step() callback is added to the next future. add_done_callback() is not actually for writing crawler business logic.</p>
<p>Look at the fetch() generator, which has all the business logic written inside it, including how to send the request and how to read the response. And the callback registered to the selector is quite simple - it binds the result value to the corresponding future object. Both yield expressions return the corresponding future object, which is then returned within Task.step(), so that Task, Future and Coroutine are all tied together.</p>
<p>After initialising the Task object, fetch() is driven to the yied f and that&rsquo;s it, what should happen next.</p>
<h4 id="the-event-loop-drives-the-coroutine">The Event Loop drives the coroutine</h4>
<p>Next, just wait for the EVENT_WRITE event that has been registered to occur. The event loop is like a heart, as long as it starts beating the whole program will keep running.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="k">def</span> <span class="nf">loop</span><span class="p">():</span>
    <span class="s2">&#34;&#34;&#34;事件循环驱动coroutine&#34;&#34;&#34;</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">stopped</span><span class="p">:</span>
        <span class="n">events</span> <span class="o">=</span> <span class="n">selector</span><span class="o">.</span><span class="n">select</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">event_key</span><span class="p">,</span> <span class="n">event_mask</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
            <span class="n">callback</span> <span class="o">=</span> <span class="n">event_key</span><span class="o">.</span><span class="n">data</span>
            <span class="n">callback</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="the-entire-crawler-after-refactoring">The entire crawler after refactoring</h4>
<p>The complete program is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">from</span> <span class="nn">selectors</span> <span class="kn">import</span> <span class="n">EVENT_READ</span><span class="p">,</span> <span class="n">EVENT_WRITE</span><span class="p">,</span> <span class="n">DefaultSelector</span>
<span class="kn">from</span> <span class="nn">socket</span> <span class="kn">import</span> <span class="n">create_connection</span>

<span class="n">selector</span> <span class="o">=</span> <span class="n">DefaultSelector</span><span class="p">()</span>
<span class="n">stopped</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">urls_todo</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="s1">&#39;/1&#39;</span><span class="p">,</span> <span class="s1">&#39;/2&#39;</span><span class="p">,</span> <span class="s1">&#39;/3&#39;</span><span class="p">,</span> <span class="s1">&#39;/4&#39;</span><span class="p">,</span> <span class="s1">&#39;/5&#39;</span><span class="p">,</span> <span class="s1">&#39;/6&#39;</span><span class="p">,</span> <span class="s1">&#39;/7&#39;</span><span class="p">,</span> <span class="s1">&#39;/8&#39;</span><span class="p">,</span> <span class="s1">&#39;/9&#39;</span><span class="p">}</span>


<span class="k">class</span> <span class="nc">Future</span><span class="p">:</span>
    <span class="s2">&#34;&#34;&#34;
</span><span class="s2">    未来对象
</span><span class="s2">    异步调用执行完的时候，就把结果放在它里面。
</span><span class="s2">    &#34;&#34;&#34;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_callbacks</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">add_done_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_callbacks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_callbacks</span><span class="p">:</span>
            <span class="n">fn</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Crawler</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">url</span> <span class="o">=</span> <span class="n">url</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">response</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span>

    <span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">setblocking</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sock</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s1">&#39;example.com&#39;</span><span class="p">,</span> <span class="mi">80</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">BlockingIOError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">Future</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">on_connect</span><span class="p">():</span>
            <span class="n">f</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="n">selector</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span> <span class="n">EVENT_WRITE</span><span class="p">,</span> <span class="n">on_connect</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">f</span>
        <span class="n">selector</span><span class="o">.</span><span class="n">unregister</span><span class="p">(</span><span class="n">sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">())</span>
        <span class="n">get</span> <span class="o">=</span> <span class="s1">&#39;GET </span><span class="si">{0}</span><span class="s1"> HTTP/1.0 </span><span class="se">\r\n</span><span class="s1">Host: example.com</span><span class="se">\r\n\r\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">url</span><span class="p">)</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">get</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">))</span>

        <span class="k">global</span> <span class="n">stopped</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">Future</span><span class="p">()</span>

            <span class="k">def</span> <span class="nf">on_readable</span><span class="p">():</span>
                <span class="n">f</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">4096</span><span class="p">))</span>

            <span class="n">selector</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span> <span class="n">EVENT_READ</span><span class="p">,</span> <span class="n">on_readable</span><span class="p">)</span>
            <span class="n">chunk</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">f</span>
            <span class="n">selector</span><span class="o">.</span><span class="n">unregister</span><span class="p">(</span><span class="n">sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">chunk</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">response</span> <span class="o">+=</span> <span class="n">chunk</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">urls_todo</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">url</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">urls_todo</span><span class="p">:</span>
                    <span class="n">stopped</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>


<span class="k">class</span> <span class="nc">Task</span><span class="p">:</span>
    <span class="s2">&#34;&#34;&#34;任务对象&#34;&#34;&#34;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coro</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coro</span> <span class="o">=</span> <span class="n">coro</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">Future</span><span class="p">()</span>
        <span class="n">f</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">future</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># send放到coro执行，即fetch，直到下次yield</span>
            <span class="c1"># next_future为yield返回对象</span>
            <span class="n">next_future</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">future</span><span class="o">.</span><span class="n">result</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="k">return</span> 
        <span class="n">next_future</span><span class="o">.</span><span class="n">add_done_callback</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">loop</span><span class="p">():</span>
    <span class="s2">&#34;&#34;&#34;事件循环驱动coroutine&#34;&#34;&#34;</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">stopped</span><span class="p">:</span>
        <span class="n">events</span> <span class="o">=</span> <span class="n">selector</span><span class="o">.</span><span class="n">select</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">event_key</span><span class="p">,</span> <span class="n">event_mask</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
            <span class="n">callback</span> <span class="o">=</span> <span class="n">event_key</span><span class="o">.</span><span class="n">data</span>
            <span class="n">callback</span><span class="p">()</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&#34;__main__&#34;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">urls_todo</span><span class="p">:</span>
        <span class="n">crawler</span> <span class="o">=</span> <span class="n">Crawler</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
        <span class="n">Task</span><span class="p">(</span><span class="n">crawler</span><span class="o">.</span><span class="n">fetch</span><span class="p">())</span>
    <span class="n">loop</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>

<span class="s2">&#34;&#34;&#34;
</span><span class="s2">现在loop有了些许变化，callback()不再传递event_key和event_mask参数。也就是说，
</span><span class="s2">这里的回调根本不关心是谁触发了这个事件,
</span><span class="s2">结合fetch()可以知道，它只需完成对future设置结果值即可f.set_result()。
</span><span class="s2">&#34;&#34;&#34;</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="summary-of-generator-styles-and-callback-styles">Summary of generator styles and callback styles</h4>
<p>In the callback style.</p>
<ul>
<li>there are chained callbacks (although the example has only one layer of nested callbacks)</li>
<li>the request and response also have to be split into two callbacks to the extent that it breaks the synchronous code kind of structure</li>
<li>The programmer has to maintain mandatory state between callbacks.</li>
</ul>
<p>Instead, the style based on the generator coroutine is.</p>
<ul>
<li>no chained calls</li>
<li>the selector callback just sets the value for future and doesn&rsquo;t care about the business logic</li>
<li>callback() within loop no longer cares about who triggered the event</li>
<li>Converges to the structure of synchronous code</li>
<li>No need for programmers to maintain state between multiple coroutines, e.g. which one is their sock</li>
</ul>
<h4 id="yield-from-improve-generator-coroutine">yield from improve generator coroutine</h4>
<p>What if fetch needs to be more fault-tolerant and the business functionality needs to be better? And the technical processing part (socket-related) is mixed with the business processing part (handling of requests and return data).</p>
<ul>
<li>Creating a socket connection can be reused in the abstract, right?</li>
<li>Reading the entire response in a loop can be reused abstractly, right?</li>
<li>The processing of socket.recv() within the loop can be abstractly reused, right?</li>
</ul>
<p>But there are yields where these key nodes are, and the abstracted code needs to be generators as well. And fetch() would have to be a generator itself. Mashing generators within generators seems a bit tricky.</p>
<p>Good thing we have yield from to solve this problem.</p>
<h4 id="yield-from-syntax">yield from syntax</h4>
<p>yield from is a new syntax introduced in Python 3.3 (PEP 380). It mainly addresses the problem of inconvenience of messing with generators in generators. It has two main functions.</p>
<p>The first feature is: instead of having to iterate through a loop to yield, nested generators can just yield from. the following two ways are equivalent.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="k">def</span> <span class="nf">gen_one</span><span class="p">():</span>
    <span class="n">subgen</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>    
    <span class="k">yield from</span> <span class="n">subgen</span>

<span class="k">def</span> <span class="nf">gen_two</span><span class="p">():</span>
    <span class="n">subgen</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>    
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">subgen</span><span class="p">:</span>        
        <span class="k">yield</span> <span class="n">item</span>
</code></pre></td></tr></table>
</div>
</div><p>The second function is to open a two-way channel between the sub-generator and the caller of the original generator, so that the two can communicate directly.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="k">def</span> <span class="nf">gen</span><span class="p">():</span>
    <span class="k">yield from</span> <span class="n">subgen</span><span class="p">()</span><span class="k">def</span> <span class="nf">subgen</span><span class="p">():</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="k">yield</span>
        <span class="k">yield</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">gen</span><span class="p">()</span>

    <span class="nb">next</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>                <span class="c1"># 驱动生成器g开始执行到第一个 yield</span>
    <span class="n">retval</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>     <span class="c1"># 看似向生成器 gen() 发送数据</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">retval</span><span class="p">)</span>          <span class="c1"># 返回2</span>
    <span class="n">g</span><span class="o">.</span><span class="n">throw</span><span class="p">(</span><span class="ne">StopIteration</span><span class="p">)</span> <span class="c1"># 看似向gen()抛入异常</span>
</code></pre></td></tr></table>
</div>
</div><p>The two-way channel function of yield from is clearly understood by the above code. The keyword yield from opens up a communication channel between subgen() and main() inside gen(). main() can send data 1 directly to subgen(), subgen() can return the calculated data 2 to main(), and main() can throw an exception directly to subgen() to terminate subgen().</p>
<h4 id="refactoring-the-code">Refactoring the code</h4>
<p>First we need to turn the Future object into an iter object.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="k">class</span> <span class="nc">Future</span><span class="p">:</span>
    <span class="s2">&#34;&#34;&#34;
</span><span class="s2">    未来对象
</span><span class="s2">    异步调用执行完的时候，就把结果放在它里面。
</span><span class="s2">    &#34;&#34;&#34;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_callbacks</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">add_done_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_callbacks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_callbacks</span><span class="p">:</span>
            <span class="n">fn</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># 将Future变成一个iter对象</span>
        <span class="k">yield</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span>
</code></pre></td></tr></table>
</div>
</div><p>After</p>
<p>abstracting the function of a socket connection.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">address</span><span class="p">):</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">Future</span><span class="p">()</span>
    <span class="n">sock</span><span class="o">.</span><span class="n">setblocking</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">BlockingIOError</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">on_connected</span><span class="p">():</span>
        <span class="n">f</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

    <span class="n">selector</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span> <span class="n">EVENT_WRITE</span><span class="p">,</span> <span class="n">on_connected</span><span class="p">)</span>
    <span class="k">yield from</span> <span class="n">f</span>
    <span class="n">selector</span><span class="o">.</span><span class="n">unregister</span><span class="p">(</span><span class="n">sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">())</span>
</code></pre></td></tr></table>
</div>
</div><p>Abstracting a single recv() and reading a full response function</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="n">sock</span><span class="p">):</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">Future</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">on_readable</span><span class="p">():</span>
        <span class="n">f</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="n">sock</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">4096</span><span class="p">))</span>

    <span class="n">selector</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">(),</span> <span class="n">EVENT_READ</span><span class="p">,</span> <span class="n">on_readable</span><span class="p">)</span>
    <span class="n">chunk</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">f</span>
    <span class="n">selector</span><span class="o">.</span><span class="n">unregister</span><span class="p">(</span><span class="n">sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">chunk</span>

<span class="k">def</span> <span class="nf">read_all</span><span class="p">(</span><span class="n">sock</span><span class="p">):</span>
    <span class="n">response</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">chunk</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">read</span><span class="p">(</span><span class="n">sock</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">chunk</span><span class="p">:</span>
        <span class="n">response</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
        <span class="n">chunk</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">read</span><span class="p">(</span><span class="n">sock</span><span class="p">)</span>
    <span class="k">return</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Now refactor the Crawler class</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="k">class</span> <span class="nc">Crawler</span><span class="p">:</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">url</span> <span class="o">=</span> <span class="n">url</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">response</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span>

    <span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">global</span> <span class="n">stopped</span>
        <span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
        <span class="k">yield from</span> <span class="n">connect</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;example.com&#39;</span><span class="p">,</span> <span class="mi">80</span><span class="p">))</span>
        <span class="n">get</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;GET </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">url</span><span class="si">}</span><span class="s1"> HTTP/1.0</span><span class="se">\r\n</span><span class="s1">Host: example.com</span><span class="se">\r\n\r\n</span><span class="s1">&#39;</span>
        <span class="n">sock</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">get</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">response</span> <span class="o">=</span> <span class="k">yield from</span> <span class="n">read_all</span><span class="p">(</span><span class="n">sock</span><span class="p">)</span>
        <span class="n">urls_todo</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">url</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">urls_todo</span><span class="p">:</span>
            <span class="n">stopped</span> <span class="o">=</span> <span class="kc">True</span>
</code></pre></td></tr></table>
</div>
</div><p>With the introduction of the new yield from syntax in Python 3.3, it is no longer recommended to use yield as a coroutine. all use yield from allows us to pass data between coroutines as we wish due to its bi-directional channel feature.</p>
<p>With yield from, we can concatenate multiple generators. yield from is meant to concatenate these generators into a tree, and provides a convenient way to return the leaf nodes of the tree in turn. yield from concatenates multiple generators in such a way that we can extract all the yield returns in a very simple way. All the yield returns can be extracted in a very simple way. The generator at the root node is continuously sent.</p>
<p>The above example introduces yield and yield from, but what are the differences and connections between them and asyncio?</p>
<h2 id="asyncio">asyncio</h2>
<h3 id="introduction-to-asyncio">Introduction to asyncio</h3>
<p>asyncio is an asynchronous I/O framework introduced experimentally in Python 3.4 (PEP 3156), providing the infrastructure for writing single-threaded concurrent code based on coroutine for asynchronous I/O. The core components are Event Loop, Coroutine, Task, Future, and a number of other modules of an extended and auxiliary nature.</p>
<p>When asyncio was introduced, the function 还提供了一个装饰器@asyncio.coroutine用于装饰使用了yield from was used to mark it as a coroutine. But it was not mandatory to use this decorator.</p>
<p>Although the development of Python 3.4 made coroutines easier with the addition of yield from, many people still don&rsquo;t understand the connection and difference between generators and coroutines, or the difference between yield and yield from, due to the historical baggage of coroutine development in Python. This confusion also goes against some of the guidelines of the Zen of Python.</p>
<p>So the designers of Python have added async/await syntax (PEP 492) in 3.5, which provides explicit and explicit support for coroutines, called native coroutines. async/await and yield from are two styles of coroutine that share a common implementation and are compatible with each other. and are compatible with each other.</p>
<p>In Python 3.6 the asyncio library was &lsquo;converted&rsquo; from being experimental to being a full member of the standard library.</p>
<p>asyncio rewrites the crawler
To rewrite a previously written example in asyncio.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">aiohttp</span>

<span class="n">host</span> <span class="o">=</span> <span class="s1">&#39;http://example.com&#39;</span>
<span class="n">urls_todo</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="s1">&#39;/1&#39;</span><span class="p">,</span> <span class="s1">&#39;/2&#39;</span><span class="p">,</span> <span class="s1">&#39;/3&#39;</span><span class="p">,</span> <span class="s1">&#39;/4&#39;</span><span class="p">,</span> <span class="s1">&#39;/5&#39;</span><span class="p">,</span> <span class="s1">&#39;/6&#39;</span><span class="p">,</span> <span class="s1">&#39;/7&#39;</span><span class="p">,</span> <span class="s1">&#39;/8&#39;</span><span class="p">,</span> <span class="s1">&#39;/9&#39;</span><span class="p">}</span>


<span class="k">async</span> <span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">aiohttp</span><span class="o">.</span><span class="n">ClientSession</span><span class="p">(</span><span class="n">loop</span><span class="o">=</span><span class="n">loop</span><span class="p">)</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
        <span class="k">async</span> <span class="k">with</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span> <span class="k">as</span> <span class="n">response</span><span class="p">:</span>
            <span class="n">response</span> <span class="o">=</span> <span class="k">await</span> <span class="n">response</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">response</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
    <span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span><span class="n">fetch</span><span class="p">(</span><span class="n">host</span> <span class="o">+</span> <span class="n">url</span><span class="p">)</span> <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">urls_todo</span><span class="p">]</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">tasks</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>The above code runs in roughly 0.36s</p>
<p>Compared to the previous one, the changes are significant.</p>
<ul>
<li>Instead of yield or yield from, it&rsquo;s async/await</li>
<li>no more self-made loop(), instead asyncio.get_event_loop()</li>
<li>No need to do your own asynchronous operations on the socket, no need to explicitly register and deregister events, the aiohttp library already does that for you</li>
<li>No more explicit Future and Task, asyncio already encapsulates them</li>
<li>Less code, more elegant design</li>
</ul>
<p>Code comparison with the synchronous blocking version.</p>
<ul>
<li>Asynchronous</li>
<li>Comparable amount of code (even less with the introduction of the aiohttp framework)</li>
<li>Same simple code logic, same structure, same logic as synchronous code</li>
<li>Nearly 10x performance improvement</li>
</ul>
<h3 id="simple-implementation-of-asyncio">Simple implementation of asyncio</h3>
<h4 id="asyncio-logic-refresh">asyncio Logic Refresh</h4>
<p>Let&rsquo;s extract the previous code that implements asynchronous, the main three things are Future, Task, event_loop.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="kn">from</span> <span class="nn">selectors</span> <span class="kn">import</span> <span class="n">EVENT_READ</span><span class="p">,</span> <span class="n">EVENT_WRITE</span><span class="p">,</span> <span class="n">DefaultSelector</span>


<span class="n">stopped</span> <span class="o">=</span> <span class="kc">False</span>

<span class="k">class</span> <span class="nc">Future</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_callbacks</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">add_done_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_callbacks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_callbacks</span><span class="p">:</span>
            <span class="n">fn</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">yield</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span>


<span class="k">class</span> <span class="nc">Task</span><span class="p">:</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coro</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coro</span> <span class="o">=</span> <span class="n">coro</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">Future</span><span class="p">()</span>
        <span class="n">f</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>  <span class="c1">#激活 Task 包裹的生成器</span>

    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">future</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">next_future</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coro</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">future</span><span class="o">.</span><span class="n">result</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">next_future</span><span class="o">.</span><span class="n">add_done_callback</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>

<span class="n">selector</span> <span class="o">=</span> <span class="n">DefaultSelector</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">loop</span><span class="p">():</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">stopped</span><span class="p">:</span>
        <span class="n">events</span> <span class="o">=</span> <span class="n">selector</span><span class="o">.</span><span class="n">select</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">event_key</span><span class="p">,</span> <span class="n">event_mask</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
            <span class="n">callback</span> <span class="o">=</span> <span class="n">event_key</span><span class="o">.</span><span class="n">data</span>
            <span class="n">callback</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>This code cannot be used directly of course, we need to adapt it.</p>
<p>The core of the asyncio library is the same three things, Future, Task and the event loop.</p>
<p>Before we get started, let&rsquo;s write a small demo using asyncio and sort out the asyncio logic based on this demo.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">get_html</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;开始获取HTML&#34;</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;结束获取HTML&#34;</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&#34;__main__&#34;</span><span class="p">:</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">get_html</span><span class="p">(</span><span class="s2">&#34;https://www.baidu.com&#34;</span><span class="p">)</span>
    <span class="n">task</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>In the above code we have constructed an asynchronous function get_html to simulate accessing a web page.</p>
<p>The first function executed in this code snippet is get_event_loop, which is a function that gets an event loop, keeps looping to check if an event is ready, and if it is ready, calls the callback function registered to the event until it stops and exits the loop. get_event_loop() returns an instance of the event loop class, which is inherited from BaseEventLoop.</p>
<p>The create_task() function is then executed to see what it does.</p>
<p>The BaseEventLoop definition is found in asyncio/base_events.py, and there is a create_task method in the BaseEventLoop class.</p>
<p>The core code of this method is just these two.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="k">def</span> <span class="nf">create_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coro</span><span class="p">):</span>    
        <span class="n">task</span> <span class="o">=</span> <span class="n">tasks</span><span class="o">.</span><span class="n">Task</span><span class="p">(</span><span class="n">coro</span><span class="p">,</span> <span class="n">loop</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">task</span>
</code></pre></td></tr></table>
</div>
</div><p>Each instance of the Task class wraps a coroutine (coro), which is then driven by the send function in step.</p>
<p>Each instance of the Task class wraps a coroutine (coro), which is then driven by the send function in step.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/18/0f8683f69c32496ebae7ec283fb3affd.png" alt="Coroutine"></p>
<p>In the Task class, the coroutine is saved when the instance is initialised, and then the step function is used to start the coroutine, but the step function here is not quite the same as the one we extracted above, it has a lot more parameter checking and exception handling, and then the Task class we extracted above drives the whole coroutine at init time. coroutine, but in asyncio it doesn&rsquo;t call the step function right away, it calls it (the _loop.call_soon function) in the next frame (the next loop).</p>
<p>The call_soon function here adds the _step function of the Task instance to the queue to be executed, which is also defined in the BaseEventLoop class of asyncio/base_events.py.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py">    <span class="k">def</span> <span class="nf">_call_soon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="n">handle</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">Handle</span><span class="p">(</span><span class="n">callback</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">handle</span><span class="o">.</span><span class="n">_source_traceback</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">handle</span><span class="o">.</span><span class="n">_source_traceback</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ready</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">handle</span><span class="p">)</span>  <span class="c1"># 事件添加到队列</span>
        <span class="k">return</span> <span class="n">handle</span>
</code></pre></td></tr></table>
</div>
</div><p>It returns an instance of the Handle class. The Handle class here is the one that wraps the callback function for the ready event, which defines a run method that executes the callback function directly. self._ready holds the instance of the Handle class, and the loop in asyncio keeps checking whether there is an event ready, i.e. checking whether self._ready is empty, and if it is not empty, the Handle instance is ejected from it. If it is not empty, the Handle instance is popped out of it, and then the run method of the Handle instance is called, which is actually a callback function registered to the ready event. Once there is a ready event, the callback function is called.</p>
<p>Now in the little demo we wrote, we have created a task instance by using task = loop.create_task(func), which wraps our own coroutine func, and when the task is initialized, it is called in the <code>__init__</code> function with <code>call_soon</code> The next step is the <code>run_until_complete</code> function, which tells the next loop to execute the task&rsquo;s <code>_step</code> function immediately.</p>
<p>The <code>run_until_complete</code> function is also defined in the BaseEventLoop class in asyncio/base_events.py. This function has the loop dead loop in it. (excerpted code, with some code removed)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="k">def</span> <span class="nf">run_until_complete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">future</span><span class="p">):</span>
        <span class="n">future</span> <span class="o">=</span> <span class="n">tasks</span><span class="o">.</span><span class="n">ensure_future</span><span class="p">(</span><span class="n">future</span><span class="p">,</span> <span class="n">loop</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>  <span class="c1"># ensure_future，即，确保是future。返回的是future（task也是future）</span>

        <span class="n">future</span><span class="o">.</span><span class="n">add_done_callback</span><span class="p">(</span><span class="n">_run_until_complete_cb</span><span class="p">)</span>  <span class="c1"># 用来结束循环</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">new_task</span> <span class="ow">and</span> <span class="n">future</span><span class="o">.</span><span class="n">done</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">future</span><span class="o">.</span><span class="n">cancelled</span><span class="p">():</span>
                <span class="n">future</span><span class="o">.</span><span class="n">exception</span><span class="p">()</span>
            <span class="k">raise</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">future</span><span class="o">.</span><span class="n">remove_done_callback</span><span class="p">(</span><span class="n">_run_until_complete_cb</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">future</span><span class="o">.</span><span class="n">done</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Event loop stopped before Future completed.&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">future</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>The function first makes sure that the parameter passed in is future, Task is inherited from Future, so task is also future. the parameter we pass in outside is a task instance, so this function call returns what is actually itself (what is passed in is what is returned), then we pass in the task instance by calling add_done_callback to add the _run_until_complete_cb callback function. callback to add the _run_until_complete_cb callback function, this callback function is more critical, the most important thing that run_until_complete does is to add this callback to the task instance passed in, click into the _run_until_complete_cb, you can see that is to call the The meaning of this is that when the coroutine wrapped in the task we passed in is finished running, this callback will be called to jump out of the loop (which is equivalent to the role of the stopped variable in the code we extracted), otherwise the dead loop is really a dead loop and can never be jumped.</p>
<p>After that it&rsquo;s really a dead loop, run forever.</p>
<p>Key code</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="k">def</span> <span class="nf">run_forever</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span><span class="k">try</span><span class="p">:</span>
            <span class="n">events</span><span class="o">.</span><span class="n">_set_running_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_run_once</span><span class="p">()</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stopping</span><span class="p">:</span>
                    <span class="k">break</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="o">...</span>
</code></pre></td></tr></table>
</div>
</div><p>This function constantly calls _run_once(), just as the following code is constantly called in the loop function that we extracted.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="n">events</span> <span class="o">=</span> <span class="n">selector</span><span class="o">.</span><span class="n">select</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">event_key</span><span class="p">,</span> <span class="n">event_mask</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
            <span class="n">callback</span> <span class="o">=</span> <span class="n">event_key</span><span class="o">.</span><span class="n">data</span>
            <span class="n">callback</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>And in _run_once().</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py">        <span class="k">else</span><span class="p">:</span>
            <span class="n">event_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selector</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span>  <span class="c1"># 筛选就绪事件，将其回调添加到self._ready中</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_events</span><span class="p">(</span><span class="n">event_list</span><span class="p">)</span>  <span class="c1"># 该函数具体实现在selector_events.py中</span>
</code></pre></td></tr></table>
</div>
</div><p>Here too, the ready event is selected and then added to the self._ready queue and subsequently executed. At the end of _run_once(), we see the following code.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="n">ntodo</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ready</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ntodo</span><span class="p">):</span>
            <span class="n">handle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ready</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">handle</span><span class="o">.</span><span class="n">_cancelled</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_current_handle</span> <span class="o">=</span> <span class="n">handle</span>
                    <span class="n">t0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                    <span class="n">handle</span><span class="o">.</span><span class="n">_run</span><span class="p">()</span>
                    <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t0</span>
                    <span class="k">if</span> <span class="n">dt</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slow_callback_duration</span><span class="p">:</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Executing </span><span class="si">%s</span><span class="s1"> took </span><span class="si">%.3f</span><span class="s1"> seconds&#39;</span><span class="p">,</span>
                                       <span class="n">_format_handle</span><span class="p">(</span><span class="n">handle</span><span class="p">),</span> <span class="n">dt</span><span class="p">)</span>
                <span class="k">finally</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_current_handle</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">handle</span><span class="o">.</span><span class="n">_run</span><span class="p">()</span>
        <span class="n">handle</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Needed to break cycles when an exception occurs.</span>
</code></pre></td></tr></table>
</div>
</div><p>Here is where the callback function for the ready event is called for execution. First we look at the _ready queue to see if there are any pending Handle instances, if there are, then we execute them one by one, and the _run() method in the handle is the callback function that executes the ready event. At this point, the logic of the loop() function we extracted corresponds to the loop in the asyncio source code.</p>
<p>Finally, let&rsquo;s look at Future</p>
<p>As with the Future in the code we extracted above.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py">    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">yield</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span>  <span class="c1"># 在Task.step中send(result)的时候再次调用这个生成器，但是此时会抛出stopInteration异常，并且把self.result返回</span>
</code></pre></td></tr></table>
</div>
</div><p>The presence of yield makes the <strong>iter</strong> function a generator, which itself has a next method, so no additional implementation is needed. yield from x first calls iter(x) to get an iterator (a generator is also an iterator).</p>
<p>The future here is the same structure as the future in asyncio, and has similar functionality. The final runtime is one layer of generators nested in one layer of generators.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/python/">python</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-01/faster-python/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">CPython performance to be improved by 5x? faster-python project PEP 659 source code interpretation</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-01/three-new-concepts-of-go-interface-since-1-18/">
            <span class="next-text nav-default">Three new concepts related to interfaces since Go 1.18</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
