<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>An article to help you understand stack operations in Go - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="This article will teach you how to understand Go&amp;rsquo;s plan9 assembly through stack operations. Knowledge points Linux process in memory layout Each process in a multitasking operating system runs in its own memory sandbox. In 32-bit mode, it is always 4GB of memory address space, and memory allocation is to allocate virtual memory to processes. When a process actually accesses a virtual memory address, the OS allocates a corresponding space" /><meta name="keywords" content="golang, Stack" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-01/go-stack/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="An article to help you understand stack operations in Go" />
<meta property="og:description" content="This article will teach you how to understand Go&rsquo;s plan9 assembly through stack operations. Knowledge points Linux process in memory layout Each process in a multitasking operating system runs in its own memory sandbox. In 32-bit mode, it is always 4GB of memory address space, and memory allocation is to allocate virtual memory to processes. When a process actually accesses a virtual memory address, the OS allocates a corresponding space" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-01/go-stack/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-01-22T16:39:10+08:00" />
<meta property="article:modified_time" content="2022-01-22T16:39:10+08:00" />

<meta itemprop="name" content="An article to help you understand stack operations in Go">
<meta itemprop="description" content="This article will teach you how to understand Go&rsquo;s plan9 assembly through stack operations. Knowledge points Linux process in memory layout Each process in a multitasking operating system runs in its own memory sandbox. In 32-bit mode, it is always 4GB of memory address space, and memory allocation is to allocate virtual memory to processes. When a process actually accesses a virtual memory address, the OS allocates a corresponding space"><meta itemprop="datePublished" content="2022-01-22T16:39:10+08:00" />
<meta itemprop="dateModified" content="2022-01-22T16:39:10+08:00" />
<meta itemprop="wordCount" content="6865">
<meta itemprop="keywords" content="golang," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="An article to help you understand stack operations in Go"/>
<meta name="twitter:description" content="This article will teach you how to understand Go&rsquo;s plan9 assembly through stack operations. Knowledge points Linux process in memory layout Each process in a multitasking operating system runs in its own memory sandbox. In 32-bit mode, it is always 4GB of memory address space, and memory allocation is to allocate virtual memory to processes. When a process actually accesses a virtual memory address, the OS allocates a corresponding space"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">An article to help you understand stack operations in Go</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-01-22 16:39:10 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 6865 words </span>
          <span class="more-meta"> 14 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#knowledge-points">Knowledge points</a>
          <ul>
            <li><a href="#linux-process-in-memory-layout">Linux process in memory layout</a></li>
            <li><a href="#concepts-related-to-the-stack">Concepts related to the stack</a></li>
            <li><a href="#goroutine-stack-operations">Goroutine stack operations</a></li>
            <li><a href="#assembly">Assembly</a></li>
          </ul>
        </li>
        <li><a href="#parsing">Parsing</a>
          <ul>
            <li><a href="#creation-of-g">Creation of G</a></li>
            <li><a href="#initialization-of-the-stack">Initialization of the stack</a></li>
            <li><a href="#allocation-of-the-stack">Allocation of the stack</a></li>
            <li><a href="#stack-expansion">Stack expansion</a></li>
            <li><a href="#stack-shrinkage">Stack shrinkage</a></li>
          </ul>
        </li>
        <li><a href="#summary">Summary</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>This article will teach you how to understand Go&rsquo;s plan9 assembly through stack operations.</p>
<h2 id="knowledge-points">Knowledge points</h2>
<h3 id="linux-process-in-memory-layout">Linux process in memory layout</h3>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/22/71a4f212941f40dfbda5fde7ab32baee.png" alt="memory layout"></p>
<p>Each process in a multitasking operating system runs in its own memory sandbox. In 32-bit mode, it is always 4GB of memory address space, and memory allocation is to allocate virtual memory to processes. When a process actually accesses a virtual memory address, the OS allocates a corresponding space on physical memory and then establishes a mapping relationship with it by triggering a missing page interrupt, so that the virtual memory address accessed by the process will be automatically converted into a valid physical memory address, and then data can be stored and accessed. The virtual memory address accessed by the process is automatically converted to a valid physical memory address, and data can be stored and accessed.</p>
<p><strong>Kernel space</strong> : the operating system kernel address space.</p>
<p><strong>Stack</strong> : The stack space is where the user stores local variables created temporarily by the program, and the stack grows from the high address to the high address down. On modern mainstream machine architectures (e.g., <code>x86</code>), the stack grows downward. However, there are some processors (e.g., <code>B5000</code>) where the stack grows upwards, some architectures (e.g., <code>System Z</code>) that allow custom stack growth, and even some processors (e.g., <code>SPARC</code>) that handle a cyclic stack.</p>
<p><strong>Heap</strong> : heap space, which is used to hold memory segments that are dynamically allocated while the process is running; it is not fixed in size and can be dynamically expanded or reduced.</p>
<p><strong>BBS segment</strong> : BSS segment, which holds global or static data, but holds global/static uninitialized data.</p>
<p><strong>Data segment</strong> : a data segment, usually a memory area used to hold global variables that have been initialized in a program.</p>
<p><strong>Text segment</strong> : A code segment, which refers to a memory area used to hold the code for program execution. The size of this segment is determined before the program runs, and the memory area is read-only.</p>
<h3 id="concepts-related-to-the-stack">Concepts related to the stack</h3>
<p>In computer science, a call stack is a stack data structure that stores information about the active subroutines of a computer program.</p>
<p>In computer programming, a subroutine is a sequence of program instructions that performs a specific task, packaged as a unit.</p>
<p>A stack frame is a frame of data that gets pushed onto the stack. In the case of a call stack, a stack frame would represent a function call and its argument data.</p>
<p>With function calls, there is a caller and a callee, e.g., if function A calls function B, A is the caller and B is the callee.</p>
<p>The stack structure of the caller and the callee is shown in the following figure.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/22/d70dddb65d534c47b565a448706f211f.png" alt="sobyte"></p>
<p>The Go assembly code is very vague in explaining the stack registers, so we probably only need to know the role of two registers, BP and SP.</p>
<p>BP: <strong>base pointer register</strong> , which maintains the base address of the current stack frame for indexing variables and parameters, like an anchor point, which in other architectures is equivalent to the frame pointer <code>FP</code>, except that in the x86 architecture, variables and parameters can be indexed by SP.</p>
<p>SP: <strong>stack pointer register</strong> , always pointing to the top of the stack.</p>
<h3 id="goroutine-stack-operations">Goroutine stack operations</h3>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/22/635ee49c991646edb6e06f62aa09c39b.png" alt="sobyte"></p>
<p>In Goroutine there is a stack data structure with two attributes lo and hi that describe the actual stack memory address.</p>
<ul>
<li>stack.lo: the low address of the stack space.</li>
<li>stack.hi: the high address of the stack space.</li>
</ul>
<p>In Goroutine it will be determined if stack growth is to be done by stackguard0: * stack.lo: the low address of the stack space; * stack.hi: the high address of the stack space.</p>
<ul>
<li>stackguard0: <code>stack.lo + StackGuard</code> , used for stack overlow detection.</li>
<li>StackGuard: protected area size, 928 bytes on constant Linux.</li>
<li>StackSmall: constant size 128 bytes, used for optimization of small function calls; * StackSmall: constant size 128 bytes, used for optimization of small function calls.</li>
<li>StackBig: constant size 4096 bytes.</li>
</ul>
<p>To determine if expansion is needed based on the size of the called function stack frame.</p>
<ol>
<li>when the stack frame size (FramSzie) is less than or equal to StackSmall (128), if SP <strong>is less than</strong> stackguard0 then perform stack expansion.</li>
<li>when the stack frame size (FramSzie) is greater than StackSmall (128), a comparison is made between <code>SP - FramSzie + StackSmall</code> and stackguard0 according to the formula <code>SP - FramSzie + StackSmall</code>, and if <strong>is less than</strong> stackguard0 then a stack expansion is performed.</li>
<li>When the stack frame size (FramSzie) is larger than StackBig (4096), it will first check whether stackguard0 has been converted to StackPreempt state; then it will perform expansion according to the formula <code>SP - stackguard0 + StackGuard &lt;= framesize + (StackGuard- StackSmall)</code> and if it is true, then perform the expansion.</li>
</ol>
<p>It should be noted that since the stack grows from the high address to the low address, the comparison is all less than before the expansion is executed, and here you need to think about it.</p>
<p>When the stack expansion is executed, a larger stack memory space will be allocated in the memory space, then all the contents of the old stack will be copied to the new stack, and the pointers to the variables corresponding to the old stack will be modified to point to the new stack again, and finally the memory space of the old stack will be destroyed and recycled, thus realizing the dynamic expansion of the stack.</p>
<h3 id="assembly">Assembly</h3>
<p>Here is a brief explanation of some of the Plan 9 assemblies used by the Go language that will be used later in the analysis, in case it is not very clear.</p>
<h4 id="assembly-functions">assembly functions</h4>
<p>Let&rsquo;s start by looking at the definition of the plan9 assembly functions.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/22/365ea4b1816347d9afbfa0b645577e0f.png" alt="sobyte"></p>
<p>stack frame size: contains local variables and the space for additional function calls.</p>
<p>arguments size: contains the size of the arguments as well as the return value, e.g. if the input is 3 int64 types and the return value is 1 int64 type, then the return value is sizeof(int64) * 4.</p>
<h4 id="stack-adjustment">Stack adjustment</h4>
<p>Stack adjustment is achieved by performing operations on the hardware SP registers, for example:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">SUBQ    <span class="nv">$24</span>, SP  // 对 sp 做减法，为函数分配函数栈帧 
...
ADDQ    <span class="nv">$24</span>, SP  // 对 sp 做加法 ，清除函数栈帧
</code></pre></td></tr></table>
</div>
</div><p>Since the stack grows downward, SUBQ actually allocates stack frames for the function when it subtracts from SP, and ADDQ clears the stack frames.</p>
<h4 id="common-instructions">Common instructions</h4>
<p><strong>Addition and subtraction operations</strong>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">ADDQ  AX, BX   // <span class="nv">BX</span> <span class="o">+=</span> AX
SUBQ  AX, BX   // BX -<span class="o">=</span> AX
</code></pre></td></tr></table>
</div>
</div><p><strong>Data handling</strong>.</p>
<p>Constants are denoted by $num in plan9 assembly, can be negative, and are decimal by default. The length of the carry is determined by the suffix of the MOV.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">MOVB <span class="nv">$1</span>, DI      // <span class="m">1</span> byte
MOVW <span class="nv">$0</span>x10, BX   // <span class="m">2</span> bytes
MOVD <span class="nv">$1</span>, DX      // <span class="m">4</span> bytes
MOVQ <span class="nv">$-</span>10, AX     // <span class="m">8</span> bytes
</code></pre></td></tr></table>
</div>
</div><p>Another difference is that when using MOVQ you will see a difference between with and without parentheses.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">// 加括号代表是指针的引用
MOVQ <span class="o">(</span>AX<span class="o">)</span>, BX   // <span class="o">=</span>&gt; <span class="nv">BX</span> <span class="o">=</span> *AX 将AX指向的内存区域8byte赋值给BX
MOVQ 16<span class="o">(</span>AX<span class="o">)</span>, BX // <span class="o">=</span>&gt; <span class="nv">BX</span> <span class="o">=</span> *<span class="o">(</span>AX + 16<span class="o">)</span>

//不加括号是值的引用
MOVQ AX, BX     // <span class="o">=</span>&gt; <span class="nv">BX</span> <span class="o">=</span> AX 将AX中存储的内容赋值给BX，注意区别
</code></pre></td></tr></table>
</div>
</div><p><strong>jump</strong>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">// 无条件跳转
JMP addr   // 跳转到地址，地址可为代码中的地址
JMP label  // 跳转到标签，可以跳转到同一函数内的标签位置
JMP 2<span class="o">(</span>PC<span class="o">)</span>  // 以当前指令为基础，向前/后跳转 x 行

// 有条件跳转
JLS addr
</code></pre></td></tr></table>
</div>
</div><p>Address arithmetic.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">LEAQ <span class="o">(</span>AX<span class="o">)(</span>AX*2<span class="o">)</span>, CX // <span class="o">=</span>&gt; <span class="nv">CX</span> <span class="o">=</span> AX + <span class="o">(</span>AX * 2<span class="o">)</span> <span class="o">=</span> AX * <span class="m">3</span>
</code></pre></td></tr></table>
</div>
</div><p>The 2 in the above code stands for scale, scale can only be 0, 2, 4, 8.</p>
<h2 id="parsing">Parsing</h2>
<h3 id="creation-of-g">Creation of G</h3>
<p>Since the stack is on the Goroutine, let&rsquo;s start with the creation of G and how to initialize the stack space. Only the code for the initialization part of the stack is explained here.</p>
<p>G creation is done by calling <code>runtime-newproc</code> to create.</p>
<p><strong>runtime.newproc</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">newproc</span><span class="p">(</span><span class="nx">siz</span> <span class="kt">int32</span><span class="p">,</span> <span class="nx">fn</span> <span class="o">*</span><span class="nx">funcval</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">argp</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">fn</span><span class="p">),</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">)</span>
    <span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
    <span class="c1">// 获取 caller 的 PC 寄存器
</span><span class="c1"></span>    <span class="nx">pc</span> <span class="o">:=</span> <span class="nf">getcallerpc</span><span class="p">()</span>
    <span class="c1">// 切换到 G0 进行创建
</span><span class="c1"></span>    <span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">newg</span> <span class="o">:=</span> <span class="nf">newproc1</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="nx">argp</span><span class="p">,</span> <span class="nx">siz</span><span class="p">,</span> <span class="nx">gp</span><span class="p">,</span> <span class="nx">pc</span><span class="p">)</span>
        <span class="o">...</span>
    <span class="p">})</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The newproc method switches to G0 to call the newproc1 function for G creation.</p>
<p><strong>runtime.newproc1</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="nx">_StackMin</span> <span class="p">=</span> <span class="mi">2048</span>
<span class="kd">func</span> <span class="nf">newproc1</span><span class="p">(</span><span class="nx">fn</span> <span class="o">*</span><span class="nx">funcval</span><span class="p">,</span> <span class="nx">argp</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">narg</span> <span class="kt">int32</span><span class="p">,</span> <span class="nx">callergp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">callerpc</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="o">*</span><span class="nx">g</span> <span class="p">{</span>
    <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
    <span class="o">...</span>
    <span class="nx">_p_</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
    <span class="c1">// 从 P 的空闲链表中获取一个新的 G
</span><span class="c1"></span>    <span class="nx">newg</span> <span class="o">:=</span> <span class="nf">gfget</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
    <span class="c1">// 获取不到则调用 malg 进行创建
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">newg</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">newg</span> <span class="p">=</span> <span class="nf">malg</span><span class="p">(</span><span class="nx">_StackMin</span><span class="p">)</span>
        <span class="nf">casgstatus</span><span class="p">(</span><span class="nx">newg</span><span class="p">,</span> <span class="nx">_Gidle</span><span class="p">,</span> <span class="nx">_Gdead</span><span class="p">)</span>
        <span class="nf">allgadd</span><span class="p">(</span><span class="nx">newg</span><span class="p">)</span> <span class="c1">// publishes with a g-&gt;status of Gdead so GC scanner doesn&#39;t look at uninitialized stack.
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="nx">newg</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The newproc1 method is very long and it mainly gets G and then does some initialization work on the obtained G. Let&rsquo;s just look at the malg function call here.</p>
<p>When calling the malg function, a minimum stack size value is passed in: _StackMin (2048).</p>
<p><strong>runtime.malg</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">malg</span><span class="p">(</span><span class="nx">stacksize</span> <span class="kt">int32</span><span class="p">)</span> <span class="o">*</span><span class="nx">g</span> <span class="p">{</span>
    <span class="c1">// 创建 G 结构体
</span><span class="c1"></span>    <span class="nx">newg</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">g</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">stacksize</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="c1">// 这里会在 stacksize 的基础上为每个栈预留系统调用所需的内存大小 _StackSystem
</span><span class="c1"></span>        <span class="c1">// 在 Linux/Darwin 上（ _StackSystem == 0 ）本行不改变 stacksize 的大小
</span><span class="c1"></span>        <span class="nx">stacksize</span> <span class="p">=</span> <span class="nf">round2</span><span class="p">(</span><span class="nx">_StackSystem</span> <span class="o">+</span> <span class="nx">stacksize</span><span class="p">)</span>
        <span class="c1">// 切换到 G0 为 newg 初始化栈内存
</span><span class="c1"></span>        <span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">newg</span><span class="p">.</span><span class="nx">stack</span> <span class="p">=</span> <span class="nf">stackalloc</span><span class="p">(</span><span class="nb">uint32</span><span class="p">(</span><span class="nx">stacksize</span><span class="p">))</span>
        <span class="p">})</span>
        <span class="c1">// 设置 stackguard0 ，用来判断是否要进行栈扩容
</span><span class="c1"></span>        <span class="nx">newg</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">newg</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">+</span> <span class="nx">_StackGuard</span>
        <span class="nx">newg</span><span class="p">.</span><span class="nx">stackguard1</span> <span class="p">=</span> <span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> 
        <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">newg</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span><span class="p">))</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">newg</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The call to malg sets aside the incoming memory size plus a _StackSystem value for use by the system call, and the round2 function rounds the incoming value to an exponent of 2. Then it switches to G0 and executes the stackalloc function to allocate the stack memory.</p>
<p>After allocation, stackguard0 is set to <code>stack.lo + _StackGuard</code>, which is used to determine if stack expansion is needed, as discussed below.</p>
<h3 id="initialization-of-the-stack">Initialization of the stack</h3>
<p>File location: src/runtime/stack.go</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Global stack cache, allocating less than 32KB of memory
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">stackpool</span> <span class="p">[</span><span class="nx">_NumStackOrders</span><span class="p">]</span><span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">item</span> <span class="nx">stackpoolItem</span>
    <span class="nx">_</span> <span class="p">[</span><span class="nx">cpu</span><span class="p">.</span><span class="nx">CacheLinePadSize</span> <span class="o">-</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">stackpoolItem</span><span class="p">{})</span><span class="o">%</span><span class="nx">cpu</span><span class="p">.</span><span class="nx">CacheLinePadSize</span><span class="p">]</span><span class="kt">byte</span>
<span class="p">}</span>

<span class="c1">//go:notinheap
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">stackpoolItem</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">mu</span> <span class="nx">mutex</span>
    <span class="nx">span</span> <span class="nx">mSpanList</span>
<span class="p">}</span> 

<span class="c1">// global stack cache, allocating more than 32KB of memory
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">stackLarge</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">lock</span> <span class="nx">mutex</span>
    <span class="nx">free</span> <span class="p">[</span><span class="nx">heapAddrBits</span> <span class="o">-</span> <span class="nx">pageShift</span><span class="p">]</span><span class="nx">mSpanList</span> <span class="c1">// free lists by log_2(s.npages)
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// initialize stackpool/stackLarge global variables
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">stackinit</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">_StackCacheSize</span><span class="o">&amp;</span><span class="nx">_PageMask</span> <span class="p">!</span> <span class="p">=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;cache size must be a multiple of page size&#34;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">stackpool</span> <span class="p">{</span>
        <span class="nx">stackpool</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">item</span><span class="p">.</span><span class="nx">span</span><span class="p">.</span><span class="nf">init</span><span class="p">()</span>
        <span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">stackpool</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">item</span><span class="p">.</span><span class="nx">mu</span><span class="p">,</span> <span class="nx">lockRankStackpool</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">stackLarge</span><span class="p">.</span><span class="nx">free</span> <span class="p">{</span>
        <span class="nx">stackLarge</span><span class="p">.</span><span class="nx">free</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nf">init</span><span class="p">()</span>
        <span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">stackLarge</span><span class="p">.</span><span class="nx">lock</span><span class="p">,</span> <span class="nx">lockRankStackLarge</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Before we do the stack allocation let&rsquo;s take a look at what is done during stack initialization. Note that stackinit is initialized by calling <code>runtime-schedinit</code>, which is done before calling <code>runtime-newproc</code>.</p>
<p>Two global variables, stackpool and stackLarge, are initialized when stack initialization is performed. stackpool can allocate less than 32KB of memory, and stackLarge is used to allocate more than 32KB of stack space.</p>
<h3 id="allocation-of-the-stack">Allocation of the stack</h3>
<p>We also know from the initialization of the two two global variables that the stack will be allocated from different locations depending on the size.</p>
<h4 id="small-stack-memory-allocation">Small stack memory allocation</h4>
<p>File location: src/runtime/stack.go</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">stackalloc</span><span class="p">(</span><span class="nx">n</span> <span class="kt">uint32</span><span class="p">)</span> <span class="nx">stack</span> <span class="p">{</span> 
    <span class="c1">// 这里的 G 是 G0
</span><span class="c1"></span>    <span class="nx">thisg</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
    <span class="o">...</span>
    <span class="kd">var</span> <span class="nx">v</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
    <span class="c1">// 在 Linux 上，_FixedStack = 2048、_NumStackOrders = 4、_StackCacheSize = 32768
</span><span class="c1"></span>    <span class="c1">// 如果申请的栈空间小于 32KB
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nx">_FixedStack</span><span class="o">&lt;&lt;</span><span class="nx">_NumStackOrders</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nx">_StackCacheSize</span> <span class="p">{</span>
        <span class="nx">order</span> <span class="o">:=</span> <span class="nb">uint8</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="nx">n2</span> <span class="o">:=</span> <span class="nx">n</span>
        <span class="c1">// 大于 2048 ,那么 for 循环 将 n2 除 2,直到 n 小于等于 2048
</span><span class="c1"></span>        <span class="k">for</span> <span class="nx">n2</span> <span class="p">&gt;</span> <span class="nx">_FixedStack</span> <span class="p">{</span>
            <span class="c1">// order 表示除了多少次
</span><span class="c1"></span>            <span class="nx">order</span><span class="o">++</span>
            <span class="nx">n2</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
        <span class="p">}</span>
        <span class="kd">var</span> <span class="nx">x</span> <span class="nx">gclinkptr</span>
        <span class="c1">//preemptoff != &#34;&#34;, 在 GC 的时候会进行设置,表示如果在 GC 那么从 stackpool 分配
</span><span class="c1"></span>        <span class="c1">// thisg.m.p = 0 会在系统调用和 改变 P 的个数的时候调用,如果发生,那么也从 stackpool 分配
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">stackNoCache</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">preemptoff</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span> 
            <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">stackpool</span><span class="p">[</span><span class="nx">order</span><span class="p">].</span><span class="nx">item</span><span class="p">.</span><span class="nx">mu</span><span class="p">)</span>
            <span class="c1">// 从 stackpool 分配
</span><span class="c1"></span>            <span class="nx">x</span> <span class="p">=</span> <span class="nf">stackpoolalloc</span><span class="p">(</span><span class="nx">order</span><span class="p">)</span>
            <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">stackpool</span><span class="p">[</span><span class="nx">order</span><span class="p">].</span><span class="nx">item</span><span class="p">.</span><span class="nx">mu</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// 从 P 的 mcache 分配内存
</span><span class="c1"></span>            <span class="nx">c</span> <span class="o">:=</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">mcache</span>
            <span class="nx">x</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">stackcache</span><span class="p">[</span><span class="nx">order</span><span class="p">].</span><span class="nx">list</span>
            <span class="k">if</span> <span class="nx">x</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="c1">// 从堆上申请一片内存空间填充到stackcache中
</span><span class="c1"></span>                <span class="nf">stackcacherefill</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">order</span><span class="p">)</span>
                <span class="nx">x</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">stackcache</span><span class="p">[</span><span class="nx">order</span><span class="p">].</span><span class="nx">list</span>
            <span class="p">}</span>
            <span class="c1">// 移除链表的头节点
</span><span class="c1"></span>            <span class="nx">c</span><span class="p">.</span><span class="nx">stackcache</span><span class="p">[</span><span class="nx">order</span><span class="p">].</span><span class="nx">list</span> <span class="p">=</span> <span class="nx">x</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">next</span>
            <span class="nx">c</span><span class="p">.</span><span class="nx">stackcache</span><span class="p">[</span><span class="nx">order</span><span class="p">].</span><span class="nx">size</span> <span class="o">-=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="c1">// 获取到分配的span内存块
</span><span class="c1"></span>        <span class="nx">v</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="o">...</span>
    <span class="p">}</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="nx">stack</span><span class="p">{</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">v</span><span class="p">),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="o">+</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">n</span><span class="p">)}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>stackalloc will allocate according to the size of the passed parameter n. On Linux, if n is less than 32768 bytes, which is 32KB, then it will enter the allocation logic of small stack.</p>
<p>The small stack refers to the stack size of 2K/4K/8K/16K, and during allocation, different order values will be calculated according to the size, if the stack size is 2K, then the order is 0, 4K corresponds to order 1, and so on. On the one hand, this can reduce the lock conflicts between different Goroutines getting different stack sizes, and on the other hand, the span of the corresponding size can be cached in advance for quick access.</p>
<p><code>thisg.m.p == 0</code> may happen when exitsyscall is called or when the number of P&rsquo;s procresize is changed, <code>thisg.m.preemptoff ! = &quot;&quot;</code> will occur during GC. That is to say, when exitsyscall is called or the number of P&rsquo;s is changed, or when GC occurs, stack space is allocated from stackpool, otherwise it is taken from mcache.</p>
<p>If the stackcache corresponding to mcache is not available, then stackcacherefill is called to request a piece of memory from the heap to fill the stackcache.</p>
<p>The main thing to note is that stackalloc is G0 since it switches to G0 for the call, so thisg is G0.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">stackalloc</span><span class="p">(</span><span class="nx">n</span> <span class="kt">uint32</span><span class="p">)</span> <span class="nx">stack</span> <span class="p">{</span> 
    <span class="nx">thisg</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
    <span class="c1">// 添加一行打印
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">schedtrace</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nb">print</span><span class="p">(</span><span class="s">&#34;stackalloc runtime: gp: gp=&#34;</span><span class="p">,</span> <span class="nx">thisg</span><span class="p">,</span> <span class="s">&#34;, goid=&#34;</span><span class="p">,</span> <span class="nx">thisg</span><span class="p">.</span><span class="nx">goid</span><span class="p">,</span> <span class="s">&#34;, gp-&gt;atomicstatus=&#34;</span><span class="p">,</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">thisg</span><span class="p">),</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Let&rsquo;s look at the stackpoolalloc and stackcacherefill functions separately.</p>
<p><strong>runtime.stackpoolalloc</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">stackpoolalloc</span><span class="p">(</span><span class="nx">order</span> <span class="kt">uint8</span><span class="p">)</span> <span class="nx">gclinkptr</span> <span class="p">{</span>
    <span class="nx">list</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">stackpool</span><span class="p">[</span><span class="nx">order</span><span class="p">].</span><span class="nx">item</span><span class="p">.</span><span class="nx">span</span>
    <span class="nx">s</span> <span class="o">:=</span> <span class="nx">list</span><span class="p">.</span><span class="nx">first</span>
    <span class="nf">lockWithRankMayAcquire</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">lock</span><span class="p">,</span> <span class="nx">lockRankMheap</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="c1">// no free stacks. Allocate another span worth.
</span><span class="c1"></span>        <span class="c1">// 从堆上分配 mspan
</span><span class="c1"></span>        <span class="c1">// _StackCacheSize = 32 * 1024
</span><span class="c1"></span>        <span class="nx">s</span> <span class="p">=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nf">allocManual</span><span class="p">(</span><span class="nx">_StackCacheSize</span><span class="o">&gt;&gt;</span><span class="nx">_PageShift</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">stacks_inuse</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;out of memory&#34;</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="c1">// 刚分配的 span 里面分配对象个数肯定为 0
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad allocCount&#34;</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">manualFreeList</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;bad manualFreeList&#34;</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="c1">//OpenBSD 6.4+ 系统需要做额外处理
</span><span class="c1"></span>        <span class="nf">osStackAlloc</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
        <span class="c1">// Linux 中 _FixedStack = 2048
</span><span class="c1"></span>        <span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span> <span class="p">=</span> <span class="nx">_FixedStack</span> <span class="o">&lt;&lt;</span> <span class="nx">order</span>
        <span class="c1">//_StackCacheSize =  32 * 1024
</span><span class="c1"></span>        <span class="c1">// 这里是将 32KB 大小的内存块分成了elemsize大小块，用单向链表进行连接
</span><span class="c1"></span>        <span class="c1">// 最后 s.manualFreeList 指向的是这块内存的尾部
</span><span class="c1"></span>        <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">_StackCacheSize</span><span class="p">;</span> <span class="nx">i</span> <span class="o">+=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span> <span class="p">{</span>
            <span class="nx">x</span> <span class="o">:=</span> <span class="nf">gclinkptr</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">()</span> <span class="o">+</span> <span class="nx">i</span><span class="p">)</span>
            <span class="nx">x</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">next</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">manualFreeList</span>
            <span class="nx">s</span><span class="p">.</span><span class="nx">manualFreeList</span> <span class="p">=</span> <span class="nx">x</span>
        <span class="p">}</span>
        <span class="c1">// 插入到 list 链表头部
</span><span class="c1"></span>        <span class="nx">list</span><span class="p">.</span><span class="nf">insert</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">x</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">manualFreeList</span>
    <span class="c1">// 代表被分配完毕
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">x</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;span has no free stacks&#34;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// 将 manualFreeList 往后移动一个单位
</span><span class="c1"></span>    <span class="nx">s</span><span class="p">.</span><span class="nx">manualFreeList</span> <span class="p">=</span> <span class="nx">x</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">next</span>
    <span class="c1">// 统计被分配的内存块
</span><span class="c1"></span>    <span class="nx">s</span><span class="p">.</span><span class="nx">allocCount</span><span class="o">++</span>
    <span class="c1">// 因为分配的时候第一个内存块是 nil
</span><span class="c1"></span>    <span class="c1">// 所以当指针为nil 的时候代表被分配完毕
</span><span class="c1"></span>    <span class="c1">// 那么需要将该对象从 list 的头节点移除
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">manualFreeList</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="c1">// all stacks in s are allocated.
</span><span class="c1"></span>        <span class="nx">list</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">x</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>In the stackpoolalloc function will look for the stackpool corresponding to the order subscript of the head node of the span table, if not empty, then directly remove the node pointed to by the attribute manualFreeList of the head node from the linkedlist and return; if <code>list.first</code> is empty, then call mheap_&rsquo;s allocManual function to allocate mspan from the heap.</p>
<p>If <code>list.first</code> is empty, then the allocManual function of mheap_ is called to allocate mspan from the heap.</p>
<p>The allocManual function allocates a 32KB block of memory, and after allocating the new span, it cuts the 32KB memory according to the size of elemsize, and then strings it together in a one-way chain and assigns the last memory address to manualFreeList.</p>
<p>For example, the current elemsize represents a memory size of 8KB.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/22/614b620ace2c4e8caa066ed57b29519a.png" alt="sobyte"></p>
<p><strong>runtime.stackcacherefill</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">stackcacherefill</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">mcache</span><span class="p">,</span> <span class="nx">order</span> <span class="kt">uint8</span><span class="p">)</span> <span class="p">{</span> 
    <span class="kd">var</span> <span class="nx">list</span> <span class="nx">gclinkptr</span>
    <span class="kd">var</span> <span class="nx">size</span> <span class="kt">uintptr</span>
    <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">stackpool</span><span class="p">[</span><span class="nx">order</span><span class="p">].</span><span class="nx">item</span><span class="p">.</span><span class="nx">mu</span><span class="p">)</span>
    <span class="c1">//_StackCacheSize = 32 * 1024
</span><span class="c1"></span>    <span class="c1">// 将 stackpool 分配的内存组成一个单向链表 list
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">size</span> <span class="p">&lt;</span> <span class="nx">_StackCacheSize</span><span class="o">/</span><span class="mi">2</span> <span class="p">{</span>
        <span class="nx">x</span> <span class="o">:=</span> <span class="nf">stackpoolalloc</span><span class="p">(</span><span class="nx">order</span><span class="p">)</span>
        <span class="nx">x</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">next</span> <span class="p">=</span> <span class="nx">list</span>
        <span class="nx">list</span> <span class="p">=</span> <span class="nx">x</span>
        <span class="c1">// _FixedStack = 2048
</span><span class="c1"></span>        <span class="nx">size</span> <span class="o">+=</span> <span class="nx">_FixedStack</span> <span class="o">&lt;&lt;</span> <span class="nx">order</span>
    <span class="p">}</span>
    <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">stackpool</span><span class="p">[</span><span class="nx">order</span><span class="p">].</span><span class="nx">item</span><span class="p">.</span><span class="nx">mu</span><span class="p">)</span>
    <span class="nx">c</span><span class="p">.</span><span class="nx">stackcache</span><span class="p">[</span><span class="nx">order</span><span class="p">].</span><span class="nx">list</span> <span class="p">=</span> <span class="nx">list</span>
    <span class="nx">c</span><span class="p">.</span><span class="nx">stackcache</span><span class="p">[</span><span class="nx">order</span><span class="p">].</span><span class="nx">size</span> <span class="p">=</span> <span class="nx">size</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The stackcacherefill function will call stackpoolalloc to get half of the space from the stackpool and assemble it into a list chain, then put it into the stackcache array.</p>
<h4 id="large-stack-memory-allocation">Large Stack Memory Allocation</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">stackalloc</span><span class="p">(</span><span class="nx">n</span> <span class="kt">uint32</span><span class="p">)</span> <span class="nx">stack</span> <span class="p">{</span> 
    <span class="nx">thisg</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span> 
    <span class="kd">var</span> <span class="nx">v</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>

    <span class="k">if</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nx">_FixedStack</span><span class="o">&lt;&lt;</span><span class="nx">_NumStackOrders</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nx">_StackCacheSize</span> <span class="p">{</span>
        <span class="o">...</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// 申请的内存空间过大，从 runtime.stackLarge 中检查是否有剩余的空间
</span><span class="c1"></span>        <span class="kd">var</span> <span class="nx">s</span> <span class="o">*</span><span class="nx">mspan</span>
        <span class="c1">// 计算需要分配多少个 span 页， 8KB 为一页
</span><span class="c1"></span>        <span class="nx">npage</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="nx">_PageShift</span>
        <span class="c1">// 计算 npage 能够被2整除几次，用来作为不同大小内存的块的索引
</span><span class="c1"></span>        <span class="nx">log2npage</span> <span class="o">:=</span> <span class="nf">stacklog2</span><span class="p">(</span><span class="nx">npage</span><span class="p">)</span>

        <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">stackLarge</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
        <span class="c1">// 如果 stackLarge 对应的链表不为空
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">!</span><span class="nx">stackLarge</span><span class="p">.</span><span class="nx">free</span><span class="p">[</span><span class="nx">log2npage</span><span class="p">].</span><span class="nf">isEmpty</span><span class="p">()</span> <span class="p">{</span>
            <span class="c1">//获取链表的头节点，并将其从链表中移除
</span><span class="c1"></span>            <span class="nx">s</span> <span class="p">=</span> <span class="nx">stackLarge</span><span class="p">.</span><span class="nx">free</span><span class="p">[</span><span class="nx">log2npage</span><span class="p">].</span><span class="nx">first</span>
            <span class="nx">stackLarge</span><span class="p">.</span><span class="nx">free</span><span class="p">[</span><span class="nx">log2npage</span><span class="p">].</span><span class="nf">remove</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">stackLarge</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

        <span class="nf">lockWithRankMayAcquire</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">mheap_</span><span class="p">.</span><span class="nx">lock</span><span class="p">,</span> <span class="nx">lockRankMheap</span><span class="p">)</span>
        <span class="c1">//这里是stackLarge为空的情况
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="c1">// 从堆上申请新的内存 span
</span><span class="c1"></span>            <span class="nx">s</span> <span class="p">=</span> <span class="nx">mheap_</span><span class="p">.</span><span class="nf">allocManual</span><span class="p">(</span><span class="nx">npage</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">stacks_inuse</span><span class="p">)</span>
            <span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;out of memory&#34;</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="c1">// OpenBSD 6.4+ 系统需要做额外处理
</span><span class="c1"></span>            <span class="nf">osStackAlloc</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
            <span class="nx">s</span><span class="p">.</span><span class="nx">elemsize</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">v</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nf">base</span><span class="p">())</span>
    <span class="p">}</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="nx">stack</span><span class="p">{</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">v</span><span class="p">),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="o">+</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">n</span><span class="p">)}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>For large stack memory allocation, the runtime will check if there is any space left in stackLarge, and if there is no space left, it will also call <code>mheap_.allocManual</code> to request new memory from the heap.</p>
<h3 id="stack-expansion">Stack expansion</h3>
<h4 id="stack-overflow-detection">Stack overflow detection</h4>
<p>The compiler will execute: src/cmd/internal/obj/x86/obj6.go:stacksplit at the time of target code generation to check if the current goroutine has enough stack space by inserting the appropriate instructions based on the function stack frame size.</p>
<ol>
<li>when the stack frame size (FramSzie) is less than or equal to StackSmall (128), if SP <strong>is less than</strong> stackguard0 then perform stack expansion.</li>
<li>when the stack frame size (FramSzie) is larger than StackSmall (128), the stack is expanded according to the formula <code>SP - FramSzie + StackSmall</code> compared to stackguard0, if <strong>is smaller than</strong> stackguard0 then the expansion is performed.</li>
<li>When the stack frame size (FramSzie) is larger than StackBig (4096), it will first check whether stackguard0 has been converted to StackPreempt state; then it will perform expansion according to the formula <code>SP - stackguard0 + StackGuard &lt;= framesize + (StackGuard- StackSmall)</code> and if it is true, then perform the expansion.</li>
</ol>
<p>Let&rsquo;s take a look at the <strong>pseudo-code</strong> which will make it a bit clearer.</p>
<p><strong>When the stack frame size (FramSzie) is less than or equal to StackSmall (128)</strong>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">CMPQ SP, stackguard
JEQ label-of-call-to-morestack
</code></pre></td></tr></table>
</div>
</div><p>When the stack frame size (FramSzie) is larger than StackSmall (128).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">LEAQ -xxx<span class="o">(</span>SP<span class="o">)</span>, AX 
CMPQ AX, stackguard
JEQ label-of-call-to-morestack
</code></pre></td></tr></table>
</div>
</div><p>where AX = SP - framesize + StackSmall and then the CMPQ instruction is executed to make AX compare with stackguard.</p>
<p><strong>When the stack frame size (FramSzie) is larger than StackBig (4096)</strong>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">MOVQ    stackguard, SI // <span class="nv">SI</span> <span class="o">=</span> stackguard
CMPQ    SI, <span class="nv">$StackPreempt</span> // compare SI ,StackPreempt
JEQ label-of-call-to-morestack
LEAQ    StackGuard<span class="o">(</span>SP<span class="o">)</span>, AX // <span class="nv">AX</span> <span class="o">=</span> SP + StackGuard
SUBQ    SI, AX // <span class="nv">AX</span> <span class="o">=</span> AX - <span class="nv">SI</span> <span class="o">=</span>  SP + StackGuard -stackguard
CMPQ    AX, <span class="k">$(</span>framesize+<span class="o">(</span>StackGuard-StackSmall<span class="k">)</span><span class="o">)</span>
</code></pre></td></tr></table>
</div>
</div><p>The pseudo-code here will be relatively complicated, as the stackguard0 inside G may be assigned to StackPreempt when it is preempted, so it is clear whether it is preempted or not, then it is necessary to compare stackguard0 with StackPreempt. Then the comparison will be performed: <code>SP-stackguard+StackGuard &lt;= framesize + (StackGuard-StackSmall)</code>, with StackGuard added on both sides to ensure that the value on the left is positive.</p>
<p>I hope you don&rsquo;t read further until you understand the above code.</p>
<p>The main thing to note is that in some functions, the compiler intelligently adds the <code>NOSPLIT</code> flag, which disables stack overflow detection after hitting this flag, which can be found in the following code.</p>
<p>Code location: cmd/internal/obj/x86/obj6.go</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">...
    <span class="k">if</span> ctxt.Arch.Family <span class="o">==</span> sys.AMD64 <span class="o">&amp;&amp;</span> autoffset &lt; objabi.StackSmall <span class="o">&amp;&amp;</span> !p.From.Sym.NoSplit<span class="o">()</span> <span class="o">{</span>
        leaf :<span class="o">=</span> <span class="nb">true</span>
    LeafSearch:
        <span class="k">for</span> q :<span class="o">=</span> p<span class="p">;</span> q !<span class="o">=</span> nil<span class="p">;</span> <span class="nv">q</span> <span class="o">=</span> q.Link <span class="o">{</span>
            ...
        <span class="o">}</span>

        <span class="k">if</span> leaf <span class="o">{</span>
            p.From.Sym.Set<span class="o">(</span>obj.AttrNoSplit, <span class="nb">true</span><span class="o">)</span>
        <span class="o">}</span>
    <span class="o">}</span>
...
</code></pre></td></tr></table>
</div>
</div><p>The general code logic should be: when the function is at a leaf node of the call chain and the stack frame is smaller than StackSmall bytes, it is automatically marked as NOSPLIT. similarly, we can write the code ourselves by adding <code>//go:nosplit</code> to the function to force the NOSPLIT attribute.</p>
<p><strong>Stack overflow example</strong></p>
<p>Here we write a simple example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>
    <span class="nx">_</span> <span class="p">=</span> <span class="nf">add1</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
    <span class="nx">_</span> <span class="p">=</span> <span class="nf">add2</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
    <span class="nx">_</span> <span class="p">=</span> <span class="nf">add3</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">add1</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="nx">_</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">add2</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="nx">_</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">add3</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="nx">_</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">5000</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Then print out its assembly:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="err">$</span> <span class="nx">GOOS</span><span class="p">=</span><span class="nx">linux</span> <span class="nx">GOARCH</span><span class="p">=</span><span class="nx">amd64</span> <span class="k">go</span> <span class="nx">tool</span> <span class="nx">compile</span> <span class="o">-</span><span class="nx">S</span> <span class="o">-</span><span class="nx">N</span> <span class="o">-</span><span class="nx">l</span> <span class="nx">main</span><span class="p">.</span><span class="k">go</span>
</code></pre></td></tr></table>
</div>
</div><p>The example above explains the three cases described above in three method calls.</p>
<p><strong>main function</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">        0x0000 00000 (main.go:3)        TEXT    &#34;&#34;.main(SB), ABIInternal, $48-0
        0x0000 00000 (main.go:3)        MOVQ    (TLS), CX 
        0x0009 00009 (main.go:3)        CMPQ    SP, 16(CX) // SP &lt; stackguard 则跳到 129执行
        0x0009 00009 (main.go:3)        CMPQ    SP, 16(CX)
        0x000d 00013 (main.go:3)        PCDATA  $0, $-2
        0x000d 00013 (main.go:3)        JLS     129
        ... 
        0x0081 00129 (main.go:3)        CALL    runtime.morestack_noctxt(SB)
</code></pre></td></tr></table>
</div>
</div><p>First, we load a value from the TLS (thread local storage) variable into the CX register, and then compare the SP with 16(CX), so what is TLS and what does 16(CX) stand for?</p>
<p>Actually, <code>TLS</code> is a pseudo-register that represents the thread-local storage, which holds the G structure. Let&rsquo;s take a look at the definition of G in the runtime source code.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">g</span> <span class="kd">struct</span> <span class="p">{</span> 
    <span class="nx">stack</span>       <span class="nx">stack</span>   <span class="c1">// offset known to runtime/cgo
</span><span class="c1"></span>    <span class="nx">stackguard0</span> <span class="kt">uintptr</span> <span class="c1">// offset known to liblink
</span><span class="c1"></span>    <span class="o">...</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">stack</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">lo</span> <span class="kt">uintptr</span>
    <span class="nx">hi</span> <span class="kt">uintptr</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>You can see that the stack takes up 16bytes, so <code>16(CX)</code> corresponds to <code>g.stackguard0</code>. So the <code>CMPQ SP, 16(CX)</code> line of code actually compares the SP and stackguard sizes. If the SP is smaller than the stackguard, then the growth threshold is reached and JLS will be executed to jump to line 129 and call runtime.morestack_noctxt to perform the next stack expansion operation.</p>
<p><strong>add1</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">        0x0000 00000 (main.go:10)       TEXT    &#34;&#34;.add1(SB), NOSPLIT|ABIInternal, $32-24
</code></pre></td></tr></table>
</div>
</div><p>When we look at the add1 assembly function, we can see that its stack size is only 32, which does not reach the StackSmall 128 bytes size, and it is a callee caller, so we can send it with the <code>NOSPLIT</code> flag, which confirms my conclusion above.</p>
<p><strong>add2</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">&#34;&#34;.add2 STEXT size=148 args=0x18 locals=0xd0
        0x0000 00000 (main.go:15)       TEXT    &#34;&#34;.add2(SB), ABIInternal, $208-24
        0x0000 00000 (main.go:15)       MOVQ    (TLS), CX
        // AX = SP  - 208 + 128 = SP -80
        0x0009 00009 (main.go:15)       LEAQ    -80(SP), AX // 栈大小大于StackSmall =128, 计算 SP - FramSzie + StackSmall 并放入AX寄存器                         
        0x000e 00014 (main.go:15)       CMPQ    AX, 16(CX) // AX &lt; stackguard 则跳到 138 执行
        0x0012 00018 (main.go:15)       PCDATA  $0, $-2
        0x0012 00018 (main.go:15)       JLS     138
        ...
        0x008a 00138 (main.go:15)       CALL    runtime.morestack_noctxt(SB)
</code></pre></td></tr></table>
</div>
</div><p>The stack frame size of add2 function is 208, which is larger than StackSmall 128 bytes, so you can see that it first loads a value from the TLS variable to the CX register.</p>
<p>Then execute the instruction <code>LEAQ -80(SP), AX</code>, but the reason why it is -80 actually made me quite confused at that time, but it should be noted that the formula here is: <code>SP - FramSzie + StackSmall</code>, after directly substituting it, you will find that it is -80, and then load this value into the AX register.</p>
<p>Finally call <code>CMPQ AX, 16(CX)</code> , 16(CX) we have already talked about above is equal to stackguard0, so here is a comparison between AX and stackguard0 of small and large, if less than then directly jump to line 138 to execute <code>runtime.morestack_noctxt</code>.</p>
<p><strong>add3</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">&#34;&#34;.add3 STEXT size=157 args=0x18 locals=0x1390
        0x0000 00000 (main.go:20)       TEXT    &#34;&#34;.add3(SB), ABIInternal, $5008-24
        0x0000 00000 (main.go:20)       MOVQ    (TLS), CX 
        0x0009 00009 (main.go:20)       MOVQ    16(CX), SI // 将 stackguard 赋值给  SI
        0x000d 00013 (main.go:20)       PCDATA  $0, $-2 
        0x000d 00013 (main.go:20)       CMPQ    SI, $-1314 // 将 stackguard &lt; stackPreempt 则跳转到 147 执行
        0x0014 00020 (main.go:20)       JEQ     147 
        0x0016 00022 (main.go:20)       LEAQ    928(SP), AX // AX = SP +928
        0x001e 00030 (main.go:20)       SUBQ    SI, AX // AX -= stackguard
        0x0021 00033 (main.go:20)       CMPQ    AX, $5808 // framesize + 928 -128  = 5808,比较 AX &lt; 5808,则执行147
        0x0027 00039 (main.go:20)       JLS     147
        ...
        0x0093 00147 (main.go:20)       CALL    runtime.morestack_noctxt(SB)
</code></pre></td></tr></table>
</div>
</div><p>The add3 function directly allocates an array of 5000 bytes on the stack, so it starts the same way, loading a value from the TLS variable into the CX register and then assigning stackguard0 to the SI register.</p>
<p>Next, the instruction <code>CMPQ SI, $-1314</code> will be executed, which actually compares the size of stackguard0 and StackPreempt, and the reason why it is -1314 is that the StackPreempt variable is called directly when the assembly code is inserted, and this variable is written inside the code.</p>
<p>Code location: cmd/internal/objabi/stack.go</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">const (
    StackPreempt = -1314 // 0xfff...fade
)
</code></pre></td></tr></table>
</div>
</div><p>If it is not preempted, then go straight down to <code>LEAQ 928(SP), AX</code>, which is equivalent to <code>AX = SP +_StackGuard</code>, and _StackGuard is equivalent to 928 in Linux.</p>
<p>Next execute <code>SUBQ SI, AX</code>, which is equal to <code>AX -= stackguard0</code>.</p>
<p>Finally <code>CMPQ AX, $5808</code>, the 5808 is actually <code>framesize + _StackGuard - _StackSmall</code>, if AX is less than 5808 then jump to line 147 and execute the runtime.morestack_noctxt function.</p>
<p>This is the end of stack overflow detection, I&rsquo;ve read other articles and I don&rsquo;t think any of them are as comprehensive as mine, especially when the stack frame size is larger than _StackBig.</p>
<h4 id="stack-expansion-1">Stack expansion</h4>
<p>runtime.morestack_noctxt is implemented in assembly and it calls to runtime-morestack, let&rsquo;s see its implementation as follows.</p>
<p>Code location: src/runtime/asm_amd64.s</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">TEXT runtime·morestack(SB),NOSPLIT,$0-0
    // Cannot grow scheduler stack (m-&gt;g0).
    // 无法增长调度器的栈(m-&gt;g0)
    get_tls(CX)
    MOVQ    g(CX), BX
    MOVQ    g_m(BX), BX
    MOVQ    m_g0(BX), SI
    CMPQ    g(CX), SI
    JNE 3(PC)
    CALL    runtime·badmorestackg0(SB)
    CALL    runtime·abort(SB)
    // 省略signal stack、morebuf和sched的处理
    ...
    // Call newstack on m-&gt;g0&#39;s stack.
    // 在 m-&gt;g0 栈上调用 newstack.
    MOVQ    m_g0(BX), BX
    MOVQ    BX, g(CX)
    MOVQ    (g_sched+gobuf_sp)(BX), SP
    CALL    runtime·newstack(SB)
    CALL    runtime·abort(SB)   // 如果 newstack 返回则崩溃 crash if newstack returns
    RET
</code></pre></td></tr></table>
</div>
</div><p>After runtime-morestack does the checksum assignment, it switches to G0 and calls <code>runtime-newstack</code> to finish the expansion operation.</p>
<p><strong>runtime-newstack</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">func newstack() {
    thisg := getg() 

    gp := thisg.m.curg

    // 初始化寄存器相关变量
    morebuf := thisg.m.morebuf
    thisg.m.morebuf.pc = 0
    thisg.m.morebuf.lr = 0
    thisg.m.morebuf.sp = 0
    thisg.m.morebuf.g = 0
    ...
    // 校验是否被抢占
    preempt := atomic.Loaduintptr(&amp;gp.stackguard0) == stackPreempt

    // 如果被抢占
    if preempt {
        // 校验是否可以安全的被抢占
        // 如果 M 上有锁
        // 如果正在进行内存分配
        // 如果明确禁止抢占
        // 如果 P 的状态不是 running
        // 那么就不执行抢占了
        if !canPreemptM(thisg.m) {
            // 到这里表示不能被抢占？
            // Let the goroutine keep running for now.
            // gp-&gt;preempt is set, so it will be preempted next time.
            gp.stackguard0 = gp.stack.lo + _StackGuard
            // 触发调度器的调度
            gogo(&amp;gp.sched) // never return
        }
    }

    if gp.stack.lo == 0 {
        throw(&#34;missing stack in newstack&#34;)
    }
    // 寄存器 sp
    sp := gp.sched.sp
    if sys.ArchFamily == sys.AMD64 || sys.ArchFamily == sys.I386 || sys.ArchFamily == sys.WASM {
        // The call to morestack cost a word.
        sp -= sys.PtrSize
    } 
    ...
    if preempt {
        //需要收缩栈
        if gp.preemptShrink { 
            gp.preemptShrink = false
            shrinkstack(gp)
        }
        // 被 runtime.suspendG 函数挂起
        if gp.preemptStop {
            // 被动让出当前处理器的控制权
            preemptPark(gp) // never returns
        }

        //主动让出当前处理器的控制权
        gopreempt_m(gp) // never return
    }

    // 计算新的栈空间是原来的两倍
    oldsize := gp.stack.hi - gp.stack.lo
    newsize := oldsize * 2 
    ... 
    //将 Goroutine 切换至 _Gcopystack 状态
    casgstatus(gp, _Grunning, _Gcopystack)

    //开始栈拷贝
    copystack(gp, newsize) 
    casgstatus(gp, _Gcopystack, _Grunning)
    gogo(&amp;gp.sched)
}
</code></pre></td></tr></table>
</div>
</div><p>The first half of the newstack function takes on the task of preempting the Goroutine.</p>
<p>The new stack is calculated to be twice the size of the original before starting the stack copy, and then the Goroutine state is switched to the _Gcopystack state.</p>
<h4 id="stack-copy">Stack Copy</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">copystack</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">newsize</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span> 
    <span class="nx">old</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span> 
    <span class="c1">// 当前已使用的栈空间大小
</span><span class="c1"></span>    <span class="nx">used</span> <span class="o">:=</span> <span class="nx">old</span><span class="p">.</span><span class="nx">hi</span> <span class="o">-</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sp</span>

    <span class="c1">//分配新的栈空间
</span><span class="c1"></span>    <span class="nx">new</span> <span class="o">:=</span> <span class="nf">stackalloc</span><span class="p">(</span><span class="nb">uint32</span><span class="p">(</span><span class="nx">newsize</span><span class="p">))</span>
    <span class="o">...</span>

    <span class="c1">// 计算调整的幅度
</span><span class="c1"></span>    <span class="kd">var</span> <span class="nx">adjinfo</span> <span class="nx">adjustinfo</span>
    <span class="nx">adjinfo</span><span class="p">.</span><span class="nx">old</span> <span class="p">=</span> <span class="nx">old</span>
    <span class="c1">// 新栈和旧栈的幅度来控制指针的移动
</span><span class="c1"></span>    <span class="nx">adjinfo</span><span class="p">.</span><span class="nx">delta</span> <span class="p">=</span> <span class="nx">new</span><span class="p">.</span><span class="nx">hi</span> <span class="o">-</span> <span class="nx">old</span><span class="p">.</span><span class="nx">hi</span>

    <span class="c1">// 调整 sudogs, 必要时与 channel 操作同步
</span><span class="c1"></span>    <span class="nx">ncopy</span> <span class="o">:=</span> <span class="nx">used</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">gp</span><span class="p">.</span><span class="nx">activeStackChans</span> <span class="p">{</span>
        <span class="o">...</span>
        <span class="nf">adjustsudogs</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">adjinfo</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// 到这里代表有被阻塞的 G 在当前 G 的channel 中，所以要防止并发操作，需要获取 channel 的锁
</span><span class="c1"></span>
        <span class="c1">// 在所有 sudog 中找到地址最大的指针
</span><span class="c1"></span>        <span class="nx">adjinfo</span><span class="p">.</span><span class="nx">sghi</span> <span class="p">=</span> <span class="nf">findsghi</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">old</span><span class="p">)</span> 
        <span class="c1">// 对所有 sudog 关联的 channel 上锁，然后调整指针，并且复制 sudog 指向的部分旧栈的数据到新的栈上
</span><span class="c1"></span>        <span class="nx">ncopy</span> <span class="o">-=</span> <span class="nf">syncadjustsudogs</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">used</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">adjinfo</span><span class="p">)</span>
    <span class="p">}</span> 
    <span class="c1">// 将源栈中的整片内存拷贝到新的栈中
</span><span class="c1"></span>    <span class="nf">memmove</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">new</span><span class="p">.</span><span class="nx">hi</span><span class="o">-</span><span class="nx">ncopy</span><span class="p">),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">old</span><span class="p">.</span><span class="nx">hi</span><span class="o">-</span><span class="nx">ncopy</span><span class="p">),</span> <span class="nx">ncopy</span><span class="p">)</span>
    <span class="c1">// 继续调整栈中 txt、defer、panic 位置的指针
</span><span class="c1"></span>    <span class="nf">adjustctxt</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">adjinfo</span><span class="p">)</span>
    <span class="nf">adjustdefers</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">adjinfo</span><span class="p">)</span>
    <span class="nf">adjustpanics</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">adjinfo</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">adjinfo</span><span class="p">.</span><span class="nx">sghi</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">adjinfo</span><span class="p">.</span><span class="nx">sghi</span> <span class="o">+=</span> <span class="nx">adjinfo</span><span class="p">.</span><span class="nx">delta</span>
    <span class="p">}</span> 
    <span class="c1">// 将 G 上的栈引用切换成新栈
</span><span class="c1"></span>    <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span> <span class="p">=</span> <span class="nx">new</span>
    <span class="nx">gp</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">new</span><span class="p">.</span><span class="nx">lo</span> <span class="o">+</span> <span class="nx">_StackGuard</span> <span class="c1">// NOTE: might clobber a preempt request
</span><span class="c1"></span>    <span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sp</span> <span class="p">=</span> <span class="nx">new</span><span class="p">.</span><span class="nx">hi</span> <span class="o">-</span> <span class="nx">used</span>
    <span class="nx">gp</span><span class="p">.</span><span class="nx">stktopsp</span> <span class="o">+=</span> <span class="nx">adjinfo</span><span class="p">.</span><span class="nx">delta</span>

    <span class="c1">// 在新栈重调整指针
</span><span class="c1"></span>    <span class="nf">gentraceback</span><span class="p">(^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">gp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="mh">0x7fffffff</span><span class="p">,</span> <span class="nx">adjustframe</span><span class="p">,</span> <span class="nf">noescape</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">adjinfo</span><span class="p">)),</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="nx">stackPoisonCopy</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nf">fillstack</span><span class="p">(</span><span class="nx">old</span><span class="p">,</span> <span class="mh">0xfc</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">//释放原始栈的内存空间
</span><span class="c1"></span>    <span class="nf">stackfree</span><span class="p">(</span><span class="nx">old</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>
<p>copystack first calculates the size of the used stack space, then only the used space is copied when the stack copy is made.</p>
</li>
<li>
<p>then call the stackalloc function to allocate a block of memory from the heap.</p>
</li>
<li>
<p>then compare the value of hi of the old and new stack to calculate the difference between the two blocks of memory delta, this delta will be called when adjustsudogs, adjustctxt and other functions to determine the location of the old stack memory pointer, then add delta and then get the location of the new stack pointer, so that you can also adjust the pointer to the new stack.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/22/ccd96d753e5a482faed3c5bbe2cd0786.png" alt="sobyte"></p>
</li>
<li>
<p>call memmove to copy the entire slice of memory from the source stack to the new stack.</p>
</li>
<li>
<p>then continue to call the function that adjusts the pointers to continue to adjust the pointers to the txt, defer, and panic locations on the stack.</p>
</li>
<li>
<p>next switch the stack reference on G to the new stack.</p>
</li>
<li>
<p>finally call stackfree to free the memory space of the original stack.</p>
</li>
</ol>
<h3 id="stack-shrinkage">Stack shrinkage</h3>
<p>Stack shrinkage occurs during the phase when the stack is scanned during GC.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">scanstack</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">gcw</span> <span class="o">*</span><span class="nx">gcWork</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">...</span> 
    <span class="c1">// 进行栈收缩
</span><span class="c1"></span>    <span class="nf">shrinkstack</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>runtime.shrinkstack</strong></p>
<p>shrinkstack This function I blocked some checksum functions, leaving only the core logic of the surface.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">shrinkstack</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="nx">oldsize</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span> <span class="o">-</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span>
    <span class="nx">newsize</span> <span class="o">:=</span> <span class="nx">oldsize</span> <span class="o">/</span> <span class="mi">2</span> 
    <span class="c1">// 当收缩后的大小小于最小的栈的大小时，不再进行收缩
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">newsize</span> <span class="p">&lt;</span> <span class="nx">_FixedStack</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="nx">avail</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span> <span class="o">-</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span>
    <span class="c1">// 计算当前正在使用的栈数量，如果 gp 使用的当前栈少于四分之一，则对栈进行收缩
</span><span class="c1"></span>    <span class="c1">// 当前使用的栈包括到 SP 的所有内容以及栈保护空间，以确保有 nosplit 功能的空间
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">used</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span> <span class="o">-</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sp</span> <span class="o">+</span> <span class="nx">_StackLimit</span><span class="p">;</span> <span class="nx">used</span> <span class="o">&gt;=</span> <span class="nx">avail</span><span class="o">/</span><span class="mi">4</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="c1">// 将旧栈拷贝到新收缩后的栈上
</span><span class="c1"></span>    <span class="nf">copystack</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">newsize</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The new stack is reduced to half its original size, and if it is smaller than _FixedStack (2KB) then it is not shrunk. It also calculates if the current stack is used by less than 1/4, and does not shrink if it is used by more than 1/4.</p>
<p>Finally, if it is determined that the stack is to be shrunk, the copystack function is called to perform the stack copy logic.</p>
<h2 id="summary">Summary</h2>
<p>If you don&rsquo;t know the memory layout, it may be difficult to understand it, because when we look at the heap, the memory grows from small to large, while the stack grows in the opposite direction, which causes the stack instruction to decrease the SP instead of increasing the stack frame.</p>
<p>In addition, Go uses plan9 assembly, which is a little bit less informative and seems to be a lot of trouble.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/golang/">golang</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-01/go-runtime/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">How to compile and debug Go runtime source code</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-01/go-func-call/">
            <span class="next-text nav-default">Understanding Go function calls from the stack</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
