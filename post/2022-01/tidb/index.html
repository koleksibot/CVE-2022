<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>What can we learn from TiDB? - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="What is TiDB TiDB is an open source distributed relational database designed and developed by PingCAP, which is a converged distributed database product that supports both Online Transaction Processing and Online Analytical Processing (HTAP).
Five core features   One-click horizontal scaling or shrinking: On-demand online scaling or shrinking of compute and storage respectively, transparent to application operators and maintenance personnel during scaling or shrinking.
  Financial High Availability: Data replicas are synchronized with transaction logs via Multi-Raft protocol, and only commits when most transactions are written successfully, ensuring strong data consistency and not affecting data availability when a few replicas fail." /><meta name="keywords" content="tidb" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-01/tidb/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="What can we learn from TiDB?" />
<meta property="og:description" content="What is TiDB TiDB is an open source distributed relational database designed and developed by PingCAP, which is a converged distributed database product that supports both Online Transaction Processing and Online Analytical Processing (HTAP).
Five core features   One-click horizontal scaling or shrinking: On-demand online scaling or shrinking of compute and storage respectively, transparent to application operators and maintenance personnel during scaling or shrinking.
  Financial High Availability: Data replicas are synchronized with transaction logs via Multi-Raft protocol, and only commits when most transactions are written successfully, ensuring strong data consistency and not affecting data availability when a few replicas fail." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-01/tidb/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-01-23T11:34:54+08:00" />
<meta property="article:modified_time" content="2022-01-23T11:34:54+08:00" />

<meta itemprop="name" content="What can we learn from TiDB?">
<meta itemprop="description" content="What is TiDB TiDB is an open source distributed relational database designed and developed by PingCAP, which is a converged distributed database product that supports both Online Transaction Processing and Online Analytical Processing (HTAP).
Five core features   One-click horizontal scaling or shrinking: On-demand online scaling or shrinking of compute and storage respectively, transparent to application operators and maintenance personnel during scaling or shrinking.
  Financial High Availability: Data replicas are synchronized with transaction logs via Multi-Raft protocol, and only commits when most transactions are written successfully, ensuring strong data consistency and not affecting data availability when a few replicas fail."><meta itemprop="datePublished" content="2022-01-23T11:34:54+08:00" />
<meta itemprop="dateModified" content="2022-01-23T11:34:54+08:00" />
<meta itemprop="wordCount" content="3185">
<meta itemprop="keywords" content="tidb," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="What can we learn from TiDB?"/>
<meta name="twitter:description" content="What is TiDB TiDB is an open source distributed relational database designed and developed by PingCAP, which is a converged distributed database product that supports both Online Transaction Processing and Online Analytical Processing (HTAP).
Five core features   One-click horizontal scaling or shrinking: On-demand online scaling or shrinking of compute and storage respectively, transparent to application operators and maintenance personnel during scaling or shrinking.
  Financial High Availability: Data replicas are synchronized with transaction logs via Multi-Raft protocol, and only commits when most transactions are written successfully, ensuring strong data consistency and not affecting data availability when a few replicas fail."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">What can we learn from TiDB?</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-01-23 11:34:54 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 3185 words </span>
          <span class="more-meta"> 15 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#what-is-tidb">What is TiDB</a>
          <ul>
            <li><a href="#five-core-features">Five core features</a></li>
            <li><a href="#architecture-analysis">Architecture Analysis</a></li>
          </ul>
        </li>
        <li><a href="#sql-execution-process">SQL execution process</a>
          <ul>
            <li><a href="#building-ast-syntax-tree">Building AST syntax tree</a></li>
            <li><a href="#build-the-execution-plan">Build the execution plan</a></li>
          </ul>
        </li>
        <li><a href="#transactions">Transactions</a>
          <ul>
            <li><a href="#percolator-distributed-transactions">Percolator Distributed Transactions</a></li>
            <li><a href="#tidb-two-phase-commit-transaction">TiDB two-phase commit transaction</a></li>
          </ul>
        </li>
        <li><a href="#storage-of-data">Storage of data</a></li>
        <li><a href="#cluster-availability--data-consistency-assurance">Cluster Availability &amp; Data Consistency Assurance</a></li>
        <li><a href="#key-value-mapping-data">Key-Value Mapping Data</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="what-is-tidb">What is TiDB</h2>
<p>TiDB is an open source distributed relational database designed and developed by PingCAP, which is a converged distributed database product that supports both <strong>Online Transaction Processing and Online Analytical Processing</strong> (HTAP).</p>
<h3 id="five-core-features">Five core features</h3>
<ul>
<li>
<p>One-click horizontal scaling or shrinking: On-demand online scaling or shrinking of compute and storage respectively, transparent to application operators and maintenance personnel during scaling or shrinking.</p>
</li>
<li>
<p>Financial High Availability: Data replicas are synchronized with transaction logs via Multi-Raft protocol, and only commits when most transactions are written successfully, ensuring strong data consistency and not affecting data availability when a few replicas fail.</p>
</li>
<li>
<p>Real-time HTAP: Provides row storage engine <a href="https://docs.pingcap.com/zh/tidb/stable/tikv-overview">TiKV</a>, column storage engine <a href="https://docs.pingcap.com/zh/tidb/">TiFlash</a> stable/tiflash-overview), TiFlash replicates data from TiKV in real time via Multi-Raft Learner protocol to ensure strong data consistency between TiKV, the row storage engine, and TiFlash, the column storage engine.</p>
</li>
<li>
<p>Cloud-native distributed database: enables tooling and automation of deployment in public, private, and hybrid clouds.</p>
</li>
<li>
<p>Compatible with MySQL 5.7 protocol and MySQL ecosystem: applications can migrate from MySQL to TiDB with no or little code changes.</p>
<blockquote>
<p>Provide rich <a href="https://docs.pingcap.com/zh/tidb/stable/ecosystem-tool-user-guide">data migration tools</a> to help applications complete data migration easily.</p>
</blockquote>
</li>
</ul>
<h3 id="architecture-analysis">Architecture Analysis</h3>
<p>In terms of kernel design, TiDB distributed database splits the overall architecture into several modules, and each module communicates with each other to form a complete TiDB system. The corresponding architecture diagram is as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/23/d50d5a9cf1c8448d90c7914ece24010a.png" alt="sobyte"></p>
<ul>
<li>TiDB Server: The SQL layer, exposing the connection endpoint of MySQL protocol, is responsible for accepting connections from clients, <strong>performing SQL parsing and optimization</strong>, and finally generating distributed execution plans. or TiFlash).</li>
<li>PD (Placement Driver) Server: The meta information management module of the whole TiDB cluster, responsible for storing the real-time data distribution of each TiKV node and the overall topology of the cluster, providing TiDB Dashboard control interface, and assigning transaction IDs to distributed transactions.</li>
<li>TiKV Server, the storage node, is responsible for storing data. Externally, TiKV is a distributed Key-Value storage engine that provides transactions. The basic unit for storing data is Region, each Region is responsible for storing data in a Key Range (left-closed right-open interval from StartKey to EndKey), and each TiKV node is responsible for multiple Regions.</li>
</ul>
<h2 id="sql-execution-process">SQL execution process</h2>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/23/5ffcac962a6d4ab88c1e02c97aba255a.png" alt="sobyte"></p>
<p>The whole SQL execution process consists of the following parts.</p>
<ul>
<li>Parser &amp; validator: parsing the text into structured data, i.e. Abstract Syntax Tree (AST), and then validating the legitimacy of the AST.</li>
<li>Logical Optimize: apply some optimization rules to the input logical execution plan in order to make the whole logical execution plan better. For example, associative subquery de-association, Max/Min elimination, predicate push-down, Join reordering, etc.</li>
<li>Physical Optimize Physical Optimize: used to create a physical execution plan for the logical execution plan generated in the previous stage. The optimizer selects a specific physical implementation for each operator in the logical execution plan. There may be multiple physical implementations of the same logical operator, such as <code>LogicalAggregate</code>, which can be either <code>HashAggregate</code> using a hashing algorithm or <code>StreamAggregate</code> in a streaming format.</li>
<li>Coprocessor: In TiDB, the computation is done in Region, the SQL layer will analyze the Key Range of the data to be processed, then divide these Key Ranges into several Key Ranges according to the Region information obtained from PD, and finally send these requests to the corresponding Region, and the module that computes the TiKV data corresponding to each Region is called Coprocessor.</li>
<li>TiDB Executor: TiDB will merge and aggregate the data returned by Region for settlement.</li>
</ul>
<h3 id="building-ast-syntax-tree">Building AST syntax tree</h3>
<p>For example, the following SQL statement.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">select</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">age</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">student</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">age</span><span class="o">&gt;</span><span class="mi">1</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;pingcap&#39;</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>It is parsed to generate a syntax tree, which is then stored in the <code>ast.StmtNode</code> data structure.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">SelectStmt</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">dmlNode</span> 
    <span class="o">*</span><span class="nx">SelectStmtOpts</span> 
    <span class="nx">Distinct</span> <span class="kt">bool</span> 
    <span class="nx">From</span> <span class="o">*</span><span class="nx">TableRefsClause</span> 
    <span class="nx">Where</span> <span class="nx">ExprNode</span> 
    <span class="nx">Fields</span> <span class="o">*</span><span class="nx">FieldList</span> 
    <span class="nx">GroupBy</span> <span class="o">*</span><span class="nx">GroupByClause</span> 
    <span class="nx">Having</span> <span class="o">*</span><span class="nx">HavingClause</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/23/f66b404f5aa940cfbc51f86855ff98da.png" alt="sobyte"></p>
<h3 id="build-the-execution-plan">Build the execution plan</h3>
<p>Next, we will build the execution plan based on the node information of the <code>ast</code> syntax tree. Since the above SQL is relatively simple, let&rsquo;s change to a function with aggregation to see the execution plan we generated.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="k">select</span> * from test1 where <span class="nv">b</span><span class="o">=</span><span class="m">5</span> or <span class="o">(</span> b&gt;5 and <span class="o">(</span>b&gt;6 or b &lt;8<span class="o">)</span>  and b&lt;12<span class="o">)</span> <span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>Our execution plan will then be generated based on the ast syntax tree generated from this SQL.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/23/2f7f5a8081c046358818c0de9845f449.png" alt="sobyte"></p>
<p>The execution plan consists of the following operators.</p>
<ul>
<li>DataSource : this is the data source, that is, the table, that is, the student table above.</li>
<li>LogicalSelection: This is the filter condition after where.</li>
<li>Projection: this is the corresponding select followed by the field.</li>
</ul>
<p><strong>LogicalOptimization</strong></p>
<p>After the logicalOptimize logical optimization is executed, the execution plan becomes the following.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/23/ca24bfbd4a6d41909932ee295e3ecff3.png" alt="sobyte"></p>
<p>The Selection operator is pushed down into the DataSource operator, which is called <strong>Predicate Push Down (PDD) optimization.</strong> Predicate Push Down(PDD) optimization.</p>
<p>The basic idea of Predicate Push Down is <strong>to move the filter expression as close to the DataSource as possible so that irrelevant data can be skipped directly when it is actually executed.</strong></p>
<p>The pushed-down filter operators are held in the pushedDownConds of the DataSource. pushedDownConds expands to a binary tree structure.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/23/e90df19a2e1e426f8b6a464f2d8255e3.png" alt="sobyte"></p>
<p>Because the index bottom is ordered, it is important to turn this tree into a scan interval.</p>
<p>In addition to predicate push-down optimization, TiDB already supports the following optimization rules.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">optRuleList</span> <span class="p">=</span> <span class="p">[]</span><span class="nx">logicalOptRule</span><span class="p">{</span>
    <span class="o">&amp;</span><span class="nx">gcSubstituter</span><span class="p">{},</span>
    <span class="o">&amp;</span><span class="nx">columnPruner</span><span class="p">{},</span>
    <span class="o">&amp;</span><span class="nx">buildKeySolver</span><span class="p">{},</span>
    <span class="o">&amp;</span><span class="nx">decorrelateSolver</span><span class="p">{},</span>
    <span class="o">&amp;</span><span class="nx">aggregationEliminator</span><span class="p">{},</span>
    <span class="o">&amp;</span><span class="nx">projectionEliminator</span><span class="p">{},</span>
    <span class="o">&amp;</span><span class="nx">maxMinEliminator</span><span class="p">{},</span>
    <span class="o">&amp;</span><span class="nx">ppdSolver</span><span class="p">{},</span>
    <span class="o">&amp;</span><span class="nx">outerJoinEliminator</span><span class="p">{},</span>
    <span class="o">&amp;</span><span class="nx">partitionProcessor</span><span class="p">{},</span>
    <span class="o">&amp;</span><span class="nx">aggregationPushDownSolver</span><span class="p">{},</span>
    <span class="o">&amp;</span><span class="nx">pushDownTopNOptimizer</span><span class="p">{},</span>
    <span class="o">&amp;</span><span class="nx">joinReOrderSolver</span><span class="p">{},</span>
    <span class="o">&amp;</span><span class="nx">columnPruner</span><span class="p">{},</span> <span class="c1">// column pruning again at last, note it will mess up the results of buildKeySolver
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Each row here is an optimizer, e.g. <code>gcSubstituter</code> for replacing expressions with virtual generated columns to facilitate the use of indexes; <code>columnPruner</code> for pruning columns, i.e. removing unused columns and avoiding reading them out to reduce data reads; <code>aggregationEliminator</code> for eliminating unneeded aggregation calculations when <code>group by {unique key}</code> to reduce the amount of calculations.</p>
<p><strong>physical optimization</strong></p>
<p>In this phase, the optimizer selects a specific physical implementation for each operator in the logical execution plan to convert the logical execution plan generated in the logical optimization phase into a physical execution plan.</p>
<p>First, DetachCondAndBuildRangeForIndex is called to generate the scan interval, and this function recursively calls the following 2 functions.</p>
<p>detachDNFCondAndBuildRangeForIndex: expands the OR conditional concatenation, also called disjunctive normal form DNF (disjunctive normal form), to generate scan intervals or merge scan intervals.</p>
<p>detachCNFCondAndBuildRangeForIndex: expand AND conditional concatenation also called collocation paradigm CNF (conjunctive normal form), generating scan intervals or merging scan intervals.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/23/101e059391804b3c979239cca0e1c4a6.png" alt="sobyte"></p>
<p>The expression tree above eventually generates the interval: <code>[5,12)</code>.</p>
<p>Then physicalOptimize recursively calls the findBestTask function for all operators, and finally calls the DataSoure operator to use the Skyline-Pruning index trimming, which gets the optimal execution plan from possibleAccessPaths.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/23/ab97839b7c494b0aab5f8c4d713509df.png" alt="sobyte"></p>
<p>The different physical implementations corresponding to the logical operators differ in terms of time complexity, resource consumption and physical properties. In this process, the optimizer determines the cost of different physical implementations based on statistical information about the data and selects the physical execution plan with the lowest overall cost.</p>
<p>If an execution plan contains multiple indexes, then <strong>Skyline-Pruning</strong> determines the merit of an index by.</p>
<ul>
<li>How many access conditions are covered by the index&rsquo;s columns. &ldquo;Access conditions&rdquo; refers to <code>where</code> conditions that can be translated into a range of columns, and if an index has more access conditions covered by its set of columns, then it is better in this dimension.</li>
<li>Selects whether the index requires a table lookup when reading tables (i.e., whether the index generates an IndexReader or IndexLookupReader plan). Indexes that do not require a table lookback outperform indexes that require a table lookback in this dimension. If both require table returns, compare how many filter conditions are covered by the index&rsquo;s columns. Filter conditions refer to <code>where</code> conditions that can be determined based on the index. If the more access conditions are covered by the set of columns of a given index, the fewer table returns it has, the better it is on this dimension.</li>
<li>Choose whether the index can satisfy a certain order. Because index reads can guarantee the order of certain sets of columns, indexes that satisfy the order required by the query are better in this dimension than indexes that do not.</li>
</ul>
<p>After using the Skyline-Pruning rule to exclude unsuitable indexes, the selection of indexes is based solely on cost estimation, and the cost estimation of read tables needs to consider the following aspects.</p>
<ul>
<li>The average length of each row of data at the storage level for the index.</li>
<li>The number of rows in the query range generated by the index.</li>
<li>The table return cost of the index.</li>
<li>Number of ranges for index queries.</li>
</ul>
<p>Based on these factors and the cost model, the optimizer selects an index with the lowest cost for table reads.</p>
<p>A structure called task is returned after the final execution, and TiDB&rsquo;s optimizer will package the PhysicalPlan as a Task.</p>
<p>Currently, TiDB computation task is divided into two different kinds of task: cop task and root task. cop task is the computation task executed by using Coprocessor in TiKV, and root task is the computation task executed in TiDB.</p>
<h2 id="transactions">Transactions</h2>
<h3 id="percolator-distributed-transactions">Percolator Distributed Transactions</h3>
<p>TiDB&rsquo;s transaction model follows Percolator&rsquo;s transaction model.</p>
<p>So let&rsquo;s talk about <strong>Percolator distributed transactions first.</strong> Percolator</p>
<p>Percolator implements distributed transactions based on three entities: Client, TSO, and BigTable.</p>
<ul>
<li>Client is the initiator and coordinator of transactions</li>
<li>TSO provides an accurate, strictly monotonically incremental timestamp service for distributed servers.</li>
<li>BigTable is a Google implementation of a multi-maintainer persistent Map.</li>
</ul>
<p>When Percolator stores one column of data, it stores multiple columns of data in the BigTable: the</p>
<ul>
<li>data column (D column): stores value</li>
<li>lock column (L column): stores lock information for distributed transactions</li>
<li>write column (W column): stores commit_timestamp for distributed transactions</li>
</ul>
<p>Percolator&rsquo;s distributed write transaction is implemented by 2-phase commit (later called 2PC). However, it has some modifications to the traditional 2PC. When a write transaction transaction is opened, the Client gets a timestamp from the TSO as the start time of the transaction (later called start_ts). Until commit, all write operations are simply cached in memory. A commit goes through a prewrite phase and a commit phase, and a write transaction can contain multiple write operations.</p>
<h4 id="write-operations">Write Operations</h4>
<p><strong>Prewrite</strong></p>
<ol>
<li>Get a timestamp from TSO as start_ts when the transaction is opened;</li>
<li>select one of the write operations for all rows as primary (not only a means of conflict security in itself, but also a marker for resolving the state of the transaction), and the others as secondaries.</li>
<li>write the primary row to the L column, i.e., lock it, and check for conflicts before locking.
<ol>
<li>check whether the L column has already been locked by another client, directly Abort the entire transaction.</li>
<li>check whether the W column has been committed after the start time of the transaction, check the W column, whether there is an update between [start_ts, +Inf) whether there is the same key data. If there is, then there is a conflict in the W column, directly Abort the entire transaction; 4.</li>
</ol>
</li>
<li>if there is no conflict, then lock and use start_ts as the Bigtable timestamp to write the data to the data column, which is not visible to other transactions because the write column has not been written yet.</li>
</ol>
<p><strong>Commit</strong></p>
<p>If Prewrite is successful, proceed to Commit phase.</p>
<ol>
<li>obtain a timestamp from the TSO as the commit time of the transaction (later called commit_ts).</li>
<li>commit the primary, and if it fails, abort the transaction.</li>
<li>check whether the lock on primary still exists, and abort if it does not. (Other transactions may assume that the current transaction has failed and thus clean up the current transaction&rsquo;s lock).</li>
<li>with commit_ts as timestamp, write to column W, value as start_ts, clean up the data in column L. Note that at this point for Commit Point, &ldquo;write column W&rdquo; and &ldquo;clean up column L&rdquo; by BigTable&rsquo;s single-row transaction to ensure ACID.</li>
<li>Once the primary commit succeeds, the entire transaction succeeds. At this point, the client can already return success, and then asynchronously secondary commit. seconary commit does not need to detect whether the lock column lock still exists, it will not fail.</li>
</ol>
<h4 id="read-operation">Read operation</h4>
<ol>
<li>check if the row has an L column with timestamp [0, start_ts], if it does, it means that another transaction is currently occupying the row, try to clear it if this lock has timed out, otherwise wait for the timeout or for another transaction to initiate the unlock.</li>
<li>if the lock is found not to exist in step 1, it is safe to read.</li>
</ol>
<h3 id="tidb-two-phase-commit-transaction">TiDB two-phase commit transaction</h3>
<p>TiDB commit transactions are performed by calling the Commit method of KVTxn. Like the protocol described in the pecolator paper, this is a two-phase commit process, a Prewrite phase and a Commit phase.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/23/1a0727d8e48a4d699a3d48799d67b5d6.png" alt="sobyte"></p>
<p><strong>Prewrite:</strong></p>
<ol>
<li>TiDB selects a Key from the current data to be written as the Primary Key for the current transaction.</li>
<li>TiDB gets the write route information of all the data from PD and classifies all the Keys according to all the routes. 3.</li>
<li>TiDB concurrently issues prewrite requests to all the TiKVs involved, TiKV receives the prewrite data, checks the data version information for conflicts and expiration, and locks the data if it meets the conditions, and records the start time stamp of this transaction in the lock. , delete the data with version startTs.</li>
<li>TiDB receives all prewrite successes.</li>
</ol>
<p>When the Prewrite phase completes, it enters the Commit phase, where the current timestamp is commitTs and TSO ensures that commitTs &gt; startTs.</p>
<p><strong>Commit:</strong></p>
<p>TiDB initiates the second stage commit operation to TiKV where the Primary Key is located. After TiKV receives the commit operation, it checks the data legitimacy and cleans up the locks left in the prewrite stage.</p>
<h2 id="storage-of-data">Storage of data</h2>
<p>TiDB&rsquo;s storage layer is implemented by TiKV, which can be seen as a huge Map, that is, it stores Key-Value pairs, in which the Keys are arranged in the order of the total raw binary bits of the Byte array in comparison.</p>
<p>TiKV stores the data in RocksDB, and RocksDB is responsible for the specific data landing. However, RocksDB is a local storage solution, as a distributed storage, it needs to ensure that data will not be lost and error-free in case of single machine failure, so TiKV uses Raft to do data replication, each data change will be landed as a Raft log, and through Raft&rsquo;s log replication function, data will be synchronized to most nodes of the Group safely and securely.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/23/920caa3271eb41e0b2d131eb31d537cd.png" alt="sobyte"></p>
<p>TiKV divides the entire Key-Value space into many segments, each segment is a series of consecutive Keys, we call each segment a <strong>Region</strong>, and we try to keep the data stored in each Region within a certain size. Each Region can be described by a left-closed-right-open interval like StartKey to EndKey.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/23/e8aa3ff0d7b84b17b2118ceab361e285.png" alt="sobyte"></p>
<p>After dividing the data into Regions, we will spread the data across all the nodes in the cluster by Region, and try to ensure that the number of Regions served on each node is about the same, and then do the replication and membership management of Raft by Region.</p>
<h2 id="cluster-availability--data-consistency-assurance">Cluster Availability &amp; Data Consistency Assurance</h2>
<p>To achieve cluster and data assurance, we need to collect information, that is, we need to know the status of each TiKV node and the status of each Region.</p>
<p>In simple terms, first information is collected, then scheduling is generated based on the collected information, and finally scheduling is executed.</p>
<p>For information collection, TiKV proactively reports two types of messages to PD periodically.</p>
<ul>
<li>Each TiKV node will periodically report the overall information of the node to the PD. This information includes the total disk capacity of the TiKV node, the available disk capacity, the number of Regions hosted, whether it is overloaded, etc.</li>
<li>The Leader of each Raft Group will periodically report information to the PD. This information is mainly Raft-related, such as the location of the Leader, the location of Followers, the number of fallen Replica, etc.</li>
</ul>
<p>The PD continuously collects information about the whole cluster through these two types of heartbeat messages, and then uses this information as the basis for decision making to generate a scheduling plan.</p>
<p>For example, if the PD finds that the number of replicas in a region does not meet the requirement through the heartbeat packet of a region leader, it needs to adjust the number of replicas through Add/Remove Replica operation. Then you can use this information to determine whether a node is offline or the administrator has adjusted the replica policy.</p>
<p>In addition to the above issue of Replica number, there are also issues such as: making the number of Leaders evenly distributed among Stores, replicas evenly distributed among Stores, and the number of access hotspots evenly distributed among Stores, and so on.</p>
<p>Finally, according to the scheduling information, the scheduling policy is sent to TiKV&rsquo;s Region Leader for execution. It should be noted that the scheduling policy here is only a suggestion to the Region Leader, and it is not guaranteed to be executed.</p>
<h2 id="key-value-mapping-data">Key-Value Mapping Data</h2>
<p>Since TiDB is stored via TiKV, but a table may have many columns in a relational database, it is necessary to map the data of each column in a row into a (Key, Value) key-value pair.</p>
<p>TiDB assigns a TableID to each table, an IndexID to each index, and a RowID to each row (if the table has an integer Primary Key, the value of the Primary Key is used as the RowID), where the TableID is unique within the cluster and the IndexID/RowID is unique within the table, and these IDs are all int64 types.</p>
<p>They are encoded into Key-Value pairs according to the following rules.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">Key: tablePrefix<span class="o">{</span>tableID<span class="o">}</span>_recordPrefixSep<span class="o">{</span>rowID<span class="o">}</span>
Value: <span class="o">[</span>col1, col2, col3, col4<span class="o">]</span>
</code></pre></td></tr></table>
</div>
</div><p>Unique Index data is encoded into Key-Value pairs according to the following rules.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">Key: tablePrefix<span class="o">{</span>tableID<span class="o">}</span>_indexPrefixSep<span class="o">{</span>indexID<span class="o">}</span>_indexedColumnsValue
Value: rowID
</code></pre></td></tr></table>
</div>
</div><p>A normal secondary index is encoded as a Key-Value pair according to the following rules.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">Key: tablePrefix<span class="o">{</span>tableID<span class="o">}</span>_indexPrefixSep<span class="o">{</span>indexID<span class="o">}</span>_indexedColumnsValue_rowID
Value: null
</code></pre></td></tr></table>
</div>
</div><p>For example, there is a table like this.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="k">User</span><span class="w"> </span><span class="p">(</span><span class="w">
</span><span class="w">    </span><span class="n">ID</span><span class="w"> </span><span class="nb">int</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">Name</span><span class="w"> </span><span class="nb">varchar</span><span class="p">(</span><span class="mi">20</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="k">Role</span><span class="w"> </span><span class="nb">varchar</span><span class="p">(</span><span class="mi">20</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="n">Age</span><span class="w"> </span><span class="nb">int</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="n">ID</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="k">KEY</span><span class="w"> </span><span class="n">idxAge</span><span class="w"> </span><span class="p">(</span><span class="n">Age</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>There are three rows of data in the table.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">1, <span class="s2">&#34;TiDB&#34;</span>, <span class="s2">&#34;SQL Layer&#34;</span>, <span class="m">10</span>
2, <span class="s2">&#34;TiKV&#34;</span>, <span class="s2">&#34;KV Engine&#34;</span>, <span class="m">20</span>
3, <span class="s2">&#34;PD&#34;</span>, <span class="s2">&#34;Manager&#34;</span>, <span class="m">30</span>
</code></pre></td></tr></table>
</div>
</div><p>For primary keys and unique indexes, the unique ID of the table and the RowID of the data in the table will be added to each entry, such as the three rows of data above.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">t10_r1 --&gt; <span class="o">[</span><span class="s2">&#34;TiDB&#34;</span>, <span class="s2">&#34;SQL Layer&#34;</span>, 10<span class="o">]</span>
t10_r2 --&gt; <span class="o">[</span><span class="s2">&#34;TiKV&#34;</span>, <span class="s2">&#34;KV Engine&#34;</span>, 20<span class="o">]</span>
t10_r3 --&gt; <span class="o">[</span><span class="s2">&#34;PD&#34;</span>, <span class="s2">&#34;Manager&#34;</span>, 30<span class="o">]</span>
</code></pre></td></tr></table>
</div>
</div><p>Where t in key means TableID prefix, t10 means the unique ID of table is 10; r in key means RowID prefix, r1 means this data RowID value is 1, r2 means RowID value is 2 and so on.</p>
<p>For ordinary secondary indexes that do not need to satisfy the uniqueness constraint, a key value may correspond to multiple rows, and you need to query the corresponding RowID according to the key range. idxAge index in the above data will be mapped to.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">t10_i1_10_1 --&gt; null
t10_i1_20_2 --&gt; null
t10_i1_30_3 --&gt; null
</code></pre></td></tr></table>
</div>
</div><p>The above key corresponds to: <code>table ID_i index ID_index value_RowID</code>.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/tidb/">tidb</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-01/startpage-privacy-protection-extension/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Startpage Search Engine Launches Open Source Browser Extension to Protect Users&#39; Private Data</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-01/go-runtime/">
            <span class="next-text nav-default">How to compile and debug Go runtime source code</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
