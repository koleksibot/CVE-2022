<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Go 1.18 will introduce a new network address packet - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="A long time ago, I came across an article by Brad Fitzpatrick called netaddr.IP: a new IP address type for Go. Brad is the core developer of the Go language and founder of tailscale, and in this article he analyzes the problems with the Go language net.IP type and their solution to them and how it evolved. Eventually Brad and his team open sourced the inet.af/netaddr package. I took a" /><meta name="keywords" content="golang, netip" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-01/go-1.18-netip/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Go 1.18 will introduce a new network address packet" />
<meta property="og:description" content="A long time ago, I came across an article by Brad Fitzpatrick called netaddr.IP: a new IP address type for Go. Brad is the core developer of the Go language and founder of tailscale, and in this article he analyzes the problems with the Go language net.IP type and their solution to them and how it evolved. Eventually Brad and his team open sourced the inet.af/netaddr package. I took a" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-01/go-1.18-netip/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-01-05T13:00:14+08:00" />
<meta property="article:modified_time" content="2022-01-05T13:00:14+08:00" />

<meta itemprop="name" content="Go 1.18 will introduce a new network address packet">
<meta itemprop="description" content="A long time ago, I came across an article by Brad Fitzpatrick called netaddr.IP: a new IP address type for Go. Brad is the core developer of the Go language and founder of tailscale, and in this article he analyzes the problems with the Go language net.IP type and their solution to them and how it evolved. Eventually Brad and his team open sourced the inet.af/netaddr package. I took a"><meta itemprop="datePublished" content="2022-01-05T13:00:14+08:00" />
<meta itemprop="dateModified" content="2022-01-05T13:00:14+08:00" />
<meta itemprop="wordCount" content="2527">
<meta itemprop="keywords" content="golang," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go 1.18 will introduce a new network address packet"/>
<meta name="twitter:description" content="A long time ago, I came across an article by Brad Fitzpatrick called netaddr.IP: a new IP address type for Go. Brad is the core developer of the Go language and founder of tailscale, and in this article he analyzes the problems with the Go language net.IP type and their solution to them and how it evolved. Eventually Brad and his team open sourced the inet.af/netaddr package. I took a"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Go 1.18 will introduce a new network address packet</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-01-05 13:00:14 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 2527 words </span>
          <span class="more-meta"> 6 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#whats-wrong-with-the-netip-type-of-go">What&rsquo;s wrong with the net.IP type of Go?</a></li>
        <li><a href="#so-what-would-the-ideal-ip-type-look-like">So what would the ideal IP type look like?</a></li>
        <li><a href="#option-1-wgcfgip">Option 1: <code>wgcfg.IP</code></a></li>
        <li><a href="#option-2-netaddrip-with-embedded-interface-variables">Option 2: netaddr.IP with embedded interface variables</a></li>
        <li><a href="#option-3-24-byte-representation-without-heap-memory-allocation">Option 3: 24-byte representation without heap memory allocation</a></li>
        <li><a href="#option-4-uint64s-acceleration">Option 4: uint64s acceleration</a></li>
        <li><a href="#option-5-uint128-type">Option 5: uint128 type</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>A long time ago, I came across an article by Brad Fitzpatrick called <a href="https://tailscale.com/blog/netaddr-new-ip-type-for-go/">netaddr.IP: a new IP address type for Go</a>. Brad is the core developer of the Go language and founder of tailscale, and in this article he analyzes the problems with the Go language net.IP type and their solution to them and how it evolved. Eventually Brad and his team open sourced the inet.af/netaddr package. I took a few glances at it and was impressed. Today I received an email subscription saying that Go 1.18 had accepted Brad&rsquo;s <a href="https://github.com/golang/go/issues/46518">proposal</a> to introduce a new package net/netip. So I quickly found Brad&rsquo;s article and read it carefully. IP type and the ingeniousness of the new scheme, but also have a better understanding of memory allocation, garbage collection and the use of unsafe packages in Go language. Today, I&rsquo;d like to share it with you.</p>
<h2 id="whats-wrong-with-the-netip-type-of-go">What&rsquo;s wrong with the net.IP type of Go?</h2>
<p>Brad lists the &ldquo;seven problems&rdquo; with net.IP in his article.</p>
<ol>
<li>The contents are mutable. The underlying type of <code>net.IP</code> is <code>[]byte</code>, which means that <code>net.IP</code> is passed by reference, and any function that handles it can change its contents.</li>
<li>Cannot be compared directly. Because slice cannot be compared directly, <code>net.IP</code> cannot be used directly to determine if two addresses are equal using <code>==</code>, nor can it be used as the key of a map.</li>
<li>There are two types of addresses in the standard library, <code>net.IP</code> and <code>net.IPAddr</code>. Common IPv4 and IPv6 addresses are stored using <code>net.IP</code>. IPv6 link-local addresses need to be stored using <code>net.IPAddr</code> (because of the additional storage of the link&rsquo;s NIC). Since there are two types of addresses, it&rsquo;s a matter of determining which one to use or both.</li>
<li>Takes up a lot of memory. A single slice header message takes 24 bytes (64-bit platforms, see Russ&rsquo;s <a href="https://research.swtch.com/godata">article</a> for details). So the memory footprint of <code>net.IP</code> contains 24 bytes of header information and 4 bytes (IPv4) or 6 bytes (IPv6) of address data. If the local link NIC (zone) needs to be stored, then <code>net.IPAddr</code> also needs a 16-byte string header and the specific NIC name.</li>
<li>Memory needs to be allocated from the heap. Each time memory is allocated from the heap, it puts extra pressure on the GC.</li>
<li>Cannot distinguish between IPv4 addresses and IPv4-mapped IPv6 addresses (in the form of ::ffff:192.168.1.1) when parsing IP addresses from strings.</li>
<li>Expose implementation details to the outside world. The definition of <code>net.IP</code> is <code>type IP []byte</code>, and the underlying <code>[]byte</code> is part of the API and cannot be changed.</li>
</ol>
<h2 id="so-what-would-the-ideal-ip-type-look-like">So what would the ideal IP type look like?</h2>
<p>Brad has summarized a table.</p>
<table>
<thead>
<tr>
<th>Features</th>
<th>Go&rsquo;s <code>net.IP</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Immutable</td>
<td>❌, slice</td>
</tr>
<tr>
<td>Comparable</td>
<td>❌, slice</td>
</tr>
<tr>
<td>Small</td>
<td>❌, 28-56 bytes</td>
</tr>
<tr>
<td>No need to allocate memory from the heap</td>
<td>❌, slice&rsquo;s underlying array</td>
</tr>
<tr>
<td>support IPv4 and IPv6</td>
<td>✅</td>
</tr>
<tr>
<td>Distinguish between IPv4/IPv6</td>
<td>❌, <a href="https://github.com/golang/go/issues/37921">#37921</a></td>
</tr>
<tr>
<td>support for IPv6 zones</td>
<td>❌, using a specialized net.IPAddr type</td>
</tr>
<tr>
<td>Hide implementation details from the outside world</td>
<td>❌, expose the underlying type <code>[]byte</code></td>
</tr>
<tr>
<td>interoperable with standard libraries</td>
<td>✅</td>
</tr>
</tbody>
</table>
<p>What follows is a series of improvement options.</p>
<h2 id="option-1-wgcfgip">Option 1: <code>wgcfg.IP</code></h2>
<p><a href="https://github.com/crawshaw">David Crawshaw</a> Submitted code in April 2019 <a href="https://github.com/tailscale/wireguard-go/commit/89476f8cb53b7b6e3e67041d204a972b69902565#diff-d6e6f254849cb9119d9aaa21a41ee7f26f499251ce073522bdd89361a316814bR13"> <code>89476f8cb5</code> </a> , which introduces the following <code>wgcfg.IP</code> Type.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 内部使用 IPv6 格式。
</span><span class="c1">// IPv4 地址使用 IPv4-in-IPv6 语法。
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">IP</span> <span class="kd">struct</span> <span class="p">{</span>
       <span class="nx">Addr</span> <span class="p">[</span><span class="mi">16</span><span class="p">]</span><span class="kt">byte</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Not perfect, but solves some problems, see the following table.</p>
<table>
<thead>
<tr>
<th>featured</th>
<th><code>net.IP</code></th>
<th><code>wgcfg.IP</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Immutable</td>
<td>❌, slice</td>
<td>✅</td>
</tr>
<tr>
<td>Comparable</td>
<td>❌, slice</td>
<td>✅</td>
</tr>
<tr>
<td>Small size</td>
<td>❌, 28-56 bytes</td>
<td>✅, 16 bytes</td>
</tr>
<tr>
<td>No need to allocate memory from the heap</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>Supports IPv4 and IPv6</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Differentiate between IPv4/IPv6</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td>support for IPv6 regions (zones)</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td>Hide implementation details externally</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td>Interoperable with standard libraries</td>
<td>✅</td>
<td>❌, requires adaptation</td>
</tr>
</tbody>
</table>
<p>This solution takes up only 16 bytes and is very compact. The implementation details can be hidden from the public by simply changing Addr to addr. However, David&rsquo;s solution still does not distinguish between IPv4 and IPv4-maped IPv6 addresses, and does not support saving zone information.</p>
<p>So there&rsquo;s a second option.</p>
<h2 id="option-2-netaddrip-with-embedded-interface-variables">Option 2: netaddr.IP with embedded interface variables</h2>
<p>In Go, interface variables can also be <a href="https://golang.org/ref/spec#Comparison_operators">compared to each other</a> (either using <code>==</code> comparisons or as the key of a map). So Brad implemented <a href="https://github.com/inetaf/netaddr/commit/7f2e8c8409b7c27c5b44192839c8a94fca95aa21#diff-5aea5a23fd374194efa71dd12c8ddf8ede924f1043045520a8283d2490f40f12R27">version 1</a> of the <code>netaddr.IP</code> scheme.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">IP</span> <span class="kd">struct</span> <span class="p">{</span>
     <span class="nx">ipImpl</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ipImpl</span> <span class="kd">interface</span> <span class="p">{</span>
     <span class="nf">is4</span><span class="p">()</span> <span class="kt">bool</span>
     <span class="nf">is6</span><span class="p">()</span> <span class="kt">bool</span>
     <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">v4Addr</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="kt">byte</span>
<span class="kd">type</span> <span class="nx">v6Addr</span> <span class="p">[</span><span class="mi">16</span><span class="p">]</span><span class="kt">byte</span>
<span class="kd">type</span> <span class="nx">v6AddrZone</span> <span class="kd">struct</span> <span class="p">{</span>
      <span class="nx">v6Addr</span>
      <span class="nx">zone</span> <span class="kt">string</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>This time, an interface variable is embedded in <code>IP</code>. On 64-bit platforms, an interface takes up 16 bytes, so the <code>IP</code> type here also takes up 16 bytes. This is better than the standard library where <code>net.IP</code> takes up 24 bytes plus the address content. Because the compass is stored, additional memory needs to be allocated for <code>v4Addr/v6Addr/v6AddrZone</code>. However, IPv6 support is solved this time.</p>
<table>
<thead>
<tr>
<th>Features</th>
<th><code>net.IP</code></th>
<th><code>wgcfg.IP</code></th>
<th>Program 2</th>
</tr>
</thead>
<tbody>
<tr>
<td>Immutable</td>
<td>❌, slice</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Comparable</td>
<td>❌, slice</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Small</td>
<td>❌, 28-56 bytes</td>
<td>✅, 16 bytes</td>
<td>🤷, 20-32 bytes</td>
</tr>
<tr>
<td>No need to allocate memory from the heap</td>
<td>❌</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td>Supports IPv4 and IPv6</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Distinguish between IPv4/IPv6</td>
<td>❌</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>Support for IPv6 regions (zones)</td>
<td>❌</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>Hide implementation details from the outside world</td>
<td>❌</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>Interoperable with standard libraries</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
</tr>
</tbody>
</table>
<p>Compared to <code>wgcfg.IP</code>, only the memory allocation problem is left unresolved. Keep carrying the front!</p>
<h2 id="option-3-24-byte-representation-without-heap-memory-allocation">Option 3: 24-byte representation without heap memory allocation</h2>
<p>The slice header of <code>,net.IP</code> is 24 bytes long. The length of <code>time.Time</code> is also 24 bytes. So Brad thinks it&rsquo;s best to keep the new address type to no more than 24 bytes.</p>
<p>The IPv6 address itself already takes up 16 bytes, which leaves 8 bytes to hold the following information.</p>
<ul>
<li>Address type (v4, v6, null). At least two bits are needed.</li>
<li>IPv6 zone information (aka NIC name)</li>
</ul>
<p>The interface scheme is out because a pointer takes up 16 bytes, which is too big. The string header information also takes 16 bytes and is out.</p>
<p>Brad came up with this solution.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">IP</span> <span class="kd">struct</span> <span class="p">{</span>
   <span class="nx">addr</span>          <span class="p">[</span><span class="mi">16</span><span class="p">]</span><span class="kt">byte</span>
   <span class="nx">zoneAndFamily</span> <span class="kt">uint64</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Then find a way to save the address type and zone information in the <code>zoneAndFamily</code> field. The question is how to store it?</p>
<p>If you use one or two bits to save the address type, that leaves 62 or 63 bits. The following options can be used.</p>
<ul>
<li>Use the remaining 62 bits to save ASCII characters, which supports up to 8 characters. Too short.</li>
<li>Number the NIC and save only the numeric number. But this only saves the local NIC.</li>
<li>Use the NIC name mapping table to create a name-to-number index. Go Standard Library does this internally <a href="https://github.com/golang/go/blob/a38a917aee626a9b9d5ce2b93964f586bf759ea0/src/net/interface.go#L172">like this</a>. However, this may be vulnerable to external attacks, as this mapping table only increases and does not decrease. the Go standard library only keeps the local NIC, so it does not have this problem.</li>
</ul>
<p>Brad was not satisfied with any of these options and came up with the pointer option.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">IP</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">addr</span>          <span class="p">[</span><span class="mi">16</span><span class="p">]</span><span class="kt">byte</span>
    <span class="nx">zoneAndFamily</span> <span class="o">*</span><span class="nx">T</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>For now, let&rsquo;s assume that it works regardless of the type of T. Only three sentinel variables need to be declared to identify the address type.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="p">(</span>
     <span class="nx">z0</span> <span class="o">*</span><span class="nx">T</span>        <span class="c1">// nil 表示空值
</span><span class="c1"></span>     <span class="nx">z4</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span>  <span class="c1">// 表示 IPv4
</span><span class="c1"></span>     <span class="nx">z6</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span>  <span class="c1">// 表示 IPv6（没有 zone 信息）
</span><span class="c1"></span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>The next step is to consider how to save the zone information to achieve the following effect.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">   <span class="nx">ip1</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">netaddr</span><span class="p">.</span><span class="nf">ParseIP</span><span class="p">(</span><span class="s">&#34;fe80::2%eth0&#34;</span><span class="p">)</span>
   <span class="nx">ip2</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">netaddr</span><span class="p">.</span><span class="nf">ParseIP</span><span class="p">(</span><span class="s">&#34;fe80::2%eth0&#34;</span><span class="p">)</span>
   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">ip1</span> <span class="o">==</span> <span class="nx">ip2</span><span class="p">)</span> <span class="c1">// true
</span></code></pre></td></tr></table>
</div>
</div><p>Simply new two identical strings will return different pointers. But Brad wanted to find a way to always return the same pointer for strings that have the same value. This way you can compare two strings by pointer to see if they are equal.</p>
<p>So a map is needed to hold all the strings. So what&rsquo;s the difference between this and the previous indexed table? The biggest difference is that if you use a zone index (integer) as the key, the corresponding map has no way to clean up and will get bigger and bigger. If you use pointers, you can use <a href="https://golang.org/pkg/runtime/#SetFinalizer"> <code>runtime.SetFinalizer</code> </a> to clean up the index table during garbage collection. Eventually they got the <a href="https://pkg.go.dev/go4.org/intern"> <strong><code>go4.org/intern</code></strong> </a> package, whose core logic is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="p">(</span>
	<span class="nx">mu</span>      <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
	<span class="nx">valMap</span>  <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span><span class="kt">uintptr</span><span class="p">{}</span> <span class="c1">// to uintptr(*Value)
</span><span class="c1"></span><span class="p">)</span>

<span class="c1">// Value 保存底层可比较的值
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Value</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">_</span>      <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="kd">func</span><span class="p">()</span> <span class="c1">// 禁止比较 Value 对象
</span><span class="c1"></span>	<span class="nx">cmpVal</span> <span class="kd">interface</span><span class="p">{}</span>
	<span class="c1">// resurrected 由 mu 保护并发读写。
</span><span class="c1"></span>	<span class="c1">// 只要有地方引用 cmpVal 就会被设为 true
</span><span class="c1"></span>	<span class="nx">resurrected</span> <span class="kt">bool</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">GetByString</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">Value</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">get</span><span class="p">(</span><span class="nx">key</span><span class="p">{</span><span class="nx">s</span><span class="p">:</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">isString</span><span class="p">:</span> <span class="kc">true</span><span class="p">})</span>
<span class="p">}</span>

<span class="c1">// get 方法违返了 unsafe 的使用规则，所以要添加 nocheckptr 指令
</span><span class="c1">//go:nocheckptr
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">get</span><span class="p">(</span><span class="nx">k</span> <span class="nx">key</span><span class="p">)</span> <span class="o">*</span><span class="nx">Value</span> <span class="p">{</span>
	<span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

	<span class="kd">var</span> <span class="nx">v</span> <span class="o">*</span><span class="nx">Value</span>
	<span class="k">if</span> <span class="nx">addr</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">valMap</span><span class="p">[</span><span class="nx">k</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
	<span class="c1">// 如果是已经存在的值，则标记并发访问
</span><span class="c1"></span>		<span class="nx">v</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">Value</span><span class="p">)((</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">addr</span><span class="p">))</span>
		<span class="nx">v</span><span class="p">.</span><span class="nx">resurrected</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">v</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">v</span>
	<span class="p">}</span>
	<span class="nx">v</span> <span class="p">=</span> <span class="nx">k</span><span class="p">.</span><span class="nf">Value</span><span class="p">()</span>
	<span class="c1">// 设置垃圾回收回调函数
</span><span class="c1"></span>	<span class="c1">// Go 在回收 v 之前如果发现有 finalize 函数，
</span><span class="c1"></span>	<span class="c1">// 会清空并调用 finalize，期望在下一个周期回收。
</span><span class="c1"></span>	<span class="nx">runtime</span><span class="p">.</span><span class="nf">SetFinalizer</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">finalize</span><span class="p">)</span>
	<span class="c1">// 参考 https://pkg.go.dev/unsafe#Pointer
</span><span class="c1"></span>	<span class="c1">// Go 语言要求 unsafe.Pointer 转成 uintptr 之后
</span><span class="c1"></span>	<span class="c1">// 要在同一个表达式中转回 unsafe.Pointer
</span><span class="c1"></span>	<span class="c1">// 但此处将其保存到 valMap
</span><span class="c1"></span>	<span class="nx">valMap</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">v</span><span class="p">))</span>
	<span class="k">return</span> <span class="nx">v</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">finalize</span><span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">Value</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">v</span><span class="p">.</span><span class="nx">resurrected</span> <span class="p">{</span>
		<span class="c1">// 进入本分支说明在垃圾回收过程中有别的协程
</span><span class="c1"></span>		<span class="c1">// 引用了当前 v，所以不能删除
</span><span class="c1"></span>		<span class="nx">v</span><span class="p">.</span><span class="nx">resurrected</span> <span class="p">=</span> <span class="kc">false</span>
		<span class="nx">runtime</span><span class="p">.</span><span class="nf">SetFinalizer</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="nx">finalize</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nb">delete</span><span class="p">(</span><span class="nx">valMap</span><span class="p">,</span> <span class="nf">keyFor</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">cmpVal</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>There are two subtleties in the above code.</p>
<p>The first is that it disables Value comparisons; the Go language supports comparing structs, but only if the first member of the struct supports comparisons. Here, we can disable Value structs from comparing with each other by embedding a <code>_ [0]func()</code> member that does not support comparisons. See <a href="https://dave.cheney.net/2020/05/09/ensmallening-go-binaries-by-prohibiting-comparisons">this article</a> for a detailed analysis.</p>
<p>The other is the garbage collection-enabled object pool <code>valMap = map[key]uintptr{}</code>. valMap stores the uintptr pointer of <code>*Value</code>, which is a so-called weak reference and does not affect Go&rsquo;s garbage collection. That is, although valMap &ldquo;references&rdquo; an object via uintptr, it will still be reclaimed by GC if it is not referenced by normal Go code. It&rsquo;s just that all <code>*Value</code>s are associated with a finalize function, and Go will execute the finalize function before executing a GC, and the recycling process will be delayed until the next GC cycle. This way, the <code>*Value</code> object will not be GC&rsquo;d as long as it is referenced elsewhere, and if all references are released, a GC will be triggered, where resurrected will be set to false, and memory will actually be reclaimed by the next GC cycle. The full working process can be found in <a href="https://mdlayher.com/blog/unsafe-string-interning-in-go/">this article</a>.</p>
<p>With the intern package, it is possible to achieve the following.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">intern</span><span class="p">.</span><span class="nf">GetByString</span><span class="p">(</span><span class="s">&#34;eth0&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="nx">intern</span><span class="p">.</span><span class="nf">GetByString</span><span class="p">(</span><span class="s">&#34;eth0&#34;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>So <code>IP</code> can be expressed as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">IP</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">addr</span> <span class="p">[</span><span class="mi">16</span><span class="p">]</span><span class="kt">byte</span>
    <span class="nx">z</span>    <span class="o">*</span><span class="nx">intern</span><span class="p">.</span><span class="nx">Value</span> <span class="c1">// 区域和类型
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">var</span> <span class="p">(</span>
     <span class="nx">z0</span>    <span class="o">*</span><span class="nx">intern</span><span class="p">.</span><span class="nx">Value</span>        <span class="c1">// nil 表示空值
</span><span class="c1"></span>     <span class="nx">z4</span>    <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">intern</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span>  <span class="c1">// 表示 IPv4
</span><span class="c1"></span>     <span class="nx">z6noz</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">intern</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span>  <span class="c1">// 表示 IPv6 （没有区域）
</span><span class="c1"></span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>The accessors to get/set the zone are then:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">ip</span> <span class="nx">IP</span><span class="p">)</span> <span class="nf">Zone</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">ip</span><span class="p">.</span><span class="nx">z</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="s">&#34;&#34;</span>
	<span class="p">}</span>
	<span class="nx">zone</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">ip</span><span class="p">.</span><span class="nx">z</span><span class="p">.</span><span class="nf">Get</span><span class="p">().(</span><span class="kt">string</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">zone</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">ip</span> <span class="nx">IP</span><span class="p">)</span> <span class="nf">WithZone</span><span class="p">(</span><span class="nx">zone</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">IP</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ip</span><span class="p">.</span><span class="nf">Is6</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">ip</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">zone</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nx">ip</span><span class="p">.</span><span class="nx">z</span> <span class="p">=</span> <span class="nx">z6noz</span>
		<span class="k">return</span> <span class="nx">ip</span>
	<span class="p">}</span>
	<span class="nx">ip</span><span class="p">.</span><span class="nx">z</span> <span class="p">=</span> <span class="nx">intern</span><span class="p">.</span><span class="nf">GetByString</span><span class="p">(</span><span class="nx">zone</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">ip</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The final result is as follows.</p>
<table>
<thead>
<tr>
<th>feature</th>
<th><code>net.IP</code></th>
<th><code>netaddr.IP</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Immutable</td>
<td>❌, slice</td>
<td>✅</td>
</tr>
<tr>
<td>Comparable</td>
<td>❌, slice</td>
<td>✅</td>
</tr>
<tr>
<td>Small size</td>
<td>❌, 28-56 bytes</td>
<td>✅, 24 bytes, fixed</td>
</tr>
<tr>
<td>No need to allocate memory from the heap</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>Supports IPv4 and IPv6</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Distinguish between IPv4/IPv6</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>Support for IPv6 regions (zones)</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>Hide implementation details externally</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>Ability to interoperate with standard libraries</td>
<td>✅</td>
<td>🤷</td>
</tr>
</tbody>
</table>
<h2 id="option-4-uint64s-acceleration">Option 4: uint64s acceleration</h2>
<p>The new scheme does not expose the underlying details, and we can easily modify the internal implementation. So Dave Anderson took <code>[16]byte</code> <a href="https://github.com/inetaf/netaddr/commit/4eb479db13f8b816537f38c664776b193c7a86ec">optimized</a> and made it a pair of <code>uint64</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">IP</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// hi and lo are the bits of an IPv6 address. If z==z4, hi and lo
</span><span class="c1"></span>	<span class="c1">// contain the IPv4-mapped IPv6 address.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// hi and lo are constructed by interpreting a 16-byte IPv6
</span><span class="c1"></span>	<span class="c1">// address as a big-endian 128-bit number. The most significant
</span><span class="c1"></span>	<span class="c1">// bits of that number go into hi, the rest into lo.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// For example, 0011:2233:4455:6677:8899:aabb:ccdd:eeff is stored as:
</span><span class="c1"></span>	<span class="c1">//  hi = 0x0011223344556677
</span><span class="c1"></span>	<span class="c1">//  lo = 0x8899aabbccddeeff
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// We store IPs like this, rather than as [16]byte, because it
</span><span class="c1"></span>	<span class="c1">// turns most operations on IPs into arithmetic and bit-twiddling
</span><span class="c1"></span>	<span class="c1">// operations on 64-bit registers, which is much faster than
</span><span class="c1"></span>	<span class="c1">// bytewise processing.
</span><span class="c1"></span>	<span class="nx">hi</span><span class="p">,</span> <span class="nx">lo</span> <span class="kt">uint64</span>

	<span class="c1">// z is a combination of the address family and the IPv6 zone.
</span><span class="c1"></span>	<span class="nx">z</span> <span class="o">*</span><span class="nx">intern</span><span class="p">.</span><span class="nx">Value</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="option-5-uint128-type">Option 5: uint128 type</h2>
<p>Finally, Brad replaces the <code>uint64</code> pair in <a href="https://github.com/inetaf/netaddr/commit/318330f177ab307858b73763bf7e8715db66a4a5"> <code>318330f177</code> </a> with a custom <code>uint128</code> type.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">uint128</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">uint64</span>

<span class="kd">type</span> <span class="nx">IP</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">addr</span> <span class="nx">uint128</span>
	<span class="nx">z</span>    <span class="o">*</span><span class="nx">intern</span><span class="p">.</span><span class="nx">Value</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>But the Go compiler has <a href="https://github.com/golang/go/issues/24416">problems</a> with allocating memory, so Brad again in <a href="https://github.com/inetaf/netaddr/commit/bf0e22f9f32fdeb31cd4c253c852708915d2c89a"> <code>bf0e22f9f3</code> </a> modified the definition of <code>uint128</code> in</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">uint128</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">hi</span> <span class="kt">uint64</span>
	<span class="nx">lo</span> <span class="kt">uint64</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The above is the full content of the article. The new net/netip package will follow the Go 1.18 release, look forward to it 😚 .</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/golang/">golang</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-01/go-text-image/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Go language implementation of text to image</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-01/go-http-server-timeout/">
            <span class="next-text nav-default">Go HTTP Service Timeout Control</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
