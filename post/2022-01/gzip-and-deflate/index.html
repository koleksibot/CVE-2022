<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Gzip format and DEFLATE compression algorithm - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="1. Introduction When you type tar -zcf src.tar.gz src, you can package all the files under src into a tar.gz format. Here &amp;ldquo;tar&amp;rdquo; is the archive format, which combines multiple files into a single file, and &amp;ldquo;gz&amp;rdquo; refers to the gzip compression format, which uses the DEFLATE algorithm to compress. As the most widely used lossless compression algorithm, how does DEFLATE work and what are the principles behind it? In this article, we will discuss this issue." /><meta name="keywords" content="Gzip, Deflate" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-01/gzip-and-deflate/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Gzip format and DEFLATE compression algorithm" />
<meta property="og:description" content="1. Introduction When you type tar -zcf src.tar.gz src, you can package all the files under src into a tar.gz format. Here &ldquo;tar&rdquo; is the archive format, which combines multiple files into a single file, and &ldquo;gz&rdquo; refers to the gzip compression format, which uses the DEFLATE algorithm to compress. As the most widely used lossless compression algorithm, how does DEFLATE work and what are the principles behind it? In this article, we will discuss this issue." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-01/gzip-and-deflate/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-01-04T12:02:16+08:00" />
<meta property="article:modified_time" content="2022-01-04T12:02:16+08:00" />

<meta itemprop="name" content="Gzip format and DEFLATE compression algorithm">
<meta itemprop="description" content="1. Introduction When you type tar -zcf src.tar.gz src, you can package all the files under src into a tar.gz format. Here &ldquo;tar&rdquo; is the archive format, which combines multiple files into a single file, and &ldquo;gz&rdquo; refers to the gzip compression format, which uses the DEFLATE algorithm to compress. As the most widely used lossless compression algorithm, how does DEFLATE work and what are the principles behind it? In this article, we will discuss this issue."><meta itemprop="datePublished" content="2022-01-04T12:02:16+08:00" />
<meta itemprop="dateModified" content="2022-01-04T12:02:16+08:00" />
<meta itemprop="wordCount" content="3746">
<meta itemprop="keywords" content="gzip,deflate," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Gzip format and DEFLATE compression algorithm"/>
<meta name="twitter:description" content="1. Introduction When you type tar -zcf src.tar.gz src, you can package all the files under src into a tar.gz format. Here &ldquo;tar&rdquo; is the archive format, which combines multiple files into a single file, and &ldquo;gz&rdquo; refers to the gzip compression format, which uses the DEFLATE algorithm to compress. As the most widely used lossless compression algorithm, how does DEFLATE work and what are the principles behind it? In this article, we will discuss this issue."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Gzip format and DEFLATE compression algorithm</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-01-04 12:02:16 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 3746 words </span>
          <span class="more-meta"> 18 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#1-introduction">1. Introduction</a></li>
        <li><a href="#2-lz77-algorithm">2. LZ77 Algorithm</a>
          <ul>
            <li><a href="#21-basic-principles">2.1 Basic principles</a></li>
            <li><a href="#22-using-hash-tables">2.2 Using Hash Tables</a></li>
            <li><a href="#23-sliding-windows">2.3 Sliding windows</a></li>
            <li><a href="#24-lazy-matching">2.4 lazy matching</a></li>
          </ul>
        </li>
        <li><a href="#3-huffman-encoding">3. Huffman encoding</a>
          <ul>
            <li><a href="#31-prefix-encoding">3.1 Prefix encoding</a></li>
            <li><a href="#32-encoding-distance-and-length">3.2 Encoding distance and length</a></li>
            <li><a href="#32-storage-of-huffman-encoding-tables">3.2 Storage of Huffman encoding tables</a></li>
          </ul>
        </li>
        <li><a href="#4-the-gzip-format">4. The Gzip format</a>
          <ul>
            <li><a href="#41-uncompressed-blocks">4.1 Uncompressed blocks</a></li>
            <li><a href="#42-compression-blocks">4.2 Compression blocks</a></li>
          </ul>
        </li>
        <li><a href="#5-summary">5. Summary</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="1-introduction">1. Introduction</h2>
<p>When you type <code>tar -zcf src.tar.gz src</code>, you can package all the files under <code>src</code> into a tar.gz format. Here &ldquo;tar&rdquo; is the archive format, which combines multiple files into a single file, and &ldquo;gz&rdquo; refers to the gzip compression format, which uses the DEFLATE algorithm to compress. As the most widely used lossless compression algorithm, how does DEFLATE work and what are the principles behind it? In this article, we will discuss this issue.</p>
<p>DEFLATE combines the LZ77 algorithm with Huffman coding, designed by Phil Katz and standardized by <a href="https://tools.ietf.org/html/rfc1951">RFC1951</a>. This paper is a summary of my research on <a href="https://tools.ietf.org/html/rfc1951">RFC1951</a> and <a href="http://www.zlib.net/">zlib</a>, introducing first the LZ77 algorithm, then the role of Huffman encoding in DEFLATE, and finally the Finally, we introduce the format of gzip.</p>
<h2 id="2-lz77-algorithm">2. LZ77 Algorithm</h2>
<p>J. Ziv and A. Lempel published a paper in 1977 called <a href="https://ieeexplore.ieee.org/abstract/document/1055714/">A Universal Algorithm for Sequential Data Compression</a>, which proposed a universal algorithm for compressing sequential data. This algorithm became known as the LZ77 algorithm. In fact, the DEFLATE algorithm uses a different version of LZ77 than the original, so here we use the one in DEFLATE.</p>
<h3 id="21-basic-principles">2.1 Basic principles</h3>
<p>The LZ77 compression algorithm takes advantage of the fact that there are always a lot of duplicates in the files we use. It tries to find as many duplicates as possible in the file, and then replaces them with a marker that clearly indicates where they occur. As an example, take the first paragraph of the <em>Gettysburg Address</em>:</p>
<blockquote>
<p>Four score and seven years ago our fathers brought forth, on this continent, a new nation, conceived in Liberty, and dedicated to the proposition that all men are created equal.</p>
</blockquote>
<p>We can find quite a few duplicate fragments. We specify that whenever more than two characters are duplicated, the duplicate token <code>&lt;d,l&gt;</code> is used in its place. <code>&lt;d,l&gt;</code> means that the string at this position is equivalent to a string of length <code>l</code> before the <code>d</code> character. So the above can be expressed as:</p>
<blockquote>
<p>Four score and seven years ago &lt;30,4&gt;fathe&lt;16,3&gt;brought forth, on this continent, a new nation,&lt;25,4&gt;ceived in Liberty&lt;36,3&gt;&lt;102,3&gt;dedicat&lt;26,3&gt;to&lt;69,3&gt;e proposi&lt;56,4&gt;&lt;85,3&gt;at all m&lt;138,3&gt;a&lt;152,3&gt;cre&lt;44,5&gt;equal.</p>
</blockquote>
<p>Well, you may have noticed that the result of this &ldquo;compression&rdquo; is even longer than the original. Don&rsquo;t worry, this is just a demonstration, and we&rsquo;ll see how to solve this problem later.</p>
<p>The simplest way to implement this algorithm is to iterate through the string, looking for duplicates in the preceding order for each character, and then finding the longest duplicate substring. This approach has a time complexity of $\mathrm{O}(n^2)$, which is inefficient, especially when working with large files. To improve efficiency, we use hash table and sliding window optimization.</p>
<h3 id="22-using-hash-tables">2.2 Using Hash Tables</h3>
<p>Sequential lookups are too slow, so we can use a hash table to improve efficiency. We use a hash table to map a string of length three to a list of all occurrences of the string. Compression scans the string from beginning to end. Suppose the next three characters are <code>XYZ</code> , first check if the string <code>XYZ</code> is in the hash table. If not, output the character <code>X</code> as is and move it to the next character. Otherwise, compare the string starting from the current position with all the strings starting from the position where <code>XYZ</code> appears, find the longest match of length N and output the duplicate marker, then move N characters backward. Whether or not a match is found in the hash table, the current position is inserted into the list mapped by <code>XYZ</code> in the hash table.</p>
<p>As an example, consider the string <code>abcabcdabcde</code> , the algorithm runs with the following steps:</p>
<ol>
<li>
<p>Scan to the 0th character <code>a</code>, the hash table is empty, output the character <code>a</code> as is, and insert the string <code>abc</code> into the hash table.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">hash table: {}
abcabcdabcde
^
output: a
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>Scanning to the 3rd character <code>a</code> , the hash table indicates that <code>abc</code> occurs at <code>0</code>. The longest match is <code>abc</code> , so the output is <code>&lt;3,3&gt;</code> . The current position is also inserted into the list of <code>abc</code> mappings.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">hash table: {&#34;abc&#34;:[0],&#34;bca&#34;:[1],&#34;cab&#34;:[2]}
abcabcdabcde
    ^
output: abc&lt;3,3&gt;
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>Scanning to the 7th character <code>a</code>, the hash table indicates that <code>abc</code> appears at <code>0</code>, <code>3</code>. Matching the current position in turn, <code>0</code> can only match <code>abc</code> , while <code>3</code> can match <code>abcd</code> , the longest match is <code>abcd</code> , so the output is <code>&lt;4,4&gt;</code> . The current position is also inserted into the list of <code>abc</code> mappings.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">hash table: {&#34;abc&#34;:[0,3],&#34;bca&#34;:[1],&#34;cab&#34;:[2],&#34;bcd&#34;:[4],&#34;cda&#34;:[5],&#34;dab&#34;:[6]}
abcabcdabcde
        ^
output: abc&lt;3,3&gt;d&lt;4,4&gt;
</code></pre></td></tr></table>
</div>
</div></li>
</ol>
<p>BTW, the implementation of this hash table in zlib is very clever and the details of its implementation are beyond the scope of this article. Anyone interested in the C language should check out this implementation.</p>
<h3 id="23-sliding-windows">2.3 Sliding windows</h3>
<p>Even with a hash table, overly long files can still cause efficiency problems. For this reason we use a sliding window, where duplicates are found only in the window. The length of the window is fixed, usually 32KB. In the zlib implementation, a buffer twice the size of the window is used, as shown below:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">|-------search-------+------lookahead-----|
                     ^
</code></pre></td></tr></table>
</div>
</div><p>Initially, the data to be compressed is filled into the buffer, and the pointer is located at the beginning of the buffer; the pointer then scans backwards to compress the data. We call the part scanned by the pointer the search area and the part not scanned the lookahead area. For each scanned character, the algorithm only looks for a match in the search area. When the lookahead area is not long enough (less than a fixed value), the algorithm moves the window to continue scanning for more data. This is done by copying the data from the second half of the buffer to the first half and moving the pointer, then reading in the new data in the second half of the buffer, and then updating the hash table as the location of the data changes.</p>
<h3 id="24-lazy-matching">2.4 lazy matching</h3>
<p>Sometimes this strategy does not give the best compression result. As an example, consider the string <code>abcbcdabcda</code>, which looks like this when the 6th character is scanned:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">hash table: {&#34;abc&#34;:[0],&#34;bcb&#34;:[1],&#34;cbc&#34;:[2],&#34;bcd&#34;:[3],&#34;cda&#34;:[4],&#34;dab&#34;:[5]}
abcbcdabcda
      ^
output: abcbcd&lt;6,3&gt;
</code></pre></td></tr></table>
</div>
</div><p>The hash table indicates that <code>abc</code> appears at 0, the longest match is <code>abc</code>, so <code>&lt;6,3&gt;</code> is output; the next <code>da</code> has no duplicates and is output as is. The result of the compression is <code>abcbcd&lt;6,3&gt;da</code> . However, a longer match <code>bcda</code> can be found in the preceding text at the 7th character position, and a better compression result would be <code>abcbcda&lt;4,4&gt;</code> .</p>
<p>To solve this problem, DEFLATE uses a strategy called <strong>inert matching</strong> to optimize. Whenever the algorithm finds a match of length N, it tries to find a longer match on the next character. Only if no longer match is found, a duplicate token is output for the current match; otherwise, the current match is discarded and a longer match is used. Note that inert matches can be triggered consecutively; if a longer match is found in one inert match, inert matching will continue until a longer match cannot be found on the next character.</p>
<p>Inert matching can improve compression, but it can slow down compression. Runtime parameters control inert matching, which is only triggered if the current match is not long enough, i.e., if it is less than a configured value. This value can be adjusted depending on whether compression rate or speed is preferred, or inertia matching can be turned off.</p>
<h2 id="3-huffman-encoding">3. Huffman encoding</h2>
<p>It would be silly if we actually used a format like <code>&lt;d,l&gt;</code> to represent repetitive content. First, it takes up so much space that the <em>Gettysburg Address</em> in section 2.1, which is &ldquo;compressed&rdquo; in this way, is longer than even the original text. Secondly, this format turns the brackets into special characters, and you have to escape them somehow. So how do you represent the distance and length of the repeated parts? DEFLATE&rsquo;s approach is to break the old order and create a new one - to re-encode the data using Huffman encoding.</p>
<p>Huffman encoding was introduced by American computer scientist David A. Huffman in 1952, and is a prefix encoding constructed from the frequency of characters. Unlike our usual fixed-bit encoding (8 bits per character), Huffman encoding may have different bits for each character, but can clearly distinguish each character without any ambiguity.</p>
<h3 id="31-prefix-encoding">3.1 Prefix encoding</h3>
<p>How is it that each character has a different number of bits but can be clearly distinguished from the others? This is where prefix encoding comes in. To illustrate what prefix coding is, imagine that we are talking on the phone. The length of a phone number varies: there are three-digit numbers, such as 110, 119; five-digit numbers, such as 10086, 10010; 7- or 8-digit landlines, 11-digit mobile numbers, etc. However, the numbers are always correctly identified when dialed in sequence (no need to press the call button for landline off-hook dialing). This is because no phone number starts with 110 except for the police 110, and no landline number can be the prefix of a cell phone number. A phone number is a prefix code. So, although each character in Huffman encoding has a different number of bits, the shorter encoding will not be the prefix of the longer encoding. This ensures that there is no ambiguity in the Huffman encoding.</p>
<p>We use Huffman trees to construct Huffman encodings. As mentioned above, Huffman encodings have both long and short lengths, so it makes sense to keep the more frequently used characters short and the more frequently used characters long. Suppose we want to encode the characters a, b, c, d, and e, and their frequencies are shown in the following table:</p>
<table>
<thead>
<tr>
<th>character</th>
<th>times</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>1</td>
</tr>
<tr>
<td>b</td>
<td>4</td>
</tr>
<tr>
<td>c</td>
<td>4</td>
</tr>
<tr>
<td>d</td>
<td>3</td>
</tr>
<tr>
<td>e</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>The construction is very simple. We consider the frequency of characters as priority and put them in a minimum priority queue:</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/04/fafb9982d08a4e6dbed037bace2f477d.png" alt="image"></p>
<p>Then the first binary tree is constructed by popping the two lowest priority characters as children; the priority of the parent node is considered as the sum of the two byte priorities, and then the parent node is inserted into the queue:</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/04/35023cab142d41e28af4c049899ec510.png" alt="image"></p>
<p>Repeating this operation, we end up with a binary tree. This is the Huffman tree.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/04/937b1bebdb444e698da4ecc4882e2b65.png" alt="image"></p>
<p>If we encode the left branch of the tree as <code>0</code> and the right branch as <code>1</code>, then by traversing from the root node down to the leaf nodes, we can obtain the Huffman encoding of the corresponding characters. So we get the Huffman encoding table for the above example as:</p>
<table>
<thead>
<tr>
<th>character</th>
<th>code</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>000</td>
</tr>
<tr>
<td>b</td>
<td>10</td>
</tr>
<tr>
<td>c</td>
<td>11</td>
</tr>
<tr>
<td>d</td>
<td>01</td>
</tr>
<tr>
<td>e</td>
<td>001</td>
</tr>
</tbody>
</table>
<p>Suppose we have the string <code>badbec</code>, and after using Huffman encoding we get <code>10000011000111</code>. Decoding is also simple, read each bit in turn, use Huffman tree, start from the root node <code>0</code> to the left and <code>1</code> to the right, and output the corresponding character when it reaches the leaf node, then go back to the root node to continue scanning.</p>
<h3 id="32-encoding-distance-and-length">3.2 Encoding distance and length</h3>
<p>A byte has 8 bits, so we need 256 Huffman encodings from 0 to 255. The frequency of each character in the file is counted, and a Huffman tree is constructed to calculate these 256 codes. How do we represent the distance and length in the repetition mark with Huffman codes? This is how the DEFLATE algorithm does it:</p>
<ul>
<li>
<p>For distance, it has 30 codes from 0 to 29. The meaning of the distance codes is shown in the table below:</p>
<table>
<thead>
<tr>
<th>code</th>
<th>extra</th>
<th>distance</th>
<th></th>
<th>code</th>
<th>extra</th>
<th>distance</th>
<th></th>
<th>code</th>
<th>extra</th>
<th>distance</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td></td>
<td>10</td>
<td>4</td>
<td>33-48</td>
<td></td>
<td>20</td>
<td>9</td>
<td>1025-1536</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>2</td>
<td></td>
<td>11</td>
<td>4</td>
<td>49-64</td>
<td></td>
<td>21</td>
<td>9</td>
<td>1537-2048</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td>3</td>
<td></td>
<td>12</td>
<td>5</td>
<td>65-96</td>
<td></td>
<td>22</td>
<td>10</td>
<td>2049-3072</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>4</td>
<td></td>
<td>13</td>
<td>5</td>
<td>97-128</td>
<td></td>
<td>23</td>
<td>10</td>
<td>3073-4096</td>
</tr>
<tr>
<td>4</td>
<td>1</td>
<td>5,6</td>
<td></td>
<td>14</td>
<td>6</td>
<td>129-192</td>
<td></td>
<td>24</td>
<td>11</td>
<td>4097-6144</td>
</tr>
<tr>
<td>5</td>
<td>1</td>
<td>7,8</td>
<td></td>
<td>15</td>
<td>6</td>
<td>193-256</td>
<td></td>
<td>25</td>
<td>11</td>
<td>6145-8192</td>
</tr>
<tr>
<td>6</td>
<td>2</td>
<td>9-12</td>
<td></td>
<td>16</td>
<td>7</td>
<td>257-384</td>
<td></td>
<td>26</td>
<td>12</td>
<td>8193-12288</td>
</tr>
<tr>
<td>7</td>
<td>2</td>
<td>13-16</td>
<td></td>
<td>17</td>
<td>7</td>
<td>385-512</td>
<td></td>
<td>27</td>
<td>12</td>
<td>12289-16384</td>
</tr>
<tr>
<td>8</td>
<td>3</td>
<td>17-24</td>
<td></td>
<td>18</td>
<td>8</td>
<td>513-768</td>
<td></td>
<td>28</td>
<td>13</td>
<td>16385-24576</td>
</tr>
<tr>
<td>9</td>
<td>3</td>
<td>25-32</td>
<td></td>
<td>19</td>
<td>8</td>
<td>769-1024</td>
<td></td>
<td>29</td>
<td>13</td>
<td>24577-32768</td>
</tr>
</tbody>
</table>
<p>Each code represents one or more distances. When it represents multiple distances, it means that there are extra bits to indicate what the specific distance is. For example, if the next 6 bits of code 14 are 011010, then the distance is 129 + 0b011010 = 129 + 26 = 155. This distance code can represent a range of 1 to 32768.</p>
</li>
<li>
<p>For length, it shares the same encoding space as the normal characters. There are 286 codes in this space, ranging from 0 to 285. 0 to 255 are the normal character codes, 256 are the end of the compressed block, and 257 to 285 are the length codes. The meaning of the length codes is shown in the table below:</p>
<table>
<thead>
<tr>
<th>code</th>
<th>extra</th>
<th>length(s)</th>
<th></th>
<th>code</th>
<th>extra</th>
<th>length(s)</th>
<th></th>
<th>code</th>
<th>extra</th>
<th>length(s)</th>
</tr>
</thead>
<tbody>
<tr>
<td>257</td>
<td>0</td>
<td>3</td>
<td></td>
<td>267</td>
<td>1</td>
<td>15,16</td>
<td></td>
<td>277</td>
<td>4</td>
<td>67-82</td>
</tr>
<tr>
<td>258</td>
<td>0</td>
<td>4</td>
<td></td>
<td>268</td>
<td>1</td>
<td>17,18</td>
<td></td>
<td>278</td>
<td>4</td>
<td>83-98</td>
</tr>
<tr>
<td>259</td>
<td>0</td>
<td>5</td>
<td></td>
<td>269</td>
<td>2</td>
<td>19-22</td>
<td></td>
<td>279</td>
<td>4</td>
<td>99-114</td>
</tr>
<tr>
<td>260</td>
<td>0</td>
<td>6</td>
<td></td>
<td>270</td>
<td>2</td>
<td>23-26</td>
<td></td>
<td>280</td>
<td>4</td>
<td>115-130</td>
</tr>
<tr>
<td>261</td>
<td>0</td>
<td>7</td>
<td></td>
<td>271</td>
<td>2</td>
<td>27-30</td>
<td></td>
<td>281</td>
<td>5</td>
<td>131-162</td>
</tr>
<tr>
<td>262</td>
<td>0</td>
<td>8</td>
<td></td>
<td>272</td>
<td>2</td>
<td>31-34</td>
<td></td>
<td>282</td>
<td>5</td>
<td>163-194</td>
</tr>
<tr>
<td>263</td>
<td>0</td>
<td>9</td>
<td></td>
<td>273</td>
<td>3</td>
<td>35-42</td>
<td></td>
<td>283</td>
<td>5</td>
<td>195-226</td>
</tr>
<tr>
<td>264</td>
<td>0</td>
<td>10</td>
<td></td>
<td>274</td>
<td>3</td>
<td>43-50</td>
<td></td>
<td>284</td>
<td>5</td>
<td>227-257</td>
</tr>
<tr>
<td>265</td>
<td>1</td>
<td>11,12</td>
<td></td>
<td>275</td>
<td>3</td>
<td>51-58</td>
<td></td>
<td>285</td>
<td>0</td>
<td>258</td>
</tr>
<tr>
<td>266</td>
<td>1</td>
<td>13,14</td>
<td></td>
<td>276</td>
<td>3</td>
<td>59-66</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Similar to the distance codes, each code represents one or more lengths, and multiple lengths are indicated by extra bits followed by the specific length. Length codes can represent lengths in the range of 3 to 258.</p>
</li>
</ul>
<p>When decompressing, if the code is less than or equal to 255, it is considered a normal character and is output as is; if it is between 257 and 285, it means that a repeat mark is encountered, which means that the current code is the length and the next code is the distance. Decode the length and distance, then find the corresponding part in the decompression buffer and output it; if it is 256, then the compression block is finished.</p>
<h3 id="32-storage-of-huffman-encoding-tables">3.2 Storage of Huffman encoding tables</h3>
<p>As we know, Huffman encoding is constructed based on the frequency of characters. The frequency of characters varies from file to file, so the Huffman encoding is different. In order to decompress correctly, the Huffman encoding table must also be stored in the compression block. In this section we will discuss how to store this Huffman table in a minimum of space.</p>
<h4 id="321-representing-huffman-encoding-tables-as-length-sequences">3.2.1 Representing Huffman encoding tables as length sequences</h4>
<p>In order to store the Huffman encoding table efficiently, the DEFLATE algorithm specifies that the leaf nodes of each layer of the Huffman tree must be ordered from the leftmost side of the layer in order of the numerical size of the Huffman encoding; the internal nodes are arranged next. In addition, the characters in the same level should be arranged in the order of the character table (e.g., ASCII code table). Thus, the Huffman tree in Section 3.1 should be adjusted to:</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/04/ceee8f1b8f254967b7ac1f5531921507.png" alt="image"></p>
<p>The adjusted Huffman code table is :</p>
<table>
<thead>
<tr>
<th>character</th>
<th>code</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>110</td>
</tr>
<tr>
<td>b</td>
<td>00</td>
</tr>
<tr>
<td>c</td>
<td>01</td>
</tr>
<tr>
<td>d</td>
<td>10</td>
</tr>
<tr>
<td>e</td>
<td>111</td>
</tr>
</tbody>
</table>
<p>Note that the adjusted Huffman encoding does not affect the compression ratio: the length of each character encoding remains the same, and the encoding of the most frequently used characters is still the shortest. It is easy to see that encodings of the same length are incremental, and that the minimum value of an encoding of a certain length depends on the minimum value and number of encodings of the previous length. Let the minimum value of an encoding of length $i$ be $m_i$ and there are $n_i$; and let the minimum value of an encoding of length 0 be 0 and there are 0. Then it is easy to obtain</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/04/0e4126e6f6c54aaa930295e0ac0ce1aa.png" alt="image"></p>
<p>The &ldquo;$\ll$&rdquo; here means left shift. Thus, we only need to know the Huffman encoding length of each character to derive the Huffman encoding of all characters. For the above example, we just need to store the length sequence $&lt;3, 2, 2, 2, 2, 3&gt;$. When decompressing this sequence, we scan the sequence for the number of codes of each length, and find the minimum value of the codes of each length; codes of the same length are incremented sequentially, so we add one to the other to find the Huffman codes of all characters. In particular, a length of 0 means that the character does not appear in the compressed block and is excluded when constructing the Huffman code.</p>
<h4 id="322-encoding-length-sequences">3.2.2 Encoding length sequences</h4>
<p>Length sequences are prone to having consecutive repetitive values; and since there may be many unused characters in the file, there may also be many zeros. Therefore DEFLATE encodes the length sequence as shown below:</p>
<table>
<thead>
<tr>
<th>code</th>
<th>meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>0-15</td>
<td>Indicates length 0 to 15</td>
</tr>
<tr>
<td>16</td>
<td>The first length is repeated 3 to 6 times. The next two digits indicate exactly how many times to repeat, similar to the length and distance codes in Section 3.2.</td>
</tr>
<tr>
<td>17</td>
<td>Length 0 is repeated 3 to 10 times. The next 3 digits indicate exactly how many times to repeat.</td>
</tr>
<tr>
<td>18</td>
<td>Length 0 is repeated 11 to 138 times. The next 7 digits indicate exactly how many times to repeat.</td>
</tr>
</tbody>
</table>
<h4 id="323-compressing-huffman-encoding-tables-with-huffman-encoding">3.2.3 Compressing Huffman Encoding Tables with Huffman Encoding</h4>
<p>Representing the Huffman encoding table as a sequence of encoded lengths is already relatively compact, but the DEFLATE algorithm does not think it is enough. It decides to compress this encoded length sequence again using Huffman encoding. This step is a little bit more involved. In order to do this, we need to construct a Huffman encoding table for the encoding of the length sequence - 0 to 18 (however, this length sequence represents a Huffman encoding table, which means we are constructing a Huffman encoding table for a Huffman encoding table). The question arises, how to represent the Huffman encoding table of this Huffman encoding table? First, the DEFLATE algorithm defines a mystery array:</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/04/99c01c49c43d4eba8d67b9938a81fe31.png" alt="image"></p>
<p>Since it is possible that not all lengths will be used, we will first identify the first k codes in the array with a number. For example, if only length sequence codes 2, 3, 4, 16, 17 are used, then k = 16. The next k numbers will be $i$, with the first $i$ indicating the length of the <u>Huffman code</u> of <u>Length Sequence Code</u> $A[i]$, and 0 indicating that the corresponding code is not used. Since the Huffman encoding length of each character is known, the Huffman encoding of all characters can be deduced. This gives us the Huffman encoding table for the length sequence of <u>encoding</u>.</p>
<p>In the compressed data, we first store the Huffman encoding table of the <u>encoded length sequence</u>, followed by the Huffman encoding data of the encoded length sequence. This way, we store the Huffman encoding table of the compressed data in a small space in the compressed block.</p>
<h2 id="4-the-gzip-format">4. The Gzip format</h2>
<p>Finally, let&rsquo;s briefly describe the gzip format.</p>
<p>The Gzip format consists of a header, a compression body, and a tail. The header contains basic information about the file, the time, the compression method, the operating system, etc. The tail contains the checksum and the original size. This information is not relevant to the compression algorithm, so we will not discuss it in depth here, but you can refer to <a href="https://tools.ietf.org/html/rfc1952">RFC1952</a>.</p>
<p>The compressed body consists of one or more <strong>blocks</strong>. Each block is of variable length, and has its own compression and encoding scheme. A block may start or end at any bit, without aligning the bytes. It is important to note that the distance indicated by the repeat marker may span the block.</p>
<p>All of the above are compressed using dynamic Huffman encoding. In fact, a block may also be compressed using static Huffman encoding or not. Blocks compressed with static Huffman encoding are compressed and decompressed using the algorithm&rsquo;s predefined Huffman encoding, without storing the Huffman encoding table.</p>
<p>All blocks start with a 3-bit header and contain the following data:</p>
<table>
<thead>
<tr>
<th>name</th>
<th>length</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>BFINAL</td>
<td>1 bit</td>
<td>Identifies if this is the last block</td>
</tr>
<tr>
<td>BTYPE</td>
<td>2 bits</td>
<td>Identifies the type. 00: uncompressed; 01: static Huffman encoding compression; 10: dynamic Huffman encoding compression; 11: reserved</td>
</tr>
</tbody>
</table>
<h3 id="41-uncompressed-blocks">4.1 Uncompressed blocks</h3>
<p>The uncompressed block contains the following data (immediately after the header):</p>
<table>
<thead>
<tr>
<th>name</th>
<th>length</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>LEN</td>
<td>2 bits</td>
<td>block data length</td>
</tr>
<tr>
<td>NLEN</td>
<td>2 bits</td>
<td>LEN&rsquo;s complement</td>
</tr>
<tr>
<td>DATA</td>
<td>LEN bytes</td>
<td>valid data</td>
</tr>
</tbody>
</table>
<h3 id="42-compression-blocks">4.2 Compression blocks</h3>
<p>The dynamic Huffman encoding compression block contains the following data (immediately after the header):</p>
<table>
<thead>
<tr>
<th>name</th>
<th>length</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>HLIT</td>
<td>5 bits</td>
<td>Maximum length/character encoding minus 257. Since not all length encodings are used, the maximum length/character encoding is marked here (lengths share the same encoding space as normal characters).</td>
</tr>
<tr>
<td>HDIST</td>
<td>5 bits</td>
<td>maximum value of distance encoding minus 1. Same principle as above.</td>
</tr>
<tr>
<td>HCLEN</td>
<td>4 bits</td>
<td>k minus 4 in Section 3.2.3. Identifies that the first few codes in the mystery array are used.</td>
</tr>
<tr>
<td>The Huffman encoding table of the encoded length sequence</td>
<td>(HCLEN + 4) * 3 bits</td>
<td>k numbers as described in Section 3.2.3. Since there are only 19 length sequences encoded, 3 bits per digit is sufficient.</td>
</tr>
<tr>
<td>The Huffman encoding table for length/character encoding</td>
<td>variable</td>
<td>is used to represent the Huffman encoding table for length/character encoding based on the length sequence encoded in the Huffman encoding table above.</td>
</tr>
<tr>
<td>Distance-encoded Huffman table</td>
<td>variable</td>
<td>A sequence of lengths encoded by the above Huffman table, used to represent the distance-encoded Huffman table.</td>
</tr>
<tr>
<td>DATA</td>
<td>variable</td>
<td>valid compressed data</td>
</tr>
<tr>
<td>256 end-tags</td>
<td>variable</td>
<td>identify the end of the block</td>
</tr>
</tbody>
</table>
<p>Static compression blocks are relatively simple, with the header followed by the valid compressed data, and finally a 256 end marker.</p>
<h2 id="5-summary">5. Summary</h2>
<p>The DEFLATE algorithm is a very complex method to compress data as much as possible. Due to time and effort constraints, I have not read the zlib source code carefully, so this article is mainly based on RFC1951, and the implementation details are less discussed. If there are any errors or ambiguities, please feel free to correct them. For those who are interested in the implementation, please refer to the zlib source code.</p>
<p>BTW, there is a simple and efficient implementation of the LZ77 algorithm: <a href="https://github.com/ariya/FastLZ">ariya/FastLZ</a>. FastLZ does not use Huffman encoding, only LZ77. It compresses text fast and well, but the compression ratio of binary data is not ideal. The FastLZ implementation is relatively simple and is recommended for reading.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/gzip/">gzip</a>
          <a href="/tags/deflate/">deflate</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-01/lua53-environment/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Why there are no more global variables in Lua 5.3</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-01/cloudflare-free-https/">
            <span class="next-text nav-default">Build HTTPS service for free with Cloudflare</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
