<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Parsing syntax using LPeg - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="LPeg is a pattern matching library for Lua. When I was first introduced to LPeg, I thought it was just another form of regular expression; I found out that it is much more powerful than regular expressions, and can easily match complex patterns that are difficult to match with regular expressions, and even parse syntax. In fact, LPeg is Parsing Expression Grammars for Lua, which is designed to parse grammars. LPeg makes it easy to parse all kinds of grammars, for example in 400 lines of code parsing Lua source code into abstract syntax trees." /><meta name="keywords" content="Lua, Lpeg" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-01/lpeg/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Parsing syntax using LPeg" />
<meta property="og:description" content="LPeg is a pattern matching library for Lua. When I was first introduced to LPeg, I thought it was just another form of regular expression; I found out that it is much more powerful than regular expressions, and can easily match complex patterns that are difficult to match with regular expressions, and even parse syntax. In fact, LPeg is Parsing Expression Grammars for Lua, which is designed to parse grammars. LPeg makes it easy to parse all kinds of grammars, for example in 400 lines of code parsing Lua source code into abstract syntax trees." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-01/lpeg/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-01-03T11:47:07+08:00" />
<meta property="article:modified_time" content="2022-01-03T11:47:07+08:00" />

<meta itemprop="name" content="Parsing syntax using LPeg">
<meta itemprop="description" content="LPeg is a pattern matching library for Lua. When I was first introduced to LPeg, I thought it was just another form of regular expression; I found out that it is much more powerful than regular expressions, and can easily match complex patterns that are difficult to match with regular expressions, and even parse syntax. In fact, LPeg is Parsing Expression Grammars for Lua, which is designed to parse grammars. LPeg makes it easy to parse all kinds of grammars, for example in 400 lines of code parsing Lua source code into abstract syntax trees."><meta itemprop="datePublished" content="2022-01-03T11:47:07+08:00" />
<meta itemprop="dateModified" content="2022-01-03T11:47:07+08:00" />
<meta itemprop="wordCount" content="2832">
<meta itemprop="keywords" content="lua,lpeg," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Parsing syntax using LPeg"/>
<meta name="twitter:description" content="LPeg is a pattern matching library for Lua. When I was first introduced to LPeg, I thought it was just another form of regular expression; I found out that it is much more powerful than regular expressions, and can easily match complex patterns that are difficult to match with regular expressions, and even parse syntax. In fact, LPeg is Parsing Expression Grammars for Lua, which is designed to parse grammars. LPeg makes it easy to parse all kinds of grammars, for example in 400 lines of code parsing Lua source code into abstract syntax trees."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Parsing syntax using LPeg</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-01-03 11:47:07 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 2832 words </span>
          <span class="more-meta"> 14 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li>
          <ul>
            <li><a href="#pegparsing-expression-grammars">PEG(Parsing Expression Grammars)</a></li>
            <li><a href="#lpeg">LPeg</a></li>
            <li><a href="#applications">Applications</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>LPeg is a pattern matching library for Lua. When I was first introduced to LPeg, I thought it was just another form of regular expression; I found out that it is much more powerful than regular expressions, and can easily match complex patterns that are difficult to match with regular expressions, and even parse syntax. In fact, LPeg is Parsing Expression Grammars for Lua, which is designed to parse grammars. LPeg makes it easy to parse all kinds of grammars, for example in 400 lines of code <a href="https://github.com/andremm/lua-parser">parsing Lua source code into abstract syntax trees</a>. With it, static code analysis and customization of DSL (Domain Specific Language) will be a snap.</p>
<p>This article will not go into detail about every function and operator in LPeg, which is clear from the <a href="http://www.inf.puc-rio.br/~roberto/lpeg/">official documentation</a>; it will focus on the matching mechanism of LPeg and how to use it. If you are new to PEG and LPeg, you can read this article first, and refer to the official documentation when you need to understand the detailed usage in practice. Since LPeg is a Lua implementation of PEG, let&rsquo;s start with PEG.</p>
<h3 id="pegparsing-expression-grammars">PEG(Parsing Expression Grammars)</h3>
<p>When it comes to pattern matching, regular expressions are the first thing that comes to mind for many students. For simple patterns, regular expressions are convenient; however, when the situation becomes complex, regular expressions are out of hand. Can you imagine using regular expressions to match conditional expressions? In addition, regular expressions have efficiency problems, and some strange regular expressions can lead to repeated backtracking, even to exponential time complexity. In order to match complex patterns, we need more powerful tools, and PEG is one of them.</p>
<h4 id="introduction">Introduction</h4>
<p>PEG was first proposed in a 2004 MIT paper <a href="http://pdos.csail.mit.edu/papers/parsing:popl04.pdf">Parsing Expression Grammars: A Recognition-Based Syntactic Foundation</a>. It is very much like CFG (Context-Free Grammars), except that CFG is a description of the language, while PEG is a parsing of the language, a distinction we will see later. <a href="http://www.lua.org/manual/5.3/manual.html#9">The last section of the Lua documentation</a> has a complete grammar described in BNF (Backus Naur Form), which is a representation of CFG. Here is a self-description of the syntax in PEG:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">grammar     &lt;-  (nonterminal ’&lt;-’ sp pattern)+
pattern     &lt;-  alternative (’/’ sp alternative)*
alternative &lt;-  ([!&amp;]? sp suffix)+
suffix      &lt;-  primary ([*+?] sp)*
primary     &lt;-  ’(’ sp pattern ’)’ sp / ’.’ sp / literal /
                charclass / nonterminal !’&lt;-’
literal     &lt;-  [’] (![’] .)* [’] sp
charclass   &lt;-  ’[’ (!’]’ (. ’-’ . / .))* ’]’ sp
nonterminal &lt;-  [a-zA-Z]+ sp
sp          &lt;-  [ \t\n]*
</code></pre></td></tr></table>
</div>
</div><p>As shown in line 1, the PEG syntax consists of more than one rule, each consisting of <strong>nonterminal</strong> and <strong>pattern</strong> separated by <code>&lt;-</code>. The next rules indicate what the nonterminal and pattern consist of, in turn, down to the character level. Some of these rules are similar to regular expressions, for example <code>+</code> means the preceding pattern is repeated more than 1 time, <code>*</code> means it is repeated more than 0 times, and <code>? </code> indicates 1 or 0 occurrences (see suffix in line 4); <code>[]</code> indicates a collection of characters (see charclass in line 8), etc. To eliminate ambiguity, literals need to be placed between <code>''</code> (see literal, line 7). There are also <code>! </code> means no match for the immediately following pattern (match succeeds if and only if the subsequent pattern fails), and <code>&amp;</code> means match the immediately following pattern without consuming the input (see line 3, alternative).</p>
<p>As shown in line 2, each pattern can contain multiple <strong>alternatives</strong>, separated by a slash <code>/</code>, a bit like <code>|</code> in BNF. For example, line 5 represents a non-terminal primary pattern that can be wrapped in parentheses, or a wildcard character <code>. </code>, or a literal, or a character class, or a non-terminal character that is not immediately followed by <code>&lt;-</code>. Unlike CFG, these options are sequential, and only the first option that fails to match will match the next option. Because PEG is used to describe a top-down parsing syntax, the ordered options allow for unambiguous parsing.</p>
<h4 id="limited-backtracking">Limited backtracking</h4>
<p>A major advantage of PEG is that it can restrict backtracking to a single matching rule. Once a selection is made, it is not changed by the failure of subsequent matches. For example, consider the following syntax:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">S   &lt;-  A B
A   &lt;-  E1 / E2 / E3
B   &lt;-  ...
</code></pre></td></tr></table>
</div>
</div><p>When we try to make a string match S, we match A and then B. When we match A, since A has three options, we first try to match pattern E1, and if the match fails, we backtrack, then match E2, and so on. Once any of the options are matched, the rule is not backtracked. For example, if E2 is selected as the match for A, if B fails to match next, then the whole pattern fails, and B&rsquo;s failure does not cause A to be reselected. This feature ensures that PEGs are efficient and do not have infinite backtracking like regular expressions.</p>
<h4 id="greedy-matching-and-non-greedy-matching">Greedy Matching and Non-Greedy Matching</h4>
<p>Students who know regular expressions should be familiar with greedy and non-greedy matching. For example, matching the string <code>abcdXefghXijk</code> , using the regular expression <code>/. *X/</code> will match to the second <code>X</code>, which is a greedy match, and <code>. *</code> will match as many characters as possible; while using <code>/. *?X/</code> will match to the first <code>X</code>, which is a non-greedy match, <code>. *? </code> will match as few characters as possible. This is convenient, but not elegant: for example, <code>/. *?X/</code> , <code>. *</code> is meant to match any character above 0, and <code>X</code> is obviously included in the wildcard <code>. </code>; just because it is followed by an <code>X</code>, <code>/. *?X/</code> stops at the first <code>X</code>. <code>/. *X/</code> is even stranger: it has to stop at the last <code>X</code> it encounters! This approach to regular expressions is intuitive, but logically odd.</p>
<p>The PEG approach is much simpler. PEGs always perform a greedy blind match, that is, they match as many characters as possible, regardless of other patterns before or after them. For example, the following PEG</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">S   &lt;-  .* ’X’
</code></pre></td></tr></table>
</div>
</div><p>It looks similar to the regular expression <code>/. *X/</code> , but it doesn&rsquo;t actually match any string. Because <code>. *</code> will match all characters until the end of the string; once it reaches the end of the string, there are no characters to match, so the match fails.</p>
<p>To achieve the regular expression <code>/. *?X/</code>, note that <code>. </code> will match any character, so to make it stop at the first <code>X</code>, we just need to change the match any character to match any character other than <code>X</code>. Use the following PEG:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">S   &lt;-  <span class="o">(</span>!’X’ .<span class="o">)</span>* ’X’
</code></pre></td></tr></table>
</div>
</div><p>Due to the presence of <code>!' X'</code>, the match will fail if <code>X</code> is encountered, so that <code>! X' . </code> will match any character other than <code>X</code>. Such a PEG is longer than a regular expression, but the logic is clearer.</p>
<p>We can also use recursion to achieve the same effect: the following PEG will do:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">S   &lt;-  ’X’ / . S
</code></pre></td></tr></table>
</div>
</div><p>The string is scanned sequentially when matching. For each character, it first tries to match <code>'X'</code> , and if the match fails, it matches <code>. S</code> . This pattern will match any character, and then match the pattern S itself &ndash; that is, do the same for the next character. Until the character <code>X</code> is encountered, the match ends.</p>
<p><code>/. *X/</code> is a little more interesting. It requires the match to stop at the last <code>X</code> of the string. How do we know where the last <code>X</code> is without scanning the whole string? We need the following PEG:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">S   &lt;-  . S / ’X’
</code></pre></td></tr></table>
</div>
</div><p>For each character, it will first try to match <code>. S</code> . where <code>. </code> will match any character, and then match the pattern <code>S</code> itself, i.e. do the same for the next character. This continues until the last character of the string:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">abcdXefghXijk
            ^
            match <span class="sb">`</span>k<span class="sb">`</span> with <span class="sb">`</span>. S / ’X’<span class="sb">`</span>
</code></pre></td></tr></table>
</div>
</div><p>When <code>k</code> matches <code>. S</code>, the wildcard character <code>. </code> will match the character <code>k</code>, and then the next character - the end of the string - will match <code>S</code>, which will naturally fail. So the optional <code>. S</code> fails, PEG will backtrack and try to match <code>'X'</code>, which will also fail. That means <code>k</code> matches <code>. S / 'X'</code> fails. Will this cause the whole string to fail? Of course not! Note that the whole operation is recursive, and the last character <code>k</code> matches the pattern <code>. S / 'X'</code> , and also the penultimate character <code>j</code> matches the pattern <code>. S / 'X'</code> in <code>S</code> . So the PEG will backtrack again, and so on, until the last character <code>X</code> .</p>
<h4 id="other-mechanisms">Other mechanisms</h4>
<p>PEGs do not require a regular expression like <code>^</code> or <code>$</code> to indicate the beginning or end of a string. First of all, PEG will always match from the beginning of the string; for the end of the string, use the pattern <code>! </code>, which does not match a single character - this condition is only met at the end of the string.</p>
<p>As mentioned above, <code>&amp;</code> means matching the pattern immediately after but not consuming the input. For example, <code>'a' 'a'</code> cannot match the string <code>&quot;a&quot;</code>, because it requires two consecutive <code>a's, but </code>&amp;&lsquo;a&rsquo; &lsquo;a '&rsquo; matches it, because when <code>&amp;'a'</code> matches the character <code>a</code>, the input is not consumed and the pointer is not moved back, so the latter pattern <code>'a'</code> can still match it.</p>
<p>In short, although PEG is less intuitive than regular expressions, its rules are simpler and closer to the essence of pattern matching.</p>
<h3 id="lpeg">LPeg</h3>
<p>LPeg is a Lua implementation of PEG. LPeg does not implement the syntax of PEG, instead, it uses Lua features to implement a set of functions, objects, and construct patterns by overloading operators. Let&rsquo;s look at some of the basic functions and operations of LPeg:</p>
<table>
<thead>
<tr>
<th>Operator</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>lpeg.P(string)</code></td>
<td>Match the literal <code>string</code> . Equivalent to <code>''</code> in PEG</td>
</tr>
<tr>
<td><code>lpeg.P(n)</code></td>
<td>Match n arbitrary characters</td>
</tr>
<tr>
<td><code>lpeg.S(string)</code></td>
<td>Matches any character in <code>string</code>. Equivalent to <code>[]</code> in PEG</td>
</tr>
<tr>
<td><code>lpeg.R(&quot;xy&quot;)</code></td>
<td>Matches all characters in the range <code>x</code> to <code>y</code>. Equivalent to <code>[x-y]</code> in PEG</td>
</tr>
<tr>
<td><code>patt ^ n</code></td>
<td>Repeat <code>patt</code> at least <code>n</code> times</td>
</tr>
<tr>
<td><code>patt ^ -n</code></td>
<td>Repeat <code>patt</code> up to <code>n</code> times</td>
</tr>
<tr>
<td><code>patt1 * patt2</code></td>
<td><code>patt1</code> is immediately followed by <code>patt2</code> . Equivalent to <code>patt1 patt2</code> in PEG</td>
</tr>
<tr>
<td><code>patt1 + patt2</code></td>
<td>Sequential selection. Match <code>patt1</code> or <code>patt2</code> . Equivalent to <code>patt1 / patt2</code> in PEG</td>
</tr>
<tr>
<td><code>patt1 - patt2</code></td>
<td>Only if <code>patt2</code> does not match, then <code>patt1</code> is matched. Equivalent to <code>!patt2 patt1</code> in PEG. can be interpreted as a difference set</td>
</tr>
<tr>
<td><code>-patt</code></td>
<td>Equivalent to <code>&quot;&quot; - patt</code> . does not match <code>patt</code> . Equivalent to <code>!patt</code> in PEG</td>
</tr>
<tr>
<td><code>#patt</code></td>
<td>Matches <code>patt</code> but does not consume input. Equivalent to <code>&amp;patt</code> in PEG</td>
</tr>
</tbody>
</table>
<p>As you can see, LPeg is much the same as PEG, but in a different form. The methods <code>lpeg.P</code>, <code>lpeg.S</code>, <code>lpeg.R</code>, etc. all return pattern objects, which override operators and can perform various operations with other patterns, the result of which is still pattern. For example, the aforementioned <code>S &lt;- (!' X' .) * 'X'</code> can be written like this using LPeg:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="kd">local</span> <span class="n">lpeg</span> <span class="o">=</span> <span class="n">require</span> <span class="s2">&#34;lpeg&#34;</span>
<span class="kd">local</span> <span class="n">S</span> <span class="o">=</span> <span class="p">(</span><span class="n">lpeg.P</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="s2">&#34;X&#34;</span><span class="p">)</span> <span class="o">^</span> <span class="mi">0</span> <span class="o">*</span> <span class="s2">&#34;X&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>Calling the <code>match</code> method of pattern matches a string, and returns the position of the end of the match:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="n">S</span><span class="p">:</span><span class="n">match</span><span class="p">(</span><span class="s2">&#34;abcdXefghXijk&#34;</span><span class="p">)</span> <span class="c1">--&gt; 6</span>
</code></pre></td></tr></table>
</div>
</div><p>How to implement <code>S &lt;- 'X' / . S</code> recursive pattern? <code>lpeg.P</code> also supports passing in a table. This table contains a series of keys <code>k = v</code> , the keys representing a non-terminator, and the values defining the pattern. Use <code>lpeg.V</code> to refer to other non-terminals. It is also required that the first value of the table <code>table[1]</code> be the initial symbol, since Lua&rsquo;s table is unordered. For example, <code>S &lt;- 'X' / . S</code> can be written like this with LPeg:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="kd">local</span> <span class="n">lpeg</span> <span class="o">=</span> <span class="n">require</span> <span class="s2">&#34;lpeg&#34;</span>
<span class="kd">local</span> <span class="n">P</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">lpeg.P</span><span class="p">,</span> <span class="n">lpeg.V</span>

<span class="kd">local</span> <span class="n">S</span> <span class="o">=</span> <span class="n">P</span><span class="p">{</span><span class="s2">&#34;S&#34;</span><span class="p">,</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">P</span><span class="s2">&#34;X&#34;</span> <span class="o">+</span> <span class="n">P</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">V</span><span class="s2">&#34;S&#34;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Here is a slightly more complex example:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="kd">local</span> <span class="n">lpeg</span> <span class="o">=</span> <span class="n">require</span> <span class="s2">&#34;lpeg&#34;</span>
<span class="kd">local</span> <span class="n">P</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">lpeg.P</span><span class="p">,</span> <span class="n">lpeg.V</span>

<span class="kd">local</span> <span class="n">S</span> <span class="o">=</span> <span class="n">P</span><span class="p">{</span><span class="s2">&#34;S&#34;</span><span class="p">,</span>
    <span class="n">S</span> <span class="o">=</span> <span class="s2">&#34;a&#34;</span> <span class="o">*</span> <span class="n">V</span><span class="s2">&#34;B&#34;</span> <span class="o">+</span> <span class="s2">&#34;b&#34;</span> <span class="o">*</span> <span class="n">V</span><span class="s2">&#34;A&#34;</span> <span class="o">+</span> <span class="s2">&#34;&#34;</span><span class="p">;</span>
    <span class="n">A</span> <span class="o">=</span> <span class="s2">&#34;a&#34;</span> <span class="o">*</span> <span class="n">V</span><span class="s2">&#34;S&#34;</span> <span class="o">+</span> <span class="s2">&#34;b&#34;</span> <span class="o">*</span> <span class="n">V</span><span class="s2">&#34;A&#34;</span> <span class="o">*</span> <span class="n">V</span><span class="s2">&#34;A&#34;</span><span class="p">;</span>
    <span class="n">B</span> <span class="o">=</span> <span class="s2">&#34;b&#34;</span> <span class="o">*</span> <span class="n">V</span><span class="s2">&#34;S&#34;</span> <span class="o">+</span> <span class="s2">&#34;a&#34;</span> <span class="o">*</span> <span class="n">V</span><span class="s2">&#34;B&#34;</span> <span class="o">*</span> <span class="n">V</span><span class="s2">&#34;B&#34;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>This is equivalent to the following PEG:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="n">S</span>   <span class="o">&lt;-</span>  <span class="err">’</span><span class="n">a</span><span class="err">’</span> <span class="n">B</span> <span class="o">/</span> <span class="err">’</span><span class="n">b</span><span class="err">’</span> <span class="n">A</span> <span class="o">/</span> <span class="err">’’</span>
<span class="n">A</span>   <span class="o">&lt;-</span>  <span class="err">’</span><span class="n">a</span><span class="err">’</span> <span class="n">S</span> <span class="o">/</span> <span class="err">’</span><span class="n">b</span><span class="err">’</span> <span class="n">A</span> <span class="n">A</span>
<span class="n">B</span>   <span class="o">&lt;-</span>  <span class="err">’</span><span class="n">b</span><span class="err">’</span> <span class="n">S</span> <span class="o">/</span> <span class="err">’</span><span class="n">a</span><span class="err">’</span> <span class="n">B</span> <span class="n">B</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="capture">Capture</h4>
<p>It is too boring to only match strings and return positions. LPeg is much more than that, LPeg has powerful capturing capabilities. Here is a list of LPeg capture methods:</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>What it Produces</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>C(patt)</code></td>
<td>matches the pattern <code>patt</code> and captures it</td>
</tr>
<tr>
<td><code>Ct(patt)</code></td>
<td>puts all the captures generated by <code>patt</code> in a table</td>
</tr>
<tr>
<td><code>Cs(patt)</code></td>
<td>Takes all the matches in <code>patt</code> and splices them into a single string</td>
</tr>
<tr>
<td><code>Cc(values)</code></td>
<td>matches the empty string and treats the given value <code>values</code> as a capture</td>
</tr>
<tr>
<td><code>lpeg.Cp()</code></td>
<td>matches the empty string and captures the current position</td>
</tr>
<tr>
<td><code>Cf(patt, f)</code></td>
<td>Pass all the catches generated by <code>patt</code> into the function <code>f</code> in sequence, similar to the reduce operation. If <code>patt</code> produces catches $C_1, C_2, &hellip; , C_n$ , then $f(&hellip;. . f(f(C_1, C_2), C_3)&hellip; , C_n)$ , then $f(&hellip; . f(f(C_1, C_2), C_3)&hellip; , C_n)$ , with the final return value of the function as the capture</td>
</tr>
<tr>
<td><code>patt / string</code></td>
<td>replaces the result of <code>patt</code> with the string <code>string</code></td>
</tr>
<tr>
<td><code>patt / number</code></td>
<td>Take the nth capture of <code>patt</code>. If 0, no result is captured</td>
</tr>
<tr>
<td><code>patt / table</code></td>
<td>If the capture result of <code>patt</code> is <code>c</code>, then <code>table[c]</code> is the result of the capture</td>
</tr>
<tr>
<td><code>patt / function</code></td>
<td>Pass the result of <code>patt</code> into <code>function</code> and take its return value as the result of the capture</td>
</tr>
</tbody>
</table>
<p>It is important to note that the capture result is only generated if the corresponding pattern matches successfully. For example, the pattern <code>lpeg.C(lpeg.P &quot;a&quot; ^ -1)</code> will return the null string when matching a string that does not start with <code>a</code>.</p>
<p>This would be done, for example, by splitting a string by a specified character:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="kr">function</span> <span class="nf">split</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">sep</span><span class="p">)</span>
    <span class="n">sep</span> <span class="o">=</span> <span class="n">lpeg.P</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
    <span class="kd">local</span> <span class="n">elem</span> <span class="o">=</span> <span class="n">lpeg.C</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">sep</span><span class="p">)</span> <span class="o">^</span> <span class="mi">0</span><span class="p">)</span>
    <span class="kd">local</span> <span class="n">p</span> <span class="o">=</span> <span class="n">elem</span> <span class="o">*</span> <span class="p">(</span><span class="n">sep</span> <span class="o">*</span> <span class="n">elem</span><span class="p">)</span> <span class="o">^</span> <span class="mi">0</span>
    <span class="kr">return</span> <span class="n">p</span><span class="p">:</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="kr">end</span>
</code></pre></td></tr></table>
</div>
</div><p>where <code>1 - sep</code> matches any character that is not a separator, then <code>^ 0</code> makes it repeat more than 0 times; then <code>elem * (sep * elem) ^ 0</code> makes the split pattern repeat several times.</p>
<p>If you need to put the result in a table, just write it like this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="kr">function</span> <span class="nf">split</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">sep</span><span class="p">)</span>
    <span class="n">sep</span> <span class="o">=</span> <span class="n">lpeg.P</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
    <span class="kd">local</span> <span class="n">elem</span> <span class="o">=</span> <span class="n">lpeg.C</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">sep</span><span class="p">)</span> <span class="o">^</span> <span class="mi">0</span><span class="p">)</span>
    <span class="kd">local</span> <span class="n">p</span> <span class="o">=</span> <span class="n">lpeg.Ct</span><span class="p">(</span><span class="n">elem</span> <span class="o">*</span> <span class="p">(</span><span class="n">sep</span> <span class="o">*</span> <span class="n">elem</span><span class="p">)</span> <span class="o">^</span> <span class="mi">0</span><span class="p">)</span>   <span class="c1">-- make a table capture</span>
    <span class="kr">return</span> <span class="n">p</span><span class="p">:</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="kr">end</span>
</code></pre></td></tr></table>
</div>
</div><p>There are many <a href="http://www.inf.puc-rio.br/~roberto/lpeg/#ex">similar examples</a> on LPeg&rsquo;s website , see for yourself.</p>
<h3 id="applications">Applications</h3>
<p>LPeg is a very powerful tool, so you can manipulate strings as you wish. It can do a lot of interesting things.</p>
<h4 id="static-analysis-code">Static analysis code</h4>
<p>We can use LPeg to analyze syntax. For example, parsing SQL statements to intercept dangerous operations that are not allowed, such as update or delete without where, or certain user interfaces that only allow select statements to be executed. We can use LPeg to parse SQL statements to know exactly what a SQL statement will do, and even check for syntax errors. We can also parse create table statements to get the expected table structure, compare it with the database table structure, check for consistency, and even migrate data automatically.</p>
<p><a href="https://github.com/andremm/lua-parser">This repo</a> uses LPeg to parse Lua source code into abstract syntax trees. The entire parsed code is only about 400 lines long. We can use it for static analysis of the code, e.g. to analyze calls to a function, to statically evaluate certain expressions, etc.</p>
<h4 id="custom-dsl">Custom DSL</h4>
<p>What if you&rsquo;re out of syntax? Create your own! With LPeg, you can define your own syntax, your own language. For example, in game programming, planners often need to configure triggers. The conditions of triggers are sometimes complicated, such as &ldquo;50% chance to trigger if blood is less than 10% or rage is more than 90&rdquo;, which is difficult to describe in a specific format, and not safe enough to let the planner write the code directly. In this case, we can customize the DSL, and the configuration table can be assigned a string, for example, this condition can be represented as a string</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="o">(</span>hp &lt; 10% <span class="o">||</span> wrath &gt; 90<span class="o">)</span> <span class="o">&amp;&amp;</span> random<span class="o">()</span> &gt; 0.5
</code></pre></td></tr></table>
</div>
</div><p>The string is then pre-compiled into a Lua function using LPeg, which is called at runtime.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/lua/">lua</a>
          <a href="/tags/lpeg/">lpeg</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-01/cloudflare-free-https/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Build HTTPS service for free with Cloudflare</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-01/lua-next/">
            <span class="next-text nav-default">An interesting problem with the Lua next function</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
