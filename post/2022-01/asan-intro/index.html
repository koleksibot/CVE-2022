<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>AddressSanitizer - A tool for programmers to detect memory access errors - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Memory access errors are the most common software errors that often cause program crashes. The AddressSanitizer tool, developed by Google engineers in 2012, has become the first choice of C/C&#43;&#43; programmers for its wide coverage, high efficiency and low overhead. Here is a brief introduction to its principle and usage.
Tools Overview The C/C&#43;&#43; language allows programmers to have low-end control over memory, and this direct memory management has made it possible to write efficient application software." /><meta name="keywords" content="addresssanitizer, c, c&#43;&#43;" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-01/asan-intro/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="AddressSanitizer - A tool for programmers to detect memory access errors" />
<meta property="og:description" content="Memory access errors are the most common software errors that often cause program crashes. The AddressSanitizer tool, developed by Google engineers in 2012, has become the first choice of C/C&#43;&#43; programmers for its wide coverage, high efficiency and low overhead. Here is a brief introduction to its principle and usage.
Tools Overview The C/C&#43;&#43; language allows programmers to have low-end control over memory, and this direct memory management has made it possible to write efficient application software." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-01/asan-intro/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-01-10T10:08:55+08:00" />
<meta property="article:modified_time" content="2022-01-10T10:08:55+08:00" />

<meta itemprop="name" content="AddressSanitizer - A tool for programmers to detect memory access errors">
<meta itemprop="description" content="Memory access errors are the most common software errors that often cause program crashes. The AddressSanitizer tool, developed by Google engineers in 2012, has become the first choice of C/C&#43;&#43; programmers for its wide coverage, high efficiency and low overhead. Here is a brief introduction to its principle and usage.
Tools Overview The C/C&#43;&#43; language allows programmers to have low-end control over memory, and this direct memory management has made it possible to write efficient application software."><meta itemprop="datePublished" content="2022-01-10T10:08:55+08:00" />
<meta itemprop="dateModified" content="2022-01-10T10:08:55+08:00" />
<meta itemprop="wordCount" content="5428">
<meta itemprop="keywords" content="addresssanitizer ," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="AddressSanitizer - A tool for programmers to detect memory access errors"/>
<meta name="twitter:description" content="Memory access errors are the most common software errors that often cause program crashes. The AddressSanitizer tool, developed by Google engineers in 2012, has become the first choice of C/C&#43;&#43; programmers for its wide coverage, high efficiency and low overhead. Here is a brief introduction to its principle and usage.
Tools Overview The C/C&#43;&#43; language allows programmers to have low-end control over memory, and this direct memory management has made it possible to write efficient application software."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">AddressSanitizer - A tool for programmers to detect memory access errors</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-01-10 10:08:55 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 5428 words </span>
          <span class="more-meta"> 26 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li>
          <ul>
            <li><a href="#tools-overview">Tools Overview</a></li>
            <li><a href="#working-principle">Working Principle</a></li>
            <li><a href="#application-examples">Application examples</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>Memory access errors are the most common software errors that often cause program crashes. The AddressSanitizer tool, developed by Google engineers in 2012, has become the first choice of C/C++ programmers for its wide coverage, high efficiency and low overhead. Here is a brief introduction to its principle and usage.</p>
<h3 id="tools-overview">Tools Overview</h3>
<p>The C/C++ language allows programmers to have low-end control over memory, and this direct memory management has made it possible to write efficient application software. However, this has also made memory access errors, including buffer overflows, accesses to freed memory, and memory leaks, a serious problem that must be faced in program design and implementation. While there are tools and software that provide the ability to detect such errors, their operational efficiency and functional coverage are often less than ideal.</p>
<p>In 2012, Google engineer Konstantin Serebryany, together with his team members, released an open source C/C++ program memory access error detector called <a href="https://github.com/google/sanitizers/wiki/AddressSanitizer">AddressSanitizer</a>. Access error detector. AddressSanitizer (ASan for short) applies new memory allocation, mapping and code stubbing techniques to efficiently detect almost all memory access errors. Measured using the SPEC 2006 benchmark analysis package, ASan runs with an average speedup ratio of no more than 2 and memory consumption of about 2.4x. In comparison, another well-known detection tool <a href="http://valgrind.org/">Valgrind</a> has an average value of about 20 for the slowdown ratio, which is almost impossible to put into practice.</p>
<p>The following table summarizes the types of memory access errors that ASan can detect for C/C++ programs.</p>
<table>
<thead>
<tr>
<th>Error Type</th>
<th>English</th>
<th>Abbreviation</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Use after heap memory release</td>
<td>heap use after free</td>
<td>UAF</td>
<td>Continued access after memory release (dangling pointer)</td>
</tr>
<tr>
<td>Heap memory buffer overflow</td>
<td>heap buffer overflow</td>
<td>Heap OOB</td>
<td>Dynamic allocation of memory for out-of-bounds reading and writing</td>
</tr>
<tr>
<td>Heap memory leaks</td>
<td>heap memory leak</td>
<td>HML</td>
<td>Memory is used and not freed</td>
</tr>
<tr>
<td>Global buffer overflow</td>
<td>global buffer overflow</td>
<td>Global OOB</td>
<td>Reading and writing global objects out of bounds</td>
</tr>
<tr>
<td>Stack scopes are used after the</td>
<td>stack use after scope</td>
<td>UAS</td>
<td>Local objects are accessed outside of scope</td>
</tr>
<tr>
<td>After the stack returns use</td>
<td>stack use after return</td>
<td>UAR</td>
<td>Local objects are accessed after the return of</td>
</tr>
<tr>
<td>Stack buffer overflow</td>
<td>stack buffer overflow</td>
<td>Stack OOB</td>
<td>Reading and writing local objects out of bounds</td>
</tr>
</tbody>
</table>
<blockquote>
<p>In fact, ASan itself does not include the ability to detect heap memory leaks, but when ASan is integrated into the compiler, the original leak detection feature of the compiler tool is integrated with ASan based on its modification of the memory allocation function. So, adding the ASan option at compile time also turns on leak detection by default.</p>
</blockquote>
<p>This covers all common memory access errors except for &ldquo;uninitialized memory reads&rdquo; (UMR), which ASan detects with a false positive rate of 0, which is quite impressive. In addition, ASan detects a number of C++-specific memory access errors.</p>
<ul>
<li>Initialization order bugs: When two static objects are defined in different source files and the constructor of one object calls the method of the other, a program crash can occur if the former is initialized first by the compiled unit.</li>
<li>Container Access Overflow (Container Overflow): Given the libc++/libstdc++ container container, access [container.end(), container.begin() + container.capacity())], i.e., exceed [ container.begin(), container.end()] area but still within the dynamically allocated memory area.</li>
<li>Delete Mismatch: An array object created with <code>new foo[n]</code> should not be deleted by calling <code>delete foo</code>, but must be deleted by calling <code>delete [] foo</code>.</li>
</ul>
<p>The high reliability and performance of ASan has made it a popular choice among compiler and IDE developers since its introduction. Today ASan is integrated into all four major compilation toolsets.</p>
<table>
<thead>
<tr>
<th>Compiler/IDE</th>
<th>Starting Support Version</th>
<th>Operating System</th>
<th>Platform</th>
</tr>
</thead>
<tbody>
<tr>
<td>Clang/LLVM2</td>
<td>3.1</td>
<td>Unix-like</td>
<td>cross-platform</td>
</tr>
<tr>
<td>GCC</td>
<td>4.8</td>
<td>Unix-like</td>
<td>cross-platform</td>
</tr>
<tr>
<td>Xcode</td>
<td>7.0</td>
<td>Mac OS X</td>
<td>Apple products</td>
</tr>
<tr>
<td>MSVC</td>
<td>16.9</td>
<td>Windows</td>
<td>IA-32, x86-64 and ARM</td>
</tr>
</tbody>
</table>
<p>ASan&rsquo;s developers first used the Chromium open source browser for routine testing and found more than 300 memory access errors over a 10-month period. After integration into mainstream compilation tools, it reported long-hidden bugs in numerous popular open source software, such as Mozilla Firefox, Perl, Vim, PHP, and MySQL. Interestingly, ASan also identified some memory access errors in the LLVM and GCC compilers' own code. Now, many software companies have added running ASan to their required quality control processes.</p>
<h3 id="working-principle">Working Principle</h3>
<p>The design principles, algorithmic ideas and programming implementation of ASan are comprehensively described in the <a href="https://www.usenix.org/system/files/conference/atc12/atc12-final39.pdf">USENIX conference paper</a> published by Serebryany in 2012. In terms of overall structure, ASan consists of two parts.</p>
<ol>
<li>the compiler instrumentation module - modifies the code to verify the shadow memory state at each memory access and creates poisoned redzones at the edges of global and stack objects to detect overflows up or down. 2.</li>
<li>run-time library replacement module - replaces memory allocation/free (<code>malloc/free</code>) and its associated functions to create poisoned redzones at the edges of dynamically allocated heap memory regions, delay reuse of memory regions after release, and generate error reports.</li>
</ol>
<p>Here shadow memory, compiler staking and memory allocation function substitution are all previously available techniques, so how has ASan innovatively applied them to achieve efficient error detection? Let&rsquo;s take a look at the details.</p>
<h4 id="shadow-memory">Shadow Memory</h4>
<p>Many inspection tools use separated shadow memory to record metadata about program memory, and then apply staking to check the shadow memory during memory accesses to confirm that reads and writes are safe. The difference is that ASan uses a more efficient <strong>direct mapping of shadow memory</strong> .</p>
<p>The designers of ASan noted that typically the <code>malloc</code> function returns a memory address that is at least 8-byte aligned. For example, a request for 20 bytes of memory would divide 24 bytes of memory, with the last 3 bits of the actual return pointer being all 0. Furthermore, any aligned sequence of 8 bytes would only have 9 different states: the first k (0 ≤ k ≤ 8) bytes are accessible, and the next 8-k are not. From this they came up with a more compact shadow memory mapping and usage scheme.</p>
<ul>
<li>Reserve one-eighth of the virtual address space for shadow memory</li>
<li>Directly map application memory to shadow memory using the formula of dividing by 8 and adding the offset
<ul>
<li>32-bit applications: <code>Shadow = (Mem &gt;&gt; 3) + 0x20000000;</code></li>
<li>64-bit applications: <code>Shadow = (Mem &gt;&gt; 3) + 0x7fff8000;</code></li>
</ul>
</li>
<li>Each byte record of shadow memory corresponds to one of the 9 states of the 8-byte memory block
<ul>
<li>All 8 bytes are accessible, value is 0</li>
<li>All 8 bytes are inaccessible (poisoned), value is negative</li>
<li>Only the first k (1 ≤ k ≤ 7) bytes are accessible, with a value of k</li>
</ul>
</li>
</ul>
<p>The following figure shows the address space layout and mapping relationship of ASan. Pay attention to the Bad area in the middle, which is the address segment after the shadow memory itself is mapped. Since the shadow memory is not visible to the application, ASan uses a page protection mechanism to set it as inaccessible.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/10/47029e8e88184e73b11666d1b22156b3.png" alt="image"></p>
<h4 id="compiler-staking">Compiler Staking</h4>
<p>Once the shadow memory design is determined, the implementation of compiler stubbing to detect dynamic memory access errors is easy. For memory accesses of 8 bytes, an instruction is inserted before the original read/write code to check the shadow memory bytes and report an error if they are not 0. For memory accesses of less than 8 bytes, stubbing is a bit more complicated, where the shadow memory byte values are compared with the last three bits of the read/write address. This situation is also known as &ldquo;slow path&rdquo; (slow path) and the sample code is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="c1">// Check the cases where we access first k bytes of the qword
</span><span class="c1">// and these k bytes are unpoisoned.
</span><span class="c1"></span><span class="kt">bool</span> <span class="nf">SlowPathCheck</span><span class="p">(</span><span class="n">shadow_value</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">kAccessSize</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">last_accessed_byte</span> <span class="o">=</span> <span class="p">(</span><span class="n">address</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">+</span> <span class="n">kAccessSize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">last_accessed_byte</span> <span class="o">&gt;=</span> <span class="n">shadow_value</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">...</span>

<span class="n">byte</span> <span class="o">*</span><span class="n">shadow_address</span> <span class="o">=</span> <span class="n">MemToShadow</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
<span class="n">byte</span> <span class="n">shadow_value</span> <span class="o">=</span> <span class="o">*</span><span class="n">shadow_address</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">shadow_value</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">SlowPathCheck</span><span class="p">(</span><span class="n">shadow_value</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">kAccessSize</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">ReportError</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">kAccessSize</span><span class="p">,</span> <span class="n">kIsWrite</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="o">*</span><span class="n">address</span> <span class="o">=</span> <span class="p">...;</span>  <span class="c1">// or: ... = *address;
</span><span class="c1"></span>
</code></pre></td></tr></table>
</div>
</div><p>For global and stack (local) objects, ASan has designed different staking to detect their out-of-bounds access errors. The red zone around a global object is added by the compiler at compile time and its address is passed to the runtime library at application startup, where the runtime library function then poisons the red zone and writes down the address in order to generate an error report. The stack object is created at function call time, and accordingly its red zone is created and poisoned at runtime. In addition, because the stack object is deleted when the function returns, the stubbing code must also zero out the shadow memory it is mapped to.</p>
<p>In practice, the ASan compiler stubbing process is placed at the end of the compiler optimization pipeline so that stubbing applies only to the memory access instructions remaining after variable and loop optimization. In the latest GCC distributions, the ASan compiler stubbing code is located in two files in the gcc subdirectory <code>gcc/asan.[ch]</code> .</p>
<h4 id="runtime-library-replacement">Runtime Library Replacement</h4>
<p>The runtime library needs to include code that manages shadow memory. The address segment to which the shadow memory itself is mapped is initialized at application startup to disable access to the shadow memory by the rest of the program. The runtime library replaces the old memory allocation and release functions and also adds some error reporting functions such as <code>__asan_report_load8</code>.</p>
<p>The new replaced memory allocation function <code>malloc</code> will allocate additional storage as a red zone before and after the requested memory block and set the red zone to be non-addressable. This is called the poisoning process. In practice, because the memory allocator maintains a list of available memory corresponding to different object sizes, if the list of a certain object is empty, the OS will allocate a large set of memory blocks and their red zones at once. As a result, the red zones of the preceding and following memory blocks will be connected, as shown in the following figure, where only n+1 red zones need to be allocated for n memory blocks.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/10/5e7e0b546ef64557b8dcc427d6d11722.png" alt="image"></p>
<p>The new <code>free</code> function needs to poison the entire store and place it in a quarantine queue after the memory is freed. This prevents the memory area from being allocated immediately. Otherwise, if the memory area is reused immediately, there is no way to detect erroneous accesses to memory since the last release. The size of the quarantine queue determines how long the storage area is in quarantine, and the larger it is the better it is at detecting UAF errors!</p>
<p>By default, both <code>malloc</code> and <code>free</code> functions log their call stacks in order to provide more detailed information in error reports. The call stack for <code>malloc</code> is kept in the red zone to the left of the allocated memory, so a larger red zone can hold more call stack frame structure. The call stack for <code>free</code> is kept at the beginning of the allocated memory area.</p>
<p>Integrated into the GCC compiler, the source code for the ASan runtime library replacement is located in the libsanitizer subdirectory <code>libsanitizer/asan/*</code> and the resulting runtime library is named <code>libasan.so</code> after compilation.</p>
<h3 id="application-examples">Application examples</h3>
<p>ASan is very easy to use. The following is an example of an Ubuntu Linux 20.4 + GCC 9.3.0 system running on an x86_64 virtual machine to demonstrate the ability to detect various memory access errors.</p>
<h4 id="test-case">test case</h4>
<p>As shown below, the test program writes seven functions, each introducing a different error type. The function names are cross-referenced with the error types one by one.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/*
</span><span class="cm"> * PakcteMania https://packetmania.github.io
</span><span class="cm"> *
</span><span class="cm"> * gcc asan-test.c -o asan-test -fsanitize=address -g
</span><span class="cm"> */</span>

<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;strings.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cm">/* #include &lt;sanitizer/lsan_interface.h&gt; */</span>

<span class="kt">int</span> <span class="n">ga</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">};</span>

<span class="kt">int</span> <span class="nf">global_buffer_overflow</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">ga</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">heap_leak</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">heap_use_after_free</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">u</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="n">u</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="n">free</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">heap_buffer_overflow</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">h</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">stack_buffer_overflow</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">s</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
    <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="o">*</span><span class="n">gp</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">stack_use_after_return</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">r</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
    <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="n">gp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">stack_use_after_scope</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">gp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="o">*</span><span class="n">gp</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>The test program calls the <code>getopt</code> library function to support a single-letter command line option that allows the user to select the type of error to be tested. The command line option usage information is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">$ ./asan-test

Test AddressSanitizer
usage: asan-test <span class="o">[</span> -bfloprs <span class="o">]</span>

-b	heap buffer overflow
-f	heap use after free
-l	heap memory leak
-o	global buffer overflow
-p	stack use after scope
-r	stack use after <span class="k">return</span>
-s	stack buffer overflow

</code></pre></td></tr></table>
</div>
</div><p>The GCC compile command for the test program is simple, just add two compile options</p>
<ul>
<li><code>-fsanitize=address</code> : activates the ASan tool</li>
<li><code>-g</code> : Activate debugging function and keep debugging information</li>
</ul>
<h4 id="oob-test">OOB test</h4>
<p>For the Heap OOB error, the run results are</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">$ ./asan-test -b
<span class="o">=================================================================</span>
<span class="o">==</span><span class="nv">57360</span><span class="o">==</span>ERROR: AddressSanitizer: heap-buffer-overflow on address 0x604000000038 at pc 0x55bf46fd64ed bp 0x7ffced908dc0 sp 0x7ffced908db0
READ of size <span class="m">4</span> at 0x604000000038 thread T0
    <span class="c1">#0 0x55bf46fd64ec in heap_buffer_overflow /home/zixi/coding/asan-test.c:34</span>
    <span class="c1">#1 0x55bf46fd6a3f in main /home/zixi/coding/asan-test.c:88</span>
    <span class="c1">#2 0x7fd16f6560b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)</span>
    <span class="c1">#3 0x55bf46fd628d in _start (/home/zixi/coding/asan-test+0x128d)</span>

0x604000000038 is located <span class="m">0</span> bytes to the right of 40-byte region <span class="o">[</span>0x604000000010,0x604000000038<span class="o">)</span>
allocated by thread T0 here:
    <span class="c1">#0 0x7fd16f92ebc8 in malloc (/lib/x86_64-linux-gnu/libasan.so.5+0x10dbc8)</span>
    <span class="c1">#1 0x55bf46fd646c in heap_buffer_overflow /home/zixi/coding/asan-test.c:32</span>
    <span class="c1">#2 0x55bf46fd6a3f in main /home/zixi/coding/asan-test.c:88</span>
    <span class="c1">#3 0x7fd16f6560b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)</span>

SUMMARY: AddressSanitizer: heap-buffer-overflow /home/zixi/coding/asan-test.c:34 in heap_buffer_overflow
Shadow bytes around the buggy address:
  0x0c087fff7fb0: <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span>
  0x0c087fff7fc0: <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span>
  0x0c087fff7fd0: <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span>
  0x0c087fff7fe0: <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span>
  0x0c087fff7ff0: <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="nv">00</span>
<span class="o">=</span>&gt;0x0c087fff8000: fa fa <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> 00<span class="o">[</span>fa<span class="o">]</span>fa fa fa fa fa fa fa fa
  0x0c087fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c087fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c087fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c087fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c087fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
Shadow byte legend <span class="o">(</span>one shadow byte represents <span class="m">8</span> application bytes<span class="o">)</span>:
  Addressable:           <span class="m">00</span>
  Partially addressable: <span class="m">01</span> <span class="m">02</span> <span class="m">03</span> <span class="m">04</span> <span class="m">05</span> <span class="m">06</span> <span class="m">07</span> 
  Heap left redzone:       fa
  Freed heap region:       fd
  ...
<span class="o">==</span><span class="nv">57360</span><span class="o">==</span>ABORTING

</code></pre></td></tr></table>
</div>
</div><p>Referring to the <code>heap-buffer-overflow</code> function implementation, you can see that it requests 40 bytes of memory to hold 10 32-bit integers. However, on the return of the function, the code overflows to read the data after the allocated memory. As the above run log shows, the program detects a Heap OOB error and aborts immediately. ASan reports the name of the code file and line number of the error <code>asan-test.c:34</code>, and also accurately lists the original allocation function call stack for dynamic memory. The summary (SUMMARY) section of the report also prints out the shadow memory data corresponding to the address in question (observe the lines marked by <code>=&gt;</code>). The address to be read is 0x604000000038, whose mapped shadow memory address 0x0c087fff8007 holds the negative value 0xfa (poisoned and inaccessible). Because of this, ASan reports an error and aborts the program.</p>
<p>The Stack OOB test case is shown below.ASan reports an out-of-bounds read error for a local object. Since the local variables are located in the stack space, the starting line number of the function <code>stack_buffr_overflow</code> is listed as <code>asan-test.c:37</code>. Unlike the Heap OOB report, the shadow memory poisoning values for the front and back redzone of the local variable are different, before <code>Stack left redzone</code> is 0xf1 and after <code>Stack right redzone</code> is 0xf3. Using different poisoning values (both negative after 0x80) is helpful to quickly distinguish between different error types.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">$ ./asan-test -s
<span class="o">=================================================================</span>
<span class="o">==</span><span class="nv">57370</span><span class="o">==</span>ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7f1cf5044058 at pc 0x55d8b7e9d601 bp 0x7ffc830c29e0 sp 0x7ffc830c29d0
READ of size <span class="m">4</span> at 0x7f1cf5044058 thread T0
    <span class="c1">#0 0x55d8b7e9d600 in stack_buffer_overflow /home/zixi/coding/asan-test.c:40</span>
    <span class="c1">#1 0x55d8b7e9daec in main /home/zixi/coding/asan-test.c:108</span>
    <span class="c1">#2 0x7f1cf87760b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)</span>
    <span class="c1">#3 0x55d8b7e9d28d in _start (/home/zixi/coding/asan-test+0x128d)</span>

Address 0x7f1cf5044058 is located in stack of thread T0 at offset <span class="m">88</span> in frame
    <span class="c1">#0 0x55d8b7e9d505 in stack_buffer_overflow /home/zixi/coding/asan-test.c:37</span>

  This frame has <span class="m">1</span> object<span class="o">(</span>s<span class="o">)</span>:
    <span class="o">[</span>48, 88<span class="o">)</span> <span class="s1">&#39;s&#39;</span> <span class="o">(</span>line 38<span class="o">)</span> &lt;<span class="o">==</span> Memory access at offset <span class="m">88</span> overflows this variable
HINT: this may be a <span class="nb">false</span> positive <span class="k">if</span> your program uses some custom stack unwind mechanism, swapcontext or vfork
      <span class="o">(</span>longjmp and C++ exceptions *are* supported<span class="o">)</span>
SUMMARY: AddressSanitizer: stack-buffer-overflow /home/zixi/coding/asan-test.c:40 in stack_buffer_overflow
Shadow bytes around the buggy address:
  0x0fe41ea007b0: <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span>
  0x0fe41ea007c0: <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span>
  0x0fe41ea007d0: <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span>
  0x0fe41ea007e0: <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span>
  0x0fe41ea007f0: <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="nv">00</span>
<span class="o">=</span>&gt;0x0fe41ea00800: f1 f1 f1 f1 f1 f1 <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> 00<span class="o">[</span>f3<span class="o">]</span>f3 f3 f3 f3
  0x0fe41ea00810: <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span>
  0x0fe41ea00820: <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span>
  0x0fe41ea00830: <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span>
  0x0fe41ea00840: <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span>
  0x0fe41ea00850: <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span>
Shadow byte legend <span class="o">(</span>one shadow byte represents <span class="m">8</span> application bytes<span class="o">)</span>:
  Addressable:           <span class="m">00</span>
  Partially addressable: <span class="m">01</span> <span class="m">02</span> <span class="m">03</span> <span class="m">04</span> <span class="m">05</span> <span class="m">06</span> <span class="m">07</span> 
  Heap left redzone:       fa
  Freed heap region:       fd
  Stack left redzone:      f1
  Stack mid redzone:       f2
  Stack right redzone:     f3
  ...
<span class="o">==</span><span class="nv">57370</span><span class="o">==</span>ABORTING

</code></pre></td></tr></table>
</div>
</div><p>The following Global OOB test result also clearly shows the error line <code>asan-test.c:16</code>, the global variable name <code>ga</code> and its definition code location <code>asan-test.c:13:5</code>, and you can also see that the global object has a red zone poisoning value of 0xf9.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">$ ./asan-test -o
<span class="o">=================================================================</span>
<span class="o">==</span><span class="nv">57367</span><span class="o">==</span>ERROR: AddressSanitizer: global-buffer-overflow on address 0x564363ea4048 at pc 0x564363ea1383 bp 0x7ffc0d6085d0 sp 0x7ffc0d6085c0
READ of size <span class="m">4</span> at 0x564363ea4048 thread T0
    <span class="c1">#0 0x564363ea1382 in global_buffer_overflow /home/zixi/coding/asan-test.c:16</span>
    <span class="c1">#1 0x564363ea1a6c in main /home/zixi/coding/asan-test.c:98</span>
    <span class="c1">#2 0x7f8cb43890b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)</span>
    <span class="c1">#3 0x564363ea128d in _start (/home/zixi/coding/asan-test+0x128d)</span>

0x564363ea4048 is located <span class="m">0</span> bytes to the right of global variable <span class="s1">&#39;ga&#39;</span> defined in <span class="s1">&#39;asan-test.c:13:5&#39;</span> <span class="o">(</span>0x564363ea4020<span class="o">)</span> of size <span class="m">40</span>
SUMMARY: AddressSanitizer: global-buffer-overflow /home/zixi/coding/asan-test.c:16 in global_buffer_overflow
Shadow bytes around the buggy address:
  0x0ac8ec7cc7b0: <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span>
  0x0ac8ec7cc7c0: <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span>
  0x0ac8ec7cc7d0: <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span>
  0x0ac8ec7cc7e0: <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span>
  0x0ac8ec7cc7f0: <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="nv">00</span>
<span class="o">=</span>&gt;0x0ac8ec7cc800: <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> 00<span class="o">[</span>f9<span class="o">]</span>f9 f9 f9 f9 f9 f9
  0x0ac8ec7cc810: <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> f9 f9 f9 f9 f9 f9 f9 f9 f9 f9 f9 f9
  0x0ac8ec7cc820: f9 f9 f9 f9 f9 f9 f9 f9 f9 f9 f9 f9 f9 f9 f9 f9
  0x0ac8ec7cc830: f9 f9 f9 f9 f9 f9 f9 f9 f9 f9 f9 f9 <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span>
  0x0ac8ec7cc840: <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span>
  0x0ac8ec7cc850: <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span>
Shadow byte legend <span class="o">(</span>one shadow byte represents <span class="m">8</span> application bytes<span class="o">)</span>:
  Addressable:           <span class="m">00</span>
  Partially addressable: <span class="m">01</span> <span class="m">02</span> <span class="m">03</span> <span class="m">04</span> <span class="m">05</span> <span class="m">06</span> <span class="m">07</span> 
  Heap left redzone:       fa
  Freed heap region:       fd
  Stack left redzone:      f1
  Stack mid redzone:       f2
  Stack right redzone:     f3
  Stack after <span class="k">return</span>:      f5
  Stack use after scope:   f8
  Global redzone:          f9
  ...
<span class="o">==</span><span class="nv">57367</span><span class="o">==</span>ABORTING

</code></pre></td></tr></table>
</div>
</div><p>Note that in this example, the global array <code>int ga[10] = {1};</code> is initialized, what happens if it is uninitialized? Change the code slightly</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="n">ga</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>

<span class="kt">int</span> <span class="nf">global_buffer_overflow</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">ga</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">ga</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>Surprisingly, ASan does not report the Global OOB error evident here. Why?</p>
<p>The reason has to do with the way GCC treats global variables. The compiler treats functions and initialized variables as Strong symbols, while <strong>uninitialized variables are Weak symbols</strong> by default. Because weak symbols may be defined differently in different source files, the amount of space they require is unknown. The compiler cannot allocate space for weak symbols in the BSS segment, so it uses the COMMON block mechanism, so that all weak symbols share a COMMON storage area, thus ASan cannot insert into the red zone. During the linking process, after the linker reads all the input target files, it can determine the size of the weak symbols and allocate space for them in the BSS segment of the final output file.</p>
<p>Fortunately, GCC&rsquo;s <code>-fno-common</code> option disables the COMMON block mechanism, allowing the compiler to add all uninitialized global variables directly to the BSS segment of the target file, also allowing ASan to work properly. This option also disables the linker from merging weak symbols, so the linker reports an error directly when it finds a compiled unit with duplicate global variables defined in the target file.</p>
<p>This is confirmed by a real test, modifying the GCC command behavior for the previous code segment</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">gcc asan-test.c -o asan-test -fsanitize=address -fno-common -g

</code></pre></td></tr></table>
</div>
</div><p>Compiling the link and running ASan successfully reported the Global OOB error.</p>
<h4 id="uaf-testing">UAF Testing</h4>
<p>The following is a running record of the UAF error test is shown. Not only is the information about the errored code reported here, but also the call stack of the original allocate and release functions of the dynamic memory is given. The log shows that the memory was allocated by <code>asan-test.c:25</code>, freed at <code>asan-test.c:27</code>, and read at <code>asan-test.c:28</code>. The shadow memory data printed later indicates that the data filled is negative 0xfd, which is also the result of the poisoning of the memory after it is freed.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">$ ./asan-test -f
<span class="o">=================================================================</span>
<span class="o">==</span><span class="nv">57363</span><span class="o">==</span>ERROR: AddressSanitizer: heap-use-after-free on address 0x604000000034 at pc 0x558b4a45444e bp 0x7ffccf4ca790 sp 0x7ffccf4ca780
READ of size <span class="m">4</span> at 0x604000000034 thread T0
    <span class="c1">#0 0x558b4a45444d in heap_use_after_free /home/zixi/coding/asan-test.c:28</span>
    <span class="c1">#1 0x558b4a454a4e in main /home/zixi/coding/asan-test.c:91</span>
    <span class="c1">#2 0x7fc7cc98b0b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)</span>
    <span class="c1">#3 0x558b4a45428d in _start (/home/zixi/coding/asan-test+0x128d)</span>

0x604000000034 is located <span class="m">36</span> bytes inside of 40-byte region <span class="o">[</span>0x604000000010,0x604000000038<span class="o">)</span>
freed by thread T0 here:
    <span class="c1">#0 0x7fc7ccc637cf in __interceptor_free (/lib/x86_64-linux-gnu/libasan.so.5+0x10d7cf)</span>
    <span class="c1">#1 0x558b4a454412 in heap_use_after_free /home/zixi/coding/asan-test.c:27</span>
    <span class="c1">#2 0x558b4a454a4e in main /home/zixi/coding/asan-test.c:91</span>
    <span class="c1">#3 0x7fc7cc98b0b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)</span>

previously allocated by thread T0 here:
    <span class="c1">#0 0x7fc7ccc63bc8 in malloc (/lib/x86_64-linux-gnu/libasan.so.5+0x10dbc8)</span>
    <span class="c1">#1 0x558b4a4543bd in heap_use_after_free /home/zixi/coding/asan-test.c:25</span>
    <span class="c1">#2 0x558b4a454a4e in main /home/zixi/coding/asan-test.c:91</span>
    <span class="c1">#3 0x7fc7cc98b0b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)</span>

SUMMARY: AddressSanitizer: heap-use-after-free /home/zixi/coding/asan-test.c:28 in heap_use_after_free
Shadow bytes around the buggy address:
  0x0c087fff7fb0: <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span>
  0x0c087fff7fc0: <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span>
  0x0c087fff7fd0: <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span>
  0x0c087fff7fe0: <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span>
  0x0c087fff7ff0: <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="nv">00</span>
<span class="o">=</span>&gt;0x0c087fff8000: fa fa fd fd fd fd<span class="o">[</span>fd<span class="o">]</span>fa fa fa fa fa fa fa fa fa
  0x0c087fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c087fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c087fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c087fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c087fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
Shadow byte legend <span class="o">(</span>one shadow byte represents <span class="m">8</span> application bytes<span class="o">)</span>:
  Addressable:           <span class="m">00</span>
  Partially addressable: <span class="m">01</span> <span class="m">02</span> <span class="m">03</span> <span class="m">04</span> <span class="m">05</span> <span class="m">06</span> <span class="m">07</span> 
  Heap left redzone:       fa
  Freed heap region:       fd
  ...
<span class="o">==</span><span class="nv">57363</span><span class="o">==</span>ABORTING

</code></pre></td></tr></table>
</div>
</div><h4 id="hml-test">HML test</h4>
<p>The results of the memory leak test are as follows. Unlike the other test cases, <code>ABORTING</code> is not printed at the end of the output record. This is because by default, ASan only generates a memory leak report when the program terminates (process ends). If you want to check for leaks on the fly, you can call ASan&rsquo;s own library function <code>__lsan_do_recoverable_leak_check</code>, whose definition is located in the header file <code>sanitizer/lsan_interface.h</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">$ ./asan-test -l
=================================================================
==57365==ERROR: LeakSanitizer: detected memory leaks

Direct leak of 40 byte(s) in 1 object(s) allocated from:
    #0 0x7f06b85b1bc8 in malloc (/lib/x86_64-linux-gnu/libasan.so.5+0x10dbc8)
    #1 0x5574a8bcd3a0 in heap_leak /home/zixi/coding/asan-test.c:20
    #2 0x5574a8bcda5d in main /home/zixi/coding/asan-test.c:94
    #3 0x7f06b82d90b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)

SUMMARY: AddressSanitizer: 40 byte(s) leaked in 1 allocation(s).

</code></pre></td></tr></table>
</div>
</div><h4 id="uas-test">UAS test</h4>
<p>See the <code>stack_use_after_scope</code> function code, where the local variable <code>c</code> is written to a storage area outside its scope. The test log accurately reports the line number <code>line 54</code> where the variable definition is located and the location of the incorrectly written code <code>asan-test.c:57</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">./asan-test -p
<span class="o">=================================================================</span>
<span class="o">==</span><span class="nv">57368</span><span class="o">==</span>ERROR: AddressSanitizer: stack-use-after-scope on address 0x7f06f0a9b020 at pc 0x56121a7548d9 bp 0x7ffd1de0d050 sp 0x7ffd1de0d040
WRITE of size <span class="m">4</span> at 0x7f06f0a9b020 thread T0
    <span class="c1">#0 0x56121a7548d8 in stack_use_after_scope /home/zixi/coding/asan-test.c:57</span>
    <span class="c1">#1 0x56121a754a7b in main /home/zixi/coding/asan-test.c:101</span>
    <span class="c1">#2 0x7f06f42cd0b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)</span>
    <span class="c1">#3 0x56121a75428d in _start (/home/zixi/coding/asan-test+0x128d)</span>

Address 0x7f06f0a9b020 is located in stack of thread T0 at offset <span class="m">32</span> in frame
    <span class="c1">#0 0x56121a7547d0 in stack_use_after_scope /home/zixi/coding/asan-test.c:52</span>

  This frame has <span class="m">1</span> object<span class="o">(</span>s<span class="o">)</span>:
    <span class="o">[</span>32, 36<span class="o">)</span> <span class="s1">&#39;c&#39;</span> <span class="o">(</span>line 54<span class="o">)</span> &lt;<span class="o">==</span> Memory access at offset <span class="m">32</span> is inside this variable
HINT: this may be a <span class="nb">false</span> positive <span class="k">if</span> your program uses some custom stack unwind mechanism, swapcontext or vfork
      <span class="o">(</span>longjmp and C++ exceptions *are* supported<span class="o">)</span>
SUMMARY: AddressSanitizer: stack-use-after-scope /home/zixi/coding/asan-test.c:57 in stack_use_after_scope
Shadow bytes around the buggy address:
  0x0fe15e14b5b0: <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span>
  0x0fe15e14b5c0: <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span>
  0x0fe15e14b5d0: <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span>
  0x0fe15e14b5e0: <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span>
  0x0fe15e14b5f0: <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="nv">00</span>
<span class="o">=</span>&gt;0x0fe15e14b600: f1 f1 f1 f1<span class="o">[</span>f8<span class="o">]</span>f3 f3 f3 <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span>
  0x0fe15e14b610: <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span>
  0x0fe15e14b620: <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span>
  0x0fe15e14b630: <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span>
  0x0fe15e14b640: <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span>
  0x0fe15e14b650: <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span>
Shadow byte legend <span class="o">(</span>one shadow byte represents <span class="m">8</span> application bytes<span class="o">)</span>:
  Addressable:           <span class="m">00</span>
  Partially addressable: <span class="m">01</span> <span class="m">02</span> <span class="m">03</span> <span class="m">04</span> <span class="m">05</span> <span class="m">06</span> <span class="m">07</span> 
  Heap left redzone:       fa
  Freed heap region:       fd
  Stack left redzone:      f1
  Stack mid redzone:       f2
  Stack right redzone:     f3
  Stack after <span class="k">return</span>:      f5
  Stack use after scope:   f8
  ...
<span class="o">==</span><span class="nv">57368</span><span class="o">==</span>ABORTING

</code></pre></td></tr></table>
</div>
</div><h4 id="uar-testing">UAR Testing</h4>
<p>The UAR test has its own peculiarities. Since the stack memory of a function is reused immediately after its return, it is necessary to set up a &ldquo;pseudo-stack&rdquo; of dynamic memory allocation to detect access errors of local objects after their return, as detailed in the relevant <a href="https://github.com/google/sanitizers/wiki/AddressSanitizerUseAfterReturn">Wiki page of ASan</a>. Since this algorithm change is not a small performance hit, ASan does not detect UAR errors by default. If you really need to, you can set the environment variable <code>ASAN_OPTIONS</code> to <code>detect_stack_use_after_return=1</code> before running. The corresponding test logs are as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">$ export ASAN_OPTIONS=detect_stack_use_after_return=1
$ env | grep ASAN
ASAN_OPTIONS=detect_stack_use_after_return=1
$ ./asan-test -r
=================================================================
==57369==ERROR: AddressSanitizer: stack-use-after-return on address 0x7f5493e93030 at pc 0x55a356890ac9 bp 0x7ffd22c5cf30 sp 0x7ffd22c5cf20
READ of size 4 at 0x7f5493e93030 thread T0
    #0 0x55a356890ac8 in main /home/zixi/coding/asan-test.c:105
    #1 0x7f54975c50b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)
    #2 0x55a35689028d in _start (/home/zixi/coding/asan-test+0x128d)

Address 0x7f5493e93030 is located in stack of thread T0 at offset 48 in frame
    #0 0x55a356890682 in stack_use_after_return /home/zixi/coding/asan-test.c:45

  This frame has 1 object(s):
    [48, 88) &#39;r&#39; (line 46) &lt;== Memory access at offset 48 is inside this variable
HINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork
      (longjmp and C++ exceptions *are* supported)
SUMMARY: AddressSanitizer: stack-use-after-return /home/zixi/coding/asan-test.c:105 in main
Shadow bytes around the buggy address:
  0x0feb127ca5b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0feb127ca5c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0feb127ca5d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0feb127ca5e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0feb127ca5f0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
=&gt;0x0feb127ca600: f5 f5 f5 f5 f5 f5[f5]f5 f5 f5 f5 f5 f5 f5 f5 f5
  0x0feb127ca610: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0feb127ca620: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0feb127ca630: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0feb127ca640: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0feb127ca650: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07 
  Heap left redzone:       fa
  Freed heap region:       fd
  Stack left redzone:      f1
  Stack mid redzone:       f2
  Stack right redzone:     f3
  Stack after return:      f5
  ...
==57369==ABORTING

</code></pre></td></tr></table>
</div>
</div><p>ASan supports many other compiler markup and runtime environment variable options to control and adjust the functionality and scope of the detection, for those interested please refer to the ASan <a href="https://github.com/google/sanitizers/wiki/AddressSanitizerFlags">Markup Wiki page</a>.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/addresssanitizer/">addresssanitizer </a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-01/ipv6-addressing/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">IPv6 Dynamic Address Allocation Mechanism Explained</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-01/analyze-ipv4-ipv6-checksum/">
            <span class="next-text nav-default">Analysis of IPv4 and IPv6 packet header checksum algorithm</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
