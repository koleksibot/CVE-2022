<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Go HTTP Service Timeout Control - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="The system must control the timeout time of each link when providing HTTP services to the outside world, otherwise it is vulnerable to DDos attacks. The business framework used by our department is based on the Go language net/http standard library secondary development. When I was developing the framework, I did not have a deep understanding of the timeout control of the Go HTTP server. TimeoutHandler in the outermost layer" /><meta name="keywords" content="golang, http server, Timeout" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-01/go-http-server-timeout/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Go HTTP Service Timeout Control" />
<meta property="og:description" content="The system must control the timeout time of each link when providing HTTP services to the outside world, otherwise it is vulnerable to DDos attacks. The business framework used by our department is based on the Go language net/http standard library secondary development. When I was developing the framework, I did not have a deep understanding of the timeout control of the Go HTTP server. TimeoutHandler in the outermost layer" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-01/go-http-server-timeout/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-01-05T12:40:54+08:00" />
<meta property="article:modified_time" content="2022-01-05T12:40:54+08:00" />

<meta itemprop="name" content="Go HTTP Service Timeout Control">
<meta itemprop="description" content="The system must control the timeout time of each link when providing HTTP services to the outside world, otherwise it is vulnerable to DDos attacks. The business framework used by our department is based on the Go language net/http standard library secondary development. When I was developing the framework, I did not have a deep understanding of the timeout control of the Go HTTP server. TimeoutHandler in the outermost layer"><meta itemprop="datePublished" content="2022-01-05T12:40:54+08:00" />
<meta itemprop="dateModified" content="2022-01-05T12:40:54+08:00" />
<meta itemprop="wordCount" content="2781">
<meta itemprop="keywords" content="golang," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go HTTP Service Timeout Control"/>
<meta name="twitter:description" content="The system must control the timeout time of each link when providing HTTP services to the outside world, otherwise it is vulnerable to DDos attacks. The business framework used by our department is based on the Go language net/http standard library secondary development. When I was developing the framework, I did not have a deep understanding of the timeout control of the Go HTTP server. TimeoutHandler in the outermost layer"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Go HTTP Service Timeout Control</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-01-05 12:40:54 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 2781 words </span>
          <span class="more-meta"> 6 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents"></nav>
  </div>
</div>
    <div class="post-content">
      <p>The system must control the timeout time of each link when providing HTTP services to the outside world, otherwise it is vulnerable to DDos attacks. The business framework used by our department is based on the Go language net/http standard library secondary development. When I was developing the framework, I did not have a deep understanding of the timeout control of the Go HTTP server. TimeoutHandler in the outermost layer was enough. TimeoutHandler in the outermost layer was enough. After the system went online, there had been no problems in this area, and I felt good about myself. In fact, it was because we set the timeout control in the outermost nginx and did not expose the system to the problem. When we ran another business system on AWS, because the AWS ALB configuration was different from the original nginx, we found that using only http. I was killed on the spot, so I rushed to find out why. I looked at the source code of the Go language HTTP service and found the cause of the deadlock. Today, I&rsquo;ll share my experience with you. While looking at the code, I found that the Go HTTP server starts another goroutine after reading the complete HTTP request, and the goroutine tries to read another byte of content. It was very strange 🤔 I also looked into it, and eventually found the issue and commit logs, and discovered a flaw in the Go language, which I&rsquo;ll share with you today.</p>
<p>The corresponding structure of the Go HTTP server is <code>net/http.Server</code>, and there are four timeout-related configurations.</p>
<ul>
<li><code>ReadTimeout</code></li>
<li><code>ReadHeaderTimeout</code></li>
<li><code>WriteTimeout</code></li>
<li><code>IdleTimeout</code></li>
</ul>
<p>In addition to these four configurations, <code>TimeoutHandler</code> can be used, but this needs to be generated by calling <code>net/http.TimeoutHandler()</code> with the following function signature.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">http</span>
<span class="kd">func</span> <span class="nf">TimeoutHandler</span><span class="p">(</span><span class="nx">h</span> <span class="nx">Handler</span><span class="p">,</span> <span class="nx">dt</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">,</span> <span class="nx">msg</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">Handler</span>
</code></pre></td></tr></table>
</div>
</div><p>The above configuration and TimeHandler corresponding to the role of the process as follows (from Cloudflare).</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/05/d1a51aad3f9b4950a61ce68d9a672564.png" alt="image"></p>
<p>This is a very important diagram because it shows the different stages of HTTP request processing by http.Server. http.Server starts and calls the Accept method and waits for the client to initiate an HTTP request. Once the client establishes a TCP connection, the server starts waiting for the client to send an HTTP request. This corresponds to the Wait phase on the far left. In general, Go HTTP services are rarely directly external, so TLS sessions are handled by edge gateways (like Nginx), so we skip the TLS handshake phase. Server starts reading the header part of the HTTP request, which leads to the Req. After processing the header information of the request, http.Server knows which Handler&rsquo;s ServeHTTP method to call, and thus enters the ServeHTTP phase. The server does not read the body content of the request in the Req.headers phase, but prepares a body object for the Req object. So the ServeHTTP phase is divided into Request body and Response phases. After the server sends the Response, it enters the Idle phase and waits for the next HTTP request for the current connection.</p>
<p>The above is the main process of handling HTTP requests by http. Let&rsquo;s go back to the timeout configuration and TimeoutHandler mentioned earlier.</p>
<p>ReadTimeout controls the timeout from Wait to Reqeust body. If we set ReadTimeout to 50ms, then the client must send both the header and the body of the request to the server within 50 milliseconds, otherwise it will time out and the server will cancel the whole process. On the other hand, the header part of the HTTP request is split by <code>\r\n</code> and the end of the header part (the beginning of the body part) is indicated by a blank line <code>\r\n\r\n</code>. The server cannot determine the length of the header data in advance, but parses it as it receives it. This protocol is very convenient for subsequent upgrades and extensions, but it makes the server very passive. Therefore, it is necessary to set a separate timeout for this process. This timeout is controlled by ReadHeaderTimeout. If we set the ReaderHeaderTimeout to 10ms, then the client must send the entire header within 10ms and cannot dawdle. If ReadTimeout is set and ReadHeaderTimout is not set, http.Server will set ReadHeaderTimeout with the value of ReadTimeout.</p>
<p>The server also needs to control the timeout for sending Response to the client. Why? If the client&rsquo;s request is processed, but it doesn&rsquo;t receive the Response or is deliberately slow, it will keep taking up server resources. So it is necessary to &ldquo;punish&rdquo; those slow and unsuspecting clients. If WriteTimeout is set to 50ms, then the client must receive all response data within 50ms or the whole process will be cancelled. One thing to note is that the WriteTimeout time includes the time to read the body. This means that the ReadTimeout and WriteTimeout timeouts overlap in the body reading part.</p>
<p>IdleTimeout controls the wait time of the Idle phase. If no new request is received for a long time after a request, the server will actively close the current TCP connection, thus freeing up resources.</p>
<p>Finally, there is the TimeoutHandler, which is also very easy to use.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">handler</span> <span class="o">:=</span> <span class="o">...</span>
<span class="nx">handler</span> <span class="p">=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">TimeoutHandler</span><span class="p">(</span><span class="nx">handler</span><span class="p">,</span> <span class="mi">1</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span> <span class="s">&#34;Timeout!\n&#34;</span><span class="p">),</span>
</code></pre></td></tr></table>
</div>
</div><p>This turns a normal handler into a handler with timeout control. timeoutHandler controls both the Reqeust body and the Response process, the ServeHTTP process. If the whole process takes longer than the specified time (1 second in the above example), http.</p>
<p>Well, so far on the basics of timeout control is introduced, the following began to analyze the specific problems.</p>
<p>When I wrote the framework when I thought so many Timeout configuration is too complex, and TimeoutHandler seems to be able to play a &ldquo;one man, no one can open&rdquo; effect, and decided to use only TimeoutHandler to control the timeout. Server default is not to timeout, that is, wait for you to the end of the world. This sets the stage for problems later.</p>
<p>The service we deployed on AWS was reporting partial <strong>Unexpected EOF</strong> errors, and after troubleshooting, we found that the client was behaving abnormally. The corresponding client specified the length of the body via the <code>Content-Length</code> header, but never sent the body data. The expected result is that the TimeoutHandler timeout is triggered and a 503 status code is sent to the client. But in reality, our service reports a Unexpected EOF error after the client actively closes the connection.</p>
<p>This is not at all what was expected and must be checked to the end! This scenario is very easy to reproduce, so it is relatively easy to troubleshoot. Just run the following code.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;io&#34;</span>
  <span class="s">&#34;net/http&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">http</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/ping&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">buf</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">io</span><span class="p">.</span><span class="nf">ReadAll</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
    <span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span>
  <span class="p">})</span>
  <span class="nx">s</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Server</span><span class="p">{</span> <span class="nx">Addr</span><span class="p">:</span> <span class="s">&#34;:8080&#34;</span> <span class="p">}</span>
  <span class="nx">s</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The following HTTP request can be replicated using telnet emulation.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">POST</span> <span class="o">/</span><span class="nx">ping</span> <span class="nx">HTTP</span><span class="o">/</span><span class="mf">1.1</span>
<span class="nx">Content</span><span class="o">-</span><span class="nx">Length</span><span class="p">:</span> <span class="mi">6</span>
<span class="nx">Host</span><span class="p">:</span> <span class="nx">localhost</span><span class="p">:</span><span class="mi">8080</span>

<span class="nx">he</span>
</code></pre></td></tr></table>
</div>
</div><p>Note that ⚠️ the length of <code>Content-Length</code> in the request is 6, but only he two bytes are actually sent.</p>
<p>At first I suspected that 🤔 TimeoutHandler might have to wait to read all the body data to work, so I looked at its source code.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">timeoutHandler</span><span class="p">)</span> <span class="nf">ServeHTTP</span><span class="p">(</span><span class="nx">w</span> <span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 设置 ctx 超时时间
</span><span class="c1"></span>  <span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancelCtx</span> <span class="p">=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nf">Context</span><span class="p">(),</span> <span class="nx">h</span><span class="p">.</span><span class="nx">dt</span><span class="p">)</span>
  <span class="k">defer</span> <span class="nf">cancelCtx</span><span class="p">()</span>
  <span class="nx">r</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">WithContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
  <span class="nx">done</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
  <span class="nx">tw</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">timeoutWriter</span><span class="p">{</span> <span class="nx">w</span><span class="p">:</span><span class="nx">w</span><span class="p">,</span> <span class="nx">h</span><span class="p">:</span><span class="nb">make</span><span class="p">(</span><span class="nx">Header</span><span class="p">),</span> <span class="nx">req</span><span class="p">:</span> <span class="nx">r</span> <span class="p">}</span>
  <span class="c1">// 新起协程处理 http 主求，当前协程等待结果或者超时
</span><span class="c1"></span>  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// process panic
</span><span class="c1"></span>    <span class="nx">h</span><span class="p">.</span><span class="nx">handler</span><span class="p">.</span><span class="nf">ServeHTTP</span><span class="p">(</span><span class="nx">tw</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
    <span class="nb">close</span><span class="p">(</span><span class="nx">done</span><span class="p">)</span>
  <span class="p">}()</span>
  <span class="k">select</span> <span class="p">{</span>
    <span class="c1">// case panic
</span><span class="c1"></span>    <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">done</span><span class="p">:</span> <span class="c1">// 请求正常处理完成
</span><span class="c1"></span>    <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span> <span class="c1">// ctx 超时了
</span><span class="c1"></span>  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>That is, the entire ServeHTTP process is controlled. And we are actually reading the req. Theoretically, TimeoutHandler should work. So we turned on the print method and inserted the Print statement directly into the TimeoutHandler source code to see if it was executed or not, and eventually found that it was stuck in the select process afterwards. That is, the <code>&lt;-ctx.Done()</code> case, which corresponds to the source code as follows</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">tw</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
<span class="k">defer</span> <span class="nx">tw</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
<span class="nx">w</span><span class="p">.</span><span class="nf">WriteHeader</span><span class="p">(</span><span class="nx">StatusServiceUnavailable</span><span class="p">)</span>
<span class="nx">io</span><span class="p">.</span><span class="nf">WriteString</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nf">errorBody</span><span class="p">())</span>
<span class="nx">tw</span><span class="p">.</span><span class="nx">timedOut</span> <span class="p">=</span> <span class="kc">true</span>
</code></pre></td></tr></table>
</div>
</div><p>In case you can&rsquo;t believe it, it&rsquo;s stuck in the <code>Write</code> step, which I really didn&rsquo;t expect!</p>
<p>Now it&rsquo;s time to look at why it&rsquo;s stuck. w&rsquo;s is a <code>ResponseWriter</code> interface, and we need to find its concrete implementation. Here is the core flow of the serve method of http.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">conn</span><span class="p">)</span> <span class="nf">serve</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">//...
</span><span class="c1"></span>  <span class="k">for</span> <span class="p">{</span>
    <span class="nx">w</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">readRequest</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
    <span class="c1">// ...
</span><span class="c1"></span>    <span class="nx">serverHandler</span><span class="p">{</span><span class="nx">c</span><span class="p">.</span><span class="nx">server</span><span class="p">}.</span><span class="nf">ServeHTTP</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">w</span><span class="p">.</span><span class="nx">req</span><span class="p">)</span>
    <span class="c1">// ...
</span><span class="c1"></span>    <span class="nx">w</span><span class="p">.</span><span class="nf">finishRequest</span><span class="p">()</span>
    <span class="c1">// ...
</span></code></pre></td></tr></table>
</div>
</div><p>We can see that w is constructed by calling <code>c.readRequest(ctx)</code>. Based on the <code>readRequest</code> interface signature, we know that the actual type of w is <code>http.response</code>. Looking further at the <code>Write</code> method of w, we see that it calls the <code>Write</code> method of <code>w.w</code> at the bottom. <code>w.w</code> is a member of <code>http.response</code>, which is of type <code>*bufio.Writer</code> interface, so we had to find out exactly what it implements. Going back to the previous <code>c.readRequest</code> method, at the end of the function there is this line.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">w</span><span class="p">.</span><span class="nx">w</span> <span class="p">=</span> <span class="nf">newBufioWriterSize</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">w</span><span class="p">.</span><span class="nx">cw</span><span class="p">,</span> <span class="nx">bufferBeforeChunkingSize</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>It turns out that this <code>w.w</code> is built out of <code>w.cw</code>. We then look at the type of <code>cw</code>, which is <code>http.chunkWriter</code>, and eventually find the <code>cw.Write</code> function, which is the <code>c.Write</code> function that we got stuck on earlier, with the relevant code as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">cw</span> <span class="o">*</span><span class="nx">chunkWriter</span><span class="p">)</span> <span class="nf">Write</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">!</span><span class="nx">cw</span><span class="p">.</span><span class="nx">wroteHeader</span> <span class="p">{</span>
    <span class="nx">cw</span><span class="p">.</span><span class="nf">writeHeader</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="c1">// ...
</span></code></pre></td></tr></table>
</div>
</div><p>I got stuck in the <code>cw.writeHeader(p)</code> place. The <code>writeHeader</code> function is very complicated, and after some debugging, I finally found this place.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">cw</span> <span class="o">*</span><span class="nx">chunkWriter</span><span class="p">)</span> <span class="nf">writeHeader</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="c1"></span>  <span class="k">if</span> <span class="nx">w</span><span class="p">.</span><span class="nx">req</span><span class="p">.</span><span class="nx">ContentLength</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">w</span><span class="p">.</span><span class="nx">closeAfterReply</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">discard</span><span class="p">,</span> <span class="nx">tooBig</span> <span class="kt">bool</span>
    <span class="k">switch</span> <span class="nx">bdy</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.</span><span class="nx">req</span><span class="p">.</span><span class="nx">Body</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// ...
</span><span class="c1"></span>    <span class="k">case</span> <span class="o">*</span><span class="nx">body</span><span class="p">:</span>
      <span class="nx">bdy</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
      <span class="k">switch</span> <span class="p">{</span>
      <span class="k">case</span> <span class="nx">bdy</span><span class="p">.</span><span class="nx">closed</span><span class="p">:</span>
      <span class="c1">// ...
</span></code></pre></td></tr></table>
</div>
</div><p>The root of the problem is <code>bdy.mu.Lock()</code> here! It turns out that <code>http.Server</code> needs to lock the body object of the request when sending a response. What&rsquo;s the point of this? There is a comment on this conditional branch.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">// Per RFC 2616, we should consume the request body before
// replying, if the handler hasn&#39;t already done so.
</code></pre></td></tr></table>
</div>
</div><p>Simply put, you need to read the body content of all responses before sending the response. The whole process is stuck in <strong>bdy.mu.Lock()</strong> step, there must be a goroutine that has got the lock and is doing something, so the lock is not released. Checking the place where the lock is used, I immediately found here.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">body</span><span class="p">)</span> <span class="nf">Read</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">b</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
  <span class="k">defer</span> <span class="nx">b</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">closed</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">ErrBodyReadAfterClose</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">b</span><span class="p">.</span><span class="nf">readLocked</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>Read</code> here is the method we call when the specific handler calls <code>io.ReadAll(req.Body)</code>. It first locks <code>b.mu.Lock()</code> and releases it when it has finished reading all the requests. Let&rsquo;s look at <code>b.readLocked(p)</code> here.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">body</span><span class="p">)</span> <span class="nf">readLocked</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">sawEOF</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span>
  <span class="p">}</span>
  <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">src</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
  <span class="c1">// ...
</span></code></pre></td></tr></table>
</div>
</div><p>The <code>Read</code> method of <code>b.src</code> is actually called here. <code>b.src</code> is another <code>io.Reader</code> interface, and again we have to find its concrete implementation. This is a bit trickier to find. The final call chain we found was <code>c.ReadRequest</code> -&gt; <code>http.readRequest</code> -&gt; <code>http.readTransfer</code>. This <code>readTransfer</code> is again quite complex, and the relevant flow is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">readTransfer</span><span class="p">(</span><span class="nx">msg</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">bufio</span><span class="p">.</span><span class="nx">Reader</span><span class="p">)</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="c1"></span>  <span class="nx">realLength</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">fixLength</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
  <span class="c1">// ...
</span><span class="c1"></span>  <span class="k">switch</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Chunked</span><span class="p">:</span>
    <span class="c1">// ...
</span><span class="c1"></span>    <span class="k">case</span> <span class="nx">realLength</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="nx">t</span><span class="p">.</span><span class="nx">Body</span> <span class="p">=</span> <span class="nx">NoBody</span>
    <span class="k">case</span> <span class="nx">realLength</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">:</span>
      <span class="nx">t</span><span class="p">.</span><span class="nx">Body</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">body</span><span class="p">{</span><span class="nx">src</span><span class="p">:</span> <span class="nx">io</span><span class="p">.</span><span class="nf">LimitReader</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="nx">realLength</span><span class="p">),</span> <span class="nx">closing</span><span class="p">:</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Close</span><span class="p">}</span>
    <span class="k">default</span><span class="p">:</span>
    <span class="c1">// ...
</span></code></pre></td></tr></table>
</div>
</div><p>The first step is to determine the length of the body via <code>fixLength</code>. In our problem, the body length is obtained by <code>Content-Length</code> and then hitting the <code>realLength &gt; 0</code> branch. So <code>b.src</code> is actually an <code>io.LimitReader</code>. This Reader blocks until it has read the full length of <code>realLength</code> before returning.</p>
<p>This is where we get to the root of the problem. It turns out that the client sent the <code>Content-Length</code> header, but not the corresponding length of body content, so the business code locks <code>bdy.mu</code> while trying to read all the body content, and waits for the client to send the remaining body content. The TimeoutHandler tries to send a 503 response to the client, but it also needs to lock the body, so it is also stuck. The whole process continues until the client takes the initiative to disconnect, at which point the server triggers a Unexpected EOF error. The effect seems to be a server-side &ldquo;deadlock&rdquo;.</p>
<p>This is the end of the whole troubleshooting process. The following is a technical summary.</p>
<ul>
<li>http.Server never times out by default, so there is a possibility of DDos attacks</li>
<li>Setting only TimeoutHandler cannot handle all timeout scenarios</li>
<li>ReadTimeout and WriteTimeout must be set, and ReadHeaderTimeout can be set when necessary</li>
</ul>
<p>Server makes extensive use of interfaces, which makes reading the code extremely inconvenient. The best way is to single-step debugging. I have been using vim development, not very friendly to single-step debugging, and rarely used. I tried dlv later, and it really saved a lot of time.</p>
<p>Now, let&rsquo;s make up the extras!</p>
<p>In the <code>http.server</code> method there is this paragraph.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="nf">requestBodyRemains</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">registerOnHitEOF</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">Body</span><span class="p">,</span> <span class="nx">w</span><span class="p">.</span><span class="nx">conn</span><span class="p">.</span><span class="nx">r</span><span class="p">.</span><span class="nx">startBackgroundRead</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The literal meaning is to execute <code>w.conn.r.startBackgroundRead</code> when the body is finished reading. The corresponding execution code looks like this.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">body</span><span class="p">)</span> <span class="nf">readLocked</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="c1"></span>  <span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">sawEOF</span> <span class="o">&amp;&amp;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">onHitEOF</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">b</span><span class="p">.</span><span class="nf">onHitEOF</span><span class="p">()</span>
  <span class="p">}</span>
  <span class="c1">// ..
</span></code></pre></td></tr></table>
</div>
</div><p>Take a closer look at the <code>startBackgroundRead</code> function.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">cr</span> <span class="o">*</span><span class="nx">connReader</span><span class="p">)</span> <span class="nf">startBackgroundRead</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="c1"></span>  <span class="k">go</span> <span class="nx">cr</span><span class="p">.</span><span class="nf">backgroundRead</span><span class="p">()</span>
  <span class="c1">// ...
</span></code></pre></td></tr></table>
</div>
</div><p>A new goroutine is started. That means that for every http request, at least two goroutine are started. And this <code>backgroundRead</code> function is also strange in that it tries to read <strong>one byte</strong> from the underlying TCP connection and will keep blocking without being controlled by all the previous timeouts. The more I look at this logic, the stranger it gets 🤔 I have to figure it out.</p>
<p>I looked at the code over and over again and couldn&rsquo;t get the hang of it, so I did the git blame thing. I also downloaded the go source code for this, and finally found this <a href="https://go-review.googlesource.com/c/go/+/31173/">CL</a>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">net/http: make Server Handler&#39;s Request.Context be done on conn errors

This CL changes how the http1 Server reads from the client.

The goal of this change is to make the Request.Context given to Server
Handlers become done when the TCP connection dies (has seen any read
or write error). I didn&#39;t finish that for Go 1.7 when Context was
added to http package.
</code></pre></td></tr></table>
</div>
</div><p>The intent is to cancel the current handler process when the underlying TCP connection is closed (i.e., when the client actively closes the connection). It is generally easiest to use event callbacks to handle this. However, Go is a concurrent blocking programming paradigm, and does not expose the ability of event callbacks to the application layer. So you can only start a goroutine to try to read a little bit of content (not zero, then read a byte). Theoretically it will keep blocking until the current request is processed or the client actively disconnects. But for this feature, you have to start a goroutine, which is a flaw of the Go language.</p>
<p>In addition, the HTTP protocol provides the pipeline feature. The client can send multiple http requests to the server at once without waiting for the server to respond. Then the server sends the corresponding responses in order. Server to detect the client&rsquo;s active disconnection and start a new concatenation, if it encounters a client that supports pipeline, it will really receive a byte of content, so it also needs to save this one byte for subsequent processing. In short, this approach is not very elegant. But it&rsquo;s the only viable solution in the Go language. What does everyone think? 😄</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/golang/">golang</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-01/go-1.18-netip/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Go 1.18 will introduce a new network address packet</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-01/vim-copy-over-ssh/">
            <span class="next-text nav-default">Copy text using vim across ssh</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
