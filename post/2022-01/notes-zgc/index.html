<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>ZGC Notes: Colored Pointers - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="ZGC is a new generation of garbage collector introduced from jdk11, the expected stopping time is less than 10ms, and the stopping time is independent of heap size, and it can support tb-level heap.
As a fan of go, isn&amp;rsquo;t go&amp;rsquo;s GC already pretty good? The Initial Mark has a little STW, and the usual gc pause is less than ms? In fact, the effect of go GC is still far from the promise of ZGC, not when it comes to large heaps." /><meta name="keywords" content="java, jvm, Zgc" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-01/notes-zgc/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="ZGC Notes: Colored Pointers" />
<meta property="og:description" content="ZGC is a new generation of garbage collector introduced from jdk11, the expected stopping time is less than 10ms, and the stopping time is independent of heap size, and it can support tb-level heap.
As a fan of go, isn&rsquo;t go&rsquo;s GC already pretty good? The Initial Mark has a little STW, and the usual gc pause is less than ms? In fact, the effect of go GC is still far from the promise of ZGC, not when it comes to large heaps." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-01/notes-zgc/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-01-12T13:20:26+08:00" />
<meta property="article:modified_time" content="2022-01-12T13:20:26+08:00" />

<meta itemprop="name" content="ZGC Notes: Colored Pointers">
<meta itemprop="description" content="ZGC is a new generation of garbage collector introduced from jdk11, the expected stopping time is less than 10ms, and the stopping time is independent of heap size, and it can support tb-level heap.
As a fan of go, isn&rsquo;t go&rsquo;s GC already pretty good? The Initial Mark has a little STW, and the usual gc pause is less than ms? In fact, the effect of go GC is still far from the promise of ZGC, not when it comes to large heaps."><meta itemprop="datePublished" content="2022-01-12T13:20:26+08:00" />
<meta itemprop="dateModified" content="2022-01-12T13:20:26+08:00" />
<meta itemprop="wordCount" content="1125">
<meta itemprop="keywords" content="java,jvm," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="ZGC Notes: Colored Pointers"/>
<meta name="twitter:description" content="ZGC is a new generation of garbage collector introduced from jdk11, the expected stopping time is less than 10ms, and the stopping time is independent of heap size, and it can support tb-level heap.
As a fan of go, isn&rsquo;t go&rsquo;s GC already pretty good? The Initial Mark has a little STW, and the usual gc pause is less than ms? In fact, the effect of go GC is still far from the promise of ZGC, not when it comes to large heaps."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">ZGC Notes: Colored Pointers</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-01-12 13:20:26 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 1125 words </span>
          <span class="more-meta"> 6 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#load-barrier">Load Barrier</a></li>
        <li><a href="#colored-pointer--multi-mapping">Colored Pointer &amp; Multi-Mapping</a></li>
        <li><a href="#mark-and-relocate">Mark and Relocate</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>ZGC is a new generation of garbage collector introduced from jdk11, the expected stopping time is less than 10ms, and the stopping time is independent of heap size, and it can support tb-level heap.</p>
<p>As a fan of go, isn&rsquo;t go&rsquo;s GC already pretty good? The Initial Mark has a little STW, and the usual gc pause is less than ms? In fact, the effect of go GC is still far from the promise of ZGC, not when it comes to large heaps. It has no compaction, and running compaction has many benefits.</p>
<ol>
<li>it avoids heap fragmentation, and memory allocation requires only one pointer jump.</li>
<li>after compaction, related objects can usually be adjacent to each other in memory, contributing to locality</li>
<li>the ability to reclaim large amounts of memory at a really high speed. the execution time of compaction is only related to the active objects, not to the total number of objects, and the smaller the percentage of active objects compared to all objects, the more efficient the reclaim, in contrast to the sweep overhead of go, which is directly related to the number of objects.</li>
</ol>
<p>Compaction means relocation of object pointers, and in CMS and G1GC, both compaction and relocation are done in the younger generation of STW.</p>
<p>This requires a mechanism that can do object relocation concurrently.</p>
<h2 id="load-barrier">Load Barrier</h2>
<p>In ZGC, this is the Load Barrier mechanism, which is very different from the CMS / G1GC Writer Barrier. The Write Barrier, including the INC Barrier and SATB Barrier, takes effect at the time when the object modifies its external reference.</p>
<p>The Load Barrier is not the direct opposite of the Write Barrier, but takes effect when &ldquo;the heap pointer is dereferenced:&rdquo;</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">Object</span> <span class="n">o</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="na">FieldA</span>
<span class="o">&lt;</span><span class="n">Load</span> <span class="n">barrier</span><span class="o">&gt;</span>
<span class="n">Object</span> <span class="n">p</span> <span class="o">=</span> <span class="n">o</span>         <span class="c1">// no barrier, it&#39;s not dereferncing any heap reference
</span></code></pre></td></tr></table>
</div>
</div><p>There are more things to do compared to the Write Barrier, and there is different logic at different stages. In addition to the Mark marker tracking, it is possible to initiate moving objects (Relocate) and even redirect references (Remap), changing the pointer in place to point to a new object address.</p>
<p>There are two issues to think about.</p>
<ol>
<li>in the tracking of Mark markers, Write Barrier will track each write operation, marker operation queuing, but in the Load Barrier scenario, each read operation is queued is a considerable amount of overhead, and this repeated queuing operations do not make sense, a reference that has been accessed many times, it is said that only need to be queued once.</li>
<li>how to know whether an object needs to Relocate, similarly, an object only needs to Relocate once in a round of GC, the relocated object does not need to make repeated attempts to relocate.</li>
</ol>
<h2 id="colored-pointer--multi-mapping">Colored Pointer &amp; Multi-Mapping</h2>
<p>For these two types of meta information, ZGC uses a set of Colored Pointer technique to save directly into the pointer:</p>
<ol>
<li>Marked pointer, marked with Marked marker, next time you see this pointer, don&rsquo;t do Marked queue again.</li>
<li>For the redirected pointer, mark it as Remapped, which means it has been successfully transferred, so don&rsquo;t try to Relocate it.</li>
</ol>
<p>ZGC is designed with a restriction that it only supports 64-bit architecture. As we all know, the pointer in 64-bit architecture often only uses 48 bits for addressing, and the 16 bits not used here can be used to store some meta information.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/12/bf09c9c401dc4b88ae80ac26ac61e527.png" alt="image"></p>
<p>Here are 4 bits of meta information.</p>
<ul>
<li>Finalizable: for destructor processing.</li>
<li>Remapped: indicates that the reference has been redirected.</li>
<li>Marked0 and Marked1: indicate that the pointer has been marked.</li>
</ul>
<p>Ignore the Finalizable bit for now.</p>
<p>The Remapped, Marked0, Marked1 bits, only one of them is always 1 and the others are 0.</p>
<p>Some architectures such as ARM support Pointer Masking mechanism, which can tell the CPU a Pointer Mask, and then the CPU will ignore the bits specified in the mask when dereferencing. x86 architecture unfortunately does not have this mechanism, for which ZGC uses the Multi-Mapping mechanism.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">  +--------------------------------+ 0x0000140000000000 (20TB)
  |         Remapped View          |
  +--------------------------------+ 0x0000100000000000 (16TB)
  |     (Reserved, but unused)     |
  +--------------------------------+ 0x00000c0000000000 (12TB)
  |         Marked1 View           |
  +--------------------------------+ 0x0000080000000000 (8TB)
  |         Marked0 View           |
  +--------------------------------+ 0x0000040000000000 (4TB)
</code></pre></td></tr></table>
</div>
</div><p>Remmaped View, Marked1 View, Marked0 View all point to the same block of memory! It&rsquo;s the same effect as Pointer Masking.</p>
<h2 id="mark-and-relocate">Mark and Relocate</h2>
<p>The Load Barrier does different things at different stages. In the Mark stage, the Load Barrier adds the accessed object to the mark queue, and then drops the mark information into the page&rsquo;s Bitmap. As mentioned earlier, it is not necessary to add the same reference to the marker queue twice, so the marker Marked0 or Marked1 is added to the pointer, and if the reference with the Marked marker is accessed next time, it is not repeatedly added to the marker queue.</p>
<p>After the Mark phase is over, the marked objects, i.e. the living objects, can be used for moving. The Relocation Set + Forwarding Table design makes the execution time of the Relocation phase more controllable on the one hand, and saves the memory overhead of pointer redirection information on the other. On the contrary, SGC 1.0 will maintain a Forwarding Pointer in each object header, which is not as economical as ZGC Forwarding Table.</p>
<p>During the Relocate phase, the GC thread will traverse the objects in the Relocation Set to do the move. If the Load Barrier encounters a pointer in Marked state, it will check whether the reference exists in the Forwarding Table, if yes, it will modify the content of the pointer to the new address and mark it as Remapped; if no, it will initiate the move and modify the Forwarding Table. The GC threads will do Relocate concurrently and will take a CAS to do arbitration.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/12/4244eda22c764ec6bba1a42b1f17862b.png" alt="image"></p>
<p>The Relocate phase completes the movement of objects in the Relocation Set, but the redirection of pointers (Remap) is only initiated based on the Load Barrier. A surviving object may not be actually accessed during the Relocate phase, so the reference will remain in the Marked state and will have to be checked in the Forwarding Table the next time it is accessed.</p>
<p>Here we may return to the question: Why are there two kinds of marked bits, Marked0 and Marked1?</p>
<p>ZGC will &ldquo;incidentally&rdquo; redirect all the pointers of the previous Marked state (Remap) when traversing all objects and references in the next Mark phase. After the new Mark phase, all the pointers of the previous Marked state can be converged to Remapped state, and all the Forwarding Tables can be released. In short, in the next Mark phase, the information from the previous Mark phase is used, so two types of markers are distinguished.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/java/">java</a>
          <a href="/tags/jvm/">jvm</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-01/kotlin-coroutine-cps/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">CPS transformations for Kotlin Coroutine</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-01/badger-tx/">
            <span class="next-text nav-default">badger transaction process</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
