<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Common Distributed Protocols and Lgorithms - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="I will mainly list here the Consistent Hash algorithm, Gossip protocol, QuorumNWR algorithm, PBFT algorithm, PoW algorithm, ZAB protocol, and Paxos will be spoken separately. Consistent Hash Algorithm The Consistent Hash algorithm is designed to solve the migration cost of the Hash algorithm. Taking a 10-node cluster as an example, if you add nodes to the cluster, you need to migrate up to 90.91% of the data if you use" /><meta name="keywords" content="raft, quorumnwr, pbft, pow, zab, paxos, consistent-hash" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-01/common-distributed-protocols-and-lgorithms/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Common Distributed Protocols and Lgorithms" />
<meta property="og:description" content="I will mainly list here the Consistent Hash algorithm, Gossip protocol, QuorumNWR algorithm, PBFT algorithm, PoW algorithm, ZAB protocol, and Paxos will be spoken separately. Consistent Hash Algorithm The Consistent Hash algorithm is designed to solve the migration cost of the Hash algorithm. Taking a 10-node cluster as an example, if you add nodes to the cluster, you need to migrate up to 90.91% of the data if you use" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-01/common-distributed-protocols-and-lgorithms/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-01-31T13:26:21+08:00" />
<meta property="article:modified_time" content="2022-01-31T13:26:21+08:00" />

<meta itemprop="name" content="Common Distributed Protocols and Lgorithms">
<meta itemprop="description" content="I will mainly list here the Consistent Hash algorithm, Gossip protocol, QuorumNWR algorithm, PBFT algorithm, PoW algorithm, ZAB protocol, and Paxos will be spoken separately. Consistent Hash Algorithm The Consistent Hash algorithm is designed to solve the migration cost of the Hash algorithm. Taking a 10-node cluster as an example, if you add nodes to the cluster, you need to migrate up to 90.91% of the data if you use"><meta itemprop="datePublished" content="2022-01-31T13:26:21+08:00" />
<meta itemprop="dateModified" content="2022-01-31T13:26:21+08:00" />
<meta itemprop="wordCount" content="3580">
<meta itemprop="keywords" content="raft," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Common Distributed Protocols and Lgorithms"/>
<meta name="twitter:description" content="I will mainly list here the Consistent Hash algorithm, Gossip protocol, QuorumNWR algorithm, PBFT algorithm, PoW algorithm, ZAB protocol, and Paxos will be spoken separately. Consistent Hash Algorithm The Consistent Hash algorithm is designed to solve the migration cost of the Hash algorithm. Taking a 10-node cluster as an example, if you add nodes to the cluster, you need to migrate up to 90.91% of the data if you use"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Common Distributed Protocols and Lgorithms</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-01-31 13:26:21 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 3580 words </span>
          <span class="more-meta"> 8 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#consistent-hash-algorithm">Consistent Hash Algorithm</a>
          <ul>
            <li><a href="#consistent-hash-algorithm-without-virtual-nodes">Consistent Hash Algorithm without Virtual Nodes</a></li>
            <li><a href="#consistent-hash-algorithm-with-virtual-nodes">Consistent Hash Algorithm with Virtual Nodes</a></li>
          </ul>
        </li>
        <li><a href="#gossip-protocol">Gossip Protocol</a>
          <ul>
            <li><a href="#gossip-data-dissemination-methods">Gossip Data Dissemination Methods</a></li>
          </ul>
        </li>
        <li><a href="#quorum-nwr-algorithm">Quorum NWR algorithm</a></li>
        <li><a href="#pbft-algorithm">PBFT Algorithm</a></li>
        <li><a href="#pow-algorithm">PoW Algorithm</a>
          <ul>
            <li><a href="#proof-of-work">Proof of Work</a></li>
            <li><a href="#how-does-the-blockchain-implement-the-pow-algorithm">How does the blockchain implement the PoW algorithm?</a></li>
          </ul>
        </li>
        <li><a href="#zab-protocol">ZAB Protocol</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>I will mainly list here the Consistent Hash algorithm, Gossip protocol, QuorumNWR algorithm, PBFT algorithm, PoW algorithm, ZAB protocol, and Paxos will be spoken separately.</p>
<h2 id="consistent-hash-algorithm">Consistent Hash Algorithm</h2>
<p>The Consistent Hash algorithm is designed to solve the migration cost of the Hash algorithm. Taking a 10-node cluster as an example, if you add nodes to the cluster, you need to migrate up to 90.91% of the data if you use the hash algorithm, and only 6.48% of the data if you use the Consistent Hash.</p>
<p>Therefore, when using the consistent hash algorithm for hash addressing, you can reduce the impact of node downtime on the entire cluster by increasing the number of nodes and the amount of data that needs to be migrated when recovering from a failure. Later, when needed, you can increase the number of nodes to improve the disaster recovery capacity and efficiency of the system. And when you do data migration, you only need to migrate some data to achieve cluster stability.</p>
<h3 id="consistent-hash-algorithm-without-virtual-nodes">Consistent Hash Algorithm without Virtual Nodes</h3>
<p>We all know that the common hash algorithm is modulo for routing addressing, and similarly the consistent hash uses modulo operations, but unlike the hash algorithm, which modulo for the number of nodes, the consistent hash algorithm modulo for 2^32. You can imagine that the consistent hash algorithm, the entire hash value space is organized into a virtual ring, that is, the hash ring.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/31/b5411a20b3954eaa8aed9b67c5f27745.png" alt="sobyte"></p>
<p>In consistent hashing, you can map nodes to a hash ring by performing a hashing algorithm so that each node can determine its position on the hash ring.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/31/4271d45717944b04b6aab8c2566269e3.png" alt="sobyte"></p>
<p>Then when the value of the specified key is to be read, by doing a hash on the key and determining the position of this key on the ring, the first node encountered is the node corresponding to the key when &ldquo;walking&rdquo; clockwise along the hash ring from this position.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/31/657d5f86a9f649b98e6f58d12a7256ea.png" alt="sobyte"></p>
<p>At this time, if node C is down, then the data of node B and node A will not actually be affected, only the data originally in node C will be relocated to node A, thus as long as the data of node C does the migration.</p>
<p>If the cluster cannot meet the business needs at this time, a node needs to be expanded.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/31/be98b9a60606490f8a853f50ab69f361.png" alt="sobyte"></p>
<p>You can see that key-01 and key-02 are not affected, and only the addressing of key-03 is relocated to the new node D. In general, in the consistent hashing algorithm, if a node is added, the only data affected is the data that will be addressed between the new node and the previous node, and the other data will not be affected.</p>
<p>The implementation code is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm"> * 不带虚拟节点的一致性Hash算法 
</span><span class="cm"> */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ConsistentHashingWithoutVirtualNode</span>
<span class="o">{</span>
    <span class="cm">/**
</span><span class="cm">     * 待添加入Hash环的服务器列表
</span><span class="cm">     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="n">String</span><span class="o">[]</span> <span class="n">servers</span> <span class="o">=</span> <span class="o">{</span><span class="s">&#34;192.168.0.0:111&#34;</span><span class="o">,</span> <span class="s">&#34;192.168.0.1:111&#34;</span><span class="o">,</span> <span class="s">&#34;192.168.0.2:111&#34;</span><span class="o">,</span>
            <span class="s">&#34;192.168.0.3:111&#34;</span><span class="o">,</span> <span class="s">&#34;192.168.0.4:111&#34;</span><span class="o">};</span>

    <span class="cm">/**
</span><span class="cm">     * key表示服务器的hash值，value表示服务器的名称
</span><span class="cm">     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="n">SortedMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">sortedMap</span> <span class="o">=</span>
            <span class="k">new</span> <span class="n">TreeMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;();</span>

    <span class="cm">/**
</span><span class="cm">     * 程序初始化，将所有的服务器放入sortedMap中
</span><span class="cm">     */</span>
    <span class="kd">static</span>
    <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">servers</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
        <span class="o">{</span>
            <span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">getHash</span><span class="o">(</span><span class="n">servers</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;[&#34;</span> <span class="o">+</span> <span class="n">servers</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="s">&#34;]加入集合中, 其Hash值为&#34;</span> <span class="o">+</span> <span class="n">hash</span><span class="o">);</span>
            <span class="n">sortedMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">servers</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span> 

    <span class="cm">/**
</span><span class="cm">     * 得到应当路由到的结点
</span><span class="cm">     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="n">String</span> <span class="nf">getServer</span><span class="o">(</span><span class="n">String</span> <span class="n">node</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="c1">// 得到带路由的结点的Hash值
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">getHash</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
        <span class="c1">// 得到大于该Hash值的所有Map
</span><span class="c1"></span>        <span class="n">SortedMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">subMap</span> <span class="o">=</span>
                <span class="n">sortedMap</span><span class="o">.</span><span class="na">tailMap</span><span class="o">(</span><span class="n">hash</span><span class="o">);</span>
        <span class="c1">// 第一个Key就是顺时针过去离node最近的那个结点
</span><span class="c1"></span>        <span class="n">Integer</span> <span class="n">i</span> <span class="o">=</span> <span class="n">subMap</span><span class="o">.</span><span class="na">firstKey</span><span class="o">();</span>
        <span class="c1">// 返回对应的服务器名称
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">subMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="n">String</span><span class="o">[]</span> <span class="n">nodes</span> <span class="o">=</span> <span class="o">{</span><span class="s">&#34;127.0.0.1:1111&#34;</span><span class="o">,</span> <span class="s">&#34;221.226.0.1:2222&#34;</span><span class="o">,</span> <span class="s">&#34;10.211.0.1:3333&#34;</span><span class="o">};</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nodes</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;[&#34;</span> <span class="o">+</span> <span class="n">nodes</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="s">&#34;]的hash值为&#34;</span> <span class="o">+</span>
                    <span class="n">getHash</span><span class="o">(</span><span class="n">nodes</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">+</span> <span class="s">&#34;, 被路由到结点[&#34;</span> <span class="o">+</span> <span class="n">getServer</span><span class="o">(</span><span class="n">nodes</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">+</span> <span class="s">&#34;]&#34;</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="consistent-hash-algorithm-with-virtual-nodes">Consistent Hash Algorithm with Virtual Nodes</h3>
<p>The above hash algorithm may result in uneven data distribution, i.e., most access requests are concentrated on a few nodes. So we can solve the uneven distribution of data by virtual nodes.</p>
<p>In fact, it is to calculate multiple hash values for each server node, and place a virtual node at each calculated location, and map the virtual node to the actual node. For example, the number can be added after the host name to calculate &ldquo;Node-A-01&rdquo;, &ldquo;Node-A-02&rdquo;, &ldquo;Node-B-01&rdquo;, &ldquo;Node-B-02&rdquo;, respectively &ldquo;Node-B-02&rdquo;, &ldquo;Node-C01&rdquo;, &ldquo;Node-C-02&rdquo;, so that 6 virtual nodes are formed.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/31/da10626e846648069d04e4cf1b09a74e.png" alt="sobyte"></p>
<p>With the addition of nodes, the distribution of nodes on the hash ring is relatively even. At this point, if an access request addresses the virtual node &ldquo;Node-A-01&rdquo;, it will be relocated to Node A.</p>
<p>The specific code implementation is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm"> * 带虚拟节点的一致性Hash算法
</span><span class="cm"> */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ConsistentHashingWithVirtualNode</span>
<span class="o">{</span>
    <span class="cm">/**
</span><span class="cm">     * 待添加入Hash环的服务器列表
</span><span class="cm">     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="n">String</span><span class="o">[]</span> <span class="n">servers</span> <span class="o">=</span> <span class="o">{</span><span class="s">&#34;192.168.0.0:111&#34;</span><span class="o">,</span> <span class="s">&#34;192.168.0.1:111&#34;</span><span class="o">,</span> <span class="s">&#34;192.168.0.2:111&#34;</span><span class="o">,</span>
            <span class="s">&#34;192.168.0.3:111&#34;</span><span class="o">,</span> <span class="s">&#34;192.168.0.4:111&#34;</span><span class="o">};</span>

    <span class="cm">/**
</span><span class="cm">     * 真实结点列表,考虑到服务器上线、下线的场景，即添加、删除的场景会比较频繁，这里使用LinkedList会更好
</span><span class="cm">     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">realNodes</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;();</span>

    <span class="cm">/**
</span><span class="cm">     * 虚拟节点，key表示虚拟节点的hash值，value表示虚拟节点的名称
</span><span class="cm">     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="n">SortedMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">virtualNodes</span> <span class="o">=</span>
            <span class="k">new</span> <span class="n">TreeMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;();</span>

    <span class="cm">/**
</span><span class="cm">     * 虚拟节点的数目，这里写死，为了演示需要，一个真实结点对应5个虚拟节点
</span><span class="cm">     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">VIRTUAL_NODES</span> <span class="o">=</span> <span class="n">5</span><span class="o">;</span>

    <span class="kd">static</span>
    <span class="o">{</span>
        <span class="c1">// 先把原始的服务器添加到真实结点列表中
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">servers</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
            <span class="n">realNodes</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">servers</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>

        <span class="c1">// 再添加虚拟节点，遍历LinkedList使用foreach循环效率会比较高
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">str</span> <span class="o">:</span> <span class="n">realNodes</span><span class="o">)</span>
        <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">VIRTUAL_NODES</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
            <span class="o">{</span>
                <span class="n">String</span> <span class="n">virtualNodeName</span> <span class="o">=</span> <span class="n">str</span> <span class="o">+</span> <span class="s">&#34;&amp;&amp;VN&#34;</span> <span class="o">+</span> <span class="n">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                <span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">getHash</span><span class="o">(</span><span class="n">virtualNodeName</span><span class="o">);</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;虚拟节点[&#34;</span> <span class="o">+</span> <span class="n">virtualNodeName</span> <span class="o">+</span> <span class="s">&#34;]被添加, hash值为&#34;</span> <span class="o">+</span> <span class="n">hash</span><span class="o">);</span>
                <span class="n">virtualNodes</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">virtualNodeName</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="cm">/**
</span><span class="cm">     * 得到应当路由到的结点
</span><span class="cm">     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="n">String</span> <span class="nf">getServer</span><span class="o">(</span><span class="n">String</span> <span class="n">node</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="c1">// 得到带路由的结点的Hash值
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">getHash</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
        <span class="c1">// 得到大于该Hash值的所有Map
</span><span class="c1"></span>        <span class="n">SortedMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">subMap</span> <span class="o">=</span>
                <span class="n">virtualNodes</span><span class="o">.</span><span class="na">tailMap</span><span class="o">(</span><span class="n">hash</span><span class="o">);</span>
        <span class="c1">// 第一个Key就是顺时针过去离node最近的那个结点
</span><span class="c1"></span>        <span class="n">Integer</span> <span class="n">i</span> <span class="o">=</span> <span class="n">subMap</span><span class="o">.</span><span class="na">firstKey</span><span class="o">();</span>
        <span class="c1">// 返回对应的虚拟节点名称，这里字符串稍微截取一下
</span><span class="c1"></span>        <span class="n">String</span> <span class="n">virtualNode</span> <span class="o">=</span> <span class="n">subMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">virtualNode</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">0</span><span class="o">,</span> <span class="n">virtualNode</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="s">&#34;&amp;&amp;&#34;</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="n">String</span><span class="o">[]</span> <span class="n">nodes</span> <span class="o">=</span> <span class="o">{</span><span class="s">&#34;127.0.0.1:1111&#34;</span><span class="o">,</span> <span class="s">&#34;221.226.0.1:2222&#34;</span><span class="o">,</span> <span class="s">&#34;10.211.0.1:3333&#34;</span><span class="o">};</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nodes</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;[&#34;</span> <span class="o">+</span> <span class="n">nodes</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="s">&#34;]的hash值为&#34;</span> <span class="o">+</span>
                    <span class="n">getHash</span><span class="o">(</span><span class="n">nodes</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">+</span> <span class="s">&#34;, 被路由到结点[&#34;</span> <span class="o">+</span> <span class="n">getServer</span><span class="o">(</span><span class="n">nodes</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">+</span> <span class="s">&#34;]&#34;</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="gossip-protocol">Gossip Protocol</h2>
<p>The Gossip protocol, as the name implies, uses a random and contagious way to spread information throughout the network and to make all nodes in the system consistent for a certain period of time. The Gossip protocol, with the above features, ensures that the system can operate in extreme situations (e.g., when only one node is running in a cluster).</p>
<h3 id="gossip-data-dissemination-methods">Gossip Data Dissemination Methods</h3>
<p>Gossip data propagation methods are: Direct Mail, Anti-entropy, and Rumor mongering.</p>
<p><strong>Direct Mail</strong>: sends updates directly, caches them when they fail, and then retransmits them. Although direct mail is easier to implement and data synchronization is timely, data may be lost because the cache queue is full. In other words, it is not possible to achieve final consistency using only direct mail.</p>
<p><strong>Anti-entropy</strong>: Anti-entropy means that the nodes in a cluster randomly select some other node at regular intervals, and then exchange all their data with each other to eliminate the difference between them and achieve the ultimate consistency of data.</p>
<p>In achieving anti-entropy, there are three main ways to push, pull and push-pull. The push approach is to push all the data of one&rsquo;s own copy to the other to repair the entropy in the other&rsquo;s copy, and the pull approach is to pull all the data of the other&rsquo;s copy to repair the entropy in its own copy.</p>
<p><strong>Rumor mongering</strong> (Rumor propagation): It means that when a node has new data, this node becomes active and periodically contacts other nodes to send it new data until all nodes have stored that new data. Since rumor propagation is very contagious, it is suitable for distributed systems that change dynamically</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/31/7ee7a32e223947f8bea145c6fed42ed5.png" alt="sobyte"></p>
<h2 id="quorum-nwr-algorithm">Quorum NWR algorithm</h2>
<p>There are three elements in Quorum NWR, N, W, and R.</p>
<p>N is the number of replicas, also called the Replication Factor. That is, N represents the number of replicas of the same data in the cluster, as shown in the figure below.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/31/34b59544df6d48a9bc88a53daab5fe74.png" alt="sobyte"></p>
<p>In this three-node cluster, DATA-1 has 2 replicas, DATA-2 has 3 replicas, and DATA-3 has 1 replica. In other words, the number of replicas may not be equal to the number of nodes, and different data may have different numbers of replicas.</p>
<p>W, also known as Write Consistency Level, indicates the successful completion of W replica updates.</p>
<p>R, also known as the Read Consistency Level, means that R copies of a data object need to be read when it is read.</p>
<p>With Quorum NWR, you can customize the consistency level by temporarily adjusting the writes or queries to achieve strong consistency when W + R &gt; N.</p>
<p>So if you want to read node B, we then assume the formula W(2) + R(2) &gt; N(3), that is, when writing two nodes and reading two nodes at the same time, then the read data must be read back to the client must be the latest copy of that data.</p>
<p>What you should note about NWR is that different combinations of N, W, and R values will produce different consistency effects, specifically, there are two effects.</p>
<p>When W + R &gt; N, the entire system can guarantee strong consistency for the client, and will definitely return the updated data.
When W + R &lt; N, for the client, the system can only guarantee the final consistency and may return the old data.</p>
<h2 id="pbft-algorithm">PBFT Algorithm</h2>
<p>The PBFT algorithm is very practical and is a Byzantine fault-tolerant algorithm that can be grounded in real-world scenarios.</p>
<p>Let&rsquo;s start with an example to see a concrete implementation of the PBFT algorithm.</p>
<p>Suppose Su Qin is once again leading an army against Qin. On this day, Su Qin and four generals from four countries, Zhao, Wei, Han, and Chu, discuss important military matters, but not long after the discussion, Su Qin receives information that there may be a traitor in the allied army. How does Su Qin give the orders to ensure that the loyal generals carry out the orders correctly and consistently and are not interfered with by the traitor?</p>
<p>It is important to note that all messages are signed messages, meaning that the identity of the message sender and the content of the message cannot be forged or tampered with (for example, Chu cannot forge a message pretending to be from Zhao).</p>
<p>First, Su Qin contacts Zhao and sends a request to Zhao containing the command &ldquo;attack&rdquo; (as shown in the picture below).</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/31/51c5a26246a24884be2b6abd46451e5c.png" alt="sobyte"></p>
<p>When Zhao receives Su Qin&rsquo;s request, it will execute the Three-phase protocol.</p>
<p>Zhao will enter the pre-preparation phase, constructing a pre-preparation message containing combat instructions and broadcasting it to the other generals (Wei, Han, and Chu).</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/31/c08af02d0ebe461ca5b832319cb1d500.png" alt="sobyte"></p>
<p>Because Wei, Han and Chu, after receiving the message, could not confirm that they received the same instructions as the others received. So they need to move to the next phase.</p>
<p>After receiving the Prepare message, Wei, Han, and Chu will enter the Prepare phase and broadcast a Prepare message to the other generals with combat instructions.</p>
<p>For example, Wei broadcasts a preparation message to Zhao, Han, and Chu (as shown in the figure). For the sake of demonstration, let&rsquo;s assume that the traitor Chu wants to interfere with the consensus negotiation by not sending a message (you can see in the diagram that Chu is not sending a message).</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/31/2ed100c7587a4b459a4831c102239dac.png" alt="sobyte"></p>
<p>Because Wei cannot confirm whether Zhao, Han, and Chu have received 2f (where 2f includes itself, where f is the number of traitors, which in my demonstration is 1) consistent preparation messages containing combat instructions. So you need to move to the next phase, Commit.</p>
<p>After entering the Commit phase, each general broadcasts a commit message to the other generals, that is, to tell the other generals that I am ready to execute the order.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/31/a6530a4f693249489149ba64e324743e.png" alt="sobyte"></p>
<p>Finally, when a general receives 2f + 1 validated submission messages, the majority of the generals have reached a consensus that it is time to execute the battle order, then the general will execute Su Qin&rsquo;s battle order and send a successful execution message to Su Qin when the execution is complete.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/31/bc9db1843b0846db8575e7714803062a.png" alt="sobyte"></p>
<p>Finally, when Su Qin receives f+1 identical Reply messages, the generals have reached a consensus on the battle order and have executed it.</p>
<p>In the above example.</p>
<p>Zhao, Wei, Han, and Chu can be understood as the four nodes of the distributed system, where Zhao is the primary node and Wei, Han, and Chu are the secondary nodes.</p>
<p>Understanding Suqin as the business, i.e., the client.</p>
<p>Understanding the message as a network message.</p>
<p>The combat command &ldquo;attack&rdquo; is understood as the value proposed by the client, that is, the value that is expected to be agreed by the nodes and submitted to the state machine.</p>
<p>If the client does not receive the same f + 1 response to the request within the specified time, it is considered that the cluster is faulty and the consensus is not reached, and the client will resend the request.</p>
<p>The PBFT algorithm deals with master node misbehavior by means of View Change, and when a master node is found to be misbehaving, a new master node will be elected in a &ldquo;rotating shift&rdquo;. If you are interested, you can check it out yourself.</p>
<p>The PBFT algorithm can tolerate (n 1)/3 malicious nodes (which can also be faulty nodes) compared to the Raft algorithm, which is completely unsuitable for malicious scenarios. The PBFT algorithm is an O(n ^ 2) message complexity algorithm, so as the number of messages increases, the impact of network latency on the operation of the system will be greater, which limits the size of the distributed system running the PBFT algorithm, and determines that the PBFT algorithm is suitable for small and medium-sized distributed systems.</p>
<h2 id="pow-algorithm">PoW Algorithm</h2>
<p>Proof Of Work (PoW) is a proof that you have done a certain amount of work. Specifically, the client needs to do a certain amount of work to get a result, but the verifier can easily check if the client has done the corresponding work by the result.</p>
<p>The specific workload proof process looks like the one in the following figure.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/31/cb84e3b455f542949985ec03c9c769f6.png" alt="sobyte"></p>
<p>So proof of work is commonly used in blockchains, which prevent bad guys from doing bad things by increasing the cost of doing bad things through Proof of Work.</p>
<h3 id="proof-of-work">Proof of Work</h3>
<p>Hash Function, also known as a hash function. That is, you enter a string of any length, the hash function will calculate a hash of the same length.</p>
<p>After understanding what a hash function is, how can we prove the workload by hashing the hash function?</p>
<p>For example, we can give a workload requirement: based on a basic string, you can add an integer value to this string, and then perform a SHA256 hash operation on the changed (added integer value) string, and if the hash value (in hexadecimal form) obtained after the operation starts with &ldquo;0000&rdquo;, then the verification passes.</p>
<p>To achieve this workload proof goal, we need to keep incrementing the integer values, one by one, and perform a SHA256 hash on the new string.</p>
<p>As you can see from this example, the proof of workload is done by performing a hash operation, and after a period of computation, a hash value is obtained that meets the conditions. In other words, we can prove our workload by this hash value.</p>
<h3 id="how-does-the-blockchain-implement-the-pow-algorithm">How does the blockchain implement the PoW algorithm?</h3>
<p>First look at what a blockchain is.</p>
<p>A blockchain block is composed of 2 parts: block head and block body.</p>
<ul>
<li>Block Head: The block head is mainly composed of the hash of the previous block, the hash of the block body, and a 4-byte random number (nonce).</li>
<li>Block Body: The block contains the transaction data, the first of which is the Coinbase transaction, a special transaction that motivates miners.</li>
</ul>
<p>In the blockchain, the block header with a fixed length of 80 bytes is the input string of the hash operation used for the proof of workload of the blockchain, and the hash value calculated by the double SHA256 hash operation (that is, the result of the SHA256 hash operation is executed once more) is valid only if it is less than the target value, otherwise the hash value is invalid and must be recalculated.</p>
<p>Therefore, in the blockchain is to prove its workload by performing SHA256 hash operation on the block header to get a hash value less than the target value.</p>
<p>After calculating the qualified hash value, the miner will broadcast this information to all other nodes in the cluster, and after the other nodes pass the verification, they will add the block to their blockchain, which eventually forms a chain of blocks, like the following figure.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/31/a4b5a010194a437a89fcfe1b27eab439.png" alt="sobyte"></p>
<p>So, it means that the attacker has more computing power and can mine a longer attack chain than the original chain and broadcast the attack chain to the whole network, then, according to the agreement, the node will accept the longer chain, that is, the attack chain, and discard the original chain. It looks like the following figure.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/31/9ad3289400c343faadb047960b6f3d23.png" alt="sobyte"></p>
<h2 id="zab-protocol">ZAB Protocol</h2>
<p>The Zab protocol is called Zookeeper Atomic Broadcast, and Zookeeper is used to ensure the ultimate consistency of distributed transactions through the Zab protocol, which is designed with the core goal of achieving sequential operations.</p>
<p>Since ZAB is not based on a state machine, but on the Atomic Broadcast protocol in a master-standby mode, it ultimately achieves sequential operations.</p>
<p>There are several main reasons why ZAB achieves sequential operations.</p>
<p>First, ZAB implements the master-standby mode, which means that all data is based on the master node</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/31/9211cb5a0f6a4d85a0a8a5a9413c3687.png" alt="sobyte"></p>
<p>Second, ZAB implements a FIFO queue to ensure sequential message processing.</p>
<p>Finally, ZAB also implements that when the master node crashes, only the node with the most complete logs can be elected as the master node, because the most complete node contains all the logs that have been committed, so that the committed logs will not change again.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/raft/">raft</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-02/new-android-13-feature-cpu-speeds/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Android 13 new features revealed: CPU acceleration to improve game loading speed</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-01/kubernetes-deployemnt-using-kubeadm/">
            <span class="next-text nav-default">Deploy a Kubernetes cluster</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
