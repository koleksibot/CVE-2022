<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Rocksdb transactions - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="rocksdb supports both PessimisticTransactionDB and OptimisticTransactionDB concurrency control modes, both of which seem to be external wrappers for DB objects, doing concurrency control outside of the storage, allowing applications to do transactional KV read and write capabilities per BEGIN, COMMIT, ROLLBACK APIs. rocksdb originally has the ability to write WriteBatch atomically, and the transaction does things on the basis of WriteBatch, where writes within the transaction are temporarily stored in" /><meta name="keywords" content="Rocksdb, transactions" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-01/rocksdb-tx/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Rocksdb transactions" />
<meta property="og:description" content="rocksdb supports both PessimisticTransactionDB and OptimisticTransactionDB concurrency control modes, both of which seem to be external wrappers for DB objects, doing concurrency control outside of the storage, allowing applications to do transactional KV read and write capabilities per BEGIN, COMMIT, ROLLBACK APIs. rocksdb originally has the ability to write WriteBatch atomically, and the transaction does things on the basis of WriteBatch, where writes within the transaction are temporarily stored in" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-01/rocksdb-tx/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-01-12T10:30:16+08:00" />
<meta property="article:modified_time" content="2022-01-12T10:30:16+08:00" />

<meta itemprop="name" content="Rocksdb transactions">
<meta itemprop="description" content="rocksdb supports both PessimisticTransactionDB and OptimisticTransactionDB concurrency control modes, both of which seem to be external wrappers for DB objects, doing concurrency control outside of the storage, allowing applications to do transactional KV read and write capabilities per BEGIN, COMMIT, ROLLBACK APIs. rocksdb originally has the ability to write WriteBatch atomically, and the transaction does things on the basis of WriteBatch, where writes within the transaction are temporarily stored in"><meta itemprop="datePublished" content="2022-01-12T10:30:16+08:00" />
<meta itemprop="dateModified" content="2022-01-12T10:30:16+08:00" />
<meta itemprop="wordCount" content="3771">
<meta itemprop="keywords" content="rocksdb," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Rocksdb transactions"/>
<meta name="twitter:description" content="rocksdb supports both PessimisticTransactionDB and OptimisticTransactionDB concurrency control modes, both of which seem to be external wrappers for DB objects, doing concurrency control outside of the storage, allowing applications to do transactional KV read and write capabilities per BEGIN, COMMIT, ROLLBACK APIs. rocksdb originally has the ability to write WriteBatch atomically, and the transaction does things on the basis of WriteBatch, where writes within the transaction are temporarily stored in"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Rocksdb transactions</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-01-12 10:30:16 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 3771 words </span>
          <span class="more-meta"> 8 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#optimistic-concurrency-control-snapshots-and-conflict-detection">Optimistic Concurrency Control: Snapshots and Conflict Detection</a></li>
        <li><a href="#pessimistic-concurrency-control-lock-management">Pessimistic Concurrency Control: Lock Management</a></li>
        <li><a href="#pessimistic-concurrency-control-deadlock-detection">Pessimistic concurrency control: deadlock detection</a></li>
        <li><a href="#summary">Summary</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>rocksdb supports both PessimisticTransactionDB and OptimisticTransactionDB concurrency control modes, both of which seem to be external wrappers for DB objects, doing concurrency control outside of the storage, allowing applications to do transactional KV read and write capabilities per BEGIN, COMMIT, ROLLBACK APIs.</p>
<p>rocksdb originally has the ability to write WriteBatch atomically, and the transaction does things on the basis of WriteBatch, where writes within the transaction are temporarily stored in its own WriteBatch, and reads within the transaction will first read its own WriteBatch, and then read MemTable, L0, L1, and so on. During this period, other transactions cannot see the contents of WriteBatch, and when the transaction commits, the value of WriteBatch will fall into MemTable and WAL, so that other transactions can see it.</p>
<p>Since the LSM Tree already has atomic write capabilities, what rocksdb does is mainly at the level of concurrency control outside the LSM Tree, and supports both optimistic and pessimistic concurrency control.</p>
<ul>
<li>In optimistic concurrency control transactions, the reads and writes of the keys within the transaction are tracked, and conflict detection is performed at Commit() to check whether these keys have been modified by other transactions, and if so, the writeBatch is aborted, which is equivalent to nothing happening.</li>
<li>In a pessimistic concurrency control transaction, a lock is placed on the keys written within the transaction, and when these keys are dropped in Commit(), the lock is released and there is no more conflict detection.</li>
</ul>
<p>The transaction API is used, roughly, as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="n">TransactionDB</span><span class="o">*</span> <span class="n">txn_db</span><span class="p">;</span>
<span class="n">Status</span> <span class="n">s</span> <span class="o">=</span> <span class="n">TransactionDB</span><span class="o">::</span><span class="n">Open</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txn_db</span><span class="p">);</span>

<span class="n">Transaction</span><span class="o">*</span> <span class="n">txn</span> <span class="o">=</span> <span class="n">txn_db</span><span class="o">-&gt;</span><span class="n">BeginTransaction</span><span class="p">(</span><span class="n">write_options</span><span class="p">,</span> <span class="n">txn_options</span><span class="p">);</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">txn</span><span class="o">-&gt;</span><span class="n">Put</span><span class="p">(</span><span class="err">“</span><span class="n">key</span><span class="err">”</span><span class="p">,</span> <span class="err">“</span><span class="n">value</span><span class="err">”</span><span class="p">);</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">txn</span><span class="o">-&gt;</span><span class="n">Delete</span><span class="p">(</span><span class="err">“</span><span class="n">key2</span><span class="err">”</span><span class="p">);</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">txn</span><span class="o">-&gt;</span><span class="n">Merge</span><span class="p">(</span><span class="err">“</span><span class="n">key3</span><span class="err">”</span><span class="p">,</span> <span class="err">“</span><span class="n">value</span><span class="err">”</span><span class="p">);</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">txn</span><span class="o">-&gt;</span><span class="n">Commit</span><span class="p">();</span>
<span class="k">delete</span> <span class="n">txn</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="optimistic-concurrency-control-snapshots-and-conflict-detection">Optimistic Concurrency Control: Snapshots and Conflict Detection</h2>
<p>Let&rsquo;s look at optimistic concurrency control. As mentioned earlier, optimistic concurrency control mainly lies in the conflict detection at the time of Commit(), but in addition, it also relies on the Snapshot mechanism to achieve transaction isolation. rocksdb&rsquo;s Snapshot does not change compared to leveldb, that is, each time a WriteBatch is written, the sequence number is incremented, and the contents of the Snapshot The content of the Snapshot is the sequence number, and the query is filtered by the latest value of the Key less than or equal to the sequence number.</p>
<p>The entry point for tracking the key comes from the TrackKey() method called by <code>OptimisticTransactionImpl::TryLock</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="n">TransactionBaseImpl</span><span class="o">::</span><span class="n">TrackKey</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">cfh_id</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">,</span>
                                   <span class="n">SequenceNumber</span> <span class="n">seq</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">read_only</span><span class="p">,</span>
                                   <span class="kt">bool</span> <span class="n">exclusive</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">PointLockRequest</span> <span class="n">r</span><span class="p">;</span>
  <span class="n">r</span><span class="p">.</span><span class="n">column_family_id</span> <span class="o">=</span> <span class="n">cfh_id</span><span class="p">;</span>
  <span class="n">r</span><span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
  <span class="n">r</span><span class="p">.</span><span class="n">seq</span> <span class="o">=</span> <span class="n">seq</span><span class="p">;</span>
  <span class="n">r</span><span class="p">.</span><span class="n">read_only</span> <span class="o">=</span> <span class="n">read_only</span><span class="p">;</span>
  <span class="n">r</span><span class="p">.</span><span class="n">exclusive</span> <span class="o">=</span> <span class="n">exclusive</span><span class="p">;</span>

  <span class="c1">// Update map of all tracked keys for this transaction
</span><span class="c1"></span>  <span class="n">tracked_locks_</span><span class="o">-&gt;</span><span class="n">Track</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">save_points_</span> <span class="o">!=</span> <span class="k">nullptr</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">save_points_</span><span class="o">-&gt;</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// Update map of tracked keys in this SavePoint
</span><span class="c1"></span>    <span class="n">save_points_</span><span class="o">-&gt;</span><span class="n">top</span><span class="p">().</span><span class="n">new_locks_</span><span class="o">-&gt;</span><span class="n">Track</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>where tracked_locks_ is a unique_ptr of the LockTracker object.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">// Tracks the lock requests.
</span><span class="c1">// In PessimisticTransaction, it tracks the locks acquired through LockMgr;
</span><span class="c1">// In OptimisticTransaction, since there is no LockMgr, it tracks the lock
</span><span class="c1">// intention. Not thread-safe.
</span><span class="c1"></span><span class="k">class</span> <span class="nc">LockTracker</span> <span class="p">{</span>
</code></pre></td></tr></table>
</div>
</div><p>According to the LockTracker class, the difference between optimistic and pessimistic concurrency control is that pessimistic concurrency control uses LockMgr to manage locking and unlocking, while optimistic concurrency control does not have LockMgr and only does tracking, not actually locking. The implementation of LockTracker is roughly a convenient wrapper around the collection, so let&rsquo;s skip it here and look at how conflict detection is done in Commit based on the information recorded in it.</p>
<p>The main function entry for conflict detection is <code>OptimisticTransaction::CheckTransactionForConflicts()</code>, which further calls <code>TransactionUtil::CheckKeysForConflicts()</code> to perform conflict detection.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="n">Status</span> <span class="n">TransactionUtil</span><span class="o">::</span><span class="n">CheckKeysForConflicts</span><span class="p">(</span><span class="n">DBImpl</span><span class="o">*</span> <span class="n">db_impl</span><span class="p">,</span>
                                              <span class="k">const</span> <span class="n">LockTracker</span><span class="o">&amp;</span> <span class="n">tracker</span><span class="p">,</span>
                                              <span class="kt">bool</span> <span class="n">cache_only</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Status</span> <span class="n">result</span><span class="p">;</span>

  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">LockTracker</span><span class="o">::</span><span class="n">ColumnFamilyIterator</span><span class="o">&gt;</span> <span class="n">cf_it</span><span class="p">(</span>
      <span class="n">tracker</span><span class="p">.</span><span class="n">GetColumnFamilyIterator</span><span class="p">());</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">cf_it</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">);</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">cf_it</span><span class="o">-&gt;</span><span class="n">HasNext</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">ColumnFamilyId</span> <span class="n">cf</span> <span class="o">=</span> <span class="n">cf_it</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">();</span>

    <span class="n">SuperVersion</span><span class="o">*</span> <span class="n">sv</span> <span class="o">=</span> <span class="n">db_impl</span><span class="o">-&gt;</span><span class="n">GetAndRefSuperVersion</span><span class="p">(</span><span class="n">cf</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sv</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">Status</span><span class="o">::</span><span class="n">InvalidArgument</span><span class="p">(</span><span class="s">&#34;Could not access column family &#34;</span> <span class="o">+</span>
                                       <span class="n">ToString</span><span class="p">(</span><span class="n">cf</span><span class="p">));</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">SequenceNumber</span> <span class="n">earliest_seq</span> <span class="o">=</span>
        <span class="n">db_impl</span><span class="o">-&gt;</span><span class="n">GetEarliestMemTableSequenceNumber</span><span class="p">(</span><span class="n">sv</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

    <span class="c1">// For each of the keys in this transaction, check to see if someone has
</span><span class="c1"></span>    <span class="c1">// written to this key since the start of the transaction.
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">LockTracker</span><span class="o">::</span><span class="n">KeyIterator</span><span class="o">&gt;</span> <span class="n">key_it</span><span class="p">(</span>
        <span class="n">tracker</span><span class="p">.</span><span class="n">GetKeyIterator</span><span class="p">(</span><span class="n">cf</span><span class="p">));</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">key_it</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">key_it</span><span class="o">-&gt;</span><span class="n">HasNext</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">key</span> <span class="o">=</span> <span class="n">key_it</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">();</span>
      <span class="n">PointLockStatus</span> <span class="n">status</span> <span class="o">=</span> <span class="n">tracker</span><span class="p">.</span><span class="n">GetPointLockStatus</span><span class="p">(</span><span class="n">cf</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
      <span class="k">const</span> <span class="n">SequenceNumber</span> <span class="n">key_seq</span> <span class="o">=</span> <span class="n">status</span><span class="p">.</span><span class="n">seq</span><span class="p">;</span>

      <span class="n">result</span> <span class="o">=</span> <span class="n">CheckKey</span><span class="p">(</span><span class="n">db_impl</span><span class="p">,</span> <span class="n">sv</span><span class="p">,</span> <span class="n">earliest_seq</span><span class="p">,</span> <span class="n">key_seq</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">cache_only</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">db_impl</span><span class="o">-&gt;</span><span class="n">ReturnAndCleanupSuperVersion</span><span class="p">(</span><span class="n">cf</span><span class="p">,</span> <span class="n">sv</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>rocksdb does not implement SSI, only conflict tracking for write operations, the process will be simpler than badger&rsquo;s SSI, only need to check one thing, that is, at commit time, each Key in the db is not updated after the sequence number of the start of the current transaction exists.</p>
<p>The dumbest way to do this is to read the db once for each Key, get its most recent sequence number, and compare it to the transaction&rsquo;s sequence number. If the sequence number in the db is larger, then sorry, there is a transaction conflict.</p>
<p>rocksdb will definitely not do something like reading IO N times for each Key in a transaction. Here is an idea, the execution time of the transaction is not long, in the conflict check scenario, you do not need to find all the historical data of the Key to make a judgment, but only the most recent data. The most recent data is MemTable, so to do the recent conflict detection, it is enough to read the data of MemTable, and there is no need to execute IO.</p>
<p>However, there is one more constraint, that is, if the start time of the transaction is earlier than the oldest Key in the MemTable, it is impossible to determine, and then rocksdb&rsquo;s processing is also more violent, so it just says that the transaction is expired, try again. The following is the relevant logic in <code>TransactionUtil::CheckKey</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">// Since it would be too slow to check the SST files, we will only use
</span><span class="c1"></span>  <span class="c1">// the memtables to check whether there have been any recent writes
</span><span class="c1"></span>  <span class="c1">// to this key after it was accessed in this transaction.  But if the
</span><span class="c1"></span>  <span class="c1">// Memtables do not contain a long enough history, we must fail the
</span><span class="c1"></span>  <span class="c1">// transaction.
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">earliest_seq</span> <span class="o">==</span> <span class="n">kMaxSequenceNumber</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// The age of this memtable is unknown.  Cannot rely on it to check
</span><span class="c1"></span>    <span class="c1">// for recent writes.  This error shouldn&#39;t happen often in practice as
</span><span class="c1"></span>    <span class="c1">// the Memtable should have a valid earliest sequence number except in some
</span><span class="c1"></span>    <span class="c1">// corner cases (such as error cases during recovery).
</span><span class="c1"></span>    <span class="n">need_to_read_sst</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">cache_only</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">Status</span><span class="o">::</span><span class="n">TryAgain</span><span class="p">(</span>
          <span class="s">&#34;Transaction could not check for conflicts as the MemTable does not &#34;</span>
          <span class="s">&#34;contain a long enough history to check write at SequenceNumber: &#34;</span><span class="p">,</span>
          <span class="n">ToString</span><span class="p">(</span><span class="n">snap_seq</span><span class="p">));</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">snap_seq</span> <span class="o">&lt;</span> <span class="n">earliest_seq</span> <span class="o">||</span> <span class="n">min_uncommitted</span> <span class="o">&lt;=</span> <span class="n">earliest_seq</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Use &lt;= for min_uncommitted since earliest_seq is actually the largest sec
</span><span class="c1"></span>    <span class="c1">// before this memtable was created
</span><span class="c1"></span>    <span class="n">need_to_read_sst</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">cache_only</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// The age of this memtable is too new to use to check for recent
</span><span class="c1"></span>      <span class="c1">// writes.
</span><span class="c1"></span>      <span class="kt">char</span> <span class="n">msg</span><span class="p">[</span><span class="mi">300</span><span class="p">];</span>
      <span class="n">snprintf</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">msg</span><span class="p">),</span>
               <span class="s">&#34;Transaction could not check for conflicts for operation at &#34;</span>
               <span class="s">&#34;SequenceNumber %&#34;</span> <span class="n">PRIu64</span>
               <span class="s">&#34; as the MemTable only contains changes newer than &#34;</span>
               <span class="s">&#34;SequenceNumber %&#34;</span> <span class="n">PRIu64</span>
               <span class="s">&#34;.  Increasing the value of the &#34;</span>
               <span class="s">&#34;max_write_buffer_size_to_maintain option could reduce the &#34;</span>
               <span class="s">&#34;frequency &#34;</span>
               <span class="s">&#34;of this error.&#34;</span><span class="p">,</span>
               <span class="n">snap_seq</span><span class="p">,</span> <span class="n">earliest_seq</span><span class="p">);</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">Status</span><span class="o">::</span><span class="n">TryAgain</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The idea of using MemTable for conflict detection is still very clever, but only for SI scenarios where only write operations need to be tracked. If SSI uses the same mechanism, all read operations will have to be MemTable writes, which is far less useful than tracking key sets like badger.</p>
<h2 id="pessimistic-concurrency-control-lock-management">Pessimistic Concurrency Control: Lock Management</h2>
<p>Pessimistic concurrency control is achieved by putting locks on key reads and writes, so that other transactions that try to get a lock go into wait. However, &ldquo;locking&rdquo; here is not really a mutex for each key, but has its own set of line lock semantics.</p>
<p>The main objects are LockMap, LockMapStripe, and LockInfo.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">// Map of #num_stripes LockMapStripes
</span><span class="c1"></span><span class="k">struct</span> <span class="nc">LockMap</span> <span class="p">{</span>
  <span class="c1">// Number of sepearate LockMapStripes to create, each with their own Mutex
</span><span class="c1"></span>  <span class="k">const</span> <span class="n">size_t</span> <span class="n">num_stripes_</span><span class="p">;</span>

  <span class="c1">// Count of keys that are currently locked in this column family.
</span><span class="c1"></span>  <span class="c1">// (Only maintained if PointLockManager::max_num_locks_ is positive.)
</span><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">lock_cnt</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>

  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">LockMapStripe</span><span class="o">*&gt;</span> <span class="n">lock_map_stripes_</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">struct</span> <span class="nc">LockMapStripe</span> <span class="p">{</span>
  <span class="c1">// Mutex must be held before modifying keys map
</span><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">TransactionDBMutex</span><span class="o">&gt;</span> <span class="n">stripe_mutex</span><span class="p">;</span>

  <span class="c1">// Condition Variable per stripe for waiting on a lock
</span><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">TransactionDBCondVar</span><span class="o">&gt;</span> <span class="n">stripe_cv</span><span class="p">;</span>

  <span class="c1">// Locked keys mapped to the info about the transactions that locked them.
</span><span class="c1"></span>  <span class="c1">// TODO(agiardullo): Explore performance of other data structures.
</span><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">LockInfo</span><span class="o">&gt;</span> <span class="n">keys</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">struct</span> <span class="nc">LockInfo</span> <span class="p">{</span>
  <span class="kt">bool</span> <span class="n">exclusive</span><span class="p">;</span>
  <span class="n">autovector</span><span class="o">&lt;</span><span class="n">TransactionID</span><span class="o">&gt;</span> <span class="n">txn_ids</span><span class="p">;</span>

  <span class="c1">// Transaction locks are not valid after this time in us
</span><span class="c1"></span>  <span class="kt">uint64_t</span> <span class="n">expiration_time</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>LockMap is the entry of all locks in a Column Family, and each LockMap is divided into 16 LockMapStripe (stripe), and LockMapStripe has a mapping between keys to LockInfo.</p>
<p>In simple terms, LockMap is a mapping table from Key to LockInfo, and the inner part is divided into a strip of LockMapStripe to improve its concurrency.</p>
<p>LockInfo has the semantics of read/write locks, exclusive means whether it is exclusive or not, if not, multiple read operations can be allowed to hold the lock at the same time, and the list of transactions holding the lock is maintained in txn_ids.</p>
<p>If a lock is acquired while waiting, it will wait on stripe_cv. It can be seen that the locks here are user-state read/write locks based on system primitives such as CondVar and mutex.</p>
<p>To look at the implementation of TryLock().</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="n">Status</span> <span class="n">PointLockManager</span><span class="o">::</span><span class="n">TryLock</span><span class="p">(</span><span class="n">PessimisticTransaction</span><span class="o">*</span> <span class="n">txn</span><span class="p">,</span>
                                 <span class="n">ColumnFamilyId</span> <span class="n">column_family_id</span><span class="p">,</span>
                                 <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">,</span> <span class="n">Env</span><span class="o">*</span> <span class="n">env</span><span class="p">,</span>
                                 <span class="kt">bool</span> <span class="n">exclusive</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Lookup lock map for this column family id
</span><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">LockMap</span><span class="o">&gt;</span> <span class="n">lock_map_ptr</span> <span class="o">=</span> <span class="n">GetLockMap</span><span class="p">(</span><span class="n">column_family_id</span><span class="p">);</span>
  <span class="n">LockMap</span><span class="o">*</span> <span class="n">lock_map</span> <span class="o">=</span> <span class="n">lock_map_ptr</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">lock_map</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">msg</span><span class="p">[</span><span class="mi">255</span><span class="p">];</span>
    <span class="n">snprintf</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">msg</span><span class="p">),</span> <span class="s">&#34;Column family id not found: %&#34;</span> <span class="n">PRIu32</span><span class="p">,</span>
             <span class="n">column_family_id</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">Status</span><span class="o">::</span><span class="n">InvalidArgument</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// Need to lock the mutex for the stripe that this key hashes to
</span><span class="c1"></span>  <span class="n">size_t</span> <span class="n">stripe_num</span> <span class="o">=</span> <span class="n">lock_map</span><span class="o">-&gt;</span><span class="n">GetStripe</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">lock_map</span><span class="o">-&gt;</span><span class="n">lock_map_stripes_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">stripe_num</span><span class="p">);</span>
  <span class="n">LockMapStripe</span><span class="o">*</span> <span class="n">stripe</span> <span class="o">=</span> <span class="n">lock_map</span><span class="o">-&gt;</span><span class="n">lock_map_stripes_</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">stripe_num</span><span class="p">);</span>

  <span class="n">LockInfo</span> <span class="nf">lock_info</span><span class="p">(</span><span class="n">txn</span><span class="o">-&gt;</span><span class="n">GetID</span><span class="p">(),</span> <span class="n">txn</span><span class="o">-&gt;</span><span class="n">GetExpirationTime</span><span class="p">(),</span> <span class="n">exclusive</span><span class="p">);</span>
  <span class="kt">int64_t</span> <span class="n">timeout</span> <span class="o">=</span> <span class="n">txn</span><span class="o">-&gt;</span><span class="n">GetLockTimeout</span><span class="p">();</span>

  <span class="k">return</span> <span class="nf">AcquireWithTimeout</span><span class="p">(</span><span class="n">txn</span><span class="p">,</span> <span class="n">lock_map</span><span class="p">,</span> <span class="n">stripe</span><span class="p">,</span> <span class="n">column_family_id</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span>
                            <span class="n">timeout</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">lock_info</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>This part is relatively easy to read, it is to obtain LockMapStripe, generate LockInfo, and finally call AcquireWithTimeout to go to the process of acquiring the lock.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">// Helper function for TryLock().
</span><span class="c1"></span><span class="n">Status</span> <span class="n">PointLockManager</span><span class="o">::</span><span class="n">AcquireWithTimeout</span><span class="p">(</span>
    <span class="n">PessimisticTransaction</span><span class="o">*</span> <span class="n">txn</span><span class="p">,</span> <span class="n">LockMap</span><span class="o">*</span> <span class="n">lock_map</span><span class="p">,</span> <span class="n">LockMapStripe</span><span class="o">*</span> <span class="n">stripe</span><span class="p">,</span>
    <span class="n">ColumnFamilyId</span> <span class="n">column_family_id</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">,</span> <span class="n">Env</span><span class="o">*</span> <span class="n">env</span><span class="p">,</span>
    <span class="kt">int64_t</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">LockInfo</span><span class="o">&amp;&amp;</span> <span class="n">lock_info</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ... 获取 stripe 的 mutex
</span><span class="c1"></span>
  <span class="c1">// 尝试获取锁
</span><span class="c1"></span>  <span class="kt">uint64_t</span> <span class="n">expire_time_hint</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">autovector</span><span class="o">&lt;</span><span class="n">TransactionID</span><span class="o">&gt;</span> <span class="n">wait_ids</span><span class="p">;</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">AcquireLocked</span><span class="p">(</span><span class="n">lock_map</span><span class="p">,</span> <span class="n">stripe</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">lock_info</span><span class="p">),</span>
                         <span class="o">&amp;</span><span class="n">expire_time_hint</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait_ids</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">.</span><span class="n">ok</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">timeout</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="n">timed_out</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">do</span> <span class="p">{</span>
      <span class="c1">// ... 根据 AcquireLocked() 返回的 expire_time_hint，计算 cv_end_time，即超时等待时间
</span><span class="c1"></span>      <span class="n">assert</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">IsBusy</span><span class="p">()</span> <span class="o">||</span> <span class="n">wait_ids</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

      <span class="c1">// ... 根据 AcquireLocked() 返回的 wait_ids，判断得知当前事务在依赖其他事务所持有的锁
</span><span class="c1"></span>      <span class="c1">// ... 发起死锁探测
</span><span class="c1"></span>
      <span class="c1">// 进入等待
</span><span class="c1"></span>      <span class="k">if</span> <span class="p">(</span><span class="n">cv_end_time</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Wait indefinitely
</span><span class="c1"></span>        <span class="n">result</span> <span class="o">=</span> <span class="n">stripe</span><span class="o">-&gt;</span><span class="n">stripe_cv</span><span class="o">-&gt;</span><span class="n">Wait</span><span class="p">(</span><span class="n">stripe</span><span class="o">-&gt;</span><span class="n">stripe_mutex</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="kt">uint64_t</span> <span class="n">now</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">NowMicros</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cv_end_time</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">now</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">result</span> <span class="o">=</span> <span class="n">stripe</span><span class="o">-&gt;</span><span class="n">stripe_cv</span><span class="o">-&gt;</span><span class="n">WaitFor</span><span class="p">(</span><span class="n">stripe</span><span class="o">-&gt;</span><span class="n">stripe_mutex</span><span class="p">,</span>
                                              <span class="n">cv_end_time</span> <span class="o">-</span> <span class="n">now</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>

      <span class="c1">// ... 清理死锁检测上下文
</span><span class="c1"></span>
      <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">IsTimedOut</span><span class="p">())</span> <span class="p">{</span>
          <span class="n">timed_out</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
          <span class="c1">// Even though we timed out, we will still make one more attempt to
</span><span class="c1"></span>          <span class="c1">// acquire lock below (it is possible the lock expired and we
</span><span class="c1"></span>          <span class="c1">// were never signaled).
</span><span class="c1"></span>      <span class="p">}</span>

      <span class="c1">// 重新尝试获取锁
</span><span class="c1"></span>      <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">ok</span><span class="p">()</span> <span class="o">||</span> <span class="n">result</span><span class="p">.</span><span class="n">IsTimedOut</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">AcquireLocked</span><span class="p">(</span><span class="n">lock_map</span><span class="p">,</span> <span class="n">stripe</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">lock_info</span><span class="p">),</span>
                               <span class="o">&amp;</span><span class="n">expire_time_hint</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait_ids</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">.</span><span class="n">ok</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">timed_out</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">stripe</span><span class="o">-&gt;</span><span class="n">stripe_mutex</span><span class="o">-&gt;</span><span class="n">UnLock</span><span class="p">();</span>

  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Leaving aside the deadlock detection part, the logic here is relatively simple:</p>
<ol>
<li>try to get the lock, AcquireLocked() is non-blocking, fail to get it, return failure</li>
<li>if the lock acquisition is unsuccessful, then back off and wait for stripe_cv event notification</li>
<li>loop to retry to get the lock</li>
</ol>
<p>AcquireLocked() is a textbook implementation of read/write locking.</p>
<ul>
<li>If the lock corresponding to the Key is not occupied, if there is no accident, the lock information will be saved in the stripe and txn_ids will be configured as the current transaction ID.
<ul>
<li>The accident here means that there is a configuration max_num_locks_ in rocksdb to limit the total number of locks, if the upper limit is exceeded, then locking fails and returns Status::Busy</li>
</ul>
</li>
<li>If the lock corresponding to the Key is already occupied
<ul>
<li>If neither the occupied lock nor the lock to be acquired is mutually exclusive, multiple readers are allowed to share the lock, and the current transaction ID is appended to the txn_ids of lock_info in stripe to indicate successful read lock acquisition.</li>
<li>If either the occupied lock or the lock to be acquired has a mutually exclusive flag, the lock should fail to be acquired and return Status::TimedOut if there is no accident, and also return txn_ids to indicate to the caller the list of transactions holding the lock to assist in deadlock detection, but there are two special cases.
<ul>
<li>Recursive lock: if the lock is held by the current transaction, the lock&rsquo;s mutex marker is overwritten and the lock is acquired successfully.</li>
<li>Lock timeout: If the occupied lock happens to time out, the lock can be grabbed</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>The code of AcquireLocked() is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">// Try to lock this key after we have acquired the mutex.
</span><span class="c1">// Sets *expire_time to the expiration time in microseconds
</span><span class="c1">//  or 0 if no expiration.
</span><span class="c1">// REQUIRED:  Stripe mutex must be held.
</span><span class="c1"></span><span class="n">Status</span> <span class="n">PointLockManager</span><span class="o">::</span><span class="n">AcquireLocked</span><span class="p">(</span><span class="n">LockMap</span><span class="o">*</span> <span class="n">lock_map</span><span class="p">,</span> <span class="n">LockMapStripe</span><span class="o">*</span> <span class="n">stripe</span><span class="p">,</span>
                                       <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">,</span> <span class="n">Env</span><span class="o">*</span> <span class="n">env</span><span class="p">,</span>
                                       <span class="n">LockInfo</span><span class="o">&amp;&amp;</span> <span class="n">txn_lock_info</span><span class="p">,</span>
                                       <span class="kt">uint64_t</span><span class="o">*</span> <span class="n">expire_time</span><span class="p">,</span>
                                       <span class="n">autovector</span><span class="o">&lt;</span><span class="n">TransactionID</span><span class="o">&gt;*</span> <span class="n">txn_ids</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">txn_lock_info</span><span class="p">.</span><span class="n">txn_ids</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>

  <span class="n">Status</span> <span class="n">result</span><span class="p">;</span>
  <span class="c1">// Check if this key is already locked
</span><span class="c1"></span>  <span class="k">auto</span> <span class="n">stripe_iter</span> <span class="o">=</span> <span class="n">stripe</span><span class="o">-&gt;</span><span class="n">keys</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">stripe_iter</span> <span class="o">!=</span> <span class="n">stripe</span><span class="o">-&gt;</span><span class="n">keys</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// Lock already held
</span><span class="c1"></span>    <span class="n">LockInfo</span><span class="o">&amp;</span> <span class="n">lock_info</span> <span class="o">=</span> <span class="n">stripe_iter</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">lock_info</span><span class="p">.</span><span class="n">txn_ids</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="o">!</span><span class="n">lock_info</span><span class="p">.</span><span class="n">exclusive</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">lock_info</span><span class="p">.</span><span class="n">exclusive</span> <span class="o">||</span> <span class="n">txn_lock_info</span><span class="p">.</span><span class="n">exclusive</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">lock_info</span><span class="p">.</span><span class="n">txn_ids</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
          <span class="n">lock_info</span><span class="p">.</span><span class="n">txn_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">txn_lock_info</span><span class="p">.</span><span class="n">txn_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
        <span class="c1">// The list contains one txn and we&#39;re it, so just take it.
</span><span class="c1"></span>        <span class="n">lock_info</span><span class="p">.</span><span class="n">exclusive</span> <span class="o">=</span> <span class="n">txn_lock_info</span><span class="p">.</span><span class="n">exclusive</span><span class="p">;</span>
        <span class="n">lock_info</span><span class="p">.</span><span class="n">expiration_time</span> <span class="o">=</span> <span class="n">txn_lock_info</span><span class="p">.</span><span class="n">expiration_time</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// Check if it&#39;s expired. Skips over txn_lock_info.txn_ids[0] in case
</span><span class="c1"></span>        <span class="c1">// it&#39;s there for a shared lock with multiple holders which was not
</span><span class="c1"></span>        <span class="c1">// caught in the first case.
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">IsLockExpired</span><span class="p">(</span><span class="n">txn_lock_info</span><span class="p">.</span><span class="n">txn_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lock_info</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span>
                          <span class="n">expire_time</span><span class="p">))</span> <span class="p">{</span>
          <span class="c1">// lock is expired, can steal it
</span><span class="c1"></span>          <span class="n">lock_info</span><span class="p">.</span><span class="n">txn_ids</span> <span class="o">=</span> <span class="n">txn_lock_info</span><span class="p">.</span><span class="n">txn_ids</span><span class="p">;</span>
          <span class="n">lock_info</span><span class="p">.</span><span class="n">exclusive</span> <span class="o">=</span> <span class="n">txn_lock_info</span><span class="p">.</span><span class="n">exclusive</span><span class="p">;</span>
          <span class="n">lock_info</span><span class="p">.</span><span class="n">expiration_time</span> <span class="o">=</span> <span class="n">txn_lock_info</span><span class="p">.</span><span class="n">expiration_time</span><span class="p">;</span>
          <span class="c1">// lock_cnt does not change
</span><span class="c1"></span>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="n">result</span> <span class="o">=</span> <span class="n">Status</span><span class="o">::</span><span class="n">TimedOut</span><span class="p">(</span><span class="n">Status</span><span class="o">::</span><span class="n">SubCode</span><span class="o">::</span><span class="n">kLockTimeout</span><span class="p">);</span>
          <span class="o">*</span><span class="n">txn_ids</span> <span class="o">=</span> <span class="n">lock_info</span><span class="p">.</span><span class="n">txn_ids</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// We are requesting shared access to a shared lock, so just grant it.
</span><span class="c1"></span>      <span class="n">lock_info</span><span class="p">.</span><span class="n">txn_ids</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">txn_lock_info</span><span class="p">.</span><span class="n">txn_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
      <span class="c1">// Using std::max means that expiration time never goes down even when
</span><span class="c1"></span>      <span class="c1">// a transaction is removed from the list. The correct solution would be
</span><span class="c1"></span>      <span class="c1">// to track expiry for every transaction, but this would also work for
</span><span class="c1"></span>      <span class="c1">// now.
</span><span class="c1"></span>      <span class="n">lock_info</span><span class="p">.</span><span class="n">expiration_time</span> <span class="o">=</span>
          <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">lock_info</span><span class="p">.</span><span class="n">expiration_time</span><span class="p">,</span> <span class="n">txn_lock_info</span><span class="p">.</span><span class="n">expiration_time</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>  <span class="c1">// Lock not held.
</span><span class="c1"></span>    <span class="c1">// Check lock limit
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">max_num_locks_</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
        <span class="n">lock_map</span><span class="o">-&gt;</span><span class="n">lock_cnt</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">max_num_locks_</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">Status</span><span class="o">::</span><span class="n">Busy</span><span class="p">(</span><span class="n">Status</span><span class="o">::</span><span class="n">SubCode</span><span class="o">::</span><span class="n">kLockLimit</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// acquire lock
</span><span class="c1"></span>      <span class="n">stripe</span><span class="o">-&gt;</span><span class="n">keys</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">txn_lock_info</span><span class="p">));</span>

      <span class="c1">// Maintain lock count if there is a limit on the number of locks
</span><span class="c1"></span>      <span class="k">if</span> <span class="p">(</span><span class="n">max_num_locks_</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">lock_map</span><span class="o">-&gt;</span><span class="n">lock_cnt</span><span class="o">++</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>A final look at the unlocking section.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="n">PointLockManager</span><span class="o">::</span><span class="n">UnLock</span><span class="p">(</span><span class="n">PessimisticTransaction</span><span class="o">*</span> <span class="n">txn</span><span class="p">,</span>
                              <span class="n">ColumnFamilyId</span> <span class="n">column_family_id</span><span class="p">,</span>
                              <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">,</span> <span class="n">Env</span><span class="o">*</span> <span class="n">env</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">LockMap</span><span class="o">&gt;</span> <span class="n">lock_map_ptr</span> <span class="o">=</span> <span class="n">GetLockMap</span><span class="p">(</span><span class="n">column_family_id</span><span class="p">);</span>
  <span class="n">LockMap</span><span class="o">*</span> <span class="n">lock_map</span> <span class="o">=</span> <span class="n">lock_map_ptr</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">lock_map</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Column Family must have been dropped.
</span><span class="c1"></span>    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Lock the mutex for the stripe that this key hashes to
</span><span class="c1"></span>  <span class="n">size_t</span> <span class="n">stripe_num</span> <span class="o">=</span> <span class="n">lock_map</span><span class="o">-&gt;</span><span class="n">GetStripe</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">lock_map</span><span class="o">-&gt;</span><span class="n">lock_map_stripes_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">stripe_num</span><span class="p">);</span>
  <span class="n">LockMapStripe</span><span class="o">*</span> <span class="n">stripe</span> <span class="o">=</span> <span class="n">lock_map</span><span class="o">-&gt;</span><span class="n">lock_map_stripes_</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">stripe_num</span><span class="p">);</span>

  <span class="n">stripe</span><span class="o">-&gt;</span><span class="n">stripe_mutex</span><span class="o">-&gt;</span><span class="n">Lock</span><span class="p">().</span><span class="n">PermitUncheckedError</span><span class="p">();</span>
  <span class="n">UnLockKey</span><span class="p">(</span><span class="n">txn</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">stripe</span><span class="p">,</span> <span class="n">lock_map</span><span class="p">,</span> <span class="n">env</span><span class="p">);</span>
  <span class="n">stripe</span><span class="o">-&gt;</span><span class="n">stripe_mutex</span><span class="o">-&gt;</span><span class="n">UnLock</span><span class="p">();</span>

  <span class="c1">// Signal waiting threads to retry locking
</span><span class="c1"></span>  <span class="n">stripe</span><span class="o">-&gt;</span><span class="n">stripe_cv</span><span class="o">-&gt;</span><span class="n">NotifyAll</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>where UnLockKey() is a wrapper for removing the current transaction ID from the LockInfo in stripe or deleting the entire LockInfo.</p>
<p>Wake Lock Waiting Here is a very violent stripe_cv→NotifyAll(), in the form of a swarm to wake up all the players waiting to get a lock, but only one player can successfully get stripe_mutex.</p>
<h2 id="pessimistic-concurrency-control-deadlock-detection">Pessimistic concurrency control: deadlock detection</h2>
<p>What deadlock detection does is to track lock dependencies between transactions, determine if there is a ring in it by BFS traversal, and prevent such ringed locking operations in advance. deadlock_detect is off by default in rocksdb, and when active deadlock detection is turned off, it can still be recovered from deadlocks by the lock timeout mechanism.</p>
<p>Deadlock detection occurs in the AcquireWithTimeout function.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++">      <span class="c1">// We are dependent on a transaction to finish, so perform deadlock
</span><span class="c1"></span>      <span class="c1">// detection.
</span><span class="c1"></span>      <span class="k">if</span> <span class="p">(</span><span class="n">wait_ids</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">txn</span><span class="o">-&gt;</span><span class="n">IsDeadlockDetect</span><span class="p">())</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">IncrementWaiters</span><span class="p">(</span><span class="n">txn</span><span class="p">,</span> <span class="n">wait_ids</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">column_family_id</span><span class="p">,</span>
                               <span class="n">lock_info</span><span class="p">.</span><span class="n">exclusive</span><span class="p">,</span> <span class="n">env</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">Status</span><span class="o">::</span><span class="n">Busy</span><span class="p">(</span><span class="n">Status</span><span class="o">::</span><span class="n">SubCode</span><span class="o">::</span><span class="n">kDeadlock</span><span class="p">);</span>
            <span class="n">stripe</span><span class="o">-&gt;</span><span class="n">stripe_mutex</span><span class="o">-&gt;</span><span class="n">UnLock</span><span class="p">();</span>
            <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">txn</span><span class="o">-&gt;</span><span class="n">SetWaitingTxn</span><span class="p">(</span><span class="n">wait_ids</span><span class="p">,</span> <span class="n">column_family_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">);</span>
      <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>A single call to AcquireLocked will return a list of wait_ids waiting for a lock when the lock fails. wait_ids This part of the information is used as the basis for tracking the lock dependency graph.</p>
<p>The fields related to deadlock detection are.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++">  <span class="c1">// Must be held when modifying wait_txn_map_ and rev_wait_txn_map_.
</span><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">wait_txn_map_mutex_</span><span class="p">;</span>

  <span class="c1">// Maps from waitee -&gt; number of waiters.
</span><span class="c1"></span>  <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">TransactionID</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">rev_wait_txn_map_</span><span class="p">;</span>
  <span class="c1">// Maps from waiter -&gt; waitee.
</span><span class="c1"></span>  <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">TransactionID</span><span class="p">,</span> <span class="n">TrackedTrxInfo</span><span class="o">&gt;</span> <span class="n">wait_txn_map_</span><span class="p">;</span>
  <span class="n">DeadlockInfoBuffer</span> <span class="n">dlock_buffer_</span>
</code></pre></td></tr></table>
</div>
</div><p>The rev_wait_txn_map_ seems to be used for pruning, tracking the number of waiters for each transaction ID, if the number of waiters is 0, then there must be no deadlock dependency, so there is no need to traverse the map later. On the other hand, if the number of waiters &gt; 1, there is not necessarily a deadlock dependency, so we still need to traverse the graph to know.</p>
<p>The wait_txn_map_ field is the target of BFS traversal. In IncrementWaiters, wait_txn_map_ is traversed from the wait_ids of the current transaction, and if the ID of the current transaction is traversed, the ring is considered to exist.</p>
<p>The logic of the BFS part is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"> <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">tail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">head</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">head</span> <span class="o">&lt;</span> <span class="n">txn</span><span class="o">-&gt;</span><span class="n">GetDeadlockDetectDepth</span><span class="p">();</span> <span class="n">head</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">next_ids</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">next_ids</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">())</span> <span class="o">&amp;&amp;</span>
             <span class="n">tail</span> <span class="o">+</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">txn</span><span class="o">-&gt;</span><span class="n">GetDeadlockDetectDepth</span><span class="p">();</span>
           <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">queue_values</span><span class="p">[</span><span class="n">tail</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">next_ids</span><span class="p">)[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">queue_parents</span><span class="p">[</span><span class="n">tail</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">tail</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// No more items in the list, meaning no deadlock.
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">tail</span> <span class="o">==</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">auto</span> <span class="n">next</span> <span class="o">=</span> <span class="n">queue_values</span><span class="p">[</span><span class="n">head</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">==</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 有死锁存在，结合 queue_parents 中的路径信息，记录到 dlock_buffer_ 中
</span><span class="c1"></span>      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wait_txn_map_</span><span class="p">.</span><span class="n">Contains</span><span class="p">(</span><span class="n">next</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">next_ids</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">parent</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
      <span class="n">next_ids</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">wait_txn_map_</span><span class="p">.</span><span class="n">Get</span><span class="p">(</span><span class="n">next</span><span class="p">).</span><span class="n">m_neighbors</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The BFS queue uses two arrays of maximum length deadlock_detect_depth_ queue_values[] and two subscripts head and tail, tail represents the tail of the queue, head represents the head, and the traversal ends when head catches up with tail. When a deadlock dependency is found, the path to the deadlock is recorded in the dlock_buffer_ based on the information in queue_parents[] to aid in the diagnosis.</p>
<h2 id="summary">Summary</h2>
<ul>
<li>In OptimisticTransaction, rocksdb directly uses MemTable to get the latest Sequence number of the Key, which is used for conflict detection during Commit to determine whether the Key has been written by other transactions during the transaction.</li>
<li>In PessimisticTransactionDB, rocksdb implements row lock semantics based on CondVar and mutex in LockManager, each Key corresponds to a row lock, and waits for CondVar notification if there is a lock conflict when obtaining a row lock.</li>
<li>Deadlock conflict is a BFS of lock dependency graph to find whether there is a ring between lock dependencies, if there is, it is considered that there will be a deadlock, so it will prevent locking in advance. rocksdb does not enable deadlock detection by default, if there is a deadlock, it can still recover by lock timeout.</li>
</ul>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/rocksdb/">rocksdb</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-01/badger-tx/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">badger transaction process</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-01/crdb-txn/">
            <span class="next-text nav-default">cockroachdb two-stage commit process</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
