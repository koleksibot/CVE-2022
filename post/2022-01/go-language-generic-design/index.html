<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Go Language Generic Design - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="After several years of work, the generic feature is finally going to follow the 1.18 release. This is a milestone. Considering that the original design document of Go generic is rather difficult and has a messy structure, I&amp;rsquo;ll compile my understanding into a document and share it with you today. Since there is a lot of content and my own understanding of the English design document is limited (especially the" /><meta name="keywords" content="golang, Generics" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-01/go-language-generic-design/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Go Language Generic Design" />
<meta property="og:description" content="After several years of work, the generic feature is finally going to follow the 1.18 release. This is a milestone. Considering that the original design document of Go generic is rather difficult and has a messy structure, I&rsquo;ll compile my understanding into a document and share it with you today. Since there is a lot of content and my own understanding of the English design document is limited (especially the" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-01/go-language-generic-design/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-01-04T18:04:39+08:00" />
<meta property="article:modified_time" content="2022-01-04T18:04:39+08:00" />

<meta itemprop="name" content="Go Language Generic Design">
<meta itemprop="description" content="After several years of work, the generic feature is finally going to follow the 1.18 release. This is a milestone. Considering that the original design document of Go generic is rather difficult and has a messy structure, I&rsquo;ll compile my understanding into a document and share it with you today. Since there is a lot of content and my own understanding of the English design document is limited (especially the"><meta itemprop="datePublished" content="2022-01-04T18:04:39+08:00" />
<meta itemprop="dateModified" content="2022-01-04T18:04:39+08:00" />
<meta itemprop="wordCount" content="7125">
<meta itemprop="keywords" content="golang," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go Language Generic Design"/>
<meta name="twitter:description" content="After several years of work, the generic feature is finally going to follow the 1.18 release. This is a milestone. Considering that the original design document of Go generic is rather difficult and has a messy structure, I&rsquo;ll compile my understanding into a document and share it with you today. Since there is a lot of content and my own understanding of the English design document is limited (especially the"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Go Language Generic Design</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-01-04 18:04:39 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 7125 words </span>
          <span class="more-meta"> 15 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#type-parameters">Type parameters</a></li>
        <li><a href="#generic-constraints">Generic Constraints</a>
          <ul>
            <li><a href="#any-constraint"><code>any</code> constraint</a></li>
            <li><a href="#functions-constraints">Functions Constraints</a></li>
            <li><a href="#operators-constraints">Operators Constraints</a></li>
            <li><a href="#composite-constraints">Composite Constraints</a></li>
            <li><a href="#built-in-constraints">Built-in constraints</a></li>
          </ul>
        </li>
        <li><a href="#generic-derivation-type-inference">Generic derivation (Type inference)</a>
          <ul>
            <li><a href="#type-unification">Type unification</a></li>
            <li><a href="#function-argument-type-inference">Function argument type inference</a></li>
            <li><a href="#constraint-type-inference">Constraint type inference</a></li>
          </ul>
        </li>
        <li><a href="#summary">Summary</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>After several years of work, the generic feature is finally going to follow the 1.18 release. This is a milestone. Considering that the original design document of Go generic is rather difficult and has a messy structure, I&rsquo;ll compile my understanding into a document and share it with you today. Since there is a lot of content and my own understanding of the English design document is limited (especially the type derivation part), mistakes are inevitable. I welcome your readers to criticize and correct me by leaving comments.</p>
<h2 id="type-parameters">Type parameters</h2>
<p>Generic is called type parameters in Go. As we know, Go is a statically strongly typed language. We need to specify explicit types for variables when we write code. Generic programming, on the other hand, is exactly writing code that can be adapted to different types, so we need a way to describe different types.</p>
<p>The following is an example from the Go language generic design scheme.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Print 打印切片 s 的所有元素。
</span><span class="c1">// 此方法可以打印任意类型的切片成员。
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Print</span><span class="p">(</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The <code>T</code> table is the type of the slice member, but the real <strong>internal type</strong> of <code>T</code> is not determined at the time of defining <code>Print()</code> and needs to be specified when the function is called. That is, we need to pass in an additional special parameter to specify the specific type of <code>T</code> when we call the <code>Print()</code> function. This special parameter is called a type parameter.</p>
<p>Since the function <code>Print()</code> needs to receive type parameters, it has to declare the type parameters it needs. Thus, the syntax for declaring type parameters is</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Print 打印切片 s 的所有元素。
</span><span class="c1">// 该函数定义了一个类型参数 T，并且使用 T 作为入参切片 s 的元素类型
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">Print</span><span class="p">[</span><span class="nx">T</span> <span class="nx">any</span><span class="p">](</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 同上
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Go inserts a set of square brackets between the original function name and the list of function arguments to indicate type arguments. As with function arguments, we need to specify a &ldquo;type&rdquo; for each type argument, which the Go language calls a <strong>constraint</strong>. We&rsquo;ll analyze this in more detail below. For now, all you need to know is that <code>any</code> is a special constraint that indicates that the corresponding type parameter can accept any type, i.e., there is no constraint.</p>
<p>All type arguments need to be specified at the time of the function call, so we need another syntax, the example of which is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 调用 Print 打印 []int{1,2,3}
</span><span class="c1">// 因为切片 s 的成员类型为 int，所以需要指定 T 的值为 int
</span><span class="c1"></span><span class="nx">Print</span><span class="p">[</span><span class="kt">int</span><span class="p">]([]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">})</span>
<span class="c1">// 输出
</span><span class="c1">// 1
</span><span class="c1">// 2
</span><span class="c1">// 3
</span></code></pre></td></tr></table>
</div>
</div><p>When calling the function <code>Print()</code>, the Go language requires that square brackets be inserted before the function name and the argument list, and that the actual type of the type argument be specified in the square brackets. In the above example, since the actual type of the entry s is <code>[]int</code>, the type <code>int</code> needs to be passed to the type parameter <code>T</code>. If you want to print a floating-point slice, you can.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">Print</span><span class="p">[</span><span class="kt">float64</span><span class="p">]([]</span><span class="kt">float64</span><span class="p">{</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.3</span><span class="p">})</span>
<span class="c1">// 输出
</span><span class="c1">// 0.1
</span><span class="c1">// 0.2
</span><span class="c1">// 0.3
</span></code></pre></td></tr></table>
</div>
</div><p>The type parameter can be used not only to declare the type of the function entry, but also to declare the type of the entry, e.g.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Pointer 返回任意参数的指针。
</span><span class="c1"></span><span class="nx">Pointer</span><span class="p">[</span><span class="nx">T</span> <span class="nx">any</span><span class="p">](</span><span class="nx">t</span> <span class="nx">T</span><span class="p">)</span> <span class="o">*</span><span class="nx">T</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">t</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Use as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">Pointer</span><span class="p">[</span><span class="kt">int</span><span class="p">](</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// 返回 *int 类型，指向的值为 1
</span><span class="c1"></span><span class="nx">Pointer</span><span class="p">[</span><span class="kt">float64</span><span class="p">](</span><span class="mf">0.1</span><span class="p">)</span> <span class="c1">// 返回 *float64 类型，指向的值为 0.1
</span></code></pre></td></tr></table>
</div>
</div><p>A generic function can declare multiple type parameters, e.g.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Must2 接受 t1, t2 和 err 三个参数，如果 err 不为空，则 panic
</span><span class="c1">// 否则返回 t1 和 t2。
</span><span class="c1">// 多类型参数的约束语法跟普通函数的参数类型相同。
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">Must2</span><span class="p">[</span><span class="nx">T1</span><span class="p">,</span> <span class="nx">T2</span> <span class="nx">any</span><span class="p">](</span><span class="nx">t1</span> <span class="nx">T1</span><span class="p">,</span> <span class="nx">t2</span> <span class="nx">T2</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">(</span><span class="nx">T1</span><span class="p">,</span> <span class="nx">T2</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">t1</span><span class="p">,</span> <span class="nx">t2</span>
<span class="p">}</span>
<span class="c1">// 假设我们需要调用 foo 函数
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">float64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="c1">// 如果 foo 函数返回 err 则会 panic。
</span><span class="c1"></span><span class="nx">i</span><span class="p">,</span> <span class="nx">f</span> <span class="o">:=</span> <span class="nx">Must2</span><span class="p">[</span><span class="kt">int</span><span class="p">,</span> <span class="kt">float64</span><span class="p">](</span><span class="nf">foo</span><span class="p">())</span>
</code></pre></td></tr></table>
</div>
</div><p>In addition to generic functions, the Go language supports declaring type parameters in type definitions. For example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Vector 是一个切片，其元素的类型由类型参数 T 确定。
</span><span class="c1">// T 的实际类型需要在声明 Vector 对象的时候指定。
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Vector</span><span class="p">[</span><span class="nx">T</span> <span class="nx">any</span><span class="p">]</span> <span class="p">[]</span><span class="nx">T</span>
</code></pre></td></tr></table>
</div>
</div><p>If we need to save the <code>int</code> element, we can define it like this.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">v</span> <span class="nx">Vector</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span> <span class="c1">// v 的类型为 []int
</span></code></pre></td></tr></table>
</div>
</div><p>Type definitions that declare type parameters are called Generic Types. For generic types, we can also define generic methods, e.g.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Push 向容器尾部追加新元素
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">Vector</span><span class="p">[</span><span class="nx">T</span><span class="p">])</span> <span class="nf">Push</span><span class="p">(</span><span class="nx">x</span> <span class="nx">T</span><span class="p">)</span> <span class="p">{</span> <span class="o">*</span><span class="nx">v</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="o">*</span><span class="nx">v</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Since the type parameter is already specified when declaring <code>v</code>, the call to the function <code>Push()</code> eliminates the need to pass in the type parameter.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">v</span> <span class="nx">Vector</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span>
<span class="nx">v</span><span class="p">.</span><span class="nf">Push</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// 不需要指定类型参数
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="c1">// 输出 [1]
</span></code></pre></td></tr></table>
</div>
</div><p>Both generic functions and generic types require specific type parameters to be passed in at the time of use. This is natural, yet cumbersome. For example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">Print</span><span class="p">[</span><span class="kt">int</span><span class="p">]([]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">})</span>
<span class="nx">Print</span><span class="p">[</span><span class="kt">float64</span><span class="p">]([]</span><span class="kt">float64</span><span class="p">{</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.3</span><span class="p">})</span>
</code></pre></td></tr></table>
</div>
</div><p>For the convenience of developers who <strong>use</strong> generic functions or types, the Go language supports derivation (inference)** of the actual types of arguments by the actual types of the arguments passed in!</p>
<p>So, the above function call can be abbreviated as follows</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nf">Print</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">})</span> <span class="c1">// 推导出 T 的实际类型为 int
</span><span class="c1"></span><span class="nf">Println</span><span class="p">([]</span><span class="kt">float64</span><span class="p">{</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.3</span><span class="p">})</span> <span class="c1">// 推导出 T 的实际类型为 float64
</span><span class="c1"></span><span class="nf">Pointer</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span> <span class="c1">// 推导出 T 的实际类型为 float64
</span></code></pre></td></tr></table>
</div>
</div><p>The generic type can also be derived.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">v</span> <span class="o">:=</span> <span class="nx">Vector</span><span class="p">{</span><span class="mi">1</span><span class="p">}</span> <span class="c1">// 推导出 T 的实际类型为 float64
</span></code></pre></td></tr></table>
</div>
</div><p>With generic derivation, developers can use generic functions and generic types just like normal functions or types, simply and clearly. This is remarkable design. But generic derivation is very complex, and we&rsquo;ll cover it in detail later in this article.</p>
<p>By now, we&rsquo;ve covered the most significant generic syntax of the Go language. A brief summary is as follows.</p>
<ul>
<li>Functions can define type arguments: <code>func F[T any](p T) { ... }</code> .</li>
<li>Types can be specified using type parameters in the argument declaration and in the function body.</li>
<li>Type parameters can also be specified in type definitions: <code>type M[T any] []T</code> .</li>
<li>Type parameters must specify type constraints: <code>func F[T Constraint](p T) { ... }</code> .</li>
<li>Using a generic function or type requires passing a type parameter.</li>
<li>The use of generics can be simplified by reducing the number of specified type arguments through generic derivation.</li>
</ul>
<p>We discuss the constraints and generic derivation of generics in detail below.</p>
<h2 id="generic-constraints">Generic Constraints</h2>
<p>We covered in the previous section that type constraints need to be specified for all type parameters. We also introduced that <code>any</code> represents a special constraint that accepts all types.</p>
<p>So why do type parameters need constraints? Look at the following example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Stringify 将任意类型的切片转化成对应的字符串切片
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">Stringify</span><span class="p">[</span><span class="nx">T</span> <span class="nx">any</span><span class="p">](</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="p">(</span><span class="nx">ret</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="nx">ret</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">ret</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nf">String</span><span class="p">())</span> <span class="c1">// 错误
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Here the type parameter <code>T</code> is bound to <code>any</code>, so the elements of the slice <code>s</code> can be of any type. This means that the elements of <code>s</code> can have no <code>String()</code> method. For example, let&rsquo;s try to execute.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">Stringify</span><span class="p">[</span><span class="kt">int</span><span class="p">]([]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">})</span>
</code></pre></td></tr></table>
</div>
</div><p>At this point, the actual type of <code>T</code> is <code>int</code>, so the type of <code>s</code> is <code>[]int</code>, and thus the type of <code>v</code> is <code>int</code>. Obviously, <code>int</code> has no <code>String()</code> method and is bound to report an error!</p>
<p>So, for the <code>Stringify</code> function, we need to restrict the scope of the type parameter <code>T</code>. Specifically, we can only pass <code>T</code> types that have a <code>String()</code> method.</p>
<p>As another example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Max 返回两者中比较大的值
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">Max</span><span class="p">[</span><span class="nx">T</span> <span class="nx">any</span><span class="p">](</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="nx">T</span><span class="p">)</span> <span class="nx">T</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span> <span class="c1">// 错误
</span><span class="c1"></span>		<span class="k">return</span> <span class="nx">a</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>If we want to determine the maximum of two integers, we can</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">m</span> <span class="o">:=</span> <span class="nf">Max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">// 返回 2
</span></code></pre></td></tr></table>
</div>
</div><p>But what if we want to compare two plurals?</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">m</span> <span class="o">:=</span> <span class="nf">Max</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="m">2i</span><span class="p">,</span> <span class="mi">3</span><span class="o">+</span><span class="m">4i</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Such a call will report an error. Why? Because complex numbers cannot be compared in size, so in Go <code>complex(64|128)</code> does not support the comparison operator!</p>
<p>So, for the <code>Max</code> function, we also need to restrict the range of <code>T</code> values. Specifically, we can only pass <code>T</code> types that support the <code>&gt;</code> operation.</p>
<p>This is the reason why we need to specify constraints on generic types. We need generic constraints to qualify the functions and operators supported by the type parameter.</p>
<p>One thing to be clear, however, is that adding a generic constraint does not mean that a compilation error will no longer be reported. If you pass the wrong type when calling a generic function, you will still get an error, but the compiler will explicitly report the error at the very beginning of the call, not when you get to the corresponding function body. If there is no constraint, then the compilation error reporting hierarchy can be very deep and extremely unfriendly for developers to troubleshoot errors (see C++&rsquo;s template error reporting).</p>
<p>If a type constraint does not restrict the functions implemented by the type and also does not restrict the operators supported by the type, then it means that the corresponding type argument can accept <strong>any</strong> type. This particular constraint is <code>any</code>.</p>
<p>The Go language can already use <code>interface</code> to restrict the methods that need to be implemented. If you want to support all objects, you can use the infamous <code>interface{}</code>. Because <code>interface{}</code> is so stinky and long, Go has officially introduced the <code>any</code> keyword to replace it. And we can now use <code>any</code> to replace <code>interface{}</code> in non-generic code, so we can look forward to that.</p>
<p>The Go team took a number of factors into account and decided to extend the existing <code>interface</code> to support restricted operators when used as a generic constraint. The syntax is discussed in the following sections.</p>
<p>Before we dive into the discussion of generic constraints, we need to talk about the <code>any</code> constraint.</p>
<h3 id="any-constraint"><code>any</code> constraint</h3>
<p>Because there are no restrictions on types, we can only write code with a syntax that is supported by all types: the</p>
<ul>
<li>declare or define variables</li>
<li>Assign values to each other before variables of the same type</li>
<li>Use as a parameter or return value of a function</li>
<li>Get the address of the corresponding variable</li>
<li>Convert the corresponding variable to <code>interface{}</code> or assign it to a variable of type <code>interface{}</code>.</li>
<li>Convert variables of type <code>interface{}</code> to variables of the corresponding type: <code>t, ok := v.(T)</code></li>
<li>Use the corresponding type in the switch type enumeration: <code>switch v.(type) { case T: /* ... */ }</code></li>
<li>Construct composite types, such as <code>[]T</code></li>
<li>pass to some built-in function, e.g. <code>p := new(T)</code></li>
</ul>
<p>So <code>any</code> is not as free as you want it to be, there is no absolute freedom.</p>
<h3 id="functions-constraints">Functions Constraints</h3>
<p>Back to the <code>Stringify</code> generic function above</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Stringify 将任意类型的切片转化成对应的字符串切片
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">Stringify</span><span class="p">[</span><span class="nx">T</span> <span class="nx">any</span><span class="p">](</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="p">(</span><span class="nx">ret</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 同上
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>We want all values of the type parameter <code>T</code> to implement the <code>String() string</code> function, so we can.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Stringer 是泛型类型约束，要求所有类型都需要实现 String 方法。
</span><span class="c1">// 所以在泛型代码中可以调用该类型变量的 String 方法。
</span><span class="c1">// String 方法返回变量的字符串表示。
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Stringer</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">String</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>From form to content there is no difference from a normal interface. We can then modify the <code>Stringify</code> function to</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Stringify 将任意类型的切片转化成对应的字符串切片
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">Stringify</span><span class="p">[</span><span class="nx">T</span> <span class="nx">Stringer</span><span class="p">](</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="p">(</span><span class="nx">ret</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="nx">ret</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">ret</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nf">String</span><span class="p">())</span> <span class="c1">// 正确
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>At this point, the following code will report a compile error.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nf">Stringify</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">})</span>
</code></pre></td></tr></table>
</div>
</div><p>Because the <code>int</code> type does not implement the <code>String() string</code> method, it cannot be passed to the type parameter <code>T</code>.</p>
<p>Instead, the following method will work properly.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">MyInt</span> <span class="kt">int</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">i</span> <span class="nx">MyInt</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">()</span> <span class="p">}</span>

<span class="nf">Stringify</span><span class="p">(</span><span class="nx">MyInt</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">})</span> <span class="c1">// 返回 []string{&#34;1&#34;,&#34;2&#34;,&#34;3&#34;}
</span></code></pre></td></tr></table>
</div>
</div><p>Instead of declaring the <code>Stringer</code> interface separately, we can also write it as follows</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nx">Stringify</span><span class="p">[</span><span class="nx">T</span> <span class="nx">inference</span><span class="p">{</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">}](</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="p">(</span><span class="nx">ret</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 同上
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The effect is the same. If we don&rsquo;t want to put any restrictions on the scope of <code>T</code>, we can write it as follows</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nx">Stringify</span><span class="p">[</span><span class="nx">T</span> <span class="kd">interface</span><span class="p">{}](</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Isn&rsquo;t that a lot harder to read than <code>func Stringify[T any](s []T) { ... }</code> is a lot harder to read?</p>
<p>Of course, we can also use someone else&rsquo;s well-defined interface to restrict the type parameters, e.g.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nx">Stringify</span><span class="p">[</span><span class="nx">T</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Stringer</span><span class="p">](</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="p">(</span><span class="nx">ret</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 同上
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The above is the main content of the function constraint, the following we discuss the operator constraints.</p>
<h3 id="operators-constraints">Operators Constraints</h3>
<p>Returning to the previous example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Max 返回两者中比较大的值
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">Max</span><span class="p">[</span><span class="nx">T</span> <span class="nx">any</span><span class="p">](</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="nx">T</span><span class="p">)</span> <span class="nx">T</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span> <span class="c1">// 错误
</span><span class="c1"></span>		<span class="k">return</span> <span class="nx">a</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The function <code>Max</code> requires that all <code>T</code>s need to support the <code>&gt;</code> operator. How can we express this constraint? One way is to convert all operator operations into function calls, so that we can use the interface to constrain operator operations. But this approach is very complicated to implement. In the end, the Go language officially chose a less elegant but very easy to implement approach: type collections.</p>
<p>The Go language does not allow overloading operators. That is, only Go&rsquo;s built-in objects can support operator operations. We can&rsquo;t declare a <code>struct</code> and then try to compare the size of the corresponding variables using <code>&gt;</code>. This makes it easier to restrict the operators to objects. Since the built-in types are limited, we can enumerate all the supported types.</p>
<p>If we want to restrict the range of type arguments to all Go&rsquo;s built-in signed integers, we can.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// PredeclaredSignedInteger 只能匹配内置的有符号整数类型
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">PredeclaredSignedInteger</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">|</span> <span class="kt">int8</span> <span class="p">|</span> <span class="kt">int16</span> <span class="p">|</span> <span class="kt">int32</span> <span class="p">|</span> <span class="kt">int64</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>So <code>PredeclaredSignedInteger</code> only allows passing in the five built-in signed integer types, passing in any other type will report a compilation error.</p>
<p>We know that the Go language allows redefining its own types, e.g.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">MyInt8</span> <span class="kt">int8</span>
</code></pre></td></tr></table>
</div>
</div><p>Although the underlying type of <code>MyInt8</code> is still <code>int8</code>, <code>MyInt8</code> does not match the <code>PredeclaredSignedInteger</code> constraint. But <code>MyInt8</code> supports exactly the same operator operations as <code>int8</code>, so we need a syntax to indicate that we can match both <code>int8</code> and <code>MyInt8</code>. So the Go language introduced the concept of Approximation Constraint, with the following syntax.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Int8 匹配所有底层类型为 int8 的类型
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Int8</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="err">~</span><span class="kt">int8</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Note that <code>~</code> is added here before <code>int8</code> to indicate an approximate match. This is fine as long as the underlying type is <code>int8</code>. So <code>MyInt8</code> can match the <code>Int8</code> constraint.</p>
<p>With the approximation constraint, our expressiveness is instantly taken to the next level. All types that support comparison operators can be written as the following constraint.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Ordered 限制所有支持比较运算符的类型。
</span><span class="c1">// 也就是说符合条件的类型都支持 &lt;, &lt;=, &gt;, 和 &gt;= 运算符。
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Ordered</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="err">~</span><span class="kt">int</span> <span class="p">|</span> <span class="err">~</span><span class="kt">int8</span> <span class="p">|</span> <span class="err">~</span><span class="kt">int16</span> <span class="p">|</span> <span class="err">~</span><span class="kt">int32</span> <span class="p">|</span> <span class="err">~</span><span class="kt">int64</span> <span class="p">|</span>
		<span class="err">~</span><span class="kt">uint</span> <span class="p">|</span> <span class="err">~</span><span class="kt">uint8</span> <span class="p">|</span> <span class="err">~</span><span class="kt">uint16</span> <span class="p">|</span> <span class="err">~</span><span class="kt">uint32</span> <span class="p">|</span> <span class="err">~</span><span class="kt">uint64</span> <span class="p">|</span> <span class="err">~</span><span class="kt">uintptr</span> <span class="p">|</span>
		<span class="err">~</span><span class="kt">float32</span> <span class="p">|</span> <span class="err">~</span><span class="kt">float64</span> <span class="p">|</span>
		<span class="err">~</span><span class="kt">string</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>We can rewrite the <code>Max</code> function above as follows</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Max 返回两者中比较大的值
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">Max</span><span class="p">[</span><span class="nx">T</span> <span class="nx">Ordered</span><span class="p">](</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="nx">T</span><span class="p">)</span> <span class="nx">T</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span> <span class="c1">// 正确
</span><span class="c1"></span>		<span class="k">return</span> <span class="nx">a</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>This time we execute <code>Max(1+2i, 3+4i)</code> again and it will trigger a compilation error.</p>
<h3 id="composite-constraints">Composite Constraints</h3>
<p>In a generic constraint, we can enumerate not only possible basic or approximate types by <code>|</code>, but also other constraints. I personally call this a composite constraint.</p>
<h4 id="concatenation-constraints">Concatenation Constraints</h4>
<p>For example, the constraint that matches all signed integers is</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// SignedInteger 匹配所有有符号整数类型
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SignedInteger</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="err">~</span><span class="kt">int</span> <span class="p">|</span> <span class="err">~</span><span class="kt">int8</span> <span class="p">|</span> <span class="err">~</span><span class="kt">int16</span> <span class="p">|</span> <span class="err">~</span><span class="kt">int32</span> <span class="p">|</span> <span class="err">~</span><span class="kt">int64</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The constraint to match all unsigned integers is</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// UnsignedInteger 匹配所有无符号整数类型
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">UnsignedInteger</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="err">~</span><span class="kt">uint</span> <span class="p">|</span> <span class="err">~</span><span class="kt">uint8</span> <span class="p">|</span> <span class="err">~</span><span class="kt">uint16</span> <span class="p">|</span> <span class="err">~</span><span class="kt">uint32</span> <span class="p">|</span> <span class="err">~</span><span class="kt">uint64</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>So the constraint to match all integers can be abbreviated as</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Integer 匹配所有整数类型
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Integer</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">SignedInteger</span> <span class="p">|</span> <span class="nx">UnsignedInteger</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The essence here is to use <code>|</code> to denote the relation of a concatenation, the result of which is that <code>Integer</code> can match the concatenation of all results matched by <code>SignedInteger</code> and <code>UnsignedInteger</code>.</p>
<h4 id="intersection-constraints">Intersection Constraints</h4>
<p>We can represent the intersection of two or more constraints, e.g.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// StringableInteger 匹配所有实现了 String() 方法的整数类型
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">StringableInteger</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">Integer</span>
	<span class="nx">Stringer</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Here we embed two constraints <code>Integer</code> and <code>Stringer</code> in the <code>StringableInteger</code> constraint, representing the intersection of the two matching results. The types that conform to this constraint are not only integers in the underlying type, but also implement the <code>String() string</code> method.</p>
<p>We can also just list the corresponding types and the list of functions that need to be implemented, e.g.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// StringableSignedInteger 匹配所有实现 String 方法的有符号整数类型
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">StringableSignedInteger</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="err">~</span><span class="kt">int</span> <span class="p">|</span> <span class="err">~</span><span class="kt">int8</span> <span class="p">|</span> <span class="err">~</span><span class="kt">int16</span> <span class="p">|</span> <span class="err">~</span><span class="kt">int32</span> <span class="p">|</span> <span class="err">~</span><span class="kt">int64</span>
	<span class="nf">String</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>For some simple usage scenarios, we can even omit the <code>interface</code> keyword. For example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Max</span><span class="p">[</span><span class="nx">T</span> <span class="kd">interface</span><span class="p">{</span><span class="kt">int</span><span class="p">|</span><span class="kt">uint</span><span class="p">}](</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="nx">T</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>It can be directly simplified to.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Max</span><span class="p">[</span><span class="nx">T</span> <span class="kt">int</span><span class="p">|</span><span class="kt">uint</span><span class="p">](</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="nx">T</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="generic-constraints-1">Generic Constraints</h4>
<p>The Go language also supports declaring type parameters in constraints! For example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// SliceConstraint 匹配所有类型为 T 的切片，但 T 的类型需要是使用的时候指定！
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SliceConstraint</span><span class="p">[</span><span class="nx">T</span> <span class="nx">any</span><span class="p">]</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="p">[]</span><span class="nx">T</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>We need to specify specific type parameters for the constraints when we use them, e.g.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Map 接受一个切片对象和一个转换函数。
</span><span class="c1">// Map 声明了两个类型参数 S 和 E，其中 S 的约束为 SliceConstraint。
</span><span class="c1">// SliceConstraint 声明了类型参数 T，Map 将 T 转成 E，最终 S 的实际约束为 []E。
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">Map</span><span class="p">[</span><span class="nx">S</span> <span class="nx">SliceConstraint</span><span class="p">[</span><span class="nx">E</span><span class="p">],</span> <span class="nx">E</span> <span class="nx">any</span><span class="p">](</span><span class="nx">s</span> <span class="nx">S</span><span class="p">,</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="nx">E</span><span class="p">)</span> <span class="nx">E</span><span class="p">)</span> <span class="nx">S</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>This example seems very complicated and redundant. It could have been written like this.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nx">Map</span><span class="p">[</span><span class="nx">S</span> <span class="p">[]</span><span class="nx">E</span><span class="p">,</span> <span class="nx">E</span> <span class="nx">any</span><span class="p">](</span><span class="nx">s</span> <span class="nx">S</span><span class="p">,</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="nx">E</span><span class="p">)</span> <span class="nx">E</span><span class="p">)</span> <span class="nx">S</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>In fact, it is not. This involves the problem of generic derivation, which we will explain in detail later.</p>
<p>In generic constraints, we can also declare self-referential constraints. For example, the following example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Equaler 限制类型必须实现 Equal 方法，但参数 T 需要在使用的时候指定。
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Equaler</span><span class="p">[</span><span class="nx">T</span> <span class="nx">any</span><span class="p">]</span> <span class="kd">interface</span> <span class="p">{</span>
        <span class="nf">Equal</span><span class="p">(</span><span class="nx">v</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span>
<span class="p">}</span>

<span class="c1">// Index 从切片 s 中查找元素 e 的索引。
</span><span class="c1">// 类型参数 T 的约束为 Equaler[T]，需要实现 Equal(v T) bool 方法。
</span><span class="c1">// 这里在声明 T 的约束的时候又用到了 T 本身。
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">Index</span><span class="p">[</span><span class="nx">T</span> <span class="nx">Equaler</span><span class="p">[</span><span class="nx">T</span><span class="p">]](</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">e</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
                <span class="k">if</span> <span class="nx">e</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
                        <span class="k">return</span> <span class="nx">i</span>
                <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="mutual-constraints">Mutual Constraints</h4>
<p>The Go language not only supports defining type parameters in constraints, but also supports cross-referencing of constraints. The purpose is to solve more complex problems in practice, such as graph theory problems.</p>
<p>Taking graph theory as an example, if we want to write a series of graph theory algorithms, then we need both <code>Edge</code> and <code>Node</code> types.</p>
<ul>
<li>The <code>Node</code> type needs to implement the <code>Edges() []Edege</code> method</li>
<li>The <code>Edge</code> type needs to implement the <code>Nodes() (Edge, Edge)</code> method</li>
</ul>
<p>A graph can be represented as a <code>[]Node</code>. This is enough to implement the graph theory algorithm. The following code is a bit more cerebral, so please read it carefully against the comments.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// NodeConstraint 是一个简单的约束，要求被约束的类型一定要实现 Edges 方法。
</span><span class="c1">// 但是 Edges 方法返回的 []Edge 类型为 Edge，没有确定，
</span><span class="c1">// 需要在使用 NodeConstraint 的时候指明。
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">NodeConstraint</span><span class="p">[</span><span class="nx">E</span> <span class="nx">any</span><span class="p">]</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Edges</span><span class="p">()</span> <span class="p">[]</span><span class="nx">E</span>
<span class="p">}</span>

<span class="c1">// EdgeConstraint 也是一个简单的约束，要求被约束的类型一定要实现 Nodes 方法。
</span><span class="c1">// 同样 Nodes 方法返回的 from t to 类型为 Node，没有确定，
</span><span class="c1">// 需要在使用 EdgeConstraint 的时候指明。
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">EdgeConstraint</span><span class="p">[</span><span class="nx">N</span> <span class="nx">any</span><span class="p">]</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Nodes</span><span class="p">()</span> <span class="p">(</span><span class="nx">from</span><span class="p">,</span> <span class="nx">to</span> <span class="nx">N</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Graph 为泛型类型，声明了两个类型变量为 Node 和 Edge。
</span><span class="c1">// Node 类型必须满足 NodeConstraint 约束，并且指定了 NodeConstraint 中 E 的类型为 Edge。
</span><span class="c1">// 所以 Node 类型必须实现 NodeConstraint 中规定的 Edges 方法，返回 []Edge。
</span><span class="c1">// 同理，Edge 类型必须实现 EdgeConstraint 中规定的 Nodes 方法，返回 (from, to Node)。
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Graph</span><span class="p">[</span><span class="nx">Node</span> <span class="nx">NodeConstraint</span><span class="p">[</span><span class="nx">Edge</span><span class="p">],</span> <span class="nx">Edge</span> <span class="nx">EdgeConstraint</span><span class="p">[</span><span class="nx">Node</span><span class="p">]]</span> <span class="kd">struct</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

<span class="c1">// New 方法通过传入一组 []Node 构造 Graph 对象
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">New</span><span class="p">[</span><span class="nx">Node</span> <span class="nx">NodeConstraint</span><span class="p">[</span><span class="nx">Edge</span><span class="p">],</span> <span class="nx">Edge</span> <span class="nx">EdgeConstraint</span><span class="p">[</span><span class="nx">Node</span><span class="p">]]</span> <span class="p">(</span><span class="nx">nodes</span> <span class="p">[]</span><span class="nx">Node</span><span class="p">)</span> <span class="o">*</span><span class="nx">Graph</span><span class="p">[</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">Edge</span><span class="p">]</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

<span class="c1">// ShortestPath 查询图中两点之间的最短路径
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">g</span> <span class="o">*</span><span class="nx">Graph</span><span class="p">[</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">Edge</span><span class="p">])</span> <span class="nf">ShortestPath</span><span class="p">(</span><span class="nx">from</span><span class="p">,</span> <span class="nx">to</span> <span class="nx">Node</span><span class="p">)</span> <span class="p">[]</span><span class="nx">Edge</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The above is only the declaration part, continue to see the calling part below. First, define the specific structure.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Vertex 表示图的顶点。
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Vertex</span> <span class="kd">struct</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

<span class="c1">// Edges 返回连接该顶点的所有边。
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">Vertex</span><span class="p">)</span> <span class="nf">Edges</span><span class="p">()</span> <span class="p">[]</span><span class="o">*</span><span class="nx">FromTo</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

<span class="c1">// FromTo 表示图的边。
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">FromTo</span> <span class="kd">struct</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

<span class="c1">// Nodes 返回边的两个端点
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">ft</span> <span class="o">*</span><span class="nx">FromTo</span><span class="p">)</span> <span class="nf">Nodes</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">Vertex</span><span class="p">,</span> <span class="o">*</span><span class="nx">Vertex</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The graph algorithm is then called.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">g</span> <span class="o">:=</span> <span class="nx">New</span><span class="p">[</span><span class="o">*</span><span class="nx">Vertex</span><span class="p">,</span> <span class="o">*</span><span class="nx">FromTo</span><span class="p">]([]</span><span class="o">*</span><span class="nx">Vertex</span><span class="p">{</span><span class="o">...</span><span class="p">})</span>
<span class="nx">edges</span> <span class="o">:=</span> <span class="nx">g</span><span class="p">.</span><span class="nf">ShortestPath</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Now let&rsquo;s analyze the initialization process of the type parameters.</p>
<p>First, the type parameters <code>Node</code> and <code>Edge</code> of <code>Graph</code> are replaced with <code>*Vertex</code> and <code>*FromTo</code>, respectively. Then the compiler starts checking for type constraints. For the <code>Node</code> type, the constraint is <code>NodeConstraint[*FromTo]</code>, so the <code>Edges() []*FromTo</code> method needs to be implemented. And <code>*Vertex</code> does implement the <code>Edges</code> method. For the <code>Edge</code> type, its constraint is <code>EdgeConstraint[*Vertex]</code>, so it needs to implement the <code>Nodes() []*Vertex</code> method, which is obviously also implemented by <code>*FromTo</code>. At this point, the constraint checking ends.</p>
<p>So, when we call <code>g.ShortestPath(a, b)</code>, the type of <code>edges</code> is <code>[]*FromTo</code>!</p>
<p>Some people may say that this way of writing is too complicated and brain-burning, it is perfectly possible to simplify <code>NodeConstraint</code> and <code>EdgeConstraint</code> to.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">NodeInterface</span> <span class="kd">interface</span> <span class="p">{</span> <span class="nf">Edges</span><span class="p">()</span> <span class="p">[]</span><span class="nx">EdgeInterface</span> <span class="p">}</span>
<span class="kd">type</span> <span class="nx">EdgeInterface</span> <span class="kd">interface</span> <span class="p">{</span> <span class="nf">Nodes</span><span class="p">()</span> <span class="p">(</span><span class="nx">NodeInterface</span><span class="p">,</span> <span class="nx">NodeInterface</span><span class="p">)</span> <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>But this would require modifying the function definitions of <code>Vertex</code> and <code>FromTo</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">Vertex</span><span class="p">)</span> <span class="nf">Edges</span><span class="p">()</span> <span class="p">[]</span><span class="nx">EdgeInterface</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">ft</span> <span class="o">*</span><span class="nx">FromTo</span><span class="p">)</span> <span class="nf">Nodes</span><span class="p">()</span> <span class="p">(</span><span class="nx">NodeInterface</span><span class="p">,</span> <span class="nx">NodeInterface</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>But the result is that calling the <code>Edges</code> function returns an abstract <code>[]EdgeInterface</code> slice rather than a concrete <code>[]*FromTo</code> list.</p>
<h3 id="built-in-constraints">Built-in constraints</h3>
<h4 id="comparable"><code>comparable</code></h4>
<p>Earlier we said that the Go language only supports performing operator operations on built-in types. The exceptions are two operators, <code>==</code> and <code>! =</code>.</p>
<p>These two operators allow comparing user-defined struct objects, so they need to be handled separately.</p>
<blockquote>
<p>The inconsistency of Go&rsquo;s design can be seen here. On the one hand, they don&rsquo;t want to introduce operator overloading, which would greatly increase the complexity of the Go language; on the other hand, they have to support equality comparisons for struct types. To do so, they had to automatically insert the equality comparison function during compilation and then &ldquo;overload&rdquo; the <code>==</code> and <code>! =</code> operators.</p>
</blockquote>
<p>For this reason, the Go language introduces a separate <code>comparable</code> constraint for this two-operator.</p>
<p>That is, if we want the types to support equal comparisons, we can write it as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Index 查询元素 x 在切片 s 中的位置。
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">Index</span><span class="p">[</span><span class="nx">T</span> <span class="nx">comparable</span><span class="p">](</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">x</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">v</span> <span class="o">==</span> <span class="nx">x</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">i</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="constraints"><code>constraints</code></h4>
<p>For the convenience of developers, Go has a built-in <code>constraints</code> package that provides commonly used type constraints.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Signed 有符号整数类型
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Signed</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="err">~</span><span class="kt">int</span> <span class="p">|</span> <span class="err">~</span><span class="kt">int8</span> <span class="p">|</span> <span class="err">~</span><span class="kt">int16</span> <span class="p">|</span> <span class="err">~</span><span class="kt">int32</span> <span class="p">|</span> <span class="err">~</span><span class="kt">int64</span>
<span class="p">}</span>
<span class="c1">// Unsigned 无符号整数类型
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Unsigned</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="err">~</span><span class="kt">uint</span> <span class="p">|</span> <span class="err">~</span><span class="kt">uint8</span> <span class="p">|</span> <span class="err">~</span><span class="kt">uint16</span> <span class="p">|</span> <span class="err">~</span><span class="kt">uint32</span> <span class="p">|</span> <span class="err">~</span><span class="kt">uint64</span> <span class="p">|</span> <span class="err">~</span><span class="kt">uintptr</span>
<span class="p">}</span>
<span class="c1">// Integer 整数类型
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Integer</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">Signed</span> <span class="p">|</span> <span class="nx">Unsigned</span>
<span class="p">}</span>
<span class="c1">// Float 浮点数类型
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Float</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="err">~</span><span class="kt">float32</span> <span class="p">|</span> <span class="err">~</span><span class="kt">float64</span>
<span class="p">}</span>
<span class="c1">// Complex 复数类型
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Complex</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="err">~</span><span class="kt">complex64</span> <span class="p">|</span> <span class="err">~</span><span class="kt">complex128</span>
<span class="p">}</span>
<span class="c1">// Ordered 支持排序的类型，即支持操作符：&lt; &lt;= &gt;= &gt;
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Ordered</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">Integer</span> <span class="p">|</span> <span class="nx">Float</span> <span class="p">|</span> <span class="err">~</span><span class="kt">string</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The above basically covers most of the contents of generic constraints, and we start discussing generic derivation below.</p>
<h2 id="generic-derivation-type-inference">Generic derivation (Type inference)</h2>
<p>We have briefly introduced generic inference earlier, and its purpose is to simplify the use of generic functions/types as much as possible and reduce unnecessary type parameter passing.</p>
<p>This section analyzes the functionality and design of generic derivation in detail. Before we start, let&rsquo;s look at the effect of generic derivation.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Map 对入参 s 切片中的每个元素执行函数 f，将结果保存到新的切片并返回。
</span><span class="c1">// 类型参数 F 和 T 需要在调用的时候指定。
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">Map</span><span class="p">[</span><span class="nx">F</span><span class="p">,</span> <span class="nx">T</span> <span class="nx">any</span><span class="p">](</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">F</span><span class="p">,</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="nx">F</span><span class="p">)</span> <span class="nx">T</span><span class="p">)</span> <span class="p">[]</span><span class="nx">T</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The Go language supports type derivation in the following cases.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">s</span> <span class="p">[]</span><span class="kt">int</span>
<span class="nx">f</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int64</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">}</span>
<span class="kd">var</span> <span class="nx">r</span> <span class="p">[]</span><span class="kt">int64</span>

<span class="c1">// 普通情形，指定全部类型参数，前文已经介绍过
</span><span class="c1"></span><span class="nx">r</span> <span class="p">=</span> <span class="nx">Map</span><span class="p">[</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int64</span><span class="p">](</span><span class="nx">s</span><span class="p">,</span> <span class="nx">f</span><span class="p">)</span>

<span class="c1">// 仅指定第一个类型参数，自动推导后面的类型参数
</span><span class="c1"></span><span class="nx">r</span> <span class="p">=</span> <span class="nx">Map</span><span class="p">[</span><span class="kt">int</span><span class="p">](</span><span class="nx">s</span><span class="p">,</span> <span class="nx">f</span><span class="p">)</span>

<span class="c1">// 自动推导所有类型参数
</span><span class="c1"></span><span class="nx">r</span> <span class="p">=</span> <span class="nf">Map</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">f</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>If a generic function/type is used without specifying all type parameters, the compiler will try to derive the missing type. If the derivation fails, a compilation error is reported.</p>
<p>Go uses so-called type unification for type derivation. However, the original text is rather abstract, so this article focuses on concrete examples to illustrate how type derivation works.</p>
<h3 id="type-unification">Type unification</h3>
<p>Assimilation is a comparison of two types to see if they are equivalent. Whether two types can be equivalent depends on.</p>
<ul>
<li>Whether the knot structure is the same, e.g. <code>[]int</code> is equivalent to <code>[]T</code> (if <code>T</code> matches <code>int</code>), and not equivalent to <code>map[int]T</code>.</li>
<li>Whether the untyped variables have the same underlying type, e.g. <code>map[T]int</code> is not equivalent to <code>map[T]string</code>, but <code>[]MyInt</code> is equivalent to <code>[]int</code>.</li>
</ul>
<p>For example, <code>T1</code> and <code>T2</code> are type parameters, and <code>[]map[int]bool</code> can be assimilated to the following types.</p>
<ul>
<li><code>[]map[int]bool</code></li>
<li><code>T1</code> ( <code>T1</code> matches <code>[]map[int]bool</code> )</li>
<li><code>[]T1</code> ( <code>T1</code> matches <code>map[int]bool</code> )</li>
<li><code>[]map[T1]T2</code> ( <code>T1</code> matches <code>int</code> , <code>T2</code> matches <code>bool</code> )</li>
</ul>
<p>But <code>[]map[int]bool</code> is not equivalent to the following types.</p>
<ul>
<li><code>int</code></li>
<li><code>struct{}</code></li>
<li><code>[]struct{}</code></li>
<li><code>[]map[T1]string</code></li>
</ul>
<h3 id="function-argument-type-inference">Function argument type inference</h3>
<p>The function argument inference is divided into two stages.</p>
<p>The first stage skips all real parameters without type constants matching once. If there are still type arguments that have not been determined, the second stage will begin. At this point, all untyped constants need to be set to their corresponding default types, and then matched again. The same type parameter may be matched more than once, and if the result of multiple matches does not match, a compilation error will be reported.</p>
<p>Returning to the example we mentioned earlier.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nx">Print</span><span class="p">[</span><span class="nx">T</span> <span class="nx">any</span><span class="p">](</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>can be simplified to <code>Print([]int{1,2,3})</code> . Since the type of <code>T</code> is not specified, the compiler performs type derivation.</p>
<p>The compiler compares the real reference type <code>[]int</code> with the formal reference type <code>[]T</code> . By definition of assimilation, the type of <code>T</code> can only be <code>int</code>, which gives the actual type of <code>T</code>.</p>
<p>So the final function call is <code>Print[int]([]int{1,2,3})</code> .</p>
<p>To analyze a more complex example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Map 对入参 s 切片中的每个元素执行函数 f，将结果保存到新的切片并返回。
</span><span class="c1">// 类型参数 F 和 T 需要在调用的时候指定。
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">Map</span><span class="p">[</span><span class="nx">F</span><span class="p">,</span> <span class="nx">T</span> <span class="nx">any</span><span class="p">](</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">F</span><span class="p">,</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="nx">F</span><span class="p">)</span> <span class="nx">T</span><span class="p">)</span> <span class="p">[]</span><span class="nx">T</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

<span class="nx">strs</span> <span class="o">:=</span> <span class="nf">Map</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">Itoa</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>The derivation process is as follows.</p>
<ul>
<li>Compare <code>[]int</code> and <code>[]F</code> and infer that <code>F</code> is of type <code>int</code></li>
<li>compare <code>strconv.Itoa(int) string</code> and <code>func(F) T</code>, inferring that <code>F</code> is <code>int</code> and <code>T</code> is <code>string</code> (<code>F</code> is matched twice, but both are <code>int</code>)</li>
<li>The final inferred call is <code>Map[int,string]([]int{1,2,3}, strconv.Itoa)</code></li>
</ul>
<p>All of the above entries have explicit types, and the cases where the entry has or does not have a type constant are discussed below.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// NewPair 返回 Pair 对象指针，包含两个相同类型的值。
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">NewPair</span><span class="p">[</span><span class="nx">F</span> <span class="nx">any</span><span class="p">](</span><span class="nx">f1</span><span class="p">,</span> <span class="nx">f2</span> <span class="nx">F</span><span class="p">)</span> <span class="o">*</span><span class="nx">Pair</span><span class="p">[</span><span class="nx">F</span><span class="p">]</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>For <code>NewPair(1,2)</code>.</p>
<p>The first stage skips all untyped constants, so the type of <code>T</code> is not deduced. The second stage sets the default type to <code>int</code> for <code>1</code> and <code>2</code>. So the type parameter <code>F</code> corresponds to <code>int</code> and the function call is inferred as <code>NewPair[int](1,2)</code>.</p>
<p>For <code>NewPair(1,int64(2))</code>.</p>
<p>The first stage of the derivation ignores the untyped constant <code>1</code>. Since the second argument is of type <code>int64</code>, it is inferred that the argument to <code>F</code> is <code>int64</code>. So the final function call is <code>NewPair[int64](1,2)</code> .</p>
<p>For <code>NewPair(1,2.5)</code>.</p>
<p>The first stage of the derivation ignores untyped constants. The second stage first sets <code>1</code> and <code>2.5</code> to default types <code>int</code> and <code>float64</code>. Then match from left to right. For parameter <code>1</code> it is confirmed that <code>F</code> is <code>int</code> and for parameter <code>2.5</code> it is determined that <code>F</code> is <code>float64</code>. The two results are not the same, so an error is reported.</p>
<p>After the type derivation is complete, the compiler still performs constraint checks and parameter type checks.</p>
<h3 id="constraint-type-inference">Constraint type inference</h3>
<p>We said earlier that type parameter constraints can also use type parameters. For such structured constraints, we can infer their actual constraints from other type parameters or constraints.</p>
<p>The derivation algorithm is also rather verbose, so here are a few examples.</p>
<h5 id="example-of-element-type-constraint">Example of element type constraint</h5>
<p>Suppose we have the following functions.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Double 返回新切片，每个元素都是 s 对应元素的两倍。
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">Double</span><span class="p">[</span><span class="nx">E</span> <span class="nx">constraints</span><span class="p">.</span><span class="nx">Number</span><span class="p">](</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">E</span><span class="p">)</span> <span class="p">[]</span><span class="nx">E</span> <span class="p">{</span>
	<span class="nx">r</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">E</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="nx">r</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">v</span> <span class="o">+</span> <span class="nx">v</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">r</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>With the above definition, if the function is called like the following.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">MySlice</span> <span class="p">[]</span><span class="kt">int</span>
<span class="kd">var</span> <span class="nx">v1</span> <span class="p">=</span> <span class="nf">Double</span><span class="p">(</span><span class="nx">MySlice</span><span class="p">{</span><span class="mi">1</span><span class="p">})</span>
</code></pre></td></tr></table>
</div>
</div><p>The derived type of <code>v1</code> is actually <code>[]int</code>, not <code>MySlice</code> as we would like. Because the compiler replaced <code>MySlice</code> with the underlying type <code>[]int</code> when comparing <code>MySlice</code> and <code>[]E</code>, it deduces that <code>E</code> is <code>int</code>.</p>
<p>In order for <code>Double</code> to return the type <code>MySlice</code> normally, we rewrite the function as follows</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// SC 限定类型必须为元素类型为 E 的切片。
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SC</span><span class="p">[</span><span class="nx">E</span> <span class="nx">any</span><span class="p">]</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="p">[]</span><span class="nx">E</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">DoubleDefined</span><span class="p">[</span><span class="nx">S</span> <span class="nx">SC</span><span class="p">[</span><span class="nx">E</span><span class="p">],</span> <span class="nx">E</span> <span class="nx">constraints</span><span class="p">.</span><span class="nx">Number</span><span class="p">](</span><span class="nx">s</span> <span class="nx">S</span><span class="p">)</span> <span class="nx">S</span> <span class="p">{</span>
	<span class="nx">r</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="nx">S</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="nx">r</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">v</span> <span class="o">+</span> <span class="nx">v</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The calling code needs to be changed to look like this.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">v2</span> <span class="p">=</span> <span class="nx">DoubleDefined</span><span class="p">[</span><span class="nx">MySlice</span><span class="p">,</span> <span class="kt">int</span><span class="p">](</span><span class="nx">MySlice</span><span class="p">{</span><span class="mi">1</span><span class="p">})</span>
</code></pre></td></tr></table>
</div>
</div><p>We can also let the compiler automatically derive the type.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">v3</span> <span class="p">=</span> <span class="nf">DoubleDefined</span><span class="p">(</span><span class="nx">MySlice</span><span class="p">{</span><span class="mi">1</span><span class="p">})</span>
</code></pre></td></tr></table>
</div>
</div><p>First, the compiler performs a function argument type derivation. At this point it is necessary to compare <code>MySlice</code> with <code>S</code>, but <code>S</code> uses structural constraints, so its actual constraint type needs to be derived.</p>
<p>To do this, the compiler constructs a mapping table.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="p">{</span><span class="nx">S</span> <span class="o">-</span><span class="p">&gt;</span> <span class="nx">MySlice</span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Then, the compiler expands the <code>S</code> constraint, expanding <code>SC[E]</code> into <code>[]E</code>. Since we previously documented the mapping of <code>S</code> to <code>MySlice</code>, we can compare <code>[]E</code> to <code>MySlice</code>. And since the underlying type of <code>MySlice</code> is <code>[]int</code>, it follows that the type of <code>E</code> is <code>int</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="p">{</span><span class="nx">S</span> <span class="o">-</span><span class="p">&gt;</span> <span class="nx">MySlice</span><span class="p">,</span> <span class="nx">E</span> <span class="o">-</span><span class="p">&gt;</span> <span class="kt">int</span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Then, we replace all the <code>E</code>s in the constraint with <code>int</code>s to see if there are any more indeterminate type parameters. There are none left, so the derivation is over. So the original call is deduced as</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">v3</span> <span class="p">=</span> <span class="nx">DoubleDefined</span><span class="p">[</span><span class="nx">MySlice</span><span class="p">,</span><span class="kt">int</span><span class="p">](</span><span class="nx">MySlice</span><span class="p">{</span><span class="mi">1</span><span class="p">})</span>
</code></pre></td></tr></table>
</div>
</div><p>The result returned is still <code>MySlice</code>.</p>
<h5 id="example-of-pointer-method-constraints">Example of pointer method constraints</h5>
<p>Suppose we wish to convert a set of strings into a set of other types of data.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Setter 限制类型需要实现 Set 方法，通过 string 设置自身的值。
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Setter</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Set</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// FromStrings 接受字符串切片，返回类型为 T 的切片。
</span><span class="c1">// 返回切片中每个元素的值通过调用其 Set 方法设置。
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">FromStrings</span><span class="p">[</span><span class="nx">T</span> <span class="nx">Setter</span><span class="p">](</span><span class="nx">s</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="nx">T</span> <span class="p">{</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">T</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nf">Set</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Let&rsquo;s look at the calling code (which is faulty and does not compile).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Settable 是可以从字符串设置自身取值的整数类型。
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Settable</span> <span class="kt">int</span>

<span class="c1">// Set 将字符串解析成整数并赋给 *p。
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Settable</span><span class="p">)</span> <span class="nf">Set</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">i</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Atoi</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="c1">// 实际代码不能忽略报错
</span><span class="c1"></span>	<span class="o">*</span><span class="nx">p</span> <span class="p">=</span> <span class="nf">Settable</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 调用函数，无法编译
</span><span class="c1"></span><span class="nx">nums</span> <span class="o">:=</span> <span class="nx">FromStrings</span><span class="p">[</span><span class="nx">Settable</span><span class="p">]([]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;1&#34;</span><span class="p">,</span> <span class="s">&#34;2&#34;</span><span class="p">})</span>
</code></pre></td></tr></table>
</div>
</div><p>The above code does not compile properly. The reason is that we specified the type <code>T</code> as <code>Settable</code>, but the type <code>Settable</code> does not implement the <code>Set(string)</code> method. It is type <code>*Settable</code> that implements that method.</p>
<p>So we change the calling code to.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 调用函数，正常编译，但运行报错
</span><span class="c1"></span><span class="nx">nums</span> <span class="o">:=</span> <span class="nx">FromStrings</span><span class="p">[</span><span class="o">*</span><span class="nx">Settable</span><span class="p">]([]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;1&#34;</span><span class="p">,</span> <span class="s">&#34;2&#34;</span><span class="p">})</span>
</code></pre></td></tr></table>
</div>
</div><p>This time it compiles fine, but running the code gives an error again. This is because in <code>FromStrings</code>, <code>result[i]</code> is of type <code>*Settable</code> and the value is <code>nil</code>, so the assignment <code>*p = *Settable(i)</code> cannot be performed.</p>
<p>So, for the <code>FromStrings</code> defined above, we can neither set <code>T</code> to <code>Settable</code>, which would lead to a compilation error, nor to <code>*Settable</code>, which would lead to a runtime error.</p>
<p>To implement <code>FromStrings</code>, we need to specify both <code>Settable</code> and <code>*Settable</code> types, which requires the structuring constraint.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Setter2 限制类型必须是 B 的指针而且要实现 Set 方法。
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Setter2</span><span class="p">[</span><span class="nx">B</span> <span class="nx">any</span><span class="p">]</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Set</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span>
	<span class="o">*</span><span class="nx">B</span>
<span class="p">}</span>

<span class="c1">// FromStrings2 接受字符串切片，返回 T 切片。
</span><span class="c1">//
</span><span class="c1">// 这里定义了两个类型参数，所以才能在返回 T 切片的同时
</span><span class="c1">// 调用 *T 也就是 PT 的方法。
</span><span class="c1">// Setter2 约束可以确保 PT 是 T 的指针。
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">FromStrings2</span><span class="p">[</span><span class="nx">T</span> <span class="nx">any</span><span class="p">,</span> <span class="nx">PT</span> <span class="nx">Setter2</span><span class="p">[</span><span class="nx">T</span><span class="p">]](</span><span class="nx">s</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="nx">T</span> <span class="p">{</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">T</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="c1">// &amp;result[i] 类型是 *T，也就是 Setter2 的类型。
</span><span class="c1"></span>		<span class="c1">// 所以可以将其强转为 PT。
</span><span class="c1"></span>		<span class="nx">p</span> <span class="o">:=</span> <span class="nf">PT</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
		<span class="c1">// PT 实现了 Set 方法
</span><span class="c1"></span>		<span class="nx">p</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The calling code is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">nums</span> <span class="o">:=</span> <span class="nx">FromStrings2</span><span class="p">[</span><span class="nx">Settable</span><span class="p">,</span> <span class="o">*</span><span class="nx">Settable</span><span class="p">]([]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;1&#34;</span><span class="p">,</span> <span class="s">&#34;2&#34;</span><span class="p">})</span>
</code></pre></td></tr></table>
</div>
</div><p>Repeating <code>Settable</code> twice feels a bit silly and can be simplified to</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 因为函数入参中没有使用 T，所以无法进一步简化
</span><span class="c1"></span><span class="nx">nums</span> <span class="o">:=</span> <span class="nx">FromStrings2</span><span class="p">[</span><span class="nx">Settable</span><span class="p">]([]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;1&#34;</span><span class="p">,</span> <span class="s">&#34;2&#34;</span><span class="p">})</span>
</code></pre></td></tr></table>
</div>
</div><p>The whole process of compiler derivation is like this. First, the mapping table is constructed from the known types.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="p">{</span><span class="nx">T</span> <span class="o">-</span><span class="p">&gt;</span> <span class="nx">Settable</span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Then replace <code>T</code> with <code>Settable</code> and expand all structured parameters. So the type <code>Setter2[T]</code> of <code>PT</code> is expanded to <code>*T</code> and added to the mapping table.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="p">{</span><span class="nx">T</span> <span class="o">-</span><span class="p">&gt;</span> <span class="nx">Settable</span><span class="p">,</span> <span class="nx">PT</span> <span class="o">-</span><span class="p">&gt;</span> <span class="o">*</span><span class="nx">T</span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Then replace all <code>T</code> with <code>Settable</code> to get.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="p">{</span><span class="nx">T</span> <span class="o">-</span><span class="p">&gt;</span> <span class="nx">Settable</span><span class="p">,</span> <span class="nx">PT</span> <span class="o">-</span><span class="p">&gt;</span> <span class="o">*</span><span class="nx">Settable</span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>This is the end of the derivation, the actual function call is <code>FromStrings2[Settable,*Settable]([]string{&quot;1&quot;, &quot;2&quot;})</code> .</p>
<h5 id="constraint-checks-after-derivation">Constraint checks after derivation</h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Unsettable 也是 int，但没有实现 Set 方法。
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Unsettable</span> <span class="kt">int</span>

<span class="c1">// 错误调用
</span><span class="c1"></span><span class="nx">nums</span> <span class="o">:=</span> <span class="nx">FromString2</span><span class="p">[</span><span class="nx">Unsettable</span><span class="p">]([]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;1&#34;</span><span class="p">,</span> <span class="s">&#34;2&#34;</span><span class="p">})</span>
</code></pre></td></tr></table>
</div>
</div><p>In this example, the compiler can derive the type of <code>PT</code> as <code>*Unsettable</code>. After the derivation, the compiler continues to check the <code>Setter2</code> constraint. But <code>*Unsettable</code> does not implement the <code>Set</code> method, so it will report a compilation error.</p>
<h2 id="summary">Summary</h2>
<p>The above is the main content of Go generic design, the main points are as follows.</p>
<ul>
<li>Functions can define type parameters: <code>func F[T any](p T) { ... }</code> .</li>
<li>Types can be specified in parameter declarations and function bodies using type parameters.</li>
<li>Type parameters can also be specified in type definitions: <code>type M[T any] []T</code> .</li>
<li>Type parameters must specify type constraints: <code>func F[T Constraint](p T) { ... }</code> .</li>
<li>Using generic functions or types requires specifying type parameters.</li>
<li>Specifying type parameters can be reduced by generic derivation, simplifying the use of generics.</li>
</ul>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/golang/">golang</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-01/go-vim/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">How to Configure Golang Development Environment for Vim</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-01/go-language-generics-example/">
            <span class="next-text nav-default">Go Language Generics Example</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
