<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Understanding Go function calls from the stack - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="This time together, we will understand common function calls, struct method calls, and closure calls in depth assembly from the stack perspective. Preamble Function call types Functions in this article refer to any executable block of code in Go. As mentioned in Go 1.1 Function Calls, there are four types of functions in Go. top-level func method with value receiver method with pointer receiver func literal top-level func is what" /><meta name="keywords" content="golang, func, call, stack" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-01/go-func-call/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Understanding Go function calls from the stack" />
<meta property="og:description" content="This time together, we will understand common function calls, struct method calls, and closure calls in depth assembly from the stack perspective. Preamble Function call types Functions in this article refer to any executable block of code in Go. As mentioned in Go 1.1 Function Calls, there are four types of functions in Go. top-level func method with value receiver method with pointer receiver func literal top-level func is what" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-01/go-func-call/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-01-22T13:38:21+08:00" />
<meta property="article:modified_time" content="2022-01-22T13:38:21+08:00" />

<meta itemprop="name" content="Understanding Go function calls from the stack">
<meta itemprop="description" content="This time together, we will understand common function calls, struct method calls, and closure calls in depth assembly from the stack perspective. Preamble Function call types Functions in this article refer to any executable block of code in Go. As mentioned in Go 1.1 Function Calls, there are four types of functions in Go. top-level func method with value receiver method with pointer receiver func literal top-level func is what"><meta itemprop="datePublished" content="2022-01-22T13:38:21+08:00" />
<meta itemprop="dateModified" content="2022-01-22T13:38:21+08:00" />
<meta itemprop="wordCount" content="6837">
<meta itemprop="keywords" content="golang," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Understanding Go function calls from the stack"/>
<meta name="twitter:description" content="This time together, we will understand common function calls, struct method calls, and closure calls in depth assembly from the stack perspective. Preamble Function call types Functions in this article refer to any executable block of code in Go. As mentioned in Go 1.1 Function Calls, there are four types of functions in Go. top-level func method with value receiver method with pointer receiver func literal top-level func is what"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Understanding Go function calls from the stack</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-01-22 13:38:21 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 6837 words </span>
          <span class="more-meta"> 14 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#preamble">Preamble</a>
          <ul>
            <li><a href="#function-call-types">Function call types</a></li>
            <li><a href="#basics">Basics</a></li>
          </ul>
        </li>
        <li><a href="#function-call-analysis">Function call analysis</a>
          <ul>
            <li><a href="#direct-function-calls">Direct function calls</a></li>
            <li><a href="#structure-methods-value-receivers-and-pointer-receivers">Structure methods: value receivers and pointer receivers</a></li>
            <li><a href="#literal-methods-func-literal">Literal methods func literal</a></li>
          </ul>
        </li>
        <li><a href="#summary-2">Summary</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>This time together, we will understand common function calls, struct method calls, and closure calls in depth assembly from the stack perspective.</p>
<h2 id="preamble">Preamble</h2>
<h3 id="function-call-types">Function call types</h3>
<p>Functions in this article refer to any executable block of code in Go. As mentioned in <strong>Go 1.1 Function Calls</strong>, there are four types of functions in Go.</p>
<ul>
<li>top-level func</li>
<li>method with value receiver</li>
<li>method with pointer receiver</li>
<li>func literal</li>
</ul>
<p>top-level func is what we normally write as a normal function.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">TopLevel</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{}</span>
</code></pre></td></tr></table>
</div>
</div><p>The method with value receiver &amp; method with pointer receiver refer to the <strong>value receiver method</strong> and <strong>pointer receiver</strong> methods of the struct method.</p>
<p>A struct method can add new behavior to a user-defined type. The difference between it and a function is that a method has a receiver, add a receiver to a function and it becomes a method. The receiver can be either a <code>value receiver</code> or a <code>pointer receiver</code>.</p>
<p>Let&rsquo;s take two simple constructs, <code>Man</code> and <code>Woman</code>, for example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Man</span> <span class="kd">struct</span> <span class="p">{</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">Woman</span> <span class="kd">struct</span> <span class="p">{</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">Man</span><span class="p">)</span> <span class="nf">Say</span><span class="p">()</span> <span class="p">{</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">Woman</span><span class="p">)</span> <span class="nf">Say</span><span class="p">()</span> <span class="p">{</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Say()<code>uses a</code>pointer receiver<code>; </code>(Woman) Say()<code>is a</code>value receiver`.</p>
<p>The definition of function literal is as follows.</p>
<blockquote>
<p>A function literal represents an anonymous function.</p>
</blockquote>
<p>That is, it contains anonymous functions and closures.</p>
<p>The following analysis is also expanded according to these types.</p>
<h3 id="basics">Basics</h3>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/22/5125f3b31c6f4a68a8a9f0c35592c755.png" alt="stack"></p>
<p>On modern mainstream machine architectures (e.g., <code>x86</code>), the stack grows downward. The stack grows downward from the high address to the status address.</p>
<p>Let&rsquo;s look at the definition of the assembly function for plan9.</p>
<h4 id="assembly-function">assembly function</h4>
<p>Let&rsquo;s take a look at the definition of the assembly function for plan9:</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/22/43913580af5c4eb2bdeb5f70e6c067de.png" alt="sobyte"></p>
<p>stack frame size: contains local variables and the space for additional function calls.</p>
<p>arguments size: contains the size of the arguments as well as the return value, e.g. if the input is 3 int64 types and the return value is 1 int64 type, then the return value is sizeof(int64) * 4.</p>
<h4 id="stack-adjustment">Stack adjustment</h4>
<p>Stack adjustment is achieved by performing operations on the hardware SP registers, for example:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">SUBQ</span>    <span class="err">$</span><span class="mi">24</span><span class="p">,</span> <span class="nx">SP</span>  <span class="c1">// 对 sp 做减法，为函数分配函数栈帧 
</span><span class="c1"></span><span class="o">...</span>
<span class="nx">ADDQ</span>    <span class="err">$</span><span class="mi">24</span><span class="p">,</span> <span class="nx">SP</span>  <span class="c1">// 对 sp 做加法 ，清除函数栈帧
</span></code></pre></td></tr></table>
</div>
</div><p>Since the stack grows downward, SUBQ actually allocates stack frames for the function when it subtracts from SP, and ADDQ clears the stack frames.</p>
<h4 id="common-instructions">Common instructions</h4>
<p><strong>Addition and subtraction operations</strong>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">ADDQ</span>  <span class="nx">AX</span><span class="p">,</span> <span class="nx">BX</span>   <span class="c1">// BX += AX
</span><span class="c1"></span><span class="nx">SUBQ</span>  <span class="nx">AX</span><span class="p">,</span> <span class="nx">BX</span>   <span class="c1">// BX -= AX
</span></code></pre></td></tr></table>
</div>
</div><p><strong>Data handling</strong>.</p>
<p>Constants are denoted by $num in plan9 assembly, can be negative, and are decimal by default. The length of the carry is determined by the suffix of the MOV.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">MOVB</span> <span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="nx">DI</span>      <span class="c1">// 1 byte
</span><span class="c1"></span><span class="nx">MOVW</span> <span class="err">$</span><span class="mh">0x10</span><span class="p">,</span> <span class="nx">BX</span>   <span class="c1">// 2 bytes
</span><span class="c1"></span><span class="nx">MOVD</span> <span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="nx">DX</span>      <span class="c1">// 4 bytes
</span><span class="c1"></span><span class="nx">MOVQ</span> <span class="err">$</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="nx">AX</span>     <span class="c1">// 8 bytes
</span></code></pre></td></tr></table>
</div>
</div><p>Another difference is that when using MOVQ you will see the difference between with and without parentheses.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 加括号代表是指针的引用
</span><span class="c1"></span><span class="nf">MOVQ</span> <span class="p">(</span><span class="nx">AX</span><span class="p">),</span> <span class="nx">BX</span>   <span class="c1">// =&gt; BX = *AX 将AX指向的内存区域8byte赋值给BX
</span><span class="c1"></span><span class="nx">MOVQ</span> <span class="mi">16</span><span class="p">(</span><span class="nx">AX</span><span class="p">),</span> <span class="nx">BX</span> <span class="c1">// =&gt; BX = *(AX + 16)
</span><span class="c1"></span>
<span class="c1">// 不加括号是值的引用
</span><span class="c1"></span><span class="nx">MOVQ</span> <span class="nx">AX</span><span class="p">,</span> <span class="nx">BX</span>     <span class="c1">// =&gt; BX = AX 将AX中存储的内容赋值给BX，注意区别
</span></code></pre></td></tr></table>
</div>
</div><p>Address arithmetic.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nf">LEAQ</span> <span class="p">(</span><span class="nx">AX</span><span class="p">)(</span><span class="nx">AX</span><span class="o">*</span><span class="mi">2</span><span class="p">),</span> <span class="nx">CX</span> <span class="c1">// =&gt; CX = AX + (AX * 2) = AX * 3
</span></code></pre></td></tr></table>
</div>
</div><p>The 2 in the above code stands for scale, and scale can only be 0, 2, 4, or 8.</p>
<h2 id="function-call-analysis">Function call analysis</h2>
<h3 id="direct-function-calls">Direct function calls</h3>
<p>We define a simple function here.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">add</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Then use the command to print out the assembly.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">GOOS</span><span class="p">=</span><span class="nx">linux</span> <span class="nx">GOARCH</span><span class="p">=</span><span class="nx">amd64</span> <span class="k">go</span> <span class="nx">tool</span> <span class="nx">compile</span> <span class="o">-</span><span class="nx">S</span> <span class="o">-</span><span class="nx">N</span> <span class="o">-</span><span class="nx">l</span> <span class="nx">main</span><span class="p">.</span><span class="k">go</span>
</code></pre></td></tr></table>
</div>
</div><p>Let&rsquo;s look at the assembly instructions and the stack in sections. Let&rsquo;s start with the main method call.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">&#34;&#34;.main STEXT size=71 args=0x0 locals=0x20
0x0000 00000 (main.go:3)        TEXT    &#34;&#34;.main(SB), ABIInternal, $32-0
0x0000 00000 (main.go:3)        MOVQ    (TLS), CX
0x0009 00009 (main.go:3)        CMPQ    SP, 16(CX)   ; 栈溢出检测
0x000d 00013 (main.go:3)        PCDATA  $0, $-2      ; GC 相关
0x000d 00013 (main.go:3)        JLS     64
0x000f 00015 (main.go:3)        PCDATA  $0, $-1      ; GC 相关
0x000f 00015 (main.go:3)        SUBQ    $32, SP      ; 分配了 32bytes 的栈地址
0x0013 00019 (main.go:3)        MOVQ    BP, 24(SP)   ; 将 BP 的值存储到栈上
0x0018 00024 (main.go:3)        LEAQ    24(SP), BP   ; 将刚分配的栈空间 8bytes 的地址赋值给BP
0x001d 00029 (main.go:3)        FUNCDATA        $0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB) ; GC 相关
0x001d 00029 (main.go:3)        FUNCDATA        $1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB) ; GC 相关
0x001d 00029 (main.go:4)        MOVQ    $1, (SP)     ; 将给add函数的第一个参数1，写到SP
0x0025 00037 (main.go:4)        MOVQ    $2, 8(SP)    ; 将给add函数的第二个参数2，写到SP 
0x002e 00046 (main.go:4)        PCDATA  $1, $0
0x002e 00046 (main.go:4)        CALL    &#34;&#34;.add(SB)   ; 调用 add 函数 
0x0033 00051 (main.go:5)        MOVQ    24(SP), BP   ; 将栈上储存的值恢复BP
0x0038 00056 (main.go:5)        ADDQ    $32, SP      ; 增加SP的值，栈收缩，收回 32 bytes的栈空间 
0x003c 00060 (main.go:5)        RET
</code></pre></td></tr></table>
</div>
</div><p>Here&rsquo;s a look at what the above assembly does.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt">0x0000 00000 (main.go:3)        TEXT    &#34;&#34;.main(SB), ABIInternal, $32-0
</code></pre></td></tr></table>
</div>
</div><p><code>0x0000</code> : the offset of the current instruction relative to the current function.</p>
<p><code>TEXT</code> : since the program code is placed in the .text segment of memory during runtime, TEXT is an instruction to define a function.</p>
<p><code>&quot;&quot;.main(SB)</code> : indicates the package name. SB is a virtual register that holds the static-base pointer, which is the start address of our program address space.</p>
<p><code>$32-0</code> :$32 table the size of the stack frame to be allocated; 0 specifies the size of the arguments passed in by the caller.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">0x000d <span class="m">00013</span> <span class="o">(</span>main.go:3<span class="o">)</span>        PCDATA  <span class="nv">$0</span>, <span class="nv">$-</span><span class="m">2</span>      <span class="p">;</span> GC 相关
0x000f <span class="m">00015</span> <span class="o">(</span>main.go:3<span class="o">)</span>        PCDATA  <span class="nv">$0</span>, <span class="nv">$-</span><span class="m">1</span>      <span class="p">;</span> GC 相关

0x001d <span class="m">00029</span> <span class="o">(</span>main.go:3<span class="o">)</span>        FUNCDATA        <span class="nv">$0</span>, gclocals·33cdeccccebe80329f1fdbee7f5874cb<span class="o">(</span>SB<span class="o">)</span> <span class="p">;</span> GC 相关
0x001d <span class="m">00029</span> <span class="o">(</span>main.go:3<span class="o">)</span>        FUNCDATA        <span class="nv">$1</span>, gclocals·33cdeccccebe80329f1fdbee7f5874cb<span class="o">(</span>SB<span class="o">)</span> <span class="p">;</span> GC 相关
</code></pre></td></tr></table>
</div>
</div><p>The FUNCDATA and PCDATA instructions contain information that is used by garbage collection; these instructions are added by the compiler.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">0x000f 00015 (main.go:3)        SUBQ    $32, SP
</code></pre></td></tr></table>
</div>
</div><p>(a) When executing a call on the stack, since the stack grows from the high bit of the memory address to the low bit, the call <code>SUBQ $32, SP</code> is called based on the current stack frame size, indicating that 32bytes of stack memory is allocated.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="mh">0x0013</span> <span class="mo">0001</span><span class="mi">9</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">3</span><span class="p">)</span>        <span class="nx">MOVQ</span>    <span class="nx">BP</span><span class="p">,</span> <span class="mi">24</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>   <span class="p">;</span> <span class="nx">将</span> <span class="nx">BP</span> <span class="nx">的值存储到栈上</span>
<span class="mh">0x0018</span> <span class="mo">00024</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">3</span><span class="p">)</span>        <span class="nx">LEAQ</span>    <span class="mi">24</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">BP</span>   <span class="p">;</span> <span class="nx">将刚分配的栈空间</span> <span class="mi">8</span><span class="nx">bytes</span> <span class="nx">的地址赋值给BP</span>
</code></pre></td></tr></table>
</div>
</div><p>Here 8 bytes (24(SP)-32(SP)) are used to store the current frame pointer BP.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="mh">0x001d</span> <span class="mo">0002</span><span class="mi">9</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">4</span><span class="p">)</span>        <span class="nx">MOVQ</span>    <span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="nx">SP</span><span class="p">)</span>     <span class="p">;</span> <span class="nx">将给add函数的第一个参数1</span><span class="err">，</span><span class="nx">写到SP</span>
<span class="mh">0x0025</span> <span class="mo">00037</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">4</span><span class="p">)</span>        <span class="nx">MOVQ</span>    <span class="err">$</span><span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>    <span class="p">;</span> <span class="nx">将给add函数的第二个参数2</span><span class="err">，</span><span class="nx">写到SP</span> 
</code></pre></td></tr></table>
</div>
</div><p>parameter value 1 will be pressed onto the stack at position (0(SP)-8(SP)).</p>
<p>Parameter value 2 will be pressed onto the stack at (8(SP)-16(SP)).</p>
<p>It is important to <strong>note</strong> that our parameter type here is int, which is 8byte in size in 64-bit. Although the stack grows from the high address bit to the low address bit, the data block inside the stack is stored from the low address bit to the high address bit, and the location pointed to by the pointer is also the starting location of the low address bit of the data block.</p>
<p>In summary, in function calls, we can know two pieces of information about the passing of parameters.</p>
<ol>
<li><strong>Parameters are passed entirely through the stack</strong>.</li>
<li><strong>Stacking from right to left of the argument list</strong>.</li>
</ol>
<p>Here are the details of the call to the stack before the add function is called.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/22/4aeddcc11d4e4b7db093084700bf5cf1.png" alt="sobyte"></p>
<p>When we prepare the function entry, we call the assembly instruction <code>CALL &quot;&quot;.add(SB)</code>, which first stores the return address of main (8 bytes) on the stack, then changes the current stack pointer SP and executes the assembly instruction for add.</p>
<p>Let&rsquo;s go to the add function.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="s">&#34;&#34;</span><span class="p">.</span><span class="nx">add</span> <span class="nx">STEXT</span> <span class="nx">nosplit</span> <span class="nx">size</span><span class="p">=</span><span class="mi">25</span> <span class="nx">args</span><span class="p">=</span><span class="mh">0x18</span> <span class="nx">locals</span><span class="p">=</span><span class="mh">0x0</span>
<span class="mh">0x0000</span> <span class="mo">00000</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">7</span><span class="p">)</span>        <span class="nx">TEXT</span>    <span class="s">&#34;&#34;</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">NOSPLIT</span><span class="p">|</span><span class="nx">ABIInternal</span><span class="p">,</span> <span class="err">$</span><span class="mi">0</span><span class="o">-</span><span class="mi">24</span>
<span class="mh">0x0000</span> <span class="mo">00000</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">7</span><span class="p">)</span>        <span class="nx">FUNCDATA</span>        <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="nx">gclocals</span><span class="err">·</span><span class="mi">33</span><span class="nf">cdeccccebe80329f1fdbee7f5874cb</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span> <span class="p">;</span> <span class="nx">GC</span> <span class="nx">相关</span>
<span class="mh">0x0000</span> <span class="mo">00000</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">7</span><span class="p">)</span>        <span class="nx">FUNCDATA</span>        <span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="nx">gclocals</span><span class="err">·</span><span class="mi">33</span><span class="nf">cdeccccebe80329f1fdbee7f5874cb</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span> <span class="p">;</span> <span class="nx">GC</span> <span class="nx">相关</span>
<span class="mh">0x0000</span> <span class="mo">00000</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">7</span><span class="p">)</span>        <span class="nx">MOVQ</span>    <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">.</span><span class="err">~</span><span class="nx">r2</span><span class="o">+</span><span class="mi">24</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>   <span class="p">;</span> <span class="nx">初始化返回值</span>
<span class="mh">0x0009</span> <span class="mo">0000</span><span class="mi">9</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">8</span><span class="p">)</span>        <span class="nx">MOVQ</span>    <span class="s">&#34;&#34;</span><span class="p">.</span><span class="nx">a</span><span class="o">+</span><span class="mi">8</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">AX</span>      <span class="p">;</span> <span class="nx">AX</span> <span class="p">=</span> <span class="mi">1</span>
<span class="mh">0x000e</span> <span class="mo">00014</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">8</span><span class="p">)</span>        <span class="nx">ADDQ</span>    <span class="s">&#34;&#34;</span><span class="p">.</span><span class="nx">b</span><span class="o">+</span><span class="mi">16</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">AX</span>     <span class="p">;</span> <span class="nx">AX</span> <span class="p">=</span> <span class="nx">AX</span> <span class="o">+</span> <span class="mi">2</span>
<span class="mh">0x0013</span> <span class="mo">0001</span><span class="mi">9</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">8</span><span class="p">)</span>        <span class="nx">MOVQ</span>    <span class="nx">AX</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">.</span><span class="err">~</span><span class="nx">r2</span><span class="o">+</span><span class="mi">24</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>   <span class="p">;</span> <span class="p">(</span><span class="mi">24</span><span class="p">)</span><span class="nx">SP</span> <span class="p">=</span> <span class="nx">AX</span> <span class="p">=</span> <span class="mi">3</span>
<span class="mh">0x0018</span> <span class="mo">00024</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">8</span><span class="p">)</span>        <span class="nx">RET</span> 
</code></pre></td></tr></table>
</div>
</div><p>Since the current stack pointer SP will be changed, let&rsquo;s look at the data on the stack before we look at the assembly code of this function, here we can actually dlv it.</p>
<p>We can print the current Rsp and Rbp registers with regs when we <strong>get to the add function</strong>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">(dlv) regs 
   Rsp = 0x000000c000044760
   Rbp = 0x000000c000044778
     ...

(dlv)  print uintptr(0x000000c000044778)
824634001272
(dlv)  print uintptr(0x000000c000044760)
824634001248
</code></pre></td></tr></table>
</div>
</div><p>The difference between the address values of Rsp and Rbp is 24 bytes, which is consistent with our example above.</p>
<p>Then <strong>after entering the add function</strong>, we can use regs to print the current Rsp and Rbp registers.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="o">(</span><span class="n">dlv</span><span class="o">)</span> <span class="n">regs</span>
   <span class="n">Rsp</span> <span class="o">=</span> <span class="n">0x000000c000044758</span>
   <span class="n">Rbp</span> <span class="o">=</span> <span class="n">0x000000c000044778</span>
   <span class="o">...</span>

<span class="o">(</span><span class="n">dlv</span><span class="o">)</span>  <span class="n">print</span> <span class="nf">uintptr</span><span class="o">(</span><span class="n">0x000000c000044778</span><span class="o">)</span>
<span class="n">824634001272</span>
<span class="o">(</span><span class="n">dlv</span><span class="o">)</span>  <span class="n">print</span> <span class="nf">uintptr</span><span class="o">(</span><span class="n">0x000000c000044758</span><span class="o">)</span>
<span class="n">824634001240</span>
</code></pre></td></tr></table>
</div>
</div><p>The difference between the address values of Rsp and Rbp is 32 bytes, because the return address of the function (8 bytes) is pushed to the top of the stack when the CALL instruction is called.</p>
<p>At this time, the position of parameter value 1 and parameter value 2 will also change.</p>
<p>Parameter value 1, which was at position (0(SP)-8(SP)) on the stack, will be moved to position (8(SP)-16(SP)) on the stack.</p>
<p>the value of parameter 2, which would have been at position (8(SP)-16(SP)) on the stack, will be moved to position (16(SP)-24(SP)) on the stack.</p>
<p>We can also print out the parameter values via dlv.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="p">(</span><span class="nx">dlv</span><span class="p">)</span> <span class="nx">print</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">int</span><span class="p">)(</span><span class="nb">uintptr</span><span class="p">(</span><span class="mh">0x000000c000044758</span><span class="p">)</span><span class="o">+</span><span class="mi">8</span><span class="p">)</span>
<span class="mi">1</span>
<span class="p">(</span><span class="nx">dlv</span><span class="p">)</span> <span class="nx">print</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">int</span><span class="p">)(</span><span class="nb">uintptr</span><span class="p">(</span><span class="mh">0x000000c000044758</span><span class="p">)</span><span class="o">+</span><span class="mi">16</span><span class="p">)</span>
<span class="mi">2</span>
</code></pre></td></tr></table>
</div>
</div><p>The following are the call details of the call stack after the add function is called.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/22/224e90145a674cde81ae4821197e78ad.png" alt="sobyte"></p>
<p>From the analysis of the add function call above we can also conclude that</p>
<ul>
<li><strong>The return value is passed on the stack, and the stack space for the return value is before the arguments</strong></li>
</ul>
<p>After the call, we look at the return of the add function.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">0x002e 00046 (main.go:4)        CALL    &#34;&#34;.add(SB)   ; 调用 add 函数 
0x0033 00051 (main.go:5)        MOVQ    24(SP), BP   ; 将栈上储存的值恢复BP
0x0038 00056 (main.go:5)        ADDQ    $32, SP      ; 增加SP的值，栈收缩，收回 32 bytes的栈空间 
0x003c 00060 (main.go:5)        RET
</code></pre></td></tr></table>
</div>
</div><p>After the add function is called, the BP pointer is restored and then the ADDQ instruction is called to increase the value of SP and perform a stack shrink. From here, we can see that the final caller is responsible for the cleanup of the stack.</p>
<p>To summarize the following rules for stack calls.</p>
<ol>
<li><strong>Parameters are passed entirely through the stack</strong>.</li>
<li><strong>Stacking from right to left of the argument list</strong>.</li>
<li><strong>return value is passed through the stack, and the stack space for the return value is before the arguments</strong></li>
<li><strong>After the function call, the caller (caller) takes care of the stack cleanup</strong></li>
</ol>
<h3 id="structure-methods-value-receivers-and-pointer-receivers">Structure methods: value receivers and pointer receivers</h3>
<p>As we mentioned above, there are two types of method receivers in Go, a <code>value receiver</code> and a <code>pointer receiver</code>. Here&rsquo;s an example to illustrate.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span> 
    <span class="nx">p</span> <span class="o">:=</span> <span class="nx">Point</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span> 
    <span class="nx">p</span><span class="p">.</span><span class="nf">VIncr</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="nx">p</span><span class="p">.</span><span class="nf">PIncr</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Point</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">X</span> <span class="kt">int</span>
    <span class="nx">Y</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">Point</span><span class="p">)</span> <span class="nf">VIncr</span><span class="p">(</span><span class="nx">factor</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">X</span> <span class="o">+=</span> <span class="nx">factor</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">Y</span> <span class="o">+=</span> <span class="nx">factor</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Point</span><span class="p">)</span> <span class="nf">PIncr</span><span class="p">(</span><span class="nx">factor</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">X</span> <span class="o">+=</span> <span class="nx">factor</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">Y</span> <span class="o">+=</span> <span class="nx">factor</span>
<span class="p">}</span> 
</code></pre></td></tr></table>
</div>
</div><p>You can look at the manual assembly output yourself in conjunction with the article.</p>
<h4 id="calling-the-value-receiver-method">Calling the value receiver method</h4>
<p>In assembly, our structure is actually a piece of contiguous memory at the assembly level, so <code>p := Point{2, 5}</code> is initialized as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">0x001d <span class="m">00029</span> <span class="o">(</span>main.go:5<span class="o">)</span>        XORPS   X0, X0                  <span class="p">;;</span> 初始化寄存器 X0
0x0020 <span class="m">00032</span> <span class="o">(</span>main.go:5<span class="o">)</span>        MOVUPS  X0, <span class="s2">&#34;&#34;</span>.p+24<span class="o">(</span>SP<span class="o">)</span>         <span class="p">;;</span> 初始化大小为16bytes连续内存块
0x0025 <span class="m">00037</span> <span class="o">(</span>main.go:5<span class="o">)</span>        MOVQ    <span class="nv">$2</span>, <span class="s2">&#34;&#34;</span>.p+24<span class="o">(</span>SP<span class="o">)</span>         <span class="p">;;</span> 初始化结构体 p 参数 x
0x002e <span class="m">00046</span> <span class="o">(</span>main.go:5<span class="o">)</span>        MOVQ    <span class="nv">$5</span>, <span class="s2">&#34;&#34;</span>.p+32<span class="o">(</span>SP<span class="o">)</span>         <span class="p">;;</span> 初始化结构体 p 参数 y
</code></pre></td></tr></table>
</div>
</div><p>Our struct Point here is composed of two int parameters, int is 8bytes on 64-bit machines, so here we use XORPS to initialize the 128-bit size X0 register first, and then use MOVUPS to assign the 128-bit size X0 to 24(SP) to request a 16bytes memory block. Then initialize the two parameters 2 and 5 of Point.</p>
<p>The next step is to initialize the variables and then call the <code>p.VIncr</code> method.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="mh">0x0037</span> <span class="mo">00055</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">7</span><span class="p">)</span>        <span class="nx">MOVQ</span>    <span class="err">$</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="nx">SP</span><span class="p">)</span>                <span class="p">;;</span> <span class="nx">初始化变量2</span>
<span class="mh">0x003f</span> <span class="mo">00063</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">7</span><span class="p">)</span>        <span class="nx">MOVQ</span>    <span class="err">$</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>               <span class="p">;;</span> <span class="nx">初始化变量5</span>
<span class="mh">0x0048</span> <span class="mo">00072</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">7</span><span class="p">)</span>        <span class="nx">MOVQ</span>    <span class="err">$</span><span class="mi">10</span><span class="p">,</span> <span class="mi">16</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>             <span class="p">;;</span> <span class="nx">初始化变量10</span>
<span class="mh">0x0051</span> <span class="mo">000</span><span class="mi">81</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">7</span><span class="p">)</span>        <span class="nx">PCDATA</span>  <span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="err">$</span><span class="mi">0</span>
<span class="mh">0x0051</span> <span class="mo">000</span><span class="mi">81</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">7</span><span class="p">)</span>        <span class="nx">CALL</span>    <span class="s">&#34;&#34;</span><span class="p">.</span><span class="nx">Point</span><span class="p">.</span><span class="nf">VIncr</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>      <span class="p">;;</span> <span class="nx">调用</span> <span class="nx">value</span> <span class="nx">receiver</span> <span class="nx">方法</span>
</code></pre></td></tr></table>
</div>
</div><p>Up to this point, the structure of the stack frame before the call probably looks like this.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/22/b6b21d852f174df496b6c305cd243316.png" alt="sobyte"></p>
<p>Look again at the assembly code for <code>p.VIncr</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="s">&#34;&#34;</span><span class="p">.</span><span class="nx">Point</span><span class="p">.</span><span class="nx">VIncr</span> <span class="nx">STEXT</span> <span class="nx">nosplit</span> <span class="nx">size</span><span class="p">=</span><span class="mi">31</span> <span class="nx">args</span><span class="p">=</span><span class="mh">0x18</span> <span class="nx">locals</span><span class="p">=</span><span class="mh">0x0</span>
        <span class="mh">0x0000</span> <span class="mo">00000</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">16</span><span class="p">)</span>       <span class="nx">TEXT</span>    <span class="s">&#34;&#34;</span><span class="p">.</span><span class="nx">Point</span><span class="p">.</span><span class="nf">VIncr</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">NOSPLIT</span><span class="p">|</span><span class="nx">ABIInternal</span><span class="p">,</span> <span class="err">$</span><span class="mi">0</span><span class="o">-</span><span class="mi">24</span>
        <span class="mh">0x0000</span> <span class="mo">00000</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">16</span><span class="p">)</span>       <span class="nx">FUNCDATA</span>        <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="nx">gclocals</span><span class="err">·</span><span class="mi">33</span><span class="nf">cdeccccebe80329f1fdbee7f5874cb</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
        <span class="mh">0x0000</span> <span class="mo">00000</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">16</span><span class="p">)</span>       <span class="nx">FUNCDATA</span>        <span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="nx">gclocals</span><span class="err">·</span><span class="mi">33</span><span class="nf">cdeccccebe80329f1fdbee7f5874cb</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
        <span class="mh">0x0000</span> <span class="mo">00000</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">17</span><span class="p">)</span>       <span class="nx">MOVQ</span>    <span class="s">&#34;&#34;</span><span class="p">.</span><span class="nx">p</span><span class="o">+</span><span class="mi">8</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">AX</span>          <span class="p">;;</span> <span class="nx">AX</span> <span class="p">=</span> <span class="mi">8</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span> <span class="p">=</span> <span class="mi">2</span>
        <span class="mh">0x0005</span> <span class="mo">00005</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">17</span><span class="p">)</span>       <span class="nx">ADDQ</span>    <span class="s">&#34;&#34;</span><span class="p">.</span><span class="nx">factor</span><span class="o">+</span><span class="mi">24</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">AX</span>    <span class="p">;;</span> <span class="nx">AX</span> <span class="p">=</span> <span class="nx">AX</span> <span class="o">+</span> <span class="mi">24</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span> <span class="p">=</span> <span class="mi">2</span><span class="o">+</span><span class="mi">10</span>
        <span class="mh">0x000a</span> <span class="mo">00010</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">17</span><span class="p">)</span>       <span class="nx">MOVQ</span>    <span class="nx">AX</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">.</span><span class="nx">p</span><span class="o">+</span><span class="mi">8</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>          <span class="p">;;</span> <span class="mi">8</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span> <span class="p">=</span> <span class="nx">AX</span> <span class="p">=</span> <span class="mi">12</span>
        <span class="mh">0x000f</span> <span class="mo">00015</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">18</span><span class="p">)</span>       <span class="nx">MOVQ</span>    <span class="s">&#34;&#34;</span><span class="p">.</span><span class="nx">p</span><span class="o">+</span><span class="mi">16</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">AX</span>         <span class="p">;;</span> <span class="nx">AX</span> <span class="p">=</span> <span class="mi">16</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span> <span class="p">=</span> <span class="mi">5</span>
        <span class="mh">0x0014</span> <span class="mo">00020</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">18</span><span class="p">)</span>       <span class="nx">ADDQ</span>    <span class="s">&#34;&#34;</span><span class="p">.</span><span class="nx">factor</span><span class="o">+</span><span class="mi">24</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">AX</span>    <span class="p">;;</span> <span class="nx">AX</span> <span class="p">=</span> <span class="nx">AX</span> <span class="o">+</span> <span class="mi">24</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span> <span class="p">=</span> <span class="mi">5</span><span class="o">+</span><span class="mi">10</span>
        <span class="mh">0x0019</span> <span class="mo">00025</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">18</span><span class="p">)</span>       <span class="nx">MOVQ</span>    <span class="nx">AX</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">.</span><span class="nx">p</span><span class="o">+</span><span class="mi">16</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>         <span class="p">;;</span> <span class="mi">16</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span> <span class="p">=</span> <span class="nx">AX</span>  <span class="p">=</span> <span class="mi">15</span>
        <span class="mh">0x001e</span> <span class="mo">00030</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">19</span><span class="p">)</span>       <span class="nx">RET</span> 
</code></pre></td></tr></table>
</div>
</div><p>The structure of the stack frame after the call here will probably look like this.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/22/01b1a46ac5434baa91638d262f37d438.png" alt="sobyte"></p>
<p>From the above analysis we can see that the caller is actually assigning values on the stack to VIncr as parameters when calling the VIncr method, and the changes in VIncr are actually modifying the last two parameter values on the stack.</p>
<h4 id="calling-the-pointer-receiver-method">Calling the pointer receiver method</h4>
<p>In main, the call is made with the following instruction</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="mh">0x0056</span> <span class="mo">000</span><span class="mi">86</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">8</span><span class="p">)</span>        <span class="nx">LEAQ</span>    <span class="s">&#34;&#34;</span><span class="p">.</span><span class="nx">p</span><span class="o">+</span><span class="mi">24</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">AX</span>         <span class="p">;;</span> <span class="nx">将</span> <span class="mi">24</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span> <span class="nx">地址值赋值到</span> <span class="nx">AX</span>
<span class="mh">0x005b</span> <span class="mo">000</span><span class="mi">91</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">8</span><span class="p">)</span>        <span class="nx">MOVQ</span>    <span class="nx">AX</span><span class="p">,</span> <span class="p">(</span><span class="nx">SP</span><span class="p">)</span>                <span class="p">;;</span> <span class="nx">将AX的值作为第一个参数</span><span class="p">,</span><span class="nx">参数值是</span> <span class="mi">2</span>
<span class="mh">0x005f</span> <span class="mo">000</span><span class="mi">95</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">8</span><span class="p">)</span>        <span class="nx">MOVQ</span>    <span class="err">$</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>              <span class="p">;;</span> <span class="nx">将</span> <span class="mi">10</span> <span class="nx">作为第二个参数</span>
<span class="mh">0x0068</span> <span class="mo">00104</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">8</span><span class="p">)</span>        <span class="nx">CALL</span>    <span class="s">&#34;&#34;</span><span class="p">.(</span><span class="o">*</span><span class="nx">Point</span><span class="p">).</span><span class="nf">PIncr</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>   <span class="p">;;</span> <span class="nx">调用</span> <span class="nx">pointer</span> <span class="nx">receiver</span> <span class="nx">方法</span>
</code></pre></td></tr></table>
</div>
</div><p>From the above assembly, we know that AX actually holds the address value of 24(SP), and the pointer stored in AX is also assigned to the first argument of SP. That is, both AX and SP&rsquo;s first argument are the address value of 24(SP).</p>
<p>The entire stack frame structure should look like the following.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/22/6d6382beea1647eab76e2efdde00ec29.png" alt="sobyte"></p>
<p>Look at the assembly code for <code>p.PIncr</code> again.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="s">&#34;&#34;</span><span class="p">.(</span><span class="o">*</span><span class="nx">Point</span><span class="p">).</span><span class="nx">PIncr</span> <span class="nx">STEXT</span> <span class="nx">nosplit</span> <span class="nx">size</span><span class="p">=</span><span class="mi">53</span> <span class="nx">args</span><span class="p">=</span><span class="mh">0x10</span> <span class="nx">locals</span><span class="p">=</span><span class="mh">0x0</span>
        <span class="mh">0x0000</span> <span class="mo">00000</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">21</span><span class="p">)</span>       <span class="nx">TEXT</span>    <span class="s">&#34;&#34;</span><span class="p">.(</span><span class="o">*</span><span class="nx">Point</span><span class="p">).</span><span class="nf">PIncr</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">NOSPLIT</span><span class="p">|</span><span class="nx">ABIInternal</span><span class="p">,</span> <span class="err">$</span><span class="mi">0</span><span class="o">-</span><span class="mi">16</span>
        <span class="mh">0x0000</span> <span class="mo">00000</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">21</span><span class="p">)</span>       <span class="nx">FUNCDATA</span>        <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="nx">gclocals</span><span class="err">·</span><span class="mi">1</span><span class="nf">a65e721a2ccc325b382662e7ffee780</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
        <span class="mh">0x0000</span> <span class="mo">00000</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">21</span><span class="p">)</span>       <span class="nx">FUNCDATA</span>        <span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="nx">gclocals</span><span class="err">·</span><span class="mi">69</span><span class="nf">c1753bd5f81501d95132d08af04464</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
        <span class="mh">0x0000</span> <span class="mo">00000</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">22</span><span class="p">)</span>       <span class="nx">MOVQ</span>    <span class="s">&#34;&#34;</span><span class="p">.</span><span class="nx">p</span><span class="o">+</span><span class="mi">8</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">AX</span>          <span class="p">;;</span> <span class="nx">将8</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span> <span class="nx">处存放地址值赋值到</span> <span class="nx">AX</span>  
        <span class="mh">0x0005</span> <span class="mo">00005</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">22</span><span class="p">)</span>       <span class="nx">TESTB</span>   <span class="nx">AL</span><span class="p">,</span> <span class="p">(</span><span class="nx">AX</span><span class="p">)</span>
        <span class="mh">0x0007</span> <span class="mo">00007</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">22</span><span class="p">)</span>       <span class="nx">MOVQ</span>    <span class="s">&#34;&#34;</span><span class="p">.</span><span class="nx">p</span><span class="o">+</span><span class="mi">8</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">CX</span>          <span class="p">;;</span> <span class="nx">将8</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span> <span class="nx">处存放地址值赋值到</span> <span class="nx">CX</span> 
        <span class="mh">0x000c</span> <span class="mo">00012</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">22</span><span class="p">)</span>       <span class="nx">TESTB</span>   <span class="nx">AL</span><span class="p">,</span> <span class="p">(</span><span class="nx">CX</span><span class="p">)</span>
        <span class="mh">0x000e</span> <span class="mo">00014</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">22</span><span class="p">)</span>       <span class="nf">MOVQ</span>    <span class="p">(</span><span class="nx">AX</span><span class="p">),</span> <span class="nx">AX</span>                <span class="p">;;</span> <span class="nx">从</span> <span class="nx">AX</span> <span class="nx">里读到内存地址</span><span class="err">，</span><span class="nx">从内存地址里拿到值</span><span class="err">，</span><span class="nx">再读到AX</span>
        <span class="mh">0x0011</span> <span class="mo">00017</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">22</span><span class="p">)</span>       <span class="nx">ADDQ</span>    <span class="s">&#34;&#34;</span><span class="p">.</span><span class="nx">factor</span><span class="o">+</span><span class="mi">16</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">AX</span>    <span class="p">;;</span> <span class="nx">将参数值</span> <span class="mi">10</span> <span class="nx">加到</span> <span class="nx">AX</span> <span class="nx">里</span><span class="p">,</span> <span class="nx">AX</span> <span class="p">=</span> <span class="nx">AX</span> <span class="o">+</span> <span class="mi">10</span> <span class="p">=</span><span class="mi">12</span>
        <span class="mh">0x0016</span> <span class="mo">00022</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">22</span><span class="p">)</span>       <span class="nx">MOVQ</span>    <span class="nx">AX</span><span class="p">,</span> <span class="p">(</span><span class="nx">CX</span><span class="p">)</span>                <span class="p">;;</span> <span class="nx">将计算结果写入到</span> <span class="nx">CX</span> <span class="nx">的内存地址</span>
        <span class="mh">0x0019</span> <span class="mo">00025</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">23</span><span class="p">)</span>       <span class="nx">MOVQ</span>    <span class="s">&#34;&#34;</span><span class="p">.</span><span class="nx">p</span><span class="o">+</span><span class="mi">8</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">AX</span>          <span class="p">;;</span> <span class="nx">将</span> <span class="mi">8</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span> <span class="nx">处的地址值赋值给</span> <span class="nx">AX</span>
        <span class="mh">0x001e</span> <span class="mo">00030</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">23</span><span class="p">)</span>       <span class="nx">TESTB</span>   <span class="nx">AL</span><span class="p">,</span> <span class="p">(</span><span class="nx">AX</span><span class="p">)</span>
        <span class="mh">0x0020</span> <span class="mo">00032</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">23</span><span class="p">)</span>       <span class="nx">MOVQ</span>    <span class="s">&#34;&#34;</span><span class="p">.</span><span class="nx">p</span><span class="o">+</span><span class="mi">8</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">CX</span>          <span class="p">;;</span> <span class="nx">将</span> <span class="mi">8</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span> <span class="nx">处的地址值赋值给</span> <span class="nx">CX</span>
        <span class="mh">0x0025</span> <span class="mo">00037</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">23</span><span class="p">)</span>       <span class="nx">TESTB</span>   <span class="nx">AL</span><span class="p">,</span> <span class="p">(</span><span class="nx">CX</span><span class="p">)</span>
        <span class="mh">0x0027</span> <span class="mo">0003</span><span class="mi">9</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">23</span><span class="p">)</span>       <span class="nx">MOVQ</span>    <span class="mi">8</span><span class="p">(</span><span class="nx">AX</span><span class="p">),</span> <span class="nx">AX</span>               <span class="p">;;</span> <span class="nx">从</span> <span class="nx">AX</span> <span class="nx">里读到内存地址值</span><span class="o">+</span><span class="mi">8</span> <span class="err">，</span><span class="nx">然后从内存地址里拿到值</span><span class="err">，</span><span class="nx">再读到AX</span>
        <span class="mh">0x002b</span> <span class="mo">00043</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">23</span><span class="p">)</span>       <span class="nx">ADDQ</span>    <span class="s">&#34;&#34;</span><span class="p">.</span><span class="nx">factor</span><span class="o">+</span><span class="mi">16</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">AX</span>    <span class="p">;;</span> <span class="nx">AX</span> <span class="p">=</span> <span class="mi">5</span><span class="o">+</span><span class="mi">10</span>
        <span class="mh">0x0030</span> <span class="mo">0004</span><span class="mi">8</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">23</span><span class="p">)</span>       <span class="nx">MOVQ</span>    <span class="nx">AX</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="nx">CX</span><span class="p">)</span>               <span class="p">;;</span> <span class="nx">将计算结果</span> <span class="mi">15</span> <span class="nx">写入到</span> <span class="nx">CX</span><span class="o">+</span><span class="mi">8</span> <span class="nx">的内存地址</span>
        <span class="mh">0x0034</span> <span class="mo">00052</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">24</span><span class="p">)</span>       <span class="nx">RET</span>
</code></pre></td></tr></table>
</div>
</div><p>In this method is actually a bit interesting and a bit roundabout, because a lot of places are actually operations on pointers, so that changes made by either side will affect the other side.</p>
<p>Here is a step-by-step analysis.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="mh">0x0000</span> <span class="mo">00000</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">22</span><span class="p">)</span>       <span class="nx">MOVQ</span>    <span class="s">&#34;&#34;</span><span class="p">.</span><span class="nx">p</span><span class="o">+</span><span class="mi">8</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">AX</span>
<span class="mh">0x0007</span> <span class="mo">00007</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">22</span><span class="p">)</span>       <span class="nx">MOVQ</span>    <span class="s">&#34;&#34;</span><span class="p">.</span><span class="nx">p</span><span class="o">+</span><span class="mi">8</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">CX</span> 
<span class="mh">0x000e</span> <span class="mo">00014</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">22</span><span class="p">)</span>       <span class="nf">MOVQ</span>    <span class="p">(</span><span class="nx">AX</span><span class="p">),</span> <span class="nx">AX</span>
</code></pre></td></tr></table>
</div>
</div><p>These two instructions assign the pointer stored in 8(SP) to AX and CX respectively, and then get the value from the AX memory address and write it to AX.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">0x0011 <span class="m">00017</span> <span class="o">(</span>main.go:22<span class="o">)</span>       ADDQ    <span class="s2">&#34;&#34;</span>.factor+16<span class="o">(</span>SP<span class="o">)</span>, AX 
0x0016 <span class="m">00022</span> <span class="o">(</span>main.go:22<span class="o">)</span>       MOVQ    AX, <span class="o">(</span>CX<span class="o">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Here the 16(SP) parameter is added to AX, so the value stored in AX should be 12. Then AX is assigned to the value pointed to by CX&rsquo;s memory address, and we know from the above assembly that CX points to the pointer stored in 8(SP), so the value pointed to by 8(SP) is also modified here.</p>
<p>We can verify this by using dlv to output regs.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="o">(</span>dlv<span class="o">)</span> regs
    <span class="nv">Rsp</span> <span class="o">=</span> 0x000000c000056748
    <span class="nv">Rax</span> <span class="o">=</span> 0x000000000000000c
    <span class="nv">Rcx</span> <span class="o">=</span> 0x000000c000056768
</code></pre></td></tr></table>
</div>
</div><p>We can then look at the values stored in 8(SP) and CX.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="o">(</span>dlv<span class="o">)</span> print *<span class="o">(</span>*int<span class="o">)(</span>uintptr<span class="o">(</span>0x000000c000056748<span class="o">)</span> +8  <span class="o">)</span> 
<span class="m">824634074984</span>
<span class="o">(</span>dlv<span class="o">)</span> print uintptr<span class="o">(</span>0x000000c000056768<span class="o">)</span>
<span class="m">824634074984</span>
</code></pre></td></tr></table>
</div>
</div><p>You can see that they all point to the same 32(SP) pointer.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="o">(</span>dlv<span class="o">)</span> print uintptr<span class="o">(</span>0x000000c000056748<span class="o">)</span> +32
<span class="m">824634074984</span>
</code></pre></td></tr></table>
</div>
</div><p>Then we can print out the exact value of the pointer.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="o">(</span>dlv<span class="o">)</span> print *<span class="o">(</span>*int<span class="o">)(</span>824634074984<span class="o">)</span> 
<span class="m">12</span>
</code></pre></td></tr></table>
</div>
</div><p>At this point, the stack frame looks like this.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/22/93903ff3c5eb458699284cea6cc55dd4.png" alt="sobyte"></p>
<p>Let&rsquo;s move on to the next</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">0x0019 <span class="m">00025</span> <span class="o">(</span>main.go:23<span class="o">)</span>       MOVQ    <span class="s2">&#34;&#34;</span>.p+8<span class="o">(</span>SP<span class="o">)</span>, AX
0x0020 <span class="m">00032</span> <span class="o">(</span>main.go:23<span class="o">)</span>       MOVQ    <span class="s2">&#34;&#34;</span>.p+8<span class="o">(</span>SP<span class="o">)</span>, CX
</code></pre></td></tr></table>
</div>
</div><p>Here the address values stored at 8(SP) are assigned to AX and CX.</p>
<p>Here we let the code run after the <code>MOVQ &quot;&quot;.p+8(SP), CX</code> execution line with the single-step step-instruction command, and then look at the AX pointer location.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="p">(</span><span class="nx">dlv</span><span class="p">)</span> <span class="nx">disassemble</span>
        <span class="o">...</span>
        <span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">21</span>      <span class="mh">0x467980</span>        <span class="mi">488</span><span class="nx">b4c2408</span>      <span class="nx">mov</span> <span class="nx">rcx</span><span class="p">,</span> <span class="nx">qword</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">rsp</span><span class="o">+</span><span class="mh">0x8</span><span class="p">]</span>
<span class="p">=&gt;</span>      <span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">21</span>      <span class="mh">0x467985</span>        <span class="mi">8401</span>            <span class="nx">test</span> <span class="kt">byte</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">rcx</span><span class="p">],</span> <span class="nx">al</span>
        <span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">21</span>      <span class="mh">0x467987</span>        <span class="mi">488</span><span class="nx">b4008</span>        <span class="nx">mov</span> <span class="nx">rax</span><span class="p">,</span> <span class="nx">qword</span> <span class="nx">ptr</span> <span class="p">[</span><span class="nx">rax</span><span class="o">+</span><span class="mh">0x8</span><span class="p">]</span>
        <span class="o">...</span>

<span class="p">(</span><span class="nx">dlv</span><span class="p">)</span> <span class="nx">regs</span>
    <span class="nx">Rsp</span> <span class="p">=</span> <span class="mh">0x000000c000056748</span>
    <span class="nx">Rax</span> <span class="p">=</span> <span class="mh">0x000000c000056768</span> 
    <span class="nx">Rcx</span> <span class="p">=</span> <span class="mh">0x000000c000056768</span>

<span class="p">(</span><span class="nx">dlv</span><span class="p">)</span> <span class="nx">print</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mh">0x000000c000056768</span><span class="p">)</span>
<span class="mi">824634074984</span>
</code></pre></td></tr></table>
</div>
</div><p>You can see that AX and CX are pointing to the same memory address location. We then go to the following.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">0x0027 <span class="m">00039</span> <span class="o">(</span>main.go:23<span class="o">)</span>       MOVQ    8<span class="o">(</span>AX<span class="o">)</span>, AX
</code></pre></td></tr></table>
</div>
</div><p>As mentioned earlier, for structures, the allocation is a continuous block of code, and 32(SP) to 48(SP) on the stack point to the structure instantiated by variable p. So in the above printout 824634074984 represents the value of variable p.X. Then the address value of p.Y is <code>824634074984+8</code>, and we can also print out the value represented by the address via dlv We can also print out the value represented by the address with dlv.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="o">(</span>dlv<span class="o">)</span> print *<span class="o">(</span>*int<span class="o">)(</span>824634074984+8<span class="o">)</span> 
<span class="m">5</span>
</code></pre></td></tr></table>
</div>
</div><p>So <code>MOVQ 8(AX), AX</code> actually does add 8 to the address value, then takes the result 5 and assigns it to AX.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">0x002b <span class="m">00043</span> <span class="o">(</span>main.go:23<span class="o">)</span>       ADDQ    <span class="s2">&#34;&#34;</span>.factor+16<span class="o">(</span>SP<span class="o">)</span>, AX <span class="p">;;</span> <span class="nv">AX</span> <span class="o">=</span> AX +10
0x0030 <span class="m">00048</span> <span class="o">(</span>main.go:23<span class="o">)</span>       MOVQ    AX, 8<span class="o">(</span>CX<span class="o">)</span>
</code></pre></td></tr></table>
</div>
</div><p>The result is that AX is calculated to be equal to 15, and then the result is written to the space pointed to by the CX+8 memory address value, which also modifies the value pointed to by the pointer at 40(SP).</p>
<p>At the end of this method, the stack frame is as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/22/01518f4123d8449a9e5f5a2ee5a814fd.png" alt="sobyte"></p>
<p>From the above analysis we can see an interesting thing, in the call to the pointer receiver (pointer receiver) method call, is actually the first copy of the structure pointer to the stack, and then in the method call is all based on the pointer operation.</p>
<h4 id="summary">Summary</h4>
<p>We know that when we call the value receiver method, the caller writes the value of the argument to the stack, and the caller callee actually operates on the value of the argument on the caller&rsquo;s stack.</p>
<p>The difference between the pointer receiver method and the value receiver method is that the caller writes to the stack the address of the parameter, so it is reflected in the receiver&rsquo;s structure directly after the call.</p>
<h3 id="literal-methods-func-literal">Literal methods func literal</h3>
<p>func literal I don&rsquo;t know how to translate it exactly, let&rsquo;s call it a literal method, in Go these methods mainly include anonymous functions and closures.</p>
<h4 id="anonymous-functions">anonymous functions</h4>
<p>I&rsquo;m going to analyze this with a simple example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">f</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
        <span class="nx">x</span> <span class="o">+=</span> <span class="nx">x</span>
        <span class="k">return</span> <span class="nx">x</span>
    <span class="p">}</span>
    <span class="nf">f</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Let&rsquo;s look at its compilation below.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">        0x0000 <span class="m">00000</span> <span class="o">(</span>main.go:3<span class="o">)</span>        TEXT    <span class="s2">&#34;&#34;</span>.main<span class="o">(</span>SB<span class="o">)</span>, ABIInternal, <span class="nv">$32</span>-0
        ...
        0x001d <span class="m">00029</span> <span class="o">(</span>main.go:4<span class="o">)</span>        LEAQ    <span class="s2">&#34;&#34;</span>.main.func1·f<span class="o">(</span>SB<span class="o">)</span>, DX
        0x0024 <span class="m">00036</span> <span class="o">(</span>main.go:4<span class="o">)</span>        MOVQ    DX, <span class="s2">&#34;&#34;</span>.f+16<span class="o">(</span>SP<span class="o">)</span>
        0x0029 <span class="m">00041</span> <span class="o">(</span>main.go:8<span class="o">)</span>        MOVQ    <span class="nv">$100</span>, <span class="o">(</span>SP<span class="o">)</span>
        0x0031 <span class="m">00049</span> <span class="o">(</span>main.go:8<span class="o">)</span>        MOVQ    <span class="s2">&#34;&#34;</span>.main.func1·f<span class="o">(</span>SB<span class="o">)</span>, AX
        0x0038 <span class="m">00056</span> <span class="o">(</span>main.go:8<span class="o">)</span>        PCDATA  <span class="nv">$1</span>, <span class="nv">$0</span>
        0x0038 <span class="m">00056</span> <span class="o">(</span>main.go:8<span class="o">)</span>        CALL    AX
        0x003a <span class="m">00058</span> <span class="o">(</span>main.go:9<span class="o">)</span>        MOVQ    24<span class="o">(</span>SP<span class="o">)</span>, BP
        0x003f <span class="m">00063</span> <span class="o">(</span>main.go:9<span class="o">)</span>        ADDQ    <span class="nv">$32</span>, SP
        0x0043 <span class="m">00067</span> <span class="o">(</span>main.go:9<span class="o">)</span>        RET
</code></pre></td></tr></table>
</div>
</div><p>Through the above analysis I believe you should be able to see what this assembly is doing. The anonymous function actually passes the entry address of the anonymous function.</p>
<h4 id="closures">Closures</h4>
<p>What are closures? Wikipedia describes closures in the following way.</p>
<blockquote>
<p>a <strong>closure</strong> is a record storing <strong>a function</strong> together with <strong>an environment</strong> .</p>
</blockquote>
<p>A <strong>closure</strong> is an entity consisting of a <strong>function</strong> and its associated reference <strong>environment</strong>.</p>
<p>I&rsquo;ll do it here with a simple example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">func</span> <span class="nf">test</span><span class="p">()</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">x</span> <span class="o">:=</span> <span class="mi">100</span>
    <span class="k">return</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">x</span> <span class="o">+=</span> <span class="mi">100</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">f</span> <span class="o">:=</span> <span class="nf">test</span><span class="p">()</span>
    <span class="nf">f</span><span class="p">()</span> <span class="c1">//x= 200
</span><span class="c1"></span>    <span class="nf">f</span><span class="p">()</span> <span class="c1">//x= 300
</span><span class="c1"></span>    <span class="nf">f</span><span class="p">()</span> <span class="c1">//x= 400
</span><span class="c1"></span><span class="p">}</span> 
</code></pre></td></tr></table>
</div>
</div><p>Since closures are contextual, let&rsquo;s take the test example where the variable x changes with each call to the f() function. But as we know from other method calls, if the variable is stored on the stack then the variable will expire with the exit of the stack frame, so the variable of the closure will escape to the heap.</p>
<p>We can perform an escape analysis to prove this.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="p">[</span><span class="nx">root</span><span class="err">@</span><span class="nx">localhost</span> <span class="nx">gotest</span><span class="p">]</span><span class="err">$</span> <span class="k">go</span> <span class="nx">run</span> <span class="o">-</span><span class="nx">gcflags</span> <span class="s">&#34;-m -l&#34;</span> <span class="nx">main</span><span class="p">.</span><span class="k">go</span> 
<span class="err">#</span> <span class="nx">command</span><span class="o">-</span><span class="nx">line</span><span class="o">-</span><span class="nx">arguments</span>
<span class="p">.</span><span class="o">/</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">4</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span> <span class="nx">moved</span> <span class="nx">to</span> <span class="nx">heap</span><span class="p">:</span> <span class="nx">x</span>
<span class="p">.</span><span class="o">/</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">:</span><span class="mi">9</span><span class="p">:</span> <span class="kd">func</span> <span class="nx">literal</span> <span class="nx">escapes</span> <span class="nx">to</span> <span class="nx">heap</span>
</code></pre></td></tr></table>
</div>
</div><p>You can see that the variable x escapes to the heap.</p>
<p>Let&rsquo;s take a look at the assembly directly.</p>
<p>Let&rsquo;s look at the main function first.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="s">&#34;&#34;</span><span class="p">.</span><span class="nx">main</span> <span class="nx">STEXT</span> <span class="nx">size</span><span class="p">=</span><span class="mi">88</span> <span class="nx">args</span><span class="p">=</span><span class="mh">0x0</span> <span class="nx">locals</span><span class="p">=</span><span class="mh">0x18</span>
        <span class="mh">0x0000</span> <span class="mo">00000</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">10</span><span class="p">)</span>       <span class="nx">TEXT</span>    <span class="s">&#34;&#34;</span><span class="p">.</span><span class="nf">main</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">ABIInternal</span><span class="p">,</span> <span class="err">$</span><span class="mi">24</span><span class="o">-</span><span class="mi">0</span>
        <span class="mh">0x0000</span> <span class="mo">00000</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">10</span><span class="p">)</span>       <span class="nf">MOVQ</span>    <span class="p">(</span><span class="nx">TLS</span><span class="p">),</span> <span class="nx">CX</span>
        <span class="mh">0x0009</span> <span class="mo">0000</span><span class="mi">9</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">10</span><span class="p">)</span>       <span class="nx">CMPQ</span>    <span class="nx">SP</span><span class="p">,</span> <span class="mi">16</span><span class="p">(</span><span class="nx">CX</span><span class="p">)</span>
        <span class="mh">0x000d</span> <span class="mo">00013</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">10</span><span class="p">)</span>       <span class="nx">PCDATA</span>  <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="err">$</span><span class="o">-</span><span class="mi">2</span>
        <span class="mh">0x000d</span> <span class="mo">00013</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">10</span><span class="p">)</span>       <span class="nx">JLS</span>     <span class="mi">81</span>
        <span class="mh">0x000f</span> <span class="mo">00015</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">10</span><span class="p">)</span>       <span class="nx">PCDATA</span>  <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="err">$</span><span class="o">-</span><span class="mi">1</span>
        <span class="mh">0x000f</span> <span class="mo">00015</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">10</span><span class="p">)</span>       <span class="nx">SUBQ</span>    <span class="err">$</span><span class="mi">24</span><span class="p">,</span> <span class="nx">SP</span>
        <span class="mh">0x0013</span> <span class="mo">0001</span><span class="mi">9</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">10</span><span class="p">)</span>       <span class="nx">MOVQ</span>    <span class="nx">BP</span><span class="p">,</span> <span class="mi">16</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>
        <span class="mh">0x0018</span> <span class="mo">00024</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">10</span><span class="p">)</span>       <span class="nx">LEAQ</span>    <span class="mi">16</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">BP</span>
        <span class="mh">0x001d</span> <span class="mo">0002</span><span class="mi">9</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">10</span><span class="p">)</span>       <span class="nx">FUNCDATA</span>        <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="nx">gclocals</span><span class="err">·</span><span class="mi">69</span><span class="nf">c1753bd5f81501d95132d08af04464</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
        <span class="mh">0x001d</span> <span class="mo">0002</span><span class="mi">9</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">10</span><span class="p">)</span>       <span class="nx">FUNCDATA</span>        <span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="nx">gclocals</span><span class="err">·</span><span class="mi">9</span><span class="nf">fb7f0986f647f17cb53dda1484e0f7a</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
        <span class="mh">0x001d</span> <span class="mo">0002</span><span class="mi">9</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">11</span><span class="p">)</span>       <span class="nx">PCDATA</span>  <span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="err">$</span><span class="mi">0</span>
        <span class="mh">0x001d</span> <span class="mo">0002</span><span class="mi">9</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">11</span><span class="p">)</span>       <span class="nx">NOP</span>
        <span class="mh">0x0020</span> <span class="mo">00032</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">11</span><span class="p">)</span>       <span class="nx">CALL</span>    <span class="s">&#34;&#34;</span><span class="p">.</span><span class="nf">test</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
        <span class="o">...</span>
</code></pre></td></tr></table>
</div>
</div><p>In fact, this assembly is the same as the assembly of other function calls, there is nothing to say, before calling the test function is to do some stack initialization work.</p>
<p>Here is a direct look at the test function.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">0x0000 00000 (main.go:3)        TEXT    &#34;&#34;.test(SB), ABIInternal, $40-8
0x0000 00000 (main.go:3)        MOVQ    (TLS), CX
0x0009 00009 (main.go:3)        CMPQ    SP, 16(CX)
0x000d 00013 (main.go:3)        PCDATA  $0, $-2
0x000d 00013 (main.go:3)        JLS     171
0x0013 00019 (main.go:3)        PCDATA  $0, $-1
0x0013 00019 (main.go:3)        SUBQ    $40, SP
0x0017 00023 (main.go:3)        MOVQ    BP, 32(SP)
0x001c 00028 (main.go:3)        LEAQ    32(SP), BP
0x0021 00033 (main.go:3)        FUNCDATA        $0, gclocals·263043c8f03e3241528dfae4e2812ef4(SB)
0x0021 00033 (main.go:3)        FUNCDATA        $1, gclocals·568470801006e5c0dc3947ea998fe279(SB)
0x0021 00033 (main.go:3)        MOVQ    $0, &#34;&#34;.~r0+48(SP)
0x002a 00042 (main.go:4)        LEAQ    type.int(SB), AX
0x0031 00049 (main.go:4)        MOVQ    AX, (SP)
0x0035 00053 (main.go:4)        PCDATA  $1, $0
0x0035 00053 (main.go:4)        CALL    runtime.newobject(SB)           ;; 申请内存
0x003a 00058 (main.go:4)        MOVQ    8(SP), AX                       ;; 将申请的内存地址写到 AX 中
0x003f 00063 (main.go:4)        MOVQ    AX, &#34;&#34;.&amp;x+24(SP)                ;; 将内存地址写到 24(SP) 中
0x0044 00068 (main.go:4)        MOVQ    $100, (AX)                      ;; 将100 写到 AX 保存的内存地址指向的内存中
0x004b 00075 (main.go:5)        LEAQ    type.noalg.struct { F uintptr; &#34;&#34;.x *int }(SB), AX ;; 创建闭包结构体,并将函数地址写到 AX
0x0052 00082 (main.go:5)        MOVQ    AX, (SP)                        ;; 将 AX 中保存的函数地址写到 (SP)   
0x0056 00086 (main.go:5)        PCDATA  $1, $1
0x0056 00086 (main.go:5)        CALL    runtime.newobject(SB)           ;; 申请内存
0x005b 00091 (main.go:5)        MOVQ    8(SP), AX                       ;; 将申请的内存地址写到 AX 中
0x0060 00096 (main.go:5)        MOVQ    AX, &#34;&#34;..autotmp_4+16(SP)        ;; 将内存地址写到 16(SP) 中
0x0065 00101 (main.go:5)        LEAQ    &#34;&#34;.test.func1(SB), CX           ;; 将 test.func1 函数地址写到 CX
0x006c 00108 (main.go:5)        MOVQ    CX, (AX)                        ;; 将 CX 中保存的函数地址写到 AX 保存的内存地址指向的内存中
0x006f 00111 (main.go:5)        MOVQ    &#34;&#34;..autotmp_4+16(SP), AX        ;; 将 16(SP) 保存的内存地址写到 AX 
0x0074 00116 (main.go:5)        TESTB   AL, (AX)
0x0076 00118 (main.go:5)        MOVQ    &#34;&#34;.&amp;x+24(SP), CX                ;; 将 24(SP) 保存的地址值写到 CX
0x007b 00123 (main.go:5)        LEAQ    8(AX), DI                       ;; 将 AX + 8 写到 DI
0x007f 00127 (main.go:5)        PCDATA  $0, $-2
0x007f 00127 (main.go:5)        CMPL    runtime.writeBarrier(SB), $0
0x0086 00134 (main.go:5)        JEQ     138
0x0088 00136 (main.go:5)        JMP     164
0x008a 00138 (main.go:5)        MOVQ    CX, 8(AX)                       ;; 将 CX 中保存的函数地址写到 AX+8
0x008e 00142 (main.go:5)        JMP     144
0x0090 00144 (main.go:5)        PCDATA  $0, $-1
0x0090 00144 (main.go:5)        MOVQ    &#34;&#34;..autotmp_4+16(SP), AX
0x0095 00149 (main.go:5)        MOVQ    AX, &#34;&#34;.~r0+48(SP)
0x009a 00154 (main.go:5)        MOVQ    32(SP), BP
0x009f 00159 (main.go:5)        ADDQ    $40, SP
0x00a3 00163 (main.go:5)        RET
</code></pre></td></tr></table>
</div>
</div><p>Let&rsquo;s look at this compilation step by step.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">0x002a 00042 (main.go:4)        LEAQ    type.int(SB), AX                ;; 将 type.int 函数地址值写到 AX
0x0031 00049 (main.go:4)        MOVQ    AX, (SP)                        ;; 将 AX 保存的函数地址值写到 (SP)  
0x0035 00053 (main.go:4)        PCDATA  $1, $0
0x0035 00053 (main.go:4)        CALL    runtime.newobject(SB)           ;; 申请内存
0x003a 00058 (main.go:4)        MOVQ    8(SP), AX                       ;; 将申请的内存地址写到 AX 中
0x003f 00063 (main.go:4)        MOVQ    AX, &#34;&#34;.&amp;x+24(SP)                ;; 将内存地址写到 24(SP) 中
0x0044 00068 (main.go:4)        MOVQ    $100, (AX)
</code></pre></td></tr></table>
</div>
</div><p>This step is actually writing the type.int function address value to (SP) via AX, then calling runtime.newobject to request a memory block, writing the memory address value to 24(SP) via AX is equivalent to allocating memory space to variable x, and finally setting the value of x to 100.</p>
<p>At this point the stack frame structure should look like this.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/22/d308e785c180401eacfc275d1e40ed74.png" alt="sobyte"></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">0x004b <span class="m">00075</span> <span class="o">(</span>main.go:5<span class="o">)</span>        LEAQ    type.noalg.struct <span class="o">{</span> F uintptr<span class="p">;</span> <span class="s2">&#34;&#34;</span>.x *int <span class="o">}(</span>SB<span class="o">)</span>, AX
</code></pre></td></tr></table>
</div>
</div><p>This structure represents a closure, and then the memory address of the created structure is placed in the AX register.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">0x0052 <span class="m">00082</span> <span class="o">(</span>main.go:5<span class="o">)</span>        MOVQ    AX, <span class="o">(</span>SP<span class="o">)</span>
</code></pre></td></tr></table>
</div>
</div><p>This assembly instruction then writes the memory address stored in AX to (SP).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">0x0056 <span class="m">00086</span> <span class="o">(</span>main.go:5<span class="o">)</span>        CALL    runtime.newobject<span class="o">(</span>SB<span class="o">)</span>           <span class="p">;;</span> 申请内存
0x005b <span class="m">00091</span> <span class="o">(</span>main.go:5<span class="o">)</span>        MOVQ    8<span class="o">(</span>SP<span class="o">)</span>, AX                       <span class="p">;;</span> 将申请的内存地址写到 AX 中
0x0060 <span class="m">00096</span> <span class="o">(</span>main.go:5<span class="o">)</span>        MOVQ    AX, <span class="s2">&#34;&#34;</span>..autotmp_4+16<span class="o">(</span>SP<span class="o">)</span>        <span class="p">;;</span> 将内存地址写到 16<span class="o">(</span>SP<span class="o">)</span> 中
</code></pre></td></tr></table>
</div>
</div><p>Here a new block of memory will be requested and the memory address will be written from AX to 16(SP).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">0x0065 <span class="m">00101</span> <span class="o">(</span>main.go:5<span class="o">)</span>        LEAQ    <span class="s2">&#34;&#34;</span>.test.func1<span class="o">(</span>SB<span class="o">)</span>, CX           <span class="p">;;</span> 将 test.func1 函数地址写到 CX
0x006c <span class="m">00108</span> <span class="o">(</span>main.go:5<span class="o">)</span>        MOVQ    CX, <span class="o">(</span>AX<span class="o">)</span>                        <span class="p">;;</span> 将 CX 中保存的函数地址写到 AX 保存的内存地址指向的内存中
0x006f <span class="m">00111</span> <span class="o">(</span>main.go:5<span class="o">)</span>        MOVQ    <span class="s2">&#34;&#34;</span>..autotmp_4+16<span class="o">(</span>SP<span class="o">)</span>, AX        <span class="p">;;</span> 将 16<span class="o">(</span>SP<span class="o">)</span> 保存的内存地址写到 AX
</code></pre></td></tr></table>
</div>
</div><p>Here the test.func1 function address value is written to CX, and then the address value stored in CX is written to the memory pointed to by the memory address saved in AX. Then it also writes the address value saved by 16(SP) to AX, in fact, the value saved by AX does not change here, so I don&rsquo;t know why it is necessary to generate an assembly instruction like this.</p>
<p>Since the AX memory address is written to 8(SP) and the 16(SP) memory address is written to AX, this one-time actually modifies the value in three places, and the specific stack frame structure is as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/22/f83ceb7753954a3b9cf0fd2c9e8cd0d5.png" alt="sobyte"></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-tex" data-lang="tex">0x0076 00118 (main.go:5)        MOVQ    &#34;&#34;.<span class="nb">&amp;</span>x+24(SP), CX                ;; 将 24(SP) 保存的地址值写到 CX
0x007b 00123 (main.go:5)        LEAQ    8(AX), DI                       ;; 将 AX + 8 写到 DI
0x007f 00127 (main.go:5)        CMPL    runtime.writeBarrier(SB), <span class="s">$</span><span class="m">0</span><span class="nb">    ;; 写屏障
</span><span class="nb"></span><span class="m">0</span><span class="nb">x</span><span class="m">0086</span><span class="nb"> </span><span class="m">00134</span><span class="nb"> </span><span class="o">(</span><span class="nb">main.go:</span><span class="m">5</span><span class="o">)</span><span class="nb">        JEQ     </span><span class="m">138</span><span class="nb">
</span><span class="nb"></span><span class="m">0</span><span class="nb">x</span><span class="m">0088</span><span class="nb"> </span><span class="m">00136</span><span class="nb"> </span><span class="o">(</span><span class="nb">main.go:</span><span class="m">5</span><span class="o">)</span><span class="nb">        JMP     </span><span class="m">164</span><span class="nb">
</span><span class="nb"></span><span class="m">0</span><span class="nb">x</span><span class="m">008</span><span class="nb">a </span><span class="m">00138</span><span class="nb"> </span><span class="o">(</span><span class="nb">main.go:</span><span class="m">5</span><span class="o">)</span><span class="nb">        MOVQ    CX, </span><span class="m">8</span><span class="o">(</span><span class="nb">AX</span><span class="o">)</span><span class="nb">                       ;; 将 CX 中保存的地址写到 AX</span><span class="o">+</span><span class="m">8</span><span class="nb">
</span></code></pre></td></tr></table>
</div>
</div><p>24(SP) actually holds the pointer address of the x variable, which will be written to CX here. Then the value saved by 8(AX) will be transferred to DI, and finally the value saved by CX will be written to 8(AX).</p>
<p>Here is a little bit more about the reference of AX at this point.</p>
<p>AX -&gt; address value of test.func1, that is, AX is pointing to the address value of test.func1 at this time.</p>
<p>8(AX) -&gt; 24(SP) address value -&gt; 100, that is, the address value saved by 8(AX) points to the 24(SP) address value, and the memory saved by the 24(SP) address value points to 100.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">0x0090 00144 (main.go:5)        MOVQ    &#34;&#34;..autotmp_4+16(SP), AX        ;; 16(SP) 中保存的地址写入 AX
0x0095 00149 (main.go:5)        MOVQ    AX, &#34;&#34;.~r0+48(SP)               ;; 将 AX 中保存的地址写到 48(SP)   
0x009a 00154 (main.go:5)        MOVQ    32(SP), BP
0x009f 00159 (main.go:5)        ADDQ    $40, SP
</code></pre></td></tr></table>
</div>
</div><p>The value of 16(SP) will be written to the upper caller&rsquo;s stack frame 48(SP) by AX, and then the stack will be shrunk and the callee stack call will be completed.</p>
<p>After the call, it returns to the main function, and the stack frame at this time is as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/22/21da325535ed4b3fbcd51874e015fe14.png" alt="sobyte"></p>
<p>Returning to the location of the main function after the test function call, the following</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">0x0020 <span class="m">00032</span> <span class="o">(</span>main.go:11<span class="o">)</span>       CALL    <span class="s2">&#34;&#34;</span>.test<span class="o">(</span>SB<span class="o">)</span>
0x0025 <span class="m">00037</span> <span class="o">(</span>main.go:11<span class="o">)</span>       MOVQ    <span class="o">(</span>SP<span class="o">)</span>, DX                <span class="p">;;</span> 将<span class="o">(</span>SP<span class="o">)</span>保存的函数地址值写到 DX 
0x0029 <span class="m">00041</span> <span class="o">(</span>main.go:11<span class="o">)</span>       MOVQ    DX, <span class="s2">&#34;&#34;</span>.f+8<span class="o">(</span>SP<span class="o">)</span>          <span class="p">;;</span> 将 DX 保存的函数地址值写到 8<span class="o">(</span>SP<span class="o">)</span>   
0x002e <span class="m">00046</span> <span class="o">(</span>main.go:12<span class="o">)</span>       MOVQ    <span class="o">(</span>DX<span class="o">)</span>, AX                <span class="p">;;</span> 将 DX 保存的函数地址值写到 AX
</code></pre></td></tr></table>
</div>
</div><p>After the test function is called, a test.func1 function address value is returned to the top of the main call stack, and then the test.func1 function address value stored in (SP) is written to AX after the test function is called, and then the following instruction is executed to call.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">0x0031 <span class="m">00049</span> <span class="o">(</span>main.go:12<span class="o">)</span>       CALL    AX
</code></pre></td></tr></table>
</div>
</div><p>Before we get to the test.func1 function, we should now know that (SP) holds the value of the address pointing to AX.</p>
<p>The test.func1 function is the function within the test function that wraps the return.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="s2">&#34;&#34;</span>.test.func1 STEXT nosplit <span class="nv">size</span><span class="o">=</span><span class="m">36</span> <span class="nv">args</span><span class="o">=</span>0x0 <span class="nv">locals</span><span class="o">=</span>0x10
        0x0000 <span class="m">00000</span> <span class="o">(</span>main.go:5<span class="o">)</span>        TEXT    <span class="s2">&#34;&#34;</span>.test.func1<span class="o">(</span>SB<span class="o">)</span>, NOSPLIT<span class="p">|</span>NEEDCTXT<span class="p">|</span>ABIInternal, <span class="nv">$16</span>-0
        0x0000 <span class="m">00000</span> <span class="o">(</span>main.go:5<span class="o">)</span>        SUBQ    <span class="nv">$16</span>, SP
        0x0004 <span class="m">00004</span> <span class="o">(</span>main.go:5<span class="o">)</span>        MOVQ    BP, 8<span class="o">(</span>SP<span class="o">)</span>
        0x0009 <span class="m">00009</span> <span class="o">(</span>main.go:5<span class="o">)</span>        LEAQ    8<span class="o">(</span>SP<span class="o">)</span>, BP
        0x000e <span class="m">00014</span> <span class="o">(</span>main.go:5<span class="o">)</span>        MOVQ    8<span class="o">(</span>DX<span class="o">)</span>, AX       <span class="p">;;</span> 这里实际上是获取变量 x 的地址值
        0x0012 <span class="m">00018</span> <span class="o">(</span>main.go:5<span class="o">)</span>        MOVQ    AX, <span class="s2">&#34;&#34;</span>.<span class="p">&amp;</span>x<span class="o">(</span>SP<span class="o">)</span>
        0x0016 <span class="m">00022</span> <span class="o">(</span>main.go:6<span class="o">)</span>        ADDQ    <span class="nv">$100</span>, <span class="o">(</span>AX<span class="o">)</span>      <span class="p">;;</span> 将x地址指向的值加100
        0x001a <span class="m">00026</span> <span class="o">(</span>main.go:7<span class="o">)</span>        MOVQ    8<span class="o">(</span>SP<span class="o">)</span>, BP
        0x001f <span class="m">00031</span> <span class="o">(</span>main.go:7<span class="o">)</span>        ADDQ    <span class="nv">$16</span>, SP
        0x0023 <span class="m">00035</span> <span class="o">(</span>main.go:7<span class="o">)</span>        RET
</code></pre></td></tr></table>
</div>
</div><p>Since DX holds the AX address value, you can get the address value of variable x by 8(DX) and write it to AX. The ADDQ instruction is then called to add 100 to the value pointed to by the x address.</p>
<h4 id="summary-1">Summary</h4>
<p>From the above analysis, we can find that anonymous functions are actually a kind of closure, just without passing variable information. In the case of a closure call, the context information is escaped to the heap to avoid being recycled at the end of the stack frame call.</p>
<p>In the above example of the closure function test call, it is very complicated to do a lot of variable passing, but it actually does these things.</p>
<ol>
<li>initialize the memory block for the context information.</li>
<li>saving the address value of the context information to the AX register.</li>
<li>write the address of the test.func1 call function wrapped in the closure function to the top of the caller&rsquo;s stack.</li>
</ol>
<p>The context information here refers to the x variable and the test.func1 function. After writing these two addresses to the AX register, go back to the main function, get the address of the function on the top of the stack, write it to AX and execute <code>CALL AX</code> to call it.</p>
<p>Since the x variable address is written to AX + 8, the test.func1 function is called by getting the value of AX + 8 to get the x variable address to change the closure context information.</p>
<h2 id="summary-2">Summary</h2>
<p>In this article, we first shared with you how the process of function calls works, including the passing of parameters, the order of parameter stacking, and the passing of function return values. Then we analyzed the difference between structured method passing and how closed function calling works.</p>
<p>The dlv tool&rsquo;s regs command and step-instruction command help a lot when analyzing closures, otherwise it&rsquo;s easy to get around the pointer passing between registers, so it&rsquo;s recommended to draw on paper while watching.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/golang/">golang</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-01/go-stack/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">An article to help you understand stack operations in Go</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-01/go-defer-principle/">
            <span class="next-text nav-default">In-depth implementation of the Go language defer principle</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
