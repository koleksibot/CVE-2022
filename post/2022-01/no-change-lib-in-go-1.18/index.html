<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Rob opposes changes to the Go 1.18 generic standard library - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Rob Pike, the father of the Go language, previously created issue to oppose the introduction of generic support in the standard library in Go 1.18. Rob&amp;rsquo;s move was both unexpected and justified. Rob&amp;rsquo;s rationale was twofold: the scope of the change was too large, and the lack of real-world experience. So Rob suggested not to change the standard library in Go 1.18, but to provide a generic version of the" /><meta name="keywords" content="golang, Rob Pike" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-01/no-change-lib-in-go-1.18/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Rob opposes changes to the Go 1.18 generic standard library" />
<meta property="og:description" content="Rob Pike, the father of the Go language, previously created issue to oppose the introduction of generic support in the standard library in Go 1.18. Rob&rsquo;s move was both unexpected and justified. Rob&rsquo;s rationale was twofold: the scope of the change was too large, and the lack of real-world experience. So Rob suggested not to change the standard library in Go 1.18, but to provide a generic version of the" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-01/no-change-lib-in-go-1.18/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-01-05T11:57:27+08:00" />
<meta property="article:modified_time" content="2022-01-05T11:57:27+08:00" />

<meta itemprop="name" content="Rob opposes changes to the Go 1.18 generic standard library">
<meta itemprop="description" content="Rob Pike, the father of the Go language, previously created issue to oppose the introduction of generic support in the standard library in Go 1.18. Rob&rsquo;s move was both unexpected and justified. Rob&rsquo;s rationale was twofold: the scope of the change was too large, and the lack of real-world experience. So Rob suggested not to change the standard library in Go 1.18, but to provide a generic version of the"><meta itemprop="datePublished" content="2022-01-05T11:57:27+08:00" />
<meta itemprop="dateModified" content="2022-01-05T11:57:27+08:00" />
<meta itemprop="wordCount" content="1931">
<meta itemprop="keywords" content="golang," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Rob opposes changes to the Go 1.18 generic standard library"/>
<meta name="twitter:description" content="Rob Pike, the father of the Go language, previously created issue to oppose the introduction of generic support in the standard library in Go 1.18. Rob&rsquo;s move was both unexpected and justified. Rob&rsquo;s rationale was twofold: the scope of the change was too large, and the lack of real-world experience. So Rob suggested not to change the standard library in Go 1.18, but to provide a generic version of the"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Rob opposes changes to the Go 1.18 generic standard library</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-01-05 11:57:27 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 1931 words </span>
          <span class="more-meta"> 4 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#introduction-to-the-syntax-of-generics">Introduction to the syntax of generics</a></li>
        <li><a href="#generic-transformation-of-standard-libraries">Generic transformation of standard libraries</a>
          <ul>
            <li><a href="#introducing-the-new-standard-library">Introducing the new standard library</a></li>
            <li><a href="#retrofitting-old-standard-libraries">Retrofitting old standard libraries</a></li>
          </ul>
        </li>
        <li><a href="#summary">Summary</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>Rob Pike, the father of the Go language, previously created <a href="https://github.com/golang/go/issues/48918">issue</a> to oppose the introduction of generic support in the standard library in Go 1.18. Rob&rsquo;s move was both unexpected and justified. Rob&rsquo;s rationale was twofold: the scope of the change was too large, and the lack of real-world experience. So Rob suggested not to change the standard library in Go 1.18, but to provide a generic version of the library at golang.org/x or golang.org/exp first. After one or two versions, we will gain enough experience to consider updating the standard library at that time. What controversial changes did the community originally want to make to the standard library? Please allow me to elaborate.</p>
<h2 id="introduction-to-the-syntax-of-generics">Introduction to the syntax of generics</h2>
<p>Before we start, let&rsquo;s briefly introduce the syntax of Go language generics. For example, to implement a simple <code>Max</code> function, you can write it like this.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nx">Max</span><span class="p">[</span><span class="nx">T</span> <span class="nx">any</span><span class="p">](</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="nx">T</span><span class="p">)</span> <span class="nx">T</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">a</span> <span class="p">&lt;</span> <span class="nx">b</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">b</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">a</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Here you need to insert <code>[T any]</code> between the function name <code>Max</code> and the argument list <code>(a,b)</code>. where <code>T</code> is the generic argument, followed by <code>any</code> which is the constraint of the generic argument. As we&rsquo;ll get into later, you know that the Go language requires generic parameters to specify a range. After declaring generic parameters, you can use them in parameter lists, return value lists, and inside functions.</p>
<p>The actual type needs to be specified when calling a generic function:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">Max</span><span class="p">[</span><span class="kt">int</span><span class="p">](</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="c1">// 2
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">Max</span><span class="p">[</span><span class="kt">float32</span><span class="p">](</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">))</span> <span class="c1">// 2.2
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">Max</span><span class="p">[</span><span class="kt">string</span><span class="p">](</span><span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="s">&#34;b&#34;</span><span class="p">))</span> <span class="c1">// b
</span></code></pre></td></tr></table>
</div>
</div><p>For ease of use, Go generics also support type inference. That is, Go can infer the type of a generic argument based on the type of the function argument, so the above example can be rewritten as follows</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">Max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="c1">// 2
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">Max</span><span class="p">(</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">))</span> <span class="c1">// 2.2
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">Max</span><span class="p">(</span><span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="s">&#34;b&#34;</span><span class="p">))</span> <span class="c1">// b
</span></code></pre></td></tr></table>
</div>
</div><p>Does it look no different from a normal function!</p>
<p>Here&rsquo;s a question, can we execute the following call?</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">Max</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">},</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">2</span><span class="p">}))</span>
</code></pre></td></tr></table>
</div>
</div><p>The answer is no. This is because there is a comparison judgment like <code>if a &lt; b {}</code> in the <code>Max</code> function, and slice is not comparable with each other (see <a href="https://golang.org/ref/spec#Comparison_operators"><em>comparable</em></a> for details). That is, although we want to use <code>T</code> to represent different argument types, the implementation of <code>Max</code> dictates that only types that can be compared with each other can be passed. This is the problem that constraint needs to solve.</p>
<p>As we said earlier, generic parameters need to specify a constraint range. So how do you define constraint? This requires a variant of interface. For example, the types that support comparison can be written like this.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Ordered</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="p">|</span> <span class="kt">int8</span> <span class="p">|</span> <span class="kt">int16</span> <span class="p">|</span> <span class="kt">int32</span> <span class="p">|</span> <span class="kt">int64</span> <span class="p">|</span>
  <span class="kt">uint</span> <span class="p">|</span> <span class="kt">uint8</span> <span class="p">|</span> <span class="kt">uint16</span> <span class="p">|</span> <span class="kt">uint32</span> <span class="p">|</span> <span class="kt">uint64</span> <span class="p">|</span> <span class="kt">uintptr</span> <span class="p">|</span>
  <span class="kt">float32</span> <span class="p">|</span> <span class="kt">float64</span> <span class="p">|</span>
  <span class="kt">string</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>So, the previous <code>Max</code> function should be rewritten as <code>Max[T ordered](a, b T) T</code>. Because of the added ordered restriction, <code>Max([]int{1}, []int{2})</code> will report an error at compile time.</p>
<p>A special syntax is also supported when defining constraint</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Float</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="err">~</span><span class="kt">float32</span> <span class="p">|</span> <span class="err">~</span><span class="kt">float64</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The <code>~</code> here means that the underlying type is <code>float32</code> or <code>float64</code>. That is, if you define <code>type MyFloat float32</code>, you can also match <code>Float</code>. But if you don&rsquo;t add <code>~</code>, then it won&rsquo;t match.</p>
<p>The interface used here, you should be able to guess that you can use the interface to limit the scope of generic parameters (you must implement the corresponding interface). If you want to support passing in all types (i.e., no restrictions), then you have to use the famous <code>interface{}</code>. But writing it as <code>func foo[T interface{}])(a T)</code> is ugly, and <code>T</code> must be followed by <code>interface{}</code>, and most generic types have <code>interface{}</code> as a parameter restriction, so the official word <code>any</code> was agreed to replace <code>interface{}</code>. This echoes the way <code>Max[T any](a, b T) T</code> is written at the top.</p>
<h2 id="generic-transformation-of-standard-libraries">Generic transformation of standard libraries</h2>
<p>With generics, many things that couldn&rsquo;t be done before or were not elegant are now better.</p>
<h3 id="introducing-the-new-standard-library">Introducing the new standard library</h3>
<p>To make it easier for you to write generic code, the first thing to introduce is the constraints standard package.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">constraints</span>
<span class="c1">// 有符号整数
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Signed</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="err">~</span><span class="kt">int</span> <span class="p">|</span> <span class="err">~</span><span class="kt">int8</span> <span class="p">|</span> <span class="err">~</span><span class="kt">int16</span> <span class="p">|</span> <span class="err">~</span><span class="kt">int32</span> <span class="p">|</span> <span class="err">~</span><span class="kt">int64</span>
<span class="p">}</span>
<span class="c1">// 无符号整数
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Unsigned</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="err">~</span><span class="kt">uint</span> <span class="p">|</span> <span class="err">~</span><span class="kt">uint8</span> <span class="p">|</span> <span class="err">~</span><span class="kt">uint16</span> <span class="p">|</span> <span class="err">~</span><span class="kt">uint32</span> <span class="p">|</span> <span class="err">~</span><span class="kt">uint64</span> <span class="p">|</span> <span class="err">~</span><span class="kt">uintptr</span>
<span class="p">}</span>
<span class="c1">// 所有整数
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Integer</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">Signed</span> <span class="p">|</span> <span class="nx">Unsigned</span>
<span class="p">}</span>
<span class="c1">// 浮点数
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Float</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="err">~</span><span class="kt">float32</span> <span class="p">|</span> <span class="err">~</span><span class="kt">float64</span>
<span class="p">}</span>
<span class="c1">// 复数
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Complex</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="err">~</span><span class="kt">complex64</span> <span class="p">|</span> <span class="err">~</span><span class="kt">complex128</span>
<span class="p">}</span>
<span class="c1">// 支持比较的类型
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Ordered</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">Integer</span> <span class="p">|</span> <span class="nx">Float</span> <span class="p">|</span> <span class="err">~</span><span class="kt">string</span>
<span class="p">}</span>
<span class="c1">// 任意类型的 slice
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Slice</span><span class="p">[</span><span class="nx">Elem</span> <span class="nx">any</span><span class="p">]</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="err">~</span><span class="p">[]</span><span class="nx">Elem</span>
<span class="p">}</span>
<span class="c1">// 任意类型的 map
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Map</span><span class="p">[</span><span class="nx">Key</span> <span class="nx">comparable</span><span class="p">,</span> <span class="nx">Val</span> <span class="nx">any</span><span class="p">]</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="err">~</span><span class="kd">map</span><span class="p">[</span><span class="nx">Key</span><span class="p">]</span><span class="nx">Val</span>
<span class="p">}</span>
<span class="c1">// 任意类型的 channel
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Chan</span><span class="p">[</span><span class="nx">Elem</span> <span class="nx">any</span><span class="p">]</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="err">~</span><span class="kd">chan</span> <span class="nx">Elem</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>where comparable is a built-in generic restriction that matches all types that allow equal comparisons. But the constraints package has just been merged, and fzipp has <a href="https://github.com/golang/go/issues/48424">proposed</a> to simplify the generic restriction syntax. Simply make <code>[T nonInterfaceType]</code> equivalent to <code>[T interface{~nonInterfaceType}]</code>. As an example.</p>
<p>A generic argument that matches all maps can be written as <code>[M interface{~map[K]V}, K comparable, V any]</code> and can also refer to the constraints package as <code>[M constraints.Map[K, V], K comparable, V any]</code>. However, if the fzipp proposal is supported, it can be written as <code>[M map[K]V, K comparable, V any]</code> . Similarly, if you want to match all slice, you can write <code>[S []T, T any]</code> . If you just want to simply match multiple types, you can write <code>[T int8|int16]</code>, which is a bit of a union type.</p>
<p>We could care less about the details of the fzipp proposal, but one thing needs to be clear: if the fzipp proposal is accepted, then Slice/Map/Chan in the constraints package is not very necessary. This is where Rob&rsquo;s concern comes in. We need real world experience to test the current generic design.</p>
<p>Also introduced is the <a href="https://github.com/golang/go/issues/45955">slice</a> package of operations.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">slices</span>
<span class="kn">import</span> <span class="s">&#34;constraints&#34;</span>
<span class="c1">// 相等
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">Equal</span><span class="p">[</span><span class="nx">T</span> <span class="nx">comparable</span><span class="p">](</span><span class="nx">s1</span><span class="p">,</span> <span class="nx">s2</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{}</span>
<span class="kd">func</span> <span class="nx">EqualFunc</span><span class="p">[</span><span class="nx">T1</span><span class="p">,</span> <span class="nx">T2</span> <span class="nx">any</span><span class="p">](</span><span class="nx">s1</span> <span class="p">[]</span><span class="nx">T1</span><span class="p">,</span> <span class="nx">s2</span> <span class="p">[]</span><span class="nx">T2</span><span class="p">,</span> <span class="nx">eq</span> <span class="kd">func</span><span class="p">(</span><span class="nx">T1</span><span class="p">,</span> <span class="nx">T2</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{}</span>
<span class="c1">// 比较
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">Compare</span><span class="p">[</span><span class="nx">T</span> <span class="nx">constraints</span><span class="p">.</span><span class="nx">Ordered</span><span class="p">](</span><span class="nx">s1</span><span class="p">,</span> <span class="nx">s2</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{}</span>
<span class="kd">func</span> <span class="nx">CompareFunc</span><span class="p">[</span><span class="nx">T1</span><span class="p">,</span> <span class="nx">T2</span> <span class="nx">any</span><span class="p">](</span><span class="nx">s1</span> <span class="p">[]</span><span class="nx">T1</span><span class="p">,</span> <span class="nx">s2</span> <span class="p">[]</span><span class="nx">T2</span><span class="p">,</span> <span class="nx">cmp</span> <span class="kd">func</span><span class="p">(</span><span class="nx">T1</span><span class="p">,</span> <span class="nx">T2</span><span class="p">)</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{}</span>
<span class="c1">// 查找
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">Index</span><span class="p">[</span><span class="nx">T</span> <span class="nx">comparable</span><span class="p">](</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">v</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{}</span>
<span class="kd">func</span> <span class="nx">IndexFunc</span><span class="p">[</span><span class="nx">T</span> <span class="nx">any</span><span class="p">](</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{}</span>
<span class="kd">func</span> <span class="nx">Contains</span><span class="p">[</span><span class="nx">T</span> <span class="nx">comparable</span><span class="p">](</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">v</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{}</span>
<span class="c1">// 插入
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">Insert</span><span class="p">[</span><span class="nx">S</span> <span class="err">~</span><span class="p">[]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">T</span> <span class="nx">any</span><span class="p">](</span><span class="nx">s</span> <span class="nx">S</span><span class="p">,</span> <span class="nx">i</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">v</span> <span class="o">...</span><span class="nx">T</span><span class="p">)</span> <span class="nx">S</span> <span class="p">{}</span>
<span class="c1">// 删除
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">Delete</span><span class="p">[</span><span class="nx">S</span> <span class="err">~</span><span class="p">[]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">T</span> <span class="nx">any</span><span class="p">](</span><span class="nx">s</span> <span class="nx">S</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">S</span> <span class="p">{}</span>
<span class="c1">// 复制
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">Clone</span><span class="p">[</span><span class="nx">S</span> <span class="err">~</span><span class="p">[]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">T</span> <span class="nx">any</span><span class="p">](</span><span class="nx">s</span> <span class="nx">S</span><span class="p">)</span> <span class="nx">S</span> <span class="p">{}</span>
<span class="c1">// 去重
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">Compact</span><span class="p">[</span><span class="nx">S</span> <span class="err">~</span><span class="p">[]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">T</span> <span class="nx">comparable</span><span class="p">](</span><span class="nx">s</span> <span class="nx">S</span><span class="p">)</span> <span class="nx">S</span> <span class="p">{}</span>
<span class="kd">func</span> <span class="nx">CompactFunc</span><span class="p">[</span><span class="nx">S</span> <span class="err">~</span><span class="p">[]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">T</span> <span class="nx">any</span><span class="p">](</span><span class="nx">s</span> <span class="nx">S</span><span class="p">,</span> <span class="nx">eq</span> <span class="kd">func</span><span class="p">(</span><span class="nx">T</span><span class="p">,</span> <span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span> <span class="nx">S</span> <span class="p">{}</span>
<span class="c1">// 扩容
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">Grow</span><span class="p">[</span><span class="nx">S</span> <span class="err">~</span><span class="p">[]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">T</span> <span class="nx">any</span><span class="p">](</span><span class="nx">s</span> <span class="nx">S</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">S</span> <span class="p">{}</span>
<span class="c1">// 缩容
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">Clip</span><span class="p">[</span><span class="nx">S</span> <span class="err">~</span><span class="p">[]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">T</span> <span class="nx">any</span><span class="p">](</span><span class="nx">s</span> <span class="nx">S</span><span class="p">)</span> <span class="nx">S</span> <span class="p">{}</span>
</code></pre></td></tr></table>
</div>
</div><p>Except for <code>Index/Contains/Insert</code> which is more commonly used, the other methods are very niche. The code for <code>Grow</code>, for example, has only the following line.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nx">Grow</span><span class="p">[</span><span class="nx">S</span> <span class="err">~</span><span class="p">[]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">T</span> <span class="nx">any</span><span class="p">](</span><span class="nx">s</span> <span class="nx">S</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">S</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nb">make</span><span class="p">(</span><span class="nx">S</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span><span class="o">...</span><span class="p">)[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)]</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>It is not known exactly how they will work in practice, and it is really too early to integrate them into the standard library.</p>
<p>The same introduced <a href="https://github.com/golang/go/issues/47649">map</a> operation.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">maps</span>
<span class="c1">// 所有 key
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">Keys</span><span class="p">[</span><span class="nx">M</span> <span class="nx">constraints</span><span class="p">.</span><span class="nx">Map</span><span class="p">[</span><span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">],</span> <span class="nx">K</span> <span class="nx">comparable</span><span class="p">,</span> <span class="nx">V</span> <span class="nx">any</span><span class="p">](</span><span class="nx">m</span> <span class="nx">M</span><span class="p">)</span> <span class="p">[]</span><span class="nx">K</span>
<span class="c1">// 所有值
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">Values</span><span class="p">[</span><span class="nx">M</span> <span class="nx">constraints</span><span class="p">.</span><span class="nx">Map</span><span class="p">[</span><span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">],</span> <span class="nx">K</span> <span class="nx">comparable</span><span class="p">,</span> <span class="nx">V</span> <span class="nx">any</span><span class="p">](</span><span class="nx">m</span> <span class="nx">M</span><span class="p">)</span> <span class="p">[]</span><span class="nx">V</span>
<span class="c1">// 判断相等
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">Equal</span><span class="p">[</span><span class="nx">M1</span><span class="p">,</span> <span class="nx">M2</span> <span class="nx">constraints</span><span class="p">.</span><span class="nx">Map</span><span class="p">[</span><span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">],</span> <span class="nx">K</span><span class="p">,</span> <span class="nx">V</span> <span class="nx">comparable</span><span class="p">](</span><span class="nx">m1</span> <span class="nx">M1</span><span class="p">,</span> <span class="nx">m2</span> <span class="nx">M2</span><span class="p">)</span> <span class="kt">bool</span>
<span class="kd">func</span> <span class="nx">EqualFunc</span><span class="p">[</span><span class="nx">M1</span> <span class="nx">constraints</span><span class="p">.</span><span class="nx">Map</span><span class="p">[</span><span class="nx">K</span><span class="p">,</span> <span class="nx">V1</span><span class="p">],</span> <span class="nx">M2</span> <span class="nx">constraints</span><span class="p">.</span><span class="nx">Map</span><span class="p">[</span><span class="nx">K</span><span class="p">,</span> <span class="nx">V2</span><span class="p">],</span> <span class="nx">K</span> <span class="nx">comparable</span><span class="p">,</span> <span class="nx">V1</span><span class="p">,</span> <span class="nx">V2</span> <span class="nx">any</span><span class="p">](</span><span class="nx">m1</span> <span class="nx">m1</span><span class="p">,</span> <span class="nx">m2</span> <span class="nx">M2</span><span class="p">,</span> <span class="nx">cmp</span> <span class="kd">func</span><span class="p">(</span><span class="nx">V1</span><span class="p">,</span> <span class="nx">V2</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">bool</span>
<span class="c1">// 清空
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">Clear</span><span class="p">[</span><span class="nx">M</span> <span class="nx">constraints</span><span class="p">.</span><span class="nx">Map</span><span class="p">[</span><span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">],</span> <span class="nx">K</span> <span class="nx">comparable</span><span class="p">,</span> <span class="nx">V</span> <span class="nx">any</span><span class="p">](</span><span class="nx">m</span> <span class="nx">M</span><span class="p">)</span>
<span class="c1">// 复制
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">Clone</span><span class="p">[</span><span class="nx">M</span> <span class="nx">constraints</span><span class="p">.</span><span class="nx">Map</span><span class="p">[</span><span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">],</span> <span class="nx">K</span> <span class="nx">comparable</span><span class="p">,</span> <span class="nx">V</span> <span class="nx">any</span><span class="p">](</span><span class="nx">m</span> <span class="nx">M</span><span class="p">)</span> <span class="nx">M</span>
<span class="c1">// 把一个 map 的所有 k-v 复制到另一个
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">Copy</span><span class="p">[</span><span class="nx">M</span> <span class="nx">constraints</span><span class="p">.</span><span class="nx">Map</span><span class="p">[</span><span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">],</span> <span class="nx">K</span> <span class="nx">comparable</span><span class="p">,</span> <span class="nx">V</span> <span class="nx">any</span><span class="p">](</span><span class="nx">dst</span><span class="p">,</span> <span class="nx">src</span> <span class="nx">M</span><span class="p">)</span>
<span class="c1">// 删除指定元素
</span><span class="c1"></span><span class="kd">func</span> <span class="nx">DeleteFunc</span><span class="p">[</span><span class="nx">M</span> <span class="nx">constraints</span><span class="p">.</span><span class="nx">Map</span><span class="p">[</span><span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">],</span> <span class="nx">K</span> <span class="nx">comparable</span><span class="p">,</span> <span class="nx">V</span> <span class="nx">any</span><span class="p">](</span><span class="nx">m</span> <span class="nx">M</span><span class="p">,</span> <span class="nx">del</span> <span class="kd">func</span><span class="p">(</span><span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>This is more commonly used is <code>Keys/Values</code>, other functions need to be further verified through practice.</p>
<p>These are the parts that introduce new standard libraries and do not create compatibility problems with existing code. There is still a part that needs to be adapted from the existing standard library, which may cause compatibility problems.</p>
<h3 id="retrofitting-old-standard-libraries">Retrofitting old standard libraries</h3>
<p>This part can be mainly found in the discussion <a href="https://github.com/golang/go/discussions/48287">how to update APIs for generics</a> started by Russ Cox. The core of the problem is that many packages already take up good names and can&rsquo;t be directly retrofitted to support generic versions. For example.</p>
<ul>
<li>The type of sync.Pool should be defined as sync.Pool[T].</li>
<li>The type of sync.Map should be defined as sync.Map[K, V].</li>
<li>The type of atomic.Value should be defined as atomic.Value[T].</li>
<li>List should be defined as list.List[T].</li>
<li>Abs should be defined as math.Abs[T].</li>
<li>math.Min should be defined as math.Min[T].</li>
<li>math.Max should be defined as math.Max[T].</li>
</ul>
<p>Unfortunately, these types or functions are strongly associated with <code>interface{}</code>.</p>
<p><code>sync.Pool</code> as an example. If you force it to <code>sync.Pool[T]</code>, then everything that declares a Pool needs to be changed to <code>var p sync.Pool[interface{}]</code>.</p>
<p>For math.Max, if you change it to a generic type directly, you will have problems with type derivation again. For example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">i</span> <span class="kt">int</span>
<span class="nf">Min</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="c1">// 对应 Min[int]
</span><span class="c1"></span><span class="nf">Min</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="c1">// 对应 Min[float64]
</span></code></pre></td></tr></table>
</div>
</div><p>So Russ proposes to add a version with an Of suffix to the relevant type or function! For example, <code>sync.Pool</code> corresponds to <code>sync.PoolOf[T any]</code>. The sync package proposal is in <a href="https://github.com/golang/go/issues/47657">here</a>. Min.MinOf feels a bit odd to be written as math.</p>
<p>Of course, there are proposals to add v2 suffixes or prefixes to the standard library, and even arguments over whether to use v2/math or math/v2.</p>
<p>Personally, I prefer DeedleFake&rsquo;s <a href="https://github.com/golang/go/discussions/48287#discussioncomment-1317563">solution</a>, which doesn&rsquo;t change the name, but decides whether to use generic code based on the go version of go.mod. If someone wants to upgrade to go 1.18, they can just run go fix once and upgrade all the code to the generic version. I think this is the most clean solution.</p>
<h2 id="summary">Summary</h2>
<p>Enough content, back to Rob&rsquo;s proposal. After the previous analysis, it&rsquo;s easy to conclude that we lack practical experience with generics, and rushing to modify the standard library now will only create more maintenance burden for the community. So Rob&rsquo;s proposal is slightly conservative, but very scientific. I&rsquo;ll end this article with a quote from Rob: I strongly believe it is best to take it slow for now. use, learn, study, and move cautiously.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/golang/">golang</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-01/vim-copy-over-ssh/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Copy text using vim across ssh</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-01/vim-macro-quick-start/">
            <span class="next-text nav-default">Vim Macro Quick Start</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
