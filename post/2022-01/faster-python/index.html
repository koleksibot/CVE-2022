<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>CPython performance to be improved by 5x? faster-python project PEP 659 source code interpretation - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Earlier in 2021, Python author Guido van Rossum was rehired by Microsoft to continue work on CPython, and they have proposed a faster-cpython project to improve the performance of CPython by a factor of 5 over 4 years. The whole project is open on GitHub&amp;rsquo;s faster-cpython group, and some of the ideas have been implemented and verified through Activity.
In this article, we will read and analyse the source code of one of the project&amp;rsquo;s key proposals, PEP 659, and learn how to optimise virtual machine performance at the bytecode level." /><meta name="keywords" content="ffmpythonpeg" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-01/faster-python/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="CPython performance to be improved by 5x? faster-python project PEP 659 source code interpretation" />
<meta property="og:description" content="Earlier in 2021, Python author Guido van Rossum was rehired by Microsoft to continue work on CPython, and they have proposed a faster-cpython project to improve the performance of CPython by a factor of 5 over 4 years. The whole project is open on GitHub&rsquo;s faster-cpython group, and some of the ideas have been implemented and verified through Activity.
In this article, we will read and analyse the source code of one of the project&rsquo;s key proposals, PEP 659, and learn how to optimise virtual machine performance at the bytecode level." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-01/faster-python/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-01-18T14:36:53+08:00" />
<meta property="article:modified_time" content="2022-01-18T14:36:53+08:00" />

<meta itemprop="name" content="CPython performance to be improved by 5x? faster-python project PEP 659 source code interpretation">
<meta itemprop="description" content="Earlier in 2021, Python author Guido van Rossum was rehired by Microsoft to continue work on CPython, and they have proposed a faster-cpython project to improve the performance of CPython by a factor of 5 over 4 years. The whole project is open on GitHub&rsquo;s faster-cpython group, and some of the ideas have been implemented and verified through Activity.
In this article, we will read and analyse the source code of one of the project&rsquo;s key proposals, PEP 659, and learn how to optimise virtual machine performance at the bytecode level."><meta itemprop="datePublished" content="2022-01-18T14:36:53+08:00" />
<meta itemprop="dateModified" content="2022-01-18T14:36:53+08:00" />
<meta itemprop="wordCount" content="3092">
<meta itemprop="keywords" content="python," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="CPython performance to be improved by 5x? faster-python project PEP 659 source code interpretation"/>
<meta name="twitter:description" content="Earlier in 2021, Python author Guido van Rossum was rehired by Microsoft to continue work on CPython, and they have proposed a faster-cpython project to improve the performance of CPython by a factor of 5 over 4 years. The whole project is open on GitHub&rsquo;s faster-cpython group, and some of the ideas have been implemented and verified through Activity.
In this article, we will read and analyse the source code of one of the project&rsquo;s key proposals, PEP 659, and learn how to optimise virtual machine performance at the bytecode level."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">CPython performance to be improved by 5x? faster-python project PEP 659 source code interpretation</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-01-18 14:36:53 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 3092 words </span>
          <span class="more-meta"> 15 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#proposal-explained">Proposal Explained</a></li>
        <li><a href="#source-code-analysis">Source code analysis</a>
          <ul>
            <li><a href="#warmup">Warmup</a></li>
            <li><a href="#adaptive">Adaptive</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>Earlier in 2021, Python author Guido van Rossum was rehired by Microsoft to continue work on CPython, and they have proposed a faster-cpython project to improve the performance of CPython by a factor of 5 over 4 years. The whole project is open on GitHub&rsquo;s faster-cpython group, and some of the ideas have been implemented and verified through Activity.</p>
<p>In this article, we will read and analyse the source code of one of the project&rsquo;s key proposals, PEP 659, and learn how to optimise virtual machine performance at the bytecode level. We hope this will be of interest to you.</p>
<h2 id="proposal-explained">Proposal Explained</h2>
<p>PEP 659 was created in April 2021 and is called Specializing Adaptive Interpreter. There are two keywords here: Specializing and Adaptive, which can be simply understood as Adaptive for <strong>specific location</strong> code, <strong>replacing</strong> it with special specializing) to improve the speed of execution of location-specific operations. For example, if we observe that the code for a particular dict does not change during multiple executions, we can optimise this code by caching the index of the dict entry directly, thus avoiding the hashtable lookup process in the next query and improving performance. The process of replacing the code corresponds to Specializing.</p>
<p>The above example is not exact, but is just to help you get a first impression of the Specializing Adaptive Interpreter, and we will now extract key statements from the proposal to explain them.</p>
<p>Firstly, it should be clear that PEP 659 is not a JIT solution, as it is intended to allow users who cannot directly use a JIT compiler such as PyPy to enjoy the benefits of faster CPython. For example, on iOS, user processes are limited by the fact that the executable code pages dynamically created by codesign are rejected on a page break because they do not contain a legal signature, and therefore cannot directly use the Python virtual machine with the JIT Compiler.</p>
<p>Some of you may be concerned about the scope and benefits of optimizing at the VM level without using JIT. In PEP 659, the authors also provide some explanation.</p>
<blockquote>
<p>Specialization is typically done in the context of a JIT compiler, but research shows specialization in an interpreter can boost performance significantly, even outperforming a naive compiler.</p>
</blockquote>
<p>That is, the study found that Specialization optimisation at the Interpreter level alone can yield significant performance gains that can outperform even some rudimentary JIT solutions. The authors also cite a previous paper of their own, which can be found in the references section of the PEP 659 proposal if you are interested.</p>
<p>We need to exhaust all possible optimisation cases and prepare the code in advance, replacing bytecode when matching optimisation conditions are observed, and being able to gracefully fall back to the pre-optimisation code to ensure correctness when the optimisation conditions are not met.</p>
<p>In order to be able to exhaust optimisation cases and switch code, it is necessary to choose the appropriate granularity of optimisation, the original proposal reads</p>
<blockquote>
<p>By using adaptive and speculative specialization at the granularity of individual virtual machine instructions, we get a faster interpreter that also generates profiling information for more sophisticated optimizations in the future.</p>
</blockquote>
<p>For example, in CPython, both globals and builtins are retrieved by the LOAD_GLOBAL instruction, which first looks in globals, and then fallsback to There are only 2 possible cases here, so we can add two new instructions to the virtual machine, LOAD_GLOBAL_MODULE and LOAD_GLOBAL_BUILTIN, and when we find that LOAD_GLOBAL in a bytecode segment keeps looking for globals, we can optimise it to the former and vice versa We can also cache the entry index of the globals and builtins dict to avoid repeated accesses to the hashtable of the dict, and roll back to the LOAD_GLOBAL instruction when we find that the optimisation conditions are not met (e.g. the find fails, or the dict is modified) to ensure correctness.</p>
<p>The above process from LOAD_GLOBAL to LOAD_GLOBAL_MODULE / LOAD_GLOBAL_BUILTIN is in fact Specializing in the PEP header, and the process of choosing whether to replace the instruction with LOAD_GLOBAL_MODULE or LOAD_GLOBAL_BUILTIN is in fact Adaptive, which is the process of choosing whether to replace the instruction with LOAD_GLOBAL_MODULE or LOAD_GLOBAL_BUILTIN. The process of choosing whether to replace an instruction with LOAD_GLOBAL_MODULE or LOAD_GLOBAL_BUILTIN is in fact Adaptive, which is responsible for observing the execution of the instructions in a given code and selecting the correct optimisation instruction for it, the process of observation is also the process of execution of the VM code, so an additional Adaptive instruction LOAD_GLOBAL_ADAPATIVE is introduced here to perform the observation and replacement logic.</p>
<p>Although Specializing can speed up the process by reducing judgements and increasing caching, the process of moving from the original instruction to the Adaptive instruction and from the Adaptive observation to the Specializing instruction is also lossy and therefore needs to be optimised based on certain strategies rather than mindlessly trying to optimise all instructions in the code, as mentioned in the original article.</p>
<blockquote>
<p>Typical optimizations for virtual machines are expensive, so a long &ldquo;warm up&rdquo; time is required to gain confidence that the cost of optimization is justified.</p>
</blockquote>
<p>This is because we need to insert optimisation code into large loops of bytecode execution, even requiring additional processing logic in each loop, while much of the code may only be executed once and it would be a waste of time to optimise them. One of the main features of such code is that it is called frequently. We can add a counter to each PyCodeObject (the object in CPython that holds the bytecode and environment information) and only execute the optimisation logic if the number of executions exceeds a certain threshold, a process called warm up.</p>
<p>At the virtual machine level, when a bytecode object PyCodeObject is executed (which can simply be interpreted as the bytecode corresponding to a piece of Python code being executed) or when an absolute jump occurs, the co_warmup counter of the code object is added up and when the threshold is reached all optimizable instructions in the bytecode are replaced with Adaptive instructions for observation and When the optimisation condition of the Specializing instruction is broken, we do not roll back to the Adaptive instruction immediately, but allow a certain number of misses to prevent bumps between optimisation and de-optimisation, and similarly when the de-optimisation is rolled back to the We also suspend the observation and optimisation logic when the de-optimisation rolls back to the Adaptive instruction, allowing the instruction to run according to the original logic for a period of time, a process known as deferred, the state diagram of which is as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/18/aa34c1a2900f4bbdb7a46747926095f5.png" alt="sobyte"></p>
<p>By now we have a good understanding of how PEP 659 works, but there are still many details that need to be explored in order to implement this optimizer in a high-performance way, such as which instructions to optimize, how to gracefully replace instructions and revert, and how to design instruction caches. 3.11, so we&rsquo;ll combine this with the source code implementation of PEP 659 in Python.</p>
<h2 id="source-code-analysis">Source code analysis</h2>
<p>The infrastructure of PEP 659 and some of the optimization instructions are already present in the CPython 3.11 branch, so we&rsquo;ll use the LOAD_GLOBAL transformation as an example to analyze the process in detail. The judgement is also relatively straightforward, clear enough to explain the problem without making it difficult to read because of the obscurity of the instructions.</p>
<p>The whole optimisation process consists of several stages - Warmup, Adaptive, Specializing &amp; Deoptimize - and we will analyse and explain the functionality and core code of each stage.</p>
<h3 id="warmup">Warmup</h3>
<p>As mentioned above, warmup solves the problem of finding code that is really executed frequently and avoiding optimizing code that will never be executed again, so instead of counting the frequency of code execution, we just set a threshold and count the number of executions of a particular bytecode object PyCodeObject and consider the warmup complete when the threshold is reached. We have introduced a new field co_warmup for PyCodeObject</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* Bytecode object */</span>
<span class="k">struct</span> <span class="nc">PyCodeObject</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span>
    <span class="c1">// The hottest fields (in the eval loop) are grouped here at the top.
</span><span class="c1"></span>    <span class="n">PyObject</span> <span class="o">*</span><span class="n">co_consts</span><span class="p">;</span>        <span class="cm">/* list (constants used) */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">co_names</span><span class="p">;</span>         <span class="cm">/* list of strings (names used) */</span>
     <span class="c1">// ...
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">co_warmup</span><span class="p">;</span>              <span class="cm">/* Warmup counter for quickening */</span>
     <span class="c1">// ...
</span><span class="c1"></span>
   <span class="cm">/* Quickened instructions and cache, or NULL
</span><span class="cm">     This should be treated as opaque by all code except the specializer and
</span><span class="cm">     interpreter. */</span>
    <span class="k">union</span> <span class="nc">_cache_or_instruction</span> <span class="o">*</span><span class="n">co_quickened</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>When the PyCodeObject object is created, the initial value of co_warmup is set to QUICKENING_WARMUP_DELAY, which is a negative value. co_warmup is set to +1 whenever the PyCodeObject is executed or when an absolute jump occurs within the code, and when the threshold of 0 is reached, the optimization logic is entered.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#define QUICKENING_WARMUP_DELAY 8
</span><span class="cp"></span><span class="cm">/* We want to compare to zero for efficiency, so we offset values accordingly */</span>
<span class="cp">#define QUICKENING_INITIAL_WARMUP_VALUE (-QUICKENING_WARMUP_DELAY)
</span><span class="cp"></span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">init_code</span><span class="p">(</span><span class="n">PyCodeObject</span> <span class="o">*</span><span class="n">co</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">_PyCodeConstructor</span> <span class="o">*</span><span class="n">con</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...
</span><span class="c1"></span>    <span class="n">co</span><span class="o">-&gt;</span><span class="n">co_warmup</span> <span class="o">=</span> <span class="n">QUICKENING_INITIAL_WARMUP_VALUE</span><span class="p">;</span>
    <span class="n">co</span><span class="o">-&gt;</span><span class="n">co_quickened</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="adaptive">Adaptive</h3>
<p>When <code>co_warmup</code>has been accumulated to 0, it goes to the _Py_Quicken function to perform the optimisation logic, where a copy of the original bytecode co_code is officially stored in quickened because of the bytecode adjustments involved, and all subsequent changes occur in quickened.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* Bytecode object */</span>
<span class="k">struct</span> <span class="nc">PyCodeObject</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span>
    <span class="c1">// The hottest fields (in the eval loop) are grouped here at the top.
</span><span class="c1"></span>    <span class="n">PyObject</span> <span class="o">*</span><span class="n">co_consts</span><span class="p">;</span>        <span class="cm">/* list (constants used) */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">co_names</span><span class="p">;</span>         <span class="cm">/* list of strings (names used) */</span>
   <span class="n">_Py_CODEUNIT</span> <span class="o">*</span><span class="n">co_firstinstr</span><span class="p">;</span> <span class="cm">/* Pointer to first instruction, used for quickening. */</span>
    <span class="c1">// ...
</span><span class="c1"></span>    <span class="n">PyObject</span> <span class="o">*</span><span class="n">co_code</span><span class="p">;</span>          <span class="cm">/* instruction opcodes */</span>
  
   <span class="cm">/* Quickened instructions and cache, or NULL
</span><span class="cm">     This should be treated as opaque by all code except the specializer and
</span><span class="cm">     interpreter. */</span>
    <span class="k">union</span> <span class="nc">_cache_or_instruction</span> <span class="o">*</span><span class="n">co_quickened</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="kt">uint16_t</span> <span class="n">_Py_CODEUNIT</span><span class="p">;</span>

<span class="kt">int</span>
<span class="nf">_Py_Quicken</span><span class="p">(</span><span class="n">PyCodeObject</span> <span class="o">*</span><span class="n">code</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">code</span><span class="o">-&gt;</span><span class="n">co_quickened</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">Py_ssize_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">PyBytes_GET_SIZE</span><span class="p">(</span><span class="n">code</span><span class="o">-&gt;</span><span class="n">co_code</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">instr_count</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">size</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">_Py_CODEUNIT</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">instr_count</span> <span class="o">&gt;</span> <span class="n">MAX_SIZE_TO_QUICKEN</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">code</span><span class="o">-&gt;</span><span class="n">co_warmup</span> <span class="o">=</span> <span class="n">QUICKENING_WARMUP_COLDEST</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">entry_count</span> <span class="o">=</span> <span class="n">entries_needed</span><span class="p">(</span><span class="n">code</span><span class="o">-&gt;</span><span class="n">co_firstinstr</span><span class="p">,</span> <span class="n">instr_count</span><span class="p">);</span>
    <span class="n">SpecializedCacheOrInstruction</span> <span class="o">*</span><span class="n">quickened</span> <span class="o">=</span> <span class="n">allocate</span><span class="p">(</span><span class="n">entry_count</span><span class="p">,</span> <span class="n">instr_count</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">quickened</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">_Py_CODEUNIT</span> <span class="o">*</span><span class="n">new_instructions</span> <span class="o">=</span> <span class="n">first_instruction</span><span class="p">(</span><span class="n">quickened</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">new_instructions</span><span class="p">,</span> <span class="n">code</span><span class="o">-&gt;</span><span class="n">co_firstinstr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
    <span class="n">optimize</span><span class="p">(</span><span class="n">quickened</span><span class="p">,</span> <span class="n">instr_count</span><span class="p">);</span>
    <span class="n">code</span><span class="o">-&gt;</span><span class="n">co_quickened</span> <span class="o">=</span> <span class="n">quickened</span><span class="p">;</span>
    <span class="n">code</span><span class="o">-&gt;</span><span class="n">co_firstinstr</span> <span class="o">=</span> <span class="n">new_instructions</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>You may wonder why quickened contains extra space other than bytecode. In fact, it is difficult to optimise just by replacing instructions, we also need to cache as many objects as possible for instruction operations. In CPython, the dictionary is a hashtable, so its complexity is greater than O(1) in case of hash collisions. In order to optimise dictionaries that do not change frequently, we can cache the hashtable index of the key, which obviously corresponds one-to-one with the instruction, so the extra space in quickened is used to store additional information about the optimised instruction.</p>
<p>quickened is a bi-directional array, with cache on the left and bytecode on the right, and a cache entry at the leftmost end of the array to store the cache count, which allows us to quickly locate the bytecode array. The first_instruction we saw earlier was located from quickened to instr 0 by means of cache_count.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cm">/* We layout the quickened data as a bi-directional array:
</span><span class="cm"> * Instructions upwards, cache entries downwards.
</span><span class="cm"> * first_instr is aligned to a SpecializedCacheEntry.
</span><span class="cm"> * The nth instruction is located at first_instr[n]
</span><span class="cm"> * The nth cache is located at ((SpecializedCacheEntry *)first_instr)[-1-n]
</span><span class="cm"> * The first (index 0) cache entry is reserved for the count, to enable finding
</span><span class="cm"> * the first instruction from the base pointer.
</span><span class="cm"> * The cache_count argument must include space for the count.
</span><span class="cm"> * We use the SpecializedCacheOrInstruction union to refer to the data
</span><span class="cm"> * to avoid type punning.
</span><span class="cm">
</span><span class="cm"> Layout of quickened data, each line 8 bytes for M cache entries and N instructions:
</span><span class="cm">
</span><span class="cm"> &lt;cache_count&gt;                              &lt;---- co-&gt;co_quickened
</span><span class="cm"> &lt;cache M-1&gt;
</span><span class="cm"> &lt;cache M-2&gt;
</span><span class="cm"> ...
</span><span class="cm"> &lt;cache 0&gt;
</span><span class="cm"> &lt;instr 0&gt; &lt;instr 1&gt; &lt;instr 2&gt; &lt;instr 3&gt;    &lt;--- co-&gt;co_first_instr
</span><span class="cm"> &lt;instr 4&gt; &lt;instr 5&gt; &lt;instr 6&gt; &lt;instr 7&gt;
</span><span class="cm"> ...
</span><span class="cm"> &lt;instr N-1&gt;
</span><span class="cm">*/</span>
</code></pre></td></tr></table>
</div>
</div><p>Each optimized instruction requires a separate cache entry, and we need a means of O(1) indexing from the instruction to the cache. The official choice is to use offset + operand to build the secondary index, where offset is used to determine the block range of the index (it&rsquo;s a bit like a page table search, where offset is PAGE and operand is PAGEOFF), operand is used to fix offset, and operand overridden by the index is stored in the cache. The above design was originally described in PEP 659 as follows.</p>
<blockquote>
<p>For instructions that need specialization data, the operand in the quickened array will serve as a partial index, along with the offset of the instruction, to find the first specialization data entry for that instruction.</p>
</blockquote>
<p>For LOAD_GLOBAL, the main information to be cached is the version of the dict and the key index, in addition to some additional information required by the optimizer, as follows.</p>
<ol>
<li>the version of the dictionary key-value pair dk_version, since both globals and builtins are involved here, we need to cache two dk_versions, each of which is a uint32_t, so the total dk_version needs to be an 8B, i.e. a cache entry.</li>
<li>the index corresponding to the key, which is a uint16_t, can only use an additional cache entry here as we have already taken up one cache entry.</li>
<li>since the original operand is used for the partial index, we also need an additional uint8_t to store the original_oparg, which can be combined with the uint16_t in 2.</li>
<li>in the proposal reading section we mentioned that conversions between Adaptive, Specilization and Deoptimize need a counter buffer to avoid bumps and a counter is needed, officially a uint8_t is used here.</li>
</ol>
<p>Putting the above analysis together, LOAD_GLOBAL requires two cache entries, the first storing orignal_oparg + counter + index and the second storing the dk_version of globals and builtins.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="n">original_oparg</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">counter</span><span class="p">;</span>
    <span class="kt">uint16_t</span> <span class="n">index</span><span class="p">;</span>
<span class="p">}</span> <span class="n">_PyAdaptiveEntry</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">module_keys_version</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">builtin_keys_version</span><span class="p">;</span>
<span class="p">}</span> <span class="n">_PyLoadGlobalCache</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>When a LOAD_GLOBAL hits globals in the Adaptive logic, we optimize it to LOAD_GLOBAL_MODULE and cache the index and module_keys_version; when a LOAD_GLOBAL does not hit globals, we need to cache both module_keys_version and builtin_keys_version, because when the globals change, it may cause the next This is because a change in globals may result in the next LOAD_GLOBAL not hitting the builtins, where we optimise this to LOAD_GLOBAL_BUILTIN, a process of optimised selection and caching that is effectively Adaptive.</p>
<p>##s# Specializing &amp; Deoptimize</p>
<p>As mentioned above, after the Warmup and Adaptive processes, the bytecode object PyCodeObject has become Specialized, e.g. LOAD_GLOBAL is now all in the form of LOAD_GLOBAL_MODULE or LOAD_GLOBAL_BUILTIN. (Deoptimize is not considered here). In plain English, the instructions in the bytecode have been optimally adapted to the current environment, so let&rsquo;s see how the adapted code looks like.</p>
<p>In fact, after the above analysis, I believe that you have already guessed the adaptation code, so let us take the more complex LOAD_GLOBAL_BUILTIN as an example and analyse the source code.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">TARGET</span><span class="p">(</span><span class="n">LOAD_GLOBAL_BUILTIN</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="c1"></span>    <span class="n">PyDictObject</span> <span class="o">*</span><span class="n">mdict</span> <span class="o">=</span> <span class="p">(</span><span class="n">PyDictObject</span> <span class="o">*</span><span class="p">)</span><span class="n">GLOBALS</span><span class="p">();</span>
    <span class="n">PyDictObject</span> <span class="o">*</span><span class="n">bdict</span> <span class="o">=</span> <span class="p">(</span><span class="n">PyDictObject</span> <span class="o">*</span><span class="p">)</span><span class="n">BUILTINS</span><span class="p">();</span>
    <span class="n">SpecializedCacheEntry</span> <span class="o">*</span><span class="n">caches</span> <span class="o">=</span> <span class="n">GET_CACHE</span><span class="p">();</span>
    <span class="n">_PyAdaptiveEntry</span> <span class="o">*</span><span class="n">cache0</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">caches</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">adaptive</span><span class="p">;</span>
    <span class="n">_PyLoadGlobalCache</span> <span class="o">*</span><span class="n">cache1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">caches</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">load_global</span><span class="p">;</span>
    <span class="n">DEOPT_IF</span><span class="p">(</span><span class="n">mdict</span><span class="o">-&gt;</span><span class="n">ma_keys</span><span class="o">-&gt;</span><span class="n">dk_version</span> <span class="o">!=</span> <span class="n">cache1</span><span class="o">-&gt;</span><span class="n">module_keys_version</span><span class="p">,</span> <span class="n">LOAD_GLOBAL</span><span class="p">);</span>
    <span class="n">DEOPT_IF</span><span class="p">(</span><span class="n">bdict</span><span class="o">-&gt;</span><span class="n">ma_keys</span><span class="o">-&gt;</span><span class="n">dk_version</span> <span class="o">!=</span> <span class="n">cache1</span><span class="o">-&gt;</span><span class="n">builtin_keys_version</span><span class="p">,</span> <span class="n">LOAD_GLOBAL</span><span class="p">);</span>
    <span class="n">PyDictKeyEntry</span> <span class="o">*</span><span class="n">ep</span> <span class="o">=</span> <span class="n">DK_ENTRIES</span><span class="p">(</span><span class="n">bdict</span><span class="o">-&gt;</span><span class="n">ma_keys</span><span class="p">)</span> <span class="o">+</span> <span class="n">cache0</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="n">ep</span><span class="o">-&gt;</span><span class="n">me_value</span><span class="p">;</span>
    <span class="n">DEOPT_IF</span><span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">LOAD_GLOBAL</span><span class="p">);</span>
    <span class="n">STAT_INC</span><span class="p">(</span><span class="n">LOAD_GLOBAL</span><span class="p">,</span> <span class="n">hit</span><span class="p">);</span>
    <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
    <span class="n">PUSH</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
    <span class="n">DISPATCH</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Let&rsquo;s ignore DEOPT_IF for a moment and look at the main logic. First we take out the cache entries of the current command, the first entry records index, the second entry records the dk_version of globals and builtins. If the cache hits, we can simply fetch the key-value pair from hashtable[index] and return its value, which is much faster than checking the globals dict first and then the builtins dict.</p>
<p>But don&rsquo;t rejoice too soon, the reduction is actually not less than one, we know that only when globals cannot be found will we look for builtins, if globals changes then the cache is bound to fail, in addition our index cache is based on the premise that builtins dict cannot change, combined with the above two points we must first make sure that both dictionaries' dk_version version of both dictionaries before we can continue, which is actually one of the triggers for Deoptimize, which is exactly what DEOPT_IF does.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#define DEOPT_IF(cond, instname) if (cond) { goto instname ## _miss; }
</span><span class="cp">#define JUMP_TO_INSTRUCTION(op) goto PREDICT_ID(op)
</span><span class="cp">#define ADAPTIVE_CACHE_BACKOFF 64
</span><span class="cp"></span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">cache_backoff</span><span class="p">(</span><span class="n">_PyAdaptiveEntry</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">entry</span><span class="o">-&gt;</span><span class="n">counter</span> <span class="o">=</span> <span class="n">ADAPTIVE_CACHE_BACKOFF</span><span class="p">;</span>
<span class="p">}</span>

<span class="nl">LOAD_GLOBAL_miss</span><span class="p">:</span> 
<span class="p">{</span> 
    <span class="n">STAT_INC</span><span class="p">(</span><span class="n">LOAD_GLOBAL</span><span class="p">,</span> <span class="n">miss</span><span class="p">);</span> 
    <span class="n">_PyAdaptiveEntry</span> <span class="o">*</span><span class="n">cache</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">GET_CACHE</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">adaptive</span><span class="p">;</span> 
    <span class="n">cache</span><span class="o">-&gt;</span><span class="n">counter</span><span class="o">--</span><span class="p">;</span> 
    <span class="k">if</span> <span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">counter</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> 
        <span class="n">next_instr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">_Py_MAKECODEUNIT</span><span class="p">(</span><span class="n">LOAD_GLOBAL_ADAPTIVE</span><span class="p">,</span> <span class="n">_Py_OPARG</span><span class="p">(</span><span class="n">next_instr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]));</span> 
        <span class="n">STAT_INC</span><span class="p">(</span><span class="n">LOAD_GLOBAL</span><span class="p">,</span> <span class="n">deopt</span><span class="p">);</span> 
        <span class="n">cache_backoff</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span> 
    <span class="p">}</span> 
    <span class="n">oparg</span> <span class="o">=</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">original_oparg</span><span class="p">;</span> 
    <span class="n">STAT_DEC</span><span class="p">(</span><span class="n">LOAD_GLOBAL</span><span class="p">,</span> <span class="n">unquickened</span><span class="p">);</span> 
    <span class="n">JUMP_TO_INSTRUCTION</span><span class="p">(</span><span class="n">LOAD_GLOBAL</span><span class="p">);</span> 
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>What DEOPT_IF does is jump to the cache miss branch of the instruction, for LOAD_GLOBAL it is LOAD_GLOBAL_miss, the miss branch does something very fixed, the first thing that is clear is that it will fallback to the regular LOAD_GLOBAL branch (JUMP_TO_INSTRUCTION at the bottom), but it will never roll back the instruction to LOAD_GLOBAL, only between Adaptive and Specialized instructions. INSTRUCTION), but it will never roll back instructions to LOAD_GLOBAL, only between Adaptive and Specialized instructions. To avoid cache bumps, the code above will degrade to the Adaptive instruction only when counter decrements to 0, and will always try to access the cache first until then.</p>
<p>This concludes our analysis of the whole optimisation and de-optimisation process, which is complex, but has a clear set of rules that make it easier to adapt other instructions once the Cache and Adaptive infrastructures have been built. One of the difficulties in accelerating instructions in this way is how to design the cache to reduce branching, as the presence of DEOPT_IF makes it difficult to directly reduce the preceding conditional judgements, but only to translate them into a more efficient form.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/python/">python</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-01/firefox-relays-blocklist/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Firefox Relay blacklisted by GitHub&#39;s &#39;Temporary Mailbox&#39; project, users protest</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-01/python-asyncio/">
            <span class="next-text nav-default">Understanding python asynchronous programming and simple implementation of asyncio</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
