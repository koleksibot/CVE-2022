<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Implementation of the time wheel in the Golang - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Recently I had a requirement at work, which simply means that millions of timer tasks will be created in a short period of time, and the corresponding amounts will be added up when they are created to prevent overselling, and the data will need to be checked again after half an hour, and if the data does not match, the added amount will need to be subtracted back. This is" /><meta name="keywords" content="golang, Timingwheel" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-01/go-timingwheel/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Implementation of the time wheel in the Golang" />
<meta property="og:description" content="Recently I had a requirement at work, which simply means that millions of timer tasks will be created in a short period of time, and the corresponding amounts will be added up when they are created to prevent overselling, and the data will need to be checked again after half an hour, and if the data does not match, the added amount will need to be subtracted back. This is" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-01/go-timingwheel/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-01-24T15:10:08+08:00" />
<meta property="article:modified_time" content="2022-01-24T15:10:08+08:00" />

<meta itemprop="name" content="Implementation of the time wheel in the Golang">
<meta itemprop="description" content="Recently I had a requirement at work, which simply means that millions of timer tasks will be created in a short period of time, and the corresponding amounts will be added up when they are created to prevent overselling, and the data will need to be checked again after half an hour, and if the data does not match, the added amount will need to be subtracted back. This is"><meta itemprop="datePublished" content="2022-01-24T15:10:08+08:00" />
<meta itemprop="dateModified" content="2022-01-24T15:10:08+08:00" />
<meta itemprop="wordCount" content="3226">
<meta itemprop="keywords" content="golang," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Implementation of the time wheel in the Golang"/>
<meta name="twitter:description" content="Recently I had a requirement at work, which simply means that millions of timer tasks will be created in a short period of time, and the corresponding amounts will be added up when they are created to prevent overselling, and the data will need to be checked again after half an hour, and if the data does not match, the added amount will need to be subtracted back. This is"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Implementation of the time wheel in the Golang</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-01-24 15:10:08 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 3226 words </span>
          <span class="more-meta"> 7 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#introduction">Introduction</a>
          <ul>
            <li><a href="#simple-time-wheel">Simple Time Wheel</a></li>
            <li><a href="#tiered-time-wheel">Tiered time wheel</a></li>
          </ul>
        </li>
        <li><a href="#code-implementation">Code Implementation</a>
          <ul>
            <li><a href="#structs">Structs</a></li>
            <li><a href="#initializing-the-time-wheel">Initializing the time wheel</a></li>
            <li><a href="#starting-the-time-wheel">Starting the time wheel</a></li>
            <li><a href="#add-task">add task</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>Recently I had a requirement at work, which simply means that millions of timer tasks will be created in a short period of time, and the corresponding amounts will be added up when they are created to prevent overselling, and the data will need to be checked again after half an hour, and if the data does not match, the added amount will need to be subtracted back.</p>
<p>This is a low performance task if done with Go&rsquo;s built-in Timer, which uses a minimal heap and has a time complexity of O(log n) for both creation and deletion. The performance is much better if you use the time wheel, which is O(1).</p>
<p>The use of the Timer wheel is actually very widespread, with components such as Netty, Akka, Quartz, ZooKeeper, Kafka and many others.</p>
<h2 id="introduction">Introduction</h2>
<h3 id="simple-time-wheel">Simple Time Wheel</h3>
<p>Storing tasks in the time wheel is a torus queue, the underlying implementation is an array, each element of which can hold a list of timed tasks. The list of timed tasks is a ring-shaped bi-directional chain table, each item in the chain table represents a timed task item, which encapsulates the real timed task.</p>
<p>The time wheel consists of a number of time frames, each representing the basic time span (tickMs) of the current time wheel. The number of time frames in the wheel is fixed and can be expressed in terms of wheelSize, so the overall time span (interval) of the wheel can be calculated using the formula tickMs x wheelSize.</p>
<p>The wheel also has a dial pointer (currentTime), which indicates the current time of the wheel. currentTime is an integer multiple of tickMs. currentTime points to the time frame that is due, indicating all the tasks in the chain table corresponding to the time frame that needs to be processed.</p>
<p>The following diagram shows a time wheel with tickMs of 1s and wheelSize equal to 10, each cell contains a chain of timed tasks, and the chain contains the real task items.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/24/4f15473bd517467fae314491a6a89b7e.png" alt="sobyte"></p>
<p>Initially the dial pointer currentTime points to time frame 0. If the tickMs of the time wheel is 1ms and the wheelSize is equal to 10, then the interval is equal to 10s. The following diagram shows that a task timed at 2s is inserted and stored in the task chain with time frame 2, marked in red. As time passes, the pointer currentTime advances and if 2s has elapsed, then currentTime will point to time frame 2 and the task chain for this time frame will be retrieved for processing.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/24/1e45e6427a0b40fbadd09f99f61fbd6f.png" alt="sobyte"></p>
<p>If the current pointer currentTime points to 2, then if a 9s task is inserted, the new task will take the original time grid chain and will be stored in time grid 1.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/24/154294f438894d42baac7dc140a34691.png" alt="sobyte"></p>
<p>The time wheels described here are simple time wheels, with one layer and an overall time range between currentTime and currentTime+interval. If you now have a 15s timed task you need to reopen a time wheel and set a time wheel with a time span of at least 15s to be sufficient. But there is no bottom line to this expansion, if a 10,000 second time wheel is needed, then an array of this size is needed to store it, which not only takes up a lot of memory space, but also makes it less efficient to traverse such a large array.</p>
<p>This is why the concept of a hierarchical time wheel was introduced.</p>
<h3 id="tiered-time-wheel">Tiered time wheel</h3>
<p>The diagram shows a two-layer time wheel, the second layer also consists of 10 time frames, each spanning 10s. the tickMs of the second layer time wheel will be the interval of the first layer time wheel, i.e. 10s. the wheelSize of each layer time wheel is fixed at 10, so the overall time span interval of the second layer time wheel is 100s.</p>
<p>The diagram shows the expiry time range for each time frame, and we can clearly see that the expiry time range for the 0th time frame of the second time frame is [0,9]. That is, one time cell of the second time wheel can represent all (10) time cells of the first time wheel.</p>
<p>If a 15s task is added to this time wheel, then when the first time wheel cannot accommodate it, it enters the second time wheel and is inserted into the time frame with an expiry time of [10, 19].</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/24/80a751ba79ba4a47845bdeeed8d2cca6.png" alt="sobyte"></p>
<p>As time passes, when there are 5s left in the original 15s task, there is a time wheel demotion operation here, at which point the overall time span of the first level time wheel is sufficient and this task is added to the time frame with an expiry time of 5 in the first level time wheel, after which another 5s are experienced before this task actually expires and the corresponding expiry operation is finally executed.</p>
<h2 id="code-implementation">Code Implementation</h2>
<p>As our Go language version of the TimingWheel code is modelled on Kafka, there are a few minor details in the implementation of the TimingWheel.</p>
<ul>
<li>Each chain in the time grid of the TimingWheel will have a root node for simplifying the boundary conditions. It is an additional chain table node which acts as the first node and which does not store anything in its value field, but is only introduced for the convenience of the operation.</li>
<li>The start time (startMs) of all higher-level time wheels except the first one is set to the currentTime of the first wheel before it when this layer was created. currentTime for each layer must be an integer multiple of tickMs, and if it is not satisfied then currentTime is trimmed to an integer multiple of tickMs. The trimming method is: currentTime = startMs - (startMs % tickMs).</li>
<li>Timers in Kafka need only hold a reference to the first level of the TimingWheel and do not hold other higher level TimingWheels directly, but each level of the TimingWheel will have a reference (overflowWheel) to a higher level of the application.</li>
<li>The timer in Kafka uses a DelayQueue to help advance the time wheel. Each chain in the time grid used is added to the DelayQueue during operation. The DelayQueue is sorted by the expiration time corresponding to the time wheel, with the task with the shortest expiration being placed at the head of the DelayQueue queue, and the tasks that expire in the DelayQueue are fetched via a separate thread.</li>
</ul>
<h3 id="structs">Structs</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">TimingWheel</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// 时间跨度,单位是毫秒
</span><span class="c1"></span>    <span class="nx">tick</span>      <span class="kt">int64</span> <span class="c1">// in milliseconds
</span><span class="c1"></span>    <span class="c1">// 时间轮个数
</span><span class="c1"></span>    <span class="nx">wheelSize</span> <span class="kt">int64</span>
    <span class="c1">// 总跨度
</span><span class="c1"></span>    <span class="nx">interval</span>    <span class="kt">int64</span> <span class="c1">// in milliseconds
</span><span class="c1"></span>    <span class="c1">// 当前指针指向时间
</span><span class="c1"></span>    <span class="nx">currentTime</span> <span class="kt">int64</span> <span class="c1">// in milliseconds
</span><span class="c1"></span>    <span class="c1">// 时间格列表
</span><span class="c1"></span>    <span class="nx">buckets</span>     <span class="p">[]</span><span class="o">*</span><span class="nx">bucket</span>
    <span class="c1">// 延迟队列
</span><span class="c1"></span>    <span class="nx">queue</span>       <span class="o">*</span><span class="nx">delayqueue</span><span class="p">.</span><span class="nx">DelayQueue</span> 
    <span class="c1">// 上级的时间轮引用
</span><span class="c1"></span>    <span class="nx">overflowWheel</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// type: *TimingWheel
</span><span class="c1"></span>
    <span class="nx">exitC</span>     <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>
    <span class="nx">waitGroup</span> <span class="nx">waitGroupWrapper</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>tick, wheelSize, interval, currentTime are all relatively well understood, the buckets field represents a list of time frames, queue is a delayed queue through which all tasks are triggered, and overflowWheel is a reference to the upper level time wheel.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">bucket</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// 任务的过期时间
</span><span class="c1"></span>    <span class="nx">expiration</span> <span class="kt">int64</span>

    <span class="nx">mu</span>     <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
    <span class="c1">// 相同过期时间的任务队列
</span><span class="c1"></span>    <span class="nx">timers</span> <span class="o">*</span><span class="nx">list</span><span class="p">.</span><span class="nx">List</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The bucket actually encapsulates the task queue inside the time frame, which puts in tasks with the same expiry time, and the queue timers will be taken out for processing after expiry. An interesting point here is that since there will be multiple threads accessing the bucket concurrently, the atomic class is needed to get the int64 bit value, and 64 bit alignment is needed to ensure consistency in reading 64 bit data on 32 bit systems.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Timer</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="c1">// 到期时间
</span><span class="c1"></span>    <span class="nx">expiration</span> <span class="kt">int64</span> <span class="c1">// in milliseconds
</span><span class="c1"></span>  <span class="c1">// 要被执行的具体任务
</span><span class="c1"></span>    <span class="nx">task</span>       <span class="kd">func</span><span class="p">()</span>
    <span class="c1">// Timer所在bucket的指针
</span><span class="c1"></span>    <span class="nx">b</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// type: *bucket
</span><span class="c1"></span>    <span class="c1">// bucket列表中对应的元素
</span><span class="c1"></span>    <span class="nx">element</span> <span class="o">*</span><span class="nx">list</span><span class="p">.</span><span class="nx">Element</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Timer is the smallest execution unit of the time wheel and is a wrapper around a timed task that will call task to execute the task when it expires.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/24/89ae3f56cdbc4faf891d70d8aa3cd3b4.png" alt="sobyte"></p>
<h3 id="initializing-the-time-wheel">Initializing the time wheel</h3>
<p>For example, now initialise a time wheel with a tick of 1s and a wheelSize of 10.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">tw</span> <span class="o">:=</span> <span class="nx">timingwheel</span><span class="p">.</span><span class="nf">NewTimingWheel</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
    <span class="nx">tw</span><span class="p">.</span><span class="nf">Start</span><span class="p">()</span> 
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">NewTimingWheel</span><span class="p">(</span><span class="nx">tick</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">,</span> <span class="nx">wheelSize</span> <span class="kt">int64</span><span class="p">)</span> <span class="o">*</span><span class="nx">TimingWheel</span> <span class="p">{</span>
  <span class="c1">// 将传入的tick转化成毫秒
</span><span class="c1"></span>    <span class="nx">tickMs</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">tick</span> <span class="o">/</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
  <span class="c1">// 如果小于零，那么panic
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">tickMs</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;tick must be greater than or equal to 1ms&#34;</span><span class="p">))</span>
    <span class="p">}</span>
    <span class="c1">// 设置开始时间
</span><span class="c1"></span>    <span class="nx">startMs</span> <span class="o">:=</span> <span class="nf">timeToMs</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">UTC</span><span class="p">())</span>
    <span class="c1">// 初始化TimingWheel
</span><span class="c1"></span>    <span class="k">return</span> <span class="nf">newTimingWheel</span><span class="p">(</span>
        <span class="nx">tickMs</span><span class="p">,</span>
        <span class="nx">wheelSize</span><span class="p">,</span>
        <span class="nx">startMs</span><span class="p">,</span>
        <span class="nx">delayqueue</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nx">wheelSize</span><span class="p">)),</span>
    <span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">newTimingWheel</span><span class="p">(</span><span class="nx">tickMs</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">wheelSize</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">startMs</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">queue</span> <span class="o">*</span><span class="nx">delayqueue</span><span class="p">.</span><span class="nx">DelayQueue</span><span class="p">)</span> <span class="o">*</span><span class="nx">TimingWheel</span> <span class="p">{</span>
  <span class="c1">// 初始化buckets的大小
</span><span class="c1"></span>    <span class="nx">buckets</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="nx">bucket</span><span class="p">,</span> <span class="nx">wheelSize</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">buckets</span> <span class="p">{</span>
        <span class="nx">buckets</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nf">newBucket</span><span class="p">()</span>
    <span class="p">}</span>
  <span class="c1">// 实例化TimingWheel
</span><span class="c1"></span>    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">TimingWheel</span><span class="p">{</span>
        <span class="nx">tick</span><span class="p">:</span>        <span class="nx">tickMs</span><span class="p">,</span>
        <span class="nx">wheelSize</span><span class="p">:</span>   <span class="nx">wheelSize</span><span class="p">,</span>
    <span class="c1">// currentTime必须是tickMs的倍数，所以这里使用truncate进行修剪
</span><span class="c1"></span>        <span class="nx">currentTime</span><span class="p">:</span> <span class="nf">truncate</span><span class="p">(</span><span class="nx">startMs</span><span class="p">,</span> <span class="nx">tickMs</span><span class="p">),</span>
        <span class="nx">interval</span><span class="p">:</span>    <span class="nx">tickMs</span> <span class="o">*</span> <span class="nx">wheelSize</span><span class="p">,</span>
        <span class="nx">buckets</span><span class="p">:</span>     <span class="nx">buckets</span><span class="p">,</span>
        <span class="nx">queue</span><span class="p">:</span>       <span class="nx">queue</span><span class="p">,</span>
        <span class="nx">exitC</span><span class="p">:</span>       <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}),</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The initialisation is very simple, you can just look at the code comments above.</p>
<h3 id="starting-the-time-wheel">Starting the time wheel</h3>
<p>Here we look at the start method.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">tw</span> <span class="o">*</span><span class="nx">TimingWheel</span><span class="p">)</span> <span class="nf">Start</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Poll会执行一个无限循环，将到期的元素放入到queue的C管道中
</span><span class="c1"></span>    <span class="nx">tw</span><span class="p">.</span><span class="nx">waitGroup</span><span class="p">.</span><span class="nf">Wrap</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">tw</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nf">Poll</span><span class="p">(</span><span class="nx">tw</span><span class="p">.</span><span class="nx">exitC</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">int64</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">timeToMs</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">UTC</span><span class="p">())</span>
        <span class="p">})</span>
    <span class="p">})</span>
    <span class="c1">// 开启无限循环获取queue中C的数据
</span><span class="c1"></span>    <span class="nx">tw</span><span class="p">.</span><span class="nx">waitGroup</span><span class="p">.</span><span class="nf">Wrap</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">{</span>
            <span class="k">select</span> <span class="p">{</span>
            <span class="c1">// 从队列里面出来的数据都是到期的bucket
</span><span class="c1"></span>            <span class="k">case</span> <span class="nx">elem</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">tw</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nx">C</span><span class="p">:</span>
                <span class="nx">b</span> <span class="o">:=</span> <span class="nx">elem</span><span class="p">.(</span><span class="o">*</span><span class="nx">bucket</span><span class="p">)</span>
                <span class="c1">// 时间轮会将当前时间 currentTime 往前移动到 bucket的到期时间
</span><span class="c1"></span>                <span class="nx">tw</span><span class="p">.</span><span class="nf">advanceClock</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nf">Expiration</span><span class="p">())</span>
                <span class="c1">// 取出bucket队列的数据，并调用addOrRun方法执行
</span><span class="c1"></span>                <span class="nx">b</span><span class="p">.</span><span class="nf">Flush</span><span class="p">(</span><span class="nx">tw</span><span class="p">.</span><span class="nx">addOrRun</span><span class="p">)</span>
            <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">tw</span><span class="p">.</span><span class="nx">exitC</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">})</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>This method will start a goroutines to execute the incoming function asynchronously, you can see the source code at the link above.</p>
<p>The first goroutines is used to call the Poll method of the queue of the delayed queue, which will keep cycling through the data in the queue and put the expired data into the C pipe of the queue; the second goroutines will infinitely cycle through the data of C in the queue, and if there is data in C, it means it has expired. If there is data in C that indicates it has expired, then the advanceClock method will be called first to move the current time currentTime forward to the expiry time of the bucket, then the Flush method will be called to take out the queue in the bucket and the addOrRun method will be called to execute it.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">tw</span> <span class="o">*</span><span class="nx">TimingWheel</span><span class="p">)</span> <span class="nf">advanceClock</span><span class="p">(</span><span class="nx">expiration</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">currentTime</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tw</span><span class="p">.</span><span class="nx">currentTime</span><span class="p">)</span>
    <span class="c1">// 过期时间大于等于（当前时间+tick）
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">expiration</span> <span class="o">&gt;=</span> <span class="nx">currentTime</span><span class="o">+</span><span class="nx">tw</span><span class="p">.</span><span class="nx">tick</span> <span class="p">{</span>
        <span class="c1">// 将currentTime设置为expiration，从而推进currentTime
</span><span class="c1"></span>        <span class="nx">currentTime</span> <span class="p">=</span> <span class="nf">truncate</span><span class="p">(</span><span class="nx">expiration</span><span class="p">,</span> <span class="nx">tw</span><span class="p">.</span><span class="nx">tick</span><span class="p">)</span>
        <span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tw</span><span class="p">.</span><span class="nx">currentTime</span><span class="p">,</span> <span class="nx">currentTime</span><span class="p">)</span>

        <span class="c1">// Try to advance the clock of the overflow wheel if present
</span><span class="c1"></span>        <span class="c1">// 如果有上层时间轮，那么递归调用上层时间轮的引用
</span><span class="c1"></span>        <span class="nx">overflowWheel</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tw</span><span class="p">.</span><span class="nx">overflowWheel</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">overflowWheel</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="p">(</span><span class="o">*</span><span class="nx">TimingWheel</span><span class="p">)(</span><span class="nx">overflowWheel</span><span class="p">).</span><span class="nf">advanceClock</span><span class="p">(</span><span class="nx">currentTime</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The advanceClock method advances the time wheel by setting the currentTime from the due time.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">bucket</span><span class="p">)</span> <span class="nf">Flush</span><span class="p">(</span><span class="nx">reinsert</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">Timer</span><span class="p">))</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">ts</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Timer</span>

    <span class="nx">b</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
    <span class="c1">// 循环获取bucket队列节点
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">e</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">timers</span><span class="p">.</span><span class="nf">Front</span><span class="p">();</span> <span class="nx">e</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">;</span> <span class="p">{</span>
        <span class="nx">next</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span>

        <span class="nx">t</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Value</span><span class="p">.(</span><span class="o">*</span><span class="nx">Timer</span><span class="p">)</span>
        <span class="c1">// 将头节点移除bucket队列
</span><span class="c1"></span>        <span class="nx">b</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
        <span class="nx">ts</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">ts</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>

        <span class="nx">e</span> <span class="p">=</span> <span class="nx">next</span>
    <span class="p">}</span>
    <span class="nx">b</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

    <span class="nx">b</span><span class="p">.</span><span class="nf">SetExpiration</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// TODO: Improve the coordination with b.Add()
</span><span class="c1"></span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">t</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ts</span> <span class="p">{</span>
        <span class="nf">reinsert</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The Flush method iterates through the list of timers in the bucket and inserts it into the ts array, then calls the reinsert method, in this case the addOrRun method.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">tw</span> <span class="o">*</span><span class="nx">TimingWheel</span><span class="p">)</span> <span class="nf">addOrRun</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Timer</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 如果已经过期，那么直接执行
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">!</span><span class="nx">tw</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="p">{</span> 
        <span class="c1">// 异步执行定时任务
</span><span class="c1"></span>        <span class="k">go</span> <span class="nx">t</span><span class="p">.</span><span class="nf">task</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>addOrRun will call the add method to check if the incoming timer has expired, and if so, call the task method asynchronously to execute it directly. add method will be analysed below.</p>
<p>The entire start execution flow is shown in the diagram.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/24/27152ba811014b2189234a944c65d43a.png" alt="sobyte"></p>
<ol>
<li>the start method starts a goroutines call back to poll to process the data due in the DelayQueue and put the data into pipe C.</li>
<li>the start method starts a second goroutines method that loops through the data in DelayQueue&rsquo;s pipe C, which actually holds a bucket, and then iterates through the bucket&rsquo;s list of timers, executing them asynchronously if the task is due, or putting them back into DelayQueue if it&rsquo;s not.</li>
</ol>
<h3 id="add-task">add task</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">tw</span> <span class="o">:=</span> <span class="nx">timingwheel</span><span class="p">.</span><span class="nf">NewTimingWheel</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
    <span class="nx">tw</span><span class="p">.</span><span class="nf">Start</span><span class="p">()</span> 
    <span class="c1">// 添加任务
</span><span class="c1"></span>    <span class="nx">tw</span><span class="p">.</span><span class="nf">AfterFunc</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="o">*</span><span class="mi">15</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;The timer fires&#34;</span><span class="p">)</span>
        <span class="nx">exitC</span> <span class="o">&lt;-</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">UTC</span><span class="p">()</span>
    <span class="p">})</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>We add a 15s timed task via the AfterFunc method and if it expires then execute the function passed in.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">tw</span> <span class="o">*</span><span class="nx">TimingWheel</span><span class="p">)</span> <span class="nf">AfterFunc</span><span class="p">(</span><span class="nx">d</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">,</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">())</span> <span class="o">*</span><span class="nx">Timer</span> <span class="p">{</span>
    <span class="nx">t</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Timer</span><span class="p">{</span>
        <span class="nx">expiration</span><span class="p">:</span> <span class="nf">timeToMs</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">UTC</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="nx">d</span><span class="p">)),</span>
        <span class="nx">task</span><span class="p">:</span>       <span class="nx">f</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="nx">tw</span><span class="p">.</span><span class="nf">addOrRun</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">t</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The AfterFunc method calls the addOrRun method based on the task due time passed in and the function that needs to be executed when it expires. addOrRun method, which we have seen above, will determine if the timed task needs to be executed based on the due time.</p>
<p>Let&rsquo;s look at the add method.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">tw</span> <span class="o">*</span><span class="nx">TimingWheel</span><span class="p">)</span> <span class="nf">add</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Timer</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="nx">currentTime</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tw</span><span class="p">.</span><span class="nx">currentTime</span><span class="p">)</span>
    <span class="c1">// 已经过期
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">expiration</span> <span class="p">&lt;</span> <span class="nx">currentTime</span><span class="o">+</span><span class="nx">tw</span><span class="p">.</span><span class="nx">tick</span> <span class="p">{</span>
        <span class="c1">// Already expired
</span><span class="c1"></span>        <span class="k">return</span> <span class="kc">false</span>
    <span class="c1">//  到期时间在第一层环内
</span><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">expiration</span> <span class="p">&lt;</span> <span class="nx">currentTime</span><span class="o">+</span><span class="nx">tw</span><span class="p">.</span><span class="nx">interval</span> <span class="p">{</span>
        <span class="c1">// Put it into its own bucket
</span><span class="c1"></span>        <span class="c1">// 获取时间轮的位置
</span><span class="c1"></span>        <span class="nx">virtualID</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">expiration</span> <span class="o">/</span> <span class="nx">tw</span><span class="p">.</span><span class="nx">tick</span>
        <span class="nx">b</span> <span class="o">:=</span> <span class="nx">tw</span><span class="p">.</span><span class="nx">buckets</span><span class="p">[</span><span class="nx">virtualID</span><span class="o">%</span><span class="nx">tw</span><span class="p">.</span><span class="nx">wheelSize</span><span class="p">]</span>
        <span class="c1">// 将任务放入到bucket队列中
</span><span class="c1"></span>        <span class="nx">b</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> 
        <span class="c1">// 如果是相同的时间，那么返回false，防止被多次插入到队列中
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nf">SetExpiration</span><span class="p">(</span><span class="nx">virtualID</span> <span class="o">*</span> <span class="nx">tw</span><span class="p">.</span><span class="nx">tick</span><span class="p">)</span> <span class="p">{</span> 
            <span class="c1">// 将该bucket加入到延迟队列中
</span><span class="c1"></span>            <span class="nx">tw</span><span class="p">.</span><span class="nx">queue</span><span class="p">.</span><span class="nf">Offer</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">b</span><span class="p">.</span><span class="nf">Expiration</span><span class="p">())</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="kc">true</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// Out of the interval. Put it into the overflow wheel
</span><span class="c1"></span>        <span class="c1">// 如果放入的到期时间超过第一层时间轮，那么放到上一层中去
</span><span class="c1"></span>        <span class="nx">overflowWheel</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tw</span><span class="p">.</span><span class="nx">overflowWheel</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">overflowWheel</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapPointer</span><span class="p">(</span>
                <span class="o">&amp;</span><span class="nx">tw</span><span class="p">.</span><span class="nx">overflowWheel</span><span class="p">,</span>
                <span class="kc">nil</span><span class="p">,</span>
                <span class="c1">// 需要注意的是，这里tick变成了interval
</span><span class="c1"></span>                <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nf">newTimingWheel</span><span class="p">(</span>
                    <span class="nx">tw</span><span class="p">.</span><span class="nx">interval</span><span class="p">,</span>
                    <span class="nx">tw</span><span class="p">.</span><span class="nx">wheelSize</span><span class="p">,</span>
                    <span class="nx">currentTime</span><span class="p">,</span>
                    <span class="nx">tw</span><span class="p">.</span><span class="nx">queue</span><span class="p">,</span>
                <span class="p">)),</span>
            <span class="p">)</span>
            <span class="nx">overflowWheel</span> <span class="p">=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tw</span><span class="p">.</span><span class="nx">overflowWheel</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="c1">// 往上递归
</span><span class="c1"></span>        <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="nx">TimingWheel</span><span class="p">)(</span><span class="nx">overflowWheel</span><span class="p">).</span><span class="nf">add</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>add method is divided into three parts according to the expiration time, the first part is less than the current time + tick, indicating that it has expired, then return false to execute the task can be.</p>
<p>The second part of the judgment will be based on whether the expiration is less than the span of the time wheel, if it is less than that, it means that the timed task can be put into the current time wheel, find the time frame corresponding to the buckets by taking the mode and put it into the bucket queue, the SetExpiration method will determine whether the delay queue has already been executed according to the parameters passed in, to prevent repeated insertion.</p>
<p>The third part indicates that the time span of the timed task has exceeded the current time wheel and needs to be escalated to the upper layer of the time wheel. Note that the tick of the time wheel of the upper level is the interval of the current time wheel, the delay queue is still the same, and then set to the pointer overflowWheel and call the add method to recurse to the upper level.</p>
<p>By now the time wheel is finished, but there are still things to note, we used the DelayQueue plus the ring queue in the implementation of the time wheel with the above time wheel. The TimingWheel time complexity is O(1) for the insertion and deletion operations of timed task items, and the queue in the DelayQueue uses a priority queue with a time complexity of O(log n), but since the buckets list is actually very small, this does not affect performance.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/golang/">golang</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-01/go-netpoller/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Explaining the Golang I/O multiplexing netpoller model</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-01/go-dispatch-loop/">
            <span class="next-text nav-default">Explaining the Golang dispatch loop source code implementation</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
