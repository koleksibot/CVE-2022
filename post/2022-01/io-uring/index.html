<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>io_uring Reading Notes - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="io_uring in a nutshell There are two important operations for asynchronous requests for io_uring: committing the request, and completing the submitted request. For IO event submission, the application is the producer and the kernel is the consumer, while for completion events, the kernel is the producer and the application is the consumer. Therefore, we need a pair of rings to provide a high-performance channel for communication between the kernel and" /><meta name="keywords" content="io_uring, linux" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-01/io-uring/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="io_uring Reading Notes" />
<meta property="og:description" content="io_uring in a nutshell There are two important operations for asynchronous requests for io_uring: committing the request, and completing the submitted request. For IO event submission, the application is the producer and the kernel is the consumer, while for completion events, the kernel is the producer and the application is the consumer. Therefore, we need a pair of rings to provide a high-performance channel for communication between the kernel and" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-01/io-uring/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-01-09T10:26:46+08:00" />
<meta property="article:modified_time" content="2022-01-09T10:26:46+08:00" />

<meta itemprop="name" content="io_uring Reading Notes">
<meta itemprop="description" content="io_uring in a nutshell There are two important operations for asynchronous requests for io_uring: committing the request, and completing the submitted request. For IO event submission, the application is the producer and the kernel is the consumer, while for completion events, the kernel is the producer and the application is the consumer. Therefore, we need a pair of rings to provide a high-performance channel for communication between the kernel and"><meta itemprop="datePublished" content="2022-01-09T10:26:46+08:00" />
<meta itemprop="dateModified" content="2022-01-09T10:26:46+08:00" />
<meta itemprop="wordCount" content="3576">
<meta itemprop="keywords" content="io_uring,linux," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="io_uring Reading Notes"/>
<meta name="twitter:description" content="io_uring in a nutshell There are two important operations for asynchronous requests for io_uring: committing the request, and completing the submitted request. For IO event submission, the application is the producer and the kernel is the consumer, while for completion events, the kernel is the producer and the application is the consumer. Therefore, we need a pair of rings to provide a high-performance channel for communication between the kernel and"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">io_uring Reading Notes</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-01-09 10:26:46 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 3576 words </span>
          <span class="more-meta"> 8 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#io_uring-in-a-nutshell">io_uring in a nutshell</a></li>
        <li><a href="#the-data-structure-of--io_uring">The data structure of  io_uring</a></li>
        <li><a href="#io_uring-communication">io_uring communication</a></li>
        <li><a href="#io_uring-interface">io_uring interface</a></li>
        <li><a href="#memory-sequence">memory sequence</a></li>
        <li><a href="#liburing-libraries">liburing libraries</a></li>
        <li><a href="#advanced-usage-and-features">Advanced Usage and Features</a></li>
        <li><a href="#more-examples">More examples</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="io_uring-in-a-nutshell">io_uring in a nutshell</h2>
<p>There are two important operations for asynchronous requests for io_uring: committing the request, and completing the submitted request.</p>
<p>For IO event submission, the application is the producer and the kernel is the consumer, while for completion events, the kernel is the producer and the application is the consumer. Therefore, we need a pair of rings to provide a high-performance channel for communication between the kernel and the application. These rings are the core of the new interface: io_uring, named <code>submission queue(SQ)</code> , <code>completion queue(CQ)</code> , and these two data structures construct the basis of the new interface. These two data structures construct the basis of the new interface.</p>
<h2 id="the-data-structure-of--io_uring">The data structure of  io_uring</h2>
<p>First let&rsquo;s look at the definition of the <code>(completion queue event)CQE</code> data structure.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">io_uring_cqe</span> <span class="p">{</span>
    <span class="n">__u64</span> <span class="n">user_data</span><span class="p">;</span>
    <span class="n">__s32</span> <span class="n">res</span><span class="p">;</span>
    <span class="n">__u32</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>First of all <code>io_uring_cqe</code> has a <code>user_data</code> field that is carried by the original commit request and can carry any information that indicates which request it is, the most basic use is to use the pointer to the original request, the kernel will not modify this field, it simply moves directly from the commit event to the completion event. <code>res</code> points to the result returned by this commit event, just like the result returned by the system call. The <code>flags</code> field will carry metadata that depends on the operation, but this field is not used yet.</p>
<p>For the <code>submission queue event(SQE)</code> the structure definition is more complex.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">io_uring_sqe</span> <span class="p">{</span>
   <span class="n">__u8</span> <span class="n">opcode</span><span class="p">;</span>
   <span class="n">__u8</span> <span class="n">flags</span><span class="p">;</span>
   <span class="n">__u16</span> <span class="n">ioprio</span><span class="p">;</span>
   <span class="n">__s32</span> <span class="n">fd</span><span class="p">;</span>
   <span class="n">__u64</span> <span class="n">off</span><span class="p">;</span>
   <span class="n">__u64</span> <span class="n">addr</span><span class="p">;</span>
   <span class="n">__u32</span> <span class="n">len</span><span class="p">;</span>
   <span class="k">union</span> <span class="p">{</span>
   	<span class="n">__kernel_rwf_t</span> <span class="n">rw_flags</span><span class="p">;</span>
   	<span class="n">__u32</span> <span class="n">fsync_flags</span><span class="p">;</span>
   	<span class="n">__u16</span> <span class="n">poll_events</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">sync_range_flags</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">msg_flags</span><span class="p">;</span>   
   <span class="p">};</span>
   <span class="n">__u64</span> <span class="n">user_data</span><span class="p">;</span>
   <span class="k">union</span> <span class="p">{</span>
   	<span class="n">__u16</span> <span class="n">buf_index</span><span class="p">;</span>
   	<span class="n">__u64</span> <span class="n">__pad2</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
   <span class="p">};</span> 
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>The <code>opcode</code> field is used to describe the opcode for a submitted request, for example <code>IORING_OP_READV</code> for a read request. <code>flags</code> contains modifier flags that are common in command types. <code>ioprio</code> is used to indicate the priority of the request, which for a normal read or write request will follow the definition of the <code>ioprio_set</code> system call. <code>fd</code> is the file descriptor associated with the request, <code>off</code> indicates the offset at which the operation will start, and <code>addr</code> contains the address at which the kernel will start the IO operation. For <code>non-vectored</code> IO transfers, <code>addr</code> must contain the address directly. In the case of <code>non-vectored</code> IO, <code>len</code> is carried directly, and in the case of <code>vectored</code> IO, a number of vectors (described by <code>addr</code>) are carried.</p>
<p>Next is a union to describe a specific <code>opcode</code>. For example, for vectored read ( <strong>IORING_OP_READV</strong> ), these flags should be the same as the flags for the <code>preadv2(2)</code> system call. <code>user_data</code> is transferred in by the user and will not be accessed or modified by the kernel. <code>buf_index</code> is described in the advanced use case, and the final <code>pad</code> is used for data structure padding and is used as a 64-bit alignment.</p>
<p>(Note: <code>vectored IO</code> is a form of IO that sequentially reads data from multiple buffer and writes to one stream through a single producer; or reads data from one buffer and writes to multiple streams, and is used to read and write multiple non-contiguous buffers in a single function call.)</p>
<h2 id="io_uring-communication">io_uring communication</h2>
<p>With the data structure of io_uring understood, let&rsquo;s look at the details of how io_uring works.</p>
<p>The <code>CQEs</code> are organized in an array whose memory is visible and modifiable for both the kernel and the application. However, since <code>CQEs</code> are generated by the kernel, only the kernel is actually modifying <code>CQEs</code>. The method of communication is managed using a ring buffer. Whenever the kernel posts a new event to the <code>CQ ring</code>, it updates the tail associated with it. when the application uses an entry, it updates the head. so if the tail is different from the head, the application knows that it has one or more events available for consumption. The ring counter itself is a free-flowing 32-bit integer that relies on natural packing when the number of completed events exceeds the ring&rsquo;s capacity. One advantage of this approach is that we can take advantage of the full size of the ring without having to manage the &ldquo;ring full&rdquo; flag on the side, which can complicate ring management. With this, the size of the ring must be a power of 2.</p>
<p>In order to find the index of an event, the application must add a mask to the current tail index, as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">  <span class="kt">unsigned</span> <span class="n">head</span><span class="p">;</span>
  <span class="n">head</span> <span class="o">=</span> <span class="n">cqring</span><span class="err">→</span><span class="n">head</span><span class="p">;</span>
<span class="n">read_barrier</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">head</span> <span class="o">!=</span> <span class="n">cqring</span><span class="err">→</span><span class="n">tail</span><span class="p">)</span> <span class="p">{</span>
     <span class="k">struct</span> <span class="n">io_uring_cqe</span> <span class="o">*</span><span class="n">cqe</span><span class="p">;</span>
     <span class="kt">unsigned</span> <span class="n">index</span><span class="p">;</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">head</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">cqring</span><span class="err">→</span><span class="n">mask</span><span class="p">);</span>
    <span class="n">cqe</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cqring</span><span class="err">→</span><span class="n">cqes</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
    <span class="cm">/* process completed cqe here */</span>
    <span class="p">...</span>
    <span class="cm">/* we&#39;ve now consumed this entry */</span>
     <span class="n">head</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
<span class="n">cqring</span><span class="err">→</span><span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
  <span class="n">write_barrier</span><span class="p">();</span>
</code></pre></td></tr></table>
</div>
</div><p><code>ring-&gt;cqes[]</code> is a shared array of <code>io_uring_cqe</code> structures. Later, we will describe how shared memory is started and managed.</p>
<p>The rules are still preserved for the commit event end. The application updates the tail while the kernel consumes the head. An important difference is that CQ rings directly index the shared memory of <code>CQEs</code>, and the commit side has an array of indirection in them, so the <code>ring buffer</code> on the commit side is accessed directly from the array via index.</p>
<p>An example is shown below.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">io_uring_sqe</span> <span class="o">*</span><span class="n">sqe</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="n">tail</span><span class="p">,</span> <span class="n">index</span><span class="p">;</span>
<span class="n">tail</span> <span class="o">=</span> <span class="n">sqring</span><span class="err">→</span><span class="n">tail</span><span class="p">;</span>
<span class="n">index</span> <span class="o">=</span> <span class="n">tail</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">sqring</span><span class="err">→</span><span class="n">ring_mask</span><span class="p">);</span>
<span class="n">sqe</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sqring</span><span class="err">→</span><span class="n">sqes</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="cm">/* this call fills in the sqe entries for this IO */</span>
<span class="n">init_io</span><span class="p">(</span><span class="n">sqe</span><span class="p">);</span>
<span class="cm">/* fill the sqe index into the SQ ring array */</span>
<span class="n">sqring</span><span class="err">→</span><span class="n">array</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
<span class="n">tail</span><span class="o">++</span><span class="p">;</span>
<span class="n">write_barrier</span><span class="p">();</span>
<span class="n">sqring</span><span class="err">→</span><span class="n">tail</span> <span class="o">=</span> <span class="n">tail</span><span class="p">;</span>
<span class="n">write_barrier</span><span class="p">();</span>
</code></pre></td></tr></table>
</div>
</div><p>Completion events may be reached in any order, the order of requests and the order of completions are not linked in any way, and the SQ ring and CQ ring operate independently. However, a completion event will always fit with a requested event. Thus, a completed event will always be associated with a specific submission request.</p>
<h2 id="io_uring-interface">io_uring interface</h2>
<p>Like <code>aio</code>, <code>io_uring</code> has a number of system calls, the first of which is used to start the <code>io_uring</code> instance.</p>
<p><code>int io_uring_setup(unsigned entries, struct io_uring_params *params);</code></p>
<p>The application must provide the number of entries specified by the <code>io_uring</code> instance, where <code>entries</code> indicates the number of <code>SQEs</code>, which must be a power of 2, in 1&hellip;4096, and the <code>params</code> structure is defined as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">io_uring_params</span> <span class="p">{</span>
    <span class="n">__u32</span> <span class="n">sq_entries</span><span class="p">;</span>
    <span class="n">__u32</span> <span class="n">cq_entries</span><span class="p">;</span>
    <span class="n">__u32</span> <span class="n">flags</span><span class="p">;</span>
    <span class="n">__u32</span> <span class="n">sq_thread_cpu</span><span class="p">;</span>
    <span class="n">__u32</span> <span class="n">sq_thread_idle</span><span class="p">;</span>
    <span class="n">__u32</span> <span class="n">resv</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
    <span class="k">struct</span> <span class="n">io_sqring_offsets</span> <span class="n">sq_off</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">io_cqring_offsets</span> <span class="n">cq_off</span><span class="p">;</span> 
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p><code>sq_entries</code> will be populated by the kernel to let the application know how many <code>SQE</code> entries are supported by the current ring. also for <code>cqe_entries</code> the application is informed how big the CQ ring is.</p>
<p>When the interface is successfully called, the kernel will return a file descriptor pointing to this <code>io_uring</code> instance. This is where <code>sq_off</code> and <code>cq_off</code> come in handy. Since SQE and CQE need to be accessed by both the kernel and the user, the application must know if it reaches this memory, which should be mapped into the application&rsquo;s memory space using <code>mmap()</code>. The application uses <code>sq_off</code> to specify the offsets of the different ring members, and the <code>io_sqring_offsets</code> structure is shown below.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">io_sqring_offsets</span> <span class="p">{</span>
    <span class="n">__u32</span> <span class="n">head</span><span class="p">;</span> <span class="cm">/* offset of ring head */</span>
    <span class="n">__u32</span> <span class="n">tail</span><span class="p">;</span> <span class="cm">/* offset of ring tail */</span>
    <span class="n">__u32</span> <span class="n">ring_mask</span><span class="p">;</span> <span class="cm">/* ring mask value */</span>
    <span class="n">__u32</span> <span class="n">ring_entries</span><span class="p">;</span> <span class="cm">/* entries in ring */</span>
    <span class="n">__u32</span> <span class="n">flags</span><span class="p">;</span> <span class="cm">/* ring flags */</span>
    <span class="n">__u32</span> <span class="n">dropped</span><span class="p">;</span> <span class="cm">/* number of sqes not submitted */</span>
    <span class="n">__u32</span> <span class="n">array</span><span class="p">;</span> <span class="cm">/* sqe index array /
</span><span class="cm">	__u32 resv1;
</span><span class="cm">	__u64 resv2;
</span><span class="cm">};
</span></code></pre></td></tr></table>
</div>
</div><p>To access this memory, the application must use <code>mmap</code> to pass the file descriptor of <code>io_uring</code> and the memory offset associated with the SQ ring. The <code>io_uring</code> API defines the following <code>mmap</code> offset so that it can be used by the application.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#define IORING_OFF_SQ_RING 0ULL 
</span><span class="cp">#define IORING_OFF_CQ_RING 0x8000000ULL 
</span><span class="cp">#define IORING_OFF_SQES 0x10000000ULL
</span></code></pre></td></tr></table>
</div>
</div><p><code>IORING_OFF_SQ_RING</code> is used to map SQ rings into user memory space, <code>IORING_OFF_CQ_RING</code> is used for CQ rings, and <code>IORING_OFF_SQES</code> is used to map sqe arrays, which for arrays of CQEs are part of their rings. Since the SQ ring is an index of the SQE&rsquo;s array, the application must map the SQE array separately.</p>
<p>The application will need to define its own data structures to obtain these offsets, a possible example of which is shown below.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">app_sq_ring</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="o">*</span><span class="n">tail</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="o">*</span><span class="n">ring_mask</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="o">*</span><span class="n">ring_entries</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="o">*</span><span class="n">flags</span><span class="p">;</span>
   	<span class="kt">unsigned</span> <span class="o">*</span><span class="n">dropped</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="o">*</span><span class="n">array</span><span class="p">;</span> 
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>An example of starting <code>io_uring</code> is shown below.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">app_sq_ring</span> <span class="nf">app_setup_sq_ring</span><span class="p">(</span><span class="kt">int</span> <span class="n">ring_fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">io_uring_params</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">app_sq_ring</span> <span class="n">sqring</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
    <span class="n">ptr</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">p</span><span class="err">→</span><span class="n">sq_off</span><span class="p">.</span><span class="n">array</span> <span class="o">+</span> <span class="n">p</span><span class="err">→</span><span class="n">sq_entries</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__u32</span><span class="p">),</span>
    <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span> <span class="n">MAP_SHARED</span> <span class="o">|</span> <span class="n">MAP_POPULATE</span><span class="p">,</span>
    <span class="n">ring_fd</span><span class="p">,</span> <span class="n">IORING_OFF_SQ_RING</span><span class="p">);</span>
    <span class="n">sring</span><span class="err">→</span><span class="n">head</span> <span class="o">=</span> <span class="n">ptr</span> <span class="o">+</span> <span class="n">p</span><span class="err">→</span><span class="n">sq_off</span><span class="p">.</span><span class="n">head</span><span class="p">;</span>
    <span class="n">sring</span><span class="err">→</span><span class="n">tail</span> <span class="o">=</span> <span class="n">ptr</span> <span class="o">+</span> <span class="n">p</span><span class="err">→</span><span class="n">sq_off</span><span class="p">.</span><span class="n">tail</span><span class="p">;</span>
    <span class="n">sring</span><span class="err">→</span><span class="n">ring_mask</span> <span class="o">=</span> <span class="n">ptr</span> <span class="o">+</span> <span class="n">p</span><span class="err">→</span><span class="n">sq_off</span><span class="p">.</span><span class="n">ring_mask</span><span class="p">;</span>
    <span class="n">sring</span><span class="err">→</span><span class="n">ring_entries</span> <span class="o">=</span> <span class="n">ptr</span> <span class="o">+</span> <span class="n">p</span><span class="err">→</span><span class="n">sq_off</span><span class="p">.</span><span class="n">ring_entries</span><span class="p">;</span>
    <span class="n">sring</span><span class="err">→</span><span class="n">flags</span> <span class="o">=</span> <span class="n">ptr</span> <span class="o">+</span> <span class="n">p</span><span class="err">→</span><span class="n">sq_off</span><span class="p">.</span><span class="n">flags</span><span class="p">;</span>
    <span class="n">sring</span><span class="err">→</span><span class="n">dropped</span> <span class="o">=</span> <span class="n">ptr</span> <span class="o">+</span> <span class="n">p</span><span class="err">→</span><span class="n">sq_off</span><span class="p">.</span><span class="n">dropped</span><span class="p">;</span>
    <span class="n">sring</span><span class="err">→</span><span class="n">array</span> <span class="o">=</span> <span class="n">ptr</span> <span class="o">+</span> <span class="n">p</span><span class="err">→</span><span class="n">sq_off</span><span class="p">.</span><span class="n">array</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">sring</span><span class="p">;</span> 
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>The application also needs a way to inform the kernel which requests need to be consumed now, and this will be done with the following system call.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">io_uring_enter</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">to_submit</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">min_complete</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="n">sigset_t</span> <span class="n">sig</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p><code>fd</code> points to the <code>io_uring</code> file descriptor, <code>to_submit</code> informs the kernel how many sqes need to be consumed and committed, and <code>min_complete</code> informs the kernel to wait for that number of requests to complete</p>
<h2 id="memory-sequence">memory sequence</h2>
<p>Pending updates&hellip;</p>
<h2 id="liburing-libraries">liburing libraries</h2>
<p>Using system calls directly is not user-friendly, so the kernel developers provide a user library of <code>io_uring</code> for users.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">io_uring</span> <span class="n">ring</span><span class="p">;</span>
<span class="n">io_uring_queue_init</span><span class="p">(</span><span class="n">ENTRIES</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ring</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>By using <code>io_uring_queue_init</code> we can start an instance of io_uring without having to use <code>io_uring_setup</code> and then call <code>mmap()</code> ,</p>
<p>When we are done with the instance we can call the following system call to destroy it.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">io_uring_queue_exit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ring</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>An example of using <code>liburing</code> is shown below.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">io_uring_sqe</span> <span class="n">sqe</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">io_uring_cqe</span> <span class="n">cqe</span><span class="p">;</span>
   <span class="cm">/* get an sqe and fill in a READV operation */</span>
	<span class="n">sqe</span> <span class="o">=</span> <span class="n">io_uring_get_sqe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ring</span><span class="p">);</span>
	<span class="n">io_uring_prep_readv</span><span class="p">(</span><span class="n">sqe</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iovec</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
   <span class="cm">/* tell the kernel we have an sqe ready for consumption */</span>
	<span class="n">io_uring_submit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ring</span><span class="p">);</span>
   <span class="cm">/* wait for the sqe to complete */</span>
	<span class="n">io_uring_wait_cqe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ring</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cqe</span><span class="p">);</span>
  <span class="cm">/* read and process cqe event */</span>
	<span class="n">app_handle_cqe</span><span class="p">(</span><span class="n">cqe</span><span class="p">);</span>
	<span class="n">io_uring_cqe_seen</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ring</span><span class="p">,</span> <span class="n">cqe</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="advanced-usage-and-features">Advanced Usage and Features</h2>
<p>To be updated&hellip;</p>
<h2 id="more-examples">More examples</h2>
<p>A chat server written with <code>io_uring</code> looks like this.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span><span class="lnt">222
</span><span class="lnt">223
</span><span class="lnt">224
</span><span class="lnt">225
</span><span class="lnt">226
</span><span class="lnt">227
</span><span class="lnt">228
</span><span class="lnt">229
</span><span class="lnt">230
</span><span class="lnt">231
</span><span class="lnt">232
</span><span class="lnt">233
</span><span class="lnt">234
</span><span class="lnt">235
</span><span class="lnt">236
</span><span class="lnt">237
</span><span class="lnt">238
</span><span class="lnt">239
</span><span class="lnt">240
</span><span class="lnt">241
</span><span class="lnt">242
</span><span class="lnt">243
</span><span class="lnt">244
</span><span class="lnt">245
</span><span class="lnt">246
</span><span class="lnt">247
</span><span class="lnt">248
</span><span class="lnt">249
</span><span class="lnt">250
</span><span class="lnt">251
</span><span class="lnt">252
</span><span class="lnt">253
</span><span class="lnt">254
</span><span class="lnt">255
</span><span class="lnt">256
</span><span class="lnt">257
</span><span class="lnt">258
</span><span class="lnt">259
</span><span class="lnt">260
</span><span class="lnt">261
</span><span class="lnt">262
</span><span class="lnt">263
</span><span class="lnt">264
</span><span class="lnt">265
</span><span class="lnt">266
</span><span class="lnt">267
</span><span class="lnt">268
</span><span class="lnt">269
</span><span class="lnt">270
</span><span class="lnt">271
</span><span class="lnt">272
</span><span class="lnt">273
</span><span class="lnt">274
</span><span class="lnt">275
</span><span class="lnt">276
</span><span class="lnt">277
</span><span class="lnt">278
</span><span class="lnt">279
</span><span class="lnt">280
</span><span class="lnt">281
</span><span class="lnt">282
</span><span class="lnt">283
</span><span class="lnt">284
</span><span class="lnt">285
</span><span class="lnt">286
</span><span class="lnt">287
</span><span class="lnt">288
</span><span class="lnt">289
</span><span class="lnt">290
</span><span class="lnt">291
</span><span class="lnt">292
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">io_uring</span>::<span class="p">{</span><span class="n">IoUring</span><span class="p">,</span><span class="w"> </span><span class="n">SubmissionQueue</span><span class="p">,</span><span class="w"> </span><span class="n">opcode</span><span class="p">,</span><span class="w"> </span><span class="n">squeue</span><span class="p">,</span><span class="w"> </span><span class="n">types</span><span class="p">};</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">slab</span>::<span class="n">Slab</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">collections</span>::<span class="n">VecDeque</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">net</span>::<span class="n">TcpListener</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">os</span>::<span class="n">unix</span>::<span class="n">io</span>::<span class="p">{</span><span class="w"> </span><span class="n">AsRawFd</span><span class="p">,</span><span class="w"> </span><span class="n">RawFd</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="p">{</span><span class="w"> </span><span class="n">io</span><span class="p">,</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="cp">#[derive(Clone, Debug)]</span><span class="w">
</span><span class="w"></span><span class="k">enum</span> <span class="nc">Token</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">Accept</span><span class="p">,</span><span class="w"> 
</span><span class="w">    </span><span class="n">Poll</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">fd</span>: <span class="nc">RawFd</span><span class="w">
</span><span class="w">    </span><span class="p">},</span><span class="w">
</span><span class="w">    </span><span class="n">Read</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">fd</span>: <span class="nc">RawFd</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">buf_index</span>: <span class="kt">usize</span>
    <span class="p">},</span><span class="w">
</span><span class="w">    </span><span class="n">Write</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">fd</span>: <span class="nc">RawFd</span><span class="p">,</span><span class="w"> 
</span><span class="w">        </span><span class="n">buf_index</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> 
</span><span class="w">        </span><span class="n">offset</span>: <span class="kt">usize</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">len</span>: <span class="kt">usize</span>
    <span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">AcceptCount</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">entry</span>: <span class="nc">squeue</span>::<span class="n">Entry</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="n">count</span>: <span class="kt">usize</span>
<span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">AcceptCount</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="sd">/// 新建 AcceptCount 结构体,fd 表示监听的文件描述符,token 表示 sqe 携带的用户数据
</span><span class="sd"></span><span class="w">    </span><span class="sd">/// count 表示该文件描述符所能接收到的最大连接
</span><span class="sd"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">fd</span>: <span class="nc">RawFd</span><span class="p">,</span><span class="w"> </span><span class="n">token</span>: <span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">count</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="n">entry</span>: <span class="nc">opcode</span>::<span class="n">Accept</span>::<span class="n">new</span><span class="p">(</span><span class="n">types</span>::<span class="n">Fd</span><span class="p">(</span><span class="n">fd</span><span class="p">),</span><span class="w"> </span><span class="n">ptr</span>::<span class="n">null_mut</span><span class="p">(),</span><span class="w"> </span><span class="n">ptr</span>::<span class="n">null_mut</span><span class="p">())</span><span class="w">
</span><span class="w">                    </span><span class="p">.</span><span class="n">build</span><span class="p">()</span><span class="w">
</span><span class="w">                    </span><span class="p">.</span><span class="n">user_data</span><span class="p">(</span><span class="n">token</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">_</span><span class="p">),</span><span class="w">
</span><span class="w">            </span><span class="n">count</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="sd">/// 向提交队列中提交事件
</span><span class="sd"></span><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">push_to</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">sq</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">SubmissionQueue</span><span class="o">&lt;&#39;</span><span class="nb">_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">count</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">unsafe</span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="k">match</span><span class="w"> </span><span class="n">sq</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">entry</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">count</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">
</span><span class="w">                    </span><span class="nb">Err</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">break</span><span class="p">,</span><span class="w">
</span><span class="w">                </span><span class="p">}</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="n">sq</span><span class="p">.</span><span class="n">sync</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">ring</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IoUring</span>::<span class="n">new</span><span class="p">(</span><span class="mi">256</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">listener</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TcpListener</span>::<span class="n">bind</span><span class="p">((</span><span class="s">&#34;127.0.0.1&#34;</span><span class="p">,</span><span class="w"> </span><span class="mi">8080</span><span class="p">)).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// 用于存放提交失败的事件
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">backlog</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VecDeque</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="c1">// 用于存放空闲的缓冲区的 buf_index,一般为关闭连接的socket被回收的
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">bufpool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">with_capacity</span><span class="p">(</span><span class="mi">64</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="c1">// 用来存储内存中的缓冲区的指针，使用 buf_index 进行访问
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">buf_alloc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Slab</span>::<span class="n">with_capacity</span><span class="p">(</span><span class="mi">64</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="c1">// 一段用来存放不同事件token的内存区域，通过token_index获取到事件类型及信息
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">token_alloc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Slab</span>::<span class="n">with_capacity</span><span class="p">(</span><span class="mi">64</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// 用来存放所有建立连接的 sockets
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">sockets</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;Server listen on {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">listener</span><span class="p">.</span><span class="n">local_addr</span><span class="p">().</span><span class="n">unwrap</span><span class="p">());</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// 从 io_uring 实例中获取提交者,提交队列，完成队列
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">submitter</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">sq</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">cq</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ring</span><span class="p">.</span><span class="n">split</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="c1">// 建立 AcceptCount，用于计算监听的文件描述符并提交事件
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">accept</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AcceptCount</span>::<span class="n">new</span><span class="p">(</span><span class="n">listener</span><span class="p">.</span><span class="n">as_raw_fd</span><span class="p">(),</span><span class="w"> </span><span class="n">token_alloc</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">Token</span>::<span class="n">Accept</span><span class="p">),</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">accept</span><span class="p">.</span><span class="n">push_to</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">sq</span><span class="p">);</span><span class="w"> 
</span><span class="w">
</span><span class="w">    </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// 提交SQ里的所有队列，等待至少一个事件成功返回
</span><span class="c1"></span><span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">submitter</span><span class="p">.</span><span class="n">submit_and_wait</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="nb">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">(),</span><span class="w">
</span><span class="w">            </span><span class="nb">Err</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">err</span><span class="p">.</span><span class="n">raw_os_error</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">libc</span>::<span class="n">EBUSY</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">break</span><span class="p">;</span><span class="w"> </span><span class="p">},</span><span class="w">
</span><span class="w">            </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">panic!</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="c1">// 同步完成队列，刷新在内核中的CQEs
</span><span class="c1"></span><span class="w">        </span><span class="n">cq</span><span class="p">.</span><span class="n">sync</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">sq</span><span class="p">.</span><span class="n">is_full</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="c1">// 提交队列满了的时候提交所有任务到内核
</span><span class="c1"></span><span class="w">                </span><span class="k">match</span><span class="w"> </span><span class="n">submitter</span><span class="p">.</span><span class="n">submit</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">(),</span><span class="w">
</span><span class="w">                    </span><span class="nb">Err</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">err</span><span class="p">.</span><span class="n">raw_os_error</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">libc</span>::<span class="n">EBUSY</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="k">break</span><span class="p">;},</span><span class="w">
</span><span class="w">                    </span><span class="nb">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">panic!</span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w">
</span><span class="w">                </span><span class="p">}</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">            </span><span class="c1">// 同步提交队列的内容
</span><span class="c1"></span><span class="w">            </span><span class="n">sq</span><span class="p">.</span><span class="n">sync</span><span class="p">();</span><span class="w">
</span><span class="w">
</span><span class="w">            </span><span class="k">match</span><span class="w"> </span><span class="n">backlog</span><span class="p">.</span><span class="n">pop_front</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="nb">Some</span><span class="p">(</span><span class="n">sqe</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                    </span><span class="c1">// 向SQ中提交事件（此时没有被提交到内核中）
</span><span class="c1"></span><span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sq</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sqe</span><span class="p">);</span><span class="w">
</span><span class="w">                </span><span class="p">},</span><span class="w">
</span><span class="w">
</span><span class="w">                </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="k">break</span><span class="p">,</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="n">accept</span><span class="p">.</span><span class="n">push_to</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">sq</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">cqe</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">cq</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">            </span><span class="c1">// 遍历完成队列的内容
</span><span class="c1"></span><span class="w">            </span><span class="c1">// 获取 CQE 的结果
</span><span class="c1"></span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cqe</span><span class="p">.</span><span class="n">result</span><span class="p">();</span><span class="w">
</span><span class="w">            </span><span class="c1">// 获取 CQE 的用户数据（用于判断是什么事件）
</span><span class="c1"></span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">token_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cqe</span><span class="p">.</span><span class="n">user_data</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w">  </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="c1">// 表明该事件执行失败了
</span><span class="c1"></span><span class="w">                </span><span class="fm">eprintln!</span><span class="p">(</span><span class="w">
</span><span class="w">                    </span><span class="s">&#34;token {:?} error: {:?}&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">                    </span><span class="n">token_alloc</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">token_index</span><span class="p">),</span><span class="w">
</span><span class="w">                    </span><span class="n">io</span>::<span class="n">Error</span>::<span class="n">from_raw_os_error</span><span class="p">(</span><span class="o">-</span><span class="n">ret</span><span class="p">)</span><span class="w">
</span><span class="w">                </span><span class="p">);</span><span class="w">
</span><span class="w">                </span><span class="k">continue</span><span class="p">;</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">            </span><span class="c1">// 通过传入的用户数据取出对应的 token 用于判断是什么事件
</span><span class="c1"></span><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">token_alloc</span><span class="p">[</span><span class="n">token_index</span><span class="p">];</span><span class="w">
</span><span class="w">            </span><span class="k">match</span><span class="w"> </span><span class="n">token</span><span class="p">.</span><span class="n">clone</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                </span><span class="n">Token</span>::<span class="n">Accept</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                    </span><span class="c1">// 当接收到客户端连接时，将 accept 的 count 域进行迭代
</span><span class="c1"></span><span class="w">                    </span><span class="n">accept</span><span class="p">.</span><span class="n">count</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">                    </span><span class="c1">// 此时收到的结果是一个文件描述符，表示的是接收到连接的socket
</span><span class="c1"></span><span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span><span class="w">
</span><span class="w">                    </span><span class="c1">// 将文件描述符push到sockets中
</span><span class="c1"></span><span class="w">                    </span><span class="n">sockets</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span><span class="w">
</span><span class="w">                    </span><span class="c1">// 此时向分配 token_alloc 中插入Token获取token用于作为 user_data
</span><span class="c1"></span><span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">poll_token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">token_alloc</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">Token</span>::<span class="n">Poll</span><span class="p">{</span><span class="w"> </span><span class="n">fd</span><span class="w"> </span><span class="p">});</span><span class="w">
</span><span class="w">                    </span><span class="c1">// 创建poll实例，不断轮询检测是否从该socket中收到信息
</span><span class="c1"></span><span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">poll_e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">opcode</span>::<span class="n">PollAdd</span>::<span class="n">new</span><span class="p">(</span><span class="n">types</span>::<span class="n">Fd</span><span class="p">(</span><span class="n">fd</span><span class="p">),</span><span class="w"> </span><span class="n">libc</span>::<span class="n">POLLIN</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="w">
</span><span class="w">                                        </span><span class="p">.</span><span class="n">build</span><span class="p">()</span><span class="w">
</span><span class="w">                                        </span><span class="p">.</span><span class="n">user_data</span><span class="p">(</span><span class="n">poll_token</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">_</span><span class="p">);</span><span class="w">
</span><span class="w">                    </span><span class="k">unsafe</span><span class="p">{</span><span class="w">
</span><span class="w">                        </span><span class="k">if</span><span class="w"> </span><span class="n">sq</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">poll_e</span><span class="p">).</span><span class="n">is_err</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                            </span><span class="c1">// 如果没有提交到提交队列中(此时应当是提交队列已满)，则将其放入backlog中，等待下一次提交
</span><span class="c1"></span><span class="w">                            </span><span class="n">backlog</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">poll_e</span><span class="p">);</span><span class="w">
</span><span class="w">                        </span><span class="p">}</span><span class="w">
</span><span class="w">                    </span><span class="p">}</span><span class="w">
</span><span class="w">                </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">                </span><span class="n">Token</span>::<span class="n">Poll</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">fd</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">buf_index</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">bufpool</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                        </span><span class="nb">Some</span><span class="p">(</span><span class="n">buf_index</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">buf_index</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">buf_alloc</span><span class="p">[</span><span class="n">buf_index</span><span class="p">]),</span><span class="w">
</span><span class="w">                        </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                            </span><span class="c1">// 新建一个缓冲区
</span><span class="c1"></span><span class="w">                            </span><span class="kd">let</span><span class="w"> </span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">0</span><span class="k">u8</span><span class="p">;</span><span class="w"> </span><span class="mi">2048</span><span class="p">].</span><span class="n">into_boxed_slice</span><span class="p">();</span><span class="w">
</span><span class="w">                            </span><span class="c1">// 返回一个空条目的 handle,允许进一步进行操作
</span><span class="c1"></span><span class="w">                            </span><span class="kd">let</span><span class="w"> </span><span class="n">buf_entry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buf_alloc</span><span class="p">.</span><span class="n">vacant_entry</span><span class="p">();</span><span class="w">
</span><span class="w">                            </span><span class="c1">// 获取该 handle 的key(index)
</span><span class="c1"></span><span class="w">                            </span><span class="kd">let</span><span class="w"> </span><span class="n">buf_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buf_entry</span><span class="p">.</span><span class="n">key</span><span class="p">();</span><span class="w">
</span><span class="w">                            </span><span class="c1">// 返回索引和将缓冲区插入 entry中
</span><span class="c1"></span><span class="w">                            </span><span class="p">(</span><span class="n">buf_index</span><span class="p">,</span><span class="w"> </span><span class="n">buf_entry</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">buf</span><span class="p">))</span><span class="w">
</span><span class="w">                        </span><span class="p">}</span><span class="w">
</span><span class="w">                    </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">                    </span><span class="o">*</span><span class="n">token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Token</span>::<span class="n">Read</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">buf_index</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">                    </span><span class="c1">// 当 Poll 事件返回后表明有一个可读事件发生，此时应当注册读取事件，并将
</span><span class="c1"></span><span class="w">                    </span><span class="c1">// 该事件 push 到提交队列中
</span><span class="c1"></span><span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">read_e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">opcode</span>::<span class="n">Recv</span>::<span class="n">new</span><span class="p">(</span><span class="n">types</span>::<span class="n">Fd</span><span class="p">(</span><span class="n">fd</span><span class="p">),</span><span class="w"> </span><span class="n">buf</span><span class="p">.</span><span class="n">as_mut_ptr</span><span class="p">(),</span><span class="w"> </span><span class="n">buf</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="w">
</span><span class="w">                                        </span><span class="p">.</span><span class="n">build</span><span class="p">()</span><span class="w">
</span><span class="w">                                        </span><span class="p">.</span><span class="n">user_data</span><span class="p">(</span><span class="n">token_index</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">_</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">                    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                        </span><span class="k">if</span><span class="w"> </span><span class="n">sq</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">read_e</span><span class="p">).</span><span class="n">is_err</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                            </span><span class="n">backlog</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">read_e</span><span class="p">);</span><span class="w">
</span><span class="w">                        </span><span class="p">}</span><span class="w">
</span><span class="w">                    </span><span class="p">}</span><span class="w">
</span><span class="w">                </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">                </span><span class="n">Token</span>::<span class="n">Read</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">buf_index</span><span class="p">}</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                    </span><span class="c1">// 读取事件返回，表明从连接的socket中读取到了传输来的信息
</span><span class="c1"></span><span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                        </span><span class="c1">// 结果为0,表明对方关闭了连接
</span><span class="c1"></span><span class="w">                        </span><span class="c1">// 此时这个缓冲区就没有用了，将其push
</span><span class="c1"></span><span class="w">                        </span><span class="c1">// 到 bufpool,用于下一次read/write事件
</span><span class="c1"></span><span class="w">                        </span><span class="c1">// 作为缓冲区
</span><span class="c1"></span><span class="w">                        </span><span class="n">bufpool</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">buf_index</span><span class="p">);</span><span class="w">
</span><span class="w">                        </span><span class="c1">// 将token_index从token_alloc移除掉
</span><span class="c1"></span><span class="w">                        </span><span class="n">token_alloc</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="n">token_index</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">                        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;shutdown&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">                        </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="n">sockets</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                            </span><span class="k">if</span><span class="w"> </span><span class="n">sockets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">fd</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                                </span><span class="n">sockets</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w">
</span><span class="w">                            </span><span class="p">}</span><span class="w">
</span><span class="w">                        </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">                        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                            </span><span class="n">libc</span>::<span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span><span class="w">
</span><span class="w">                        </span><span class="p">}</span><span class="w">
</span><span class="w">                    </span><span class="p">}</span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                        </span><span class="c1">// 读取成功，此时的结果表明读取的字节数
</span><span class="c1"></span><span class="w">                        </span><span class="kd">let</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">;</span><span class="w">
</span><span class="w">                        </span><span class="c1">// 获取用来获取 read 的缓冲区
</span><span class="c1"></span><span class="w">                        </span><span class="kd">let</span><span class="w"> </span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">buf_alloc</span><span class="p">[</span><span class="n">buf_index</span><span class="p">];</span><span class="w">
</span><span class="w">
</span><span class="w">                        </span><span class="kd">let</span><span class="w"> </span><span class="n">socket_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sockets</span><span class="p">.</span><span class="n">len</span><span class="p">();</span><span class="w">
</span><span class="w">                        </span><span class="n">token_alloc</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="n">token_index</span><span class="p">);</span><span class="w">
</span><span class="w">                        </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="n">socket_len</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                            </span><span class="c1">// 新建write_token并将其传输给所有正在连接的socket
</span><span class="c1"></span><span class="w">                            </span><span class="kd">let</span><span class="w"> </span><span class="n">write_token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Token</span>::<span class="n">Write</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                                </span><span class="n">fd</span>: <span class="nc">sockets</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> 
</span><span class="w">                                </span><span class="n">buf_index</span><span class="p">,</span><span class="w">
</span><span class="w">                                </span><span class="n">len</span><span class="p">,</span><span class="w">
</span><span class="w">                                </span><span class="n">offset</span>: <span class="mi">0</span><span class="w">
</span><span class="w">                            </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">                            </span><span class="kd">let</span><span class="w"> </span><span class="n">write_token_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">token_alloc</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">write_token</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">                            </span><span class="c1">// 注册 write 事件，实际上是注册 send syscall 的事件
</span><span class="c1"></span><span class="w">                            </span><span class="kd">let</span><span class="w"> </span><span class="n">write_e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">opcode</span>::<span class="nb">Send</span>::<span class="n">new</span><span class="p">(</span><span class="n">types</span>::<span class="n">Fd</span><span class="p">(</span><span class="n">sockets</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span><span class="w"> </span><span class="n">buf</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">(),</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="w">
</span><span class="w">                                                </span><span class="p">.</span><span class="n">build</span><span class="p">()</span><span class="w">
</span><span class="w">                                                </span><span class="p">.</span><span class="n">user_data</span><span class="p">(</span><span class="n">write_token_index</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">_</span><span class="p">);</span><span class="w">
</span><span class="w">                            </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                                </span><span class="k">if</span><span class="w"> </span><span class="n">sq</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">write_e</span><span class="p">).</span><span class="n">is_err</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                                    </span><span class="n">backlog</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">write_e</span><span class="p">);</span><span class="w">
</span><span class="w">                                </span><span class="p">}</span><span class="w">
</span><span class="w">                            </span><span class="p">}</span><span class="w">
</span><span class="w">                        </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">                    </span><span class="p">}</span><span class="w">
</span><span class="w">                </span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">                </span><span class="n">Token</span>::<span class="n">Write</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                    </span><span class="n">fd</span><span class="p">,</span><span class="w">
</span><span class="w">                    </span><span class="n">buf_index</span><span class="p">,</span><span class="w">
</span><span class="w">                    </span><span class="n">offset</span><span class="p">,</span><span class="w">
</span><span class="w">                    </span><span class="n">len</span><span class="w">
</span><span class="w">                </span><span class="p">}</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                    </span><span class="c1">// write(send) 事件返回，此时的结果是写字节数
</span><span class="c1"></span><span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">write_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">;</span><span class="w"> 
</span><span class="w">
</span><span class="w">                    </span><span class="c1">// 如果写偏移量的写数据的字节数大于等于要写的长度，
</span><span class="c1"></span><span class="w">                    </span><span class="c1">// 此时表明已经写完，则开始注册等待事件继续轮询socket是否传输信息
</span><span class="c1"></span><span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">entry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">write_len</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                        </span><span class="n">bufpool</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">buf_index</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">                        </span><span class="o">*</span><span class="n">token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Token</span>::<span class="n">Poll</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">fd</span><span class="w"> </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">                        </span><span class="n">opcode</span>::<span class="n">PollAdd</span>::<span class="n">new</span><span class="p">(</span><span class="n">types</span>::<span class="n">Fd</span><span class="p">(</span><span class="n">fd</span><span class="p">),</span><span class="w"> </span><span class="n">libc</span>::<span class="n">POLLIN</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="w">
</span><span class="w">                                </span><span class="p">.</span><span class="n">build</span><span class="p">()</span><span class="w">
</span><span class="w">                                </span><span class="p">.</span><span class="n">user_data</span><span class="p">(</span><span class="n">token_index</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="w">
</span><span class="w">                    </span><span class="p">}</span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                        </span><span class="c1">// 如果没写完的话则更新参数重新写
</span><span class="c1"></span><span class="w">                        </span><span class="c1">// 将写偏移量加上写字节数
</span><span class="c1"></span><span class="w">                        </span><span class="kd">let</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">write_len</span><span class="p">;</span><span class="w">
</span><span class="w">                        </span><span class="c1">// 将要写的数据长度减去偏移量
</span><span class="c1"></span><span class="w">                        </span><span class="kd">let</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">offset</span><span class="p">;</span><span class="w">
</span><span class="w">                        </span><span class="c1">// 通过偏移量获取缓冲区的指针
</span><span class="c1"></span><span class="w">                        </span><span class="kd">let</span><span class="w"> </span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">buf_alloc</span><span class="p">[</span><span class="n">buf_index</span><span class="p">][</span><span class="n">offset</span><span class="o">..</span><span class="p">];</span><span class="w">
</span><span class="w">
</span><span class="w">                        </span><span class="o">*</span><span class="n">token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Token</span>::<span class="n">Write</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                            </span><span class="n">fd</span><span class="p">,</span><span class="w"> 
</span><span class="w">                            </span><span class="n">buf_index</span><span class="p">,</span><span class="w">
</span><span class="w">                            </span><span class="n">offset</span><span class="p">,</span><span class="w"> 
</span><span class="w">                            </span><span class="n">len</span><span class="w">
</span><span class="w">                        </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">                        </span><span class="n">opcode</span>::<span class="n">Write</span>::<span class="n">new</span><span class="p">(</span><span class="n">types</span>::<span class="n">Fd</span><span class="p">(</span><span class="n">fd</span><span class="p">),</span><span class="w"> </span><span class="n">buf</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">(),</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="w">
</span><span class="w">                                    </span><span class="p">.</span><span class="n">build</span><span class="p">()</span><span class="w">
</span><span class="w">                                    </span><span class="p">.</span><span class="n">user_data</span><span class="p">(</span><span class="n">token_index</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="w">
</span><span class="w">                    </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">                    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                        </span><span class="k">if</span><span class="w"> </span><span class="n">sq</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="p">).</span><span class="n">is_err</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">                            </span><span class="c1">// 将事件push到提交队列中，失败了则放入到备份中
</span><span class="c1"></span><span class="w">                            </span><span class="n">backlog</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span><span class="w">
</span><span class="w">                        </span><span class="p">}</span><span class="w">
</span><span class="w">                    </span><span class="p">}</span><span class="w">
</span><span class="w">                </span><span class="p">}</span><span class="w">
</span><span class="w">            </span><span class="p">}</span><span class="w">
</span><span class="w">        </span><span class="p">}</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div>
    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/io_uring/">io_uring</a>
          <a href="/tags/linux/">linux</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-01/rust-fat32/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Implementing the FAT32 file system with Rust</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-01/risc-v-n-extensions/">
            <span class="next-text nav-default">RISC -V N Extensions</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
