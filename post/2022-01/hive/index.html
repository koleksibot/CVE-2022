<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Big Data Basics: HIVE - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Hive Introduction Hive, implemented by Facebook and open source, is a data warehouse tool based on Hadoop. It maps structured data into a database table and provides HQL (Hive SQL) queries. The underlying data is stored on HDFS, and Hive essentially converts SQL statements into MapReduce tasks to run, making it easy for users unfamiliar with MapReduce to process and compute structured data on HDFS using HQL, suitable for offline" /><meta name="keywords" content="Hive, Big Data" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-01/hive/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Big Data Basics: HIVE" />
<meta property="og:description" content="Hive Introduction Hive, implemented by Facebook and open source, is a data warehouse tool based on Hadoop. It maps structured data into a database table and provides HQL (Hive SQL) queries. The underlying data is stored on HDFS, and Hive essentially converts SQL statements into MapReduce tasks to run, making it easy for users unfamiliar with MapReduce to process and compute structured data on HDFS using HQL, suitable for offline" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-01/hive/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-01-14T10:35:25+08:00" />
<meta property="article:modified_time" content="2022-01-14T10:35:25+08:00" />

<meta itemprop="name" content="Big Data Basics: HIVE">
<meta itemprop="description" content="Hive Introduction Hive, implemented by Facebook and open source, is a data warehouse tool based on Hadoop. It maps structured data into a database table and provides HQL (Hive SQL) queries. The underlying data is stored on HDFS, and Hive essentially converts SQL statements into MapReduce tasks to run, making it easy for users unfamiliar with MapReduce to process and compute structured data on HDFS using HQL, suitable for offline"><meta itemprop="datePublished" content="2022-01-14T10:35:25+08:00" />
<meta itemprop="dateModified" content="2022-01-14T10:35:25+08:00" />
<meta itemprop="wordCount" content="3313">
<meta itemprop="keywords" content="hive," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Big Data Basics: HIVE"/>
<meta name="twitter:description" content="Hive Introduction Hive, implemented by Facebook and open source, is a data warehouse tool based on Hadoop. It maps structured data into a database table and provides HQL (Hive SQL) queries. The underlying data is stored on HDFS, and Hive essentially converts SQL statements into MapReduce tasks to run, making it easy for users unfamiliar with MapReduce to process and compute structured data on HDFS using HQL, suitable for offline"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Big Data Basics: HIVE</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-01-14 10:35:25 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 3313 words </span>
          <span class="more-meta"> 7 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#hive-introduction">Hive Introduction</a></li>
        <li><a href="#hives-architecture">Hive&rsquo;s architecture</a></li>
        <li><a href="#hive-data-storage">Hive Data Storage</a></li>
        <li><a href="#hive-metastore">Hive Metastore</a></li>
        <li><a href="#introduction-to-hive-sql">Introduction to Hive SQL</a>
          <ul>
            <li><a href="#hive-query-statements">Hive query statements</a></li>
            <li><a href="#hive-definition-statements-ddl">Hive Definition Statements (DDL)</a></li>
            <li><a href="#hive-operation-statements">Hive operation statements</a></li>
            <li><a href="#hive-sql-optimisation">HIVE SQL Optimisation</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="hive-introduction">Hive Introduction</h2>
<p>Hive, implemented by Facebook and open source, is a data warehouse tool based on Hadoop. It maps structured data into a database table and provides HQL (Hive SQL) queries. The underlying data is stored on HDFS, and Hive essentially converts SQL statements into MapReduce tasks to run, making it easy for users unfamiliar with MapReduce to process and compute structured data on HDFS using HQL, suitable for offline bulk data computation.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/14/8cd15f83c92a4141927b5745bf394e09.png" alt="hive"></p>
<p>Differences between Hive and ordinary relational databases.</p>
<ul>
<li>Query language. Hive provides a SQL-like query language, HQL, which can be used directly by developers familiar with SQL.</li>
<li>Hive is built on Hadoop, and all Hive data is stored in HDFS. The database, on the other hand, can store data on a block device or local file system.</li>
<li>There is no specific data format defined in Hive, the data format can be specified by the user, who has to specify three properties: the column separator (usually spaces, \t, \x001), the row separator (\n) and the method of reading the data from the file (there are three default file formats in Hive: TextFile, SequenceFile and RCFile). As there is no conversion from the user data format to the data format defined by Hive during the loading process, Hive does not make any changes to the data itself during the loading process, but simply copies or moves the data contents to the appropriate HDFS directory. In contrast, in databases, different databases have different storage engines that define their own data formats. All data is stored according to a certain organisation, so the process of loading data into a database can be more time consuming.</li>
<li>Data updates. As Hive is designed for data warehouse applications, which are more read and less written. Therefore, there is no support for rewriting or adding to data in Hive; all data is determined at load time. The data in the database is usually modified frequently, so you can add data using INSERT INTO &hellip; VALUES and modify data using UPDATE &hellip; SET.</li>
<li>Hive does not do anything to the data as it loads it, not even scan it, and therefore does not index certain Keys in the data. to access a specific value in the data that meets a condition, Hive has to brute-force scan the entire data, so access latency is high. Thanks to the introduction of MapReduce, Hive can access data in parallel, so even without indexes, Hive can still be advantageous for large volumes of data. In databases, indexes are usually created for one or a few columns, so databases can be very efficient and have low latency for accessing small amounts of data with specific conditions. The high latency of accessing data dictates that Hive is not suitable for online data queries.</li>
<li>Execution. most queries in Hive are executed through MapReduce provided by Hadoop. Databases usually have their own execution engines.</li>
<li>Execution latency. Hive has high latency when querying data because there are no indexes and the entire table needs to be scanned. Another factor that contributes to the high execution latency of Hive is the MapReduce framework. Because MapReduce itself has high latency, there is also high latency when executing Hive queries using MapReduce. In contrast, database execution latency is low. Of course, this low latency is conditional on the size of the data being small, and Hive&rsquo;s parallel computing is clearly an advantage when the data is large enough to exceed the database&rsquo;s processing power.</li>
<li>Scalability. Since Hive is built on Hadoop, the scalability of Hive is consistent with the scalability of Hadoop. Databases, on the other hand, have very limited scalability rows due to the strict limitations of ACID semantics. Oracle, the most advanced parallel database available, has a theoretical scalability of only about 100 machines.</li>
<li>Data size. Because Hive is built on a cluster and can use MapReduce for parallel computing, it can support very large data sizes; the corresponding database can support smaller data sizes.</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/14/3762bba563c5499cafacdb2b902dd7c6.png" alt="image"></p>
<p>To be clear, Hive, as a data warehouse application tool, has 3 &ldquo;no&rsquo;s&rdquo; compared to RDBMS (relational database).</p>
<ul>
<li>Can&rsquo;t respond in real time like an RDBMS, Hive has a large query latency</li>
<li>Can&rsquo;t do transactional queries like RDBMS, Hive has no transaction mechanism</li>
<li>Can&rsquo;t do row-level change operations (including insert, update, delete) like RDBMS</li>
</ul>
<p>In addition, Hive is a more &ldquo;relaxed&rdquo; world than RDBMS, for example.</p>
<ul>
<li>Hive doesn&rsquo;t have a fixed-length varchar type, strings are all string</li>
<li>Hive is in read-time mode, it doesn&rsquo;t validate the data when it saves the table data, instead it checks the data when it reads it to set it to NULL if it doesn&rsquo;t match the format</li>
</ul>
<h2 id="hives-architecture">Hive&rsquo;s architecture</h2>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/01/14/6b2ebcbccd2a40afb35200ebbcc48721.png" alt="image"></p>
<p>The Hive architecture consists of the following components: CLI (command line interface), JDBC/ODBC, Thrift Server, WEB GUI, metastore and Driver (Complier, Optimizer and Executor). Optimizer and Executor), these components can be divided into two main categories.</p>
<ul>
<li>Server-side components.
<ul>
<li>Driver component: this component includes Complier, Optimizer and Executor, its role is to parse the HiveQL (SQL-like) statements we write, compile and optimize them, generate an execution plan, and then call the underlying mapreduce computation framework.</li>
<li>Metastore component: metadata service component, this component stores hive&rsquo;s metadata, hive&rsquo;s metadata is stored in a relational database, hive supports relational databases such as derby, mysql. metadata is very important to hive, so hive supports the metastore service as a separate component, installed in a remote server cluster The metastore service can be decoupled from the hive service and the metastore service to ensure robustness of hive operation.</li>
<li>Thrift service: thrift is a software framework developed by facebook, which is used to develop scalable and cross-language services. hive integrates with this service, allowing different programming languages to call hive&rsquo;s interface.</li>
</ul>
</li>
<li>Client-side components.
<ul>
<li>CLI: command line interface.</li>
<li>Thrift client: The Thrift client is not written in the architecture diagram above, but many of the client interfaces of the hive architecture are built on top of the thrift client, including the JDBC and ODBC interfaces.</li>
<li>WEB GUI: The hive client provides a way to access the services provided by hive via the web. This interface corresponds to hive&rsquo;s hwi component (hive web interface) and requires the hwi service to be started before use.</li>
</ul>
</li>
</ul>
<h2 id="hive-data-storage">Hive Data Storage</h2>
<p>Hive&rsquo;s storage structure consists of databases, tables, views, partitions and table data. Databases, tables, partitions, etc. all correspond to a directory on HDFS. All data in Hive is stored in HDFS and there is no special data storage format, as Hive is in Schema On Read mode and can support TextFile, SequenceFile, RCFile or custom formats.</p>
<p>Hive does not have a special format for storing data, nor does it create indexes for the data, so you can organise the tables in Hive very freely, simply by telling Hive the column and row separators in the data when you create the table, and Hive can parse the data. Secondly, all the data in Hive is stored in HDFS, which contains the following data models: Table, External Table, Partition, Bucket.</p>
<ul>
<li>A Table in Hive is conceptually similar to a Table in a database, in that each Table has a corresponding directory in Hive where the data is stored. For example, a table pvs has a path in HDFS: /wh/pvs, where wh is the directory of the data warehouse specified by ${hive.metastore.warehouse.dir} in hive-site.xml, and all Table data (excluding External Table) is stored in this directory. All Table data (excluding External Table) is stored in this directory.</li>
<li>A Partition corresponds to a dense index of Partition columns in a database, but the way in which Partitions are organised in Hive is very different to that in a database. In Hive, a Partition in a table corresponds to a directory under the table, and all the data for the Partition is stored in the corresponding directory. For example, if the pvs table contains two Partitions, ds and city, the HDFS subdirectory corresponding to ds = 20090801, ctry = US would be: /wh/pvs/ds=20090801/ctry=US; the HDFS subdirectory corresponding to ds = 20090801, ctry = CA would be: /wh/pvs/ ds=20090801/ctry=CA</li>
<li>Buckets compute hash on specified columns and slice data based on hash values, for parallelism purposes, with each Bucket corresponding to one file. The HDFS directory with hash value 0 is: /wh/pvs/ds=20090801/ctry=US/part-00000; the HDFS directory with hash value 20 is: /wh/pvs/ds=20090801/ ctry=US/part-00020</li>
<li>External Table refers to data that already exists in HDFS and can be created as a Partition; it is the same as a Table in terms of metadata organization, but the actual data storage is much different.
<ul>
<li>The Table creation process and the data loading process (both of which can be done in the same statement), during the data loading process the actual data is moved to the data warehouse directory, after which access to the data will be done directly in the data warehouse directory. When a table is deleted, the data and metadata in the table are deleted at the same time.</li>
<li>The actual data is stored in the HDFS path specified after LOCATION and is not moved to the data warehouse directory. It is not moved to the data repository directory. When an External Table is deleted, it is only deleted.</li>
</ul>
</li>
</ul>
<h2 id="hive-metastore">Hive Metastore</h2>
<p>Hive&rsquo;s metastore component is a central repository for hive metadata. the metastore component consists of two parts: the metastore service and the backend data store. The backend data storage medium is a relational database, such as hive&rsquo;s default embedded disk database derby, and a mysql database. the metastore service is a service component that is built on top of the backend data storage medium and can interact with the hive service. by default, the metastore service and the hive service are installed together and run in the same process. By default, the metastore service and the hive service are installed together, running in the same process. I can also strip the metastore service from the hive service, and install the metastore independently in a cluster, so that hive can call the metastore service remotely. This provides better manageability and security. Using a remote metastore service allows the metastore service and the hive service to run in separate processes, which also ensures the stability of hive and improves the efficiency of the hive service.</p>
<p>Hive stores metadata in the RDBMS and there are three modes to connect to the database.</p>
<ul>
<li>Single User Mode: This mode connects to an In-memory database Derby, typically used for Unit Tests.</li>
<li>Multi User Mode: Connects to a database over the network and is the most frequently used mode.</li>
<li>Remote Server Mode: Used for non-Java clients to access the meta-database. A MetaStoreServer is started on the server side and the client accesses the meta-database through the MetaStoreServer using the Thrift protocol.</li>
</ul>
<p><strong>Hive field types</strong></p>
<table>
<thead>
<tr>
<th>Category</th>
<th>Type</th>
<th>Description</th>
<th>Literal Amount Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>primitive</td>
<td>BOOLEAN</td>
<td>true/false</td>
<td>TRUE</td>
</tr>
<tr>
<td></td>
<td>TINYINT</td>
<td>1-byte signed integer -128 to 127</td>
<td>1Y</td>
</tr>
<tr>
<td></td>
<td>SMALLINT</td>
<td>2-byte signed integer, -32768~32767</td>
<td>1S</td>
</tr>
<tr>
<td></td>
<td>INT</td>
<td>4-byte signed integer</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>BIGINT</td>
<td>8-byte signed integer</td>
<td>1L</td>
</tr>
<tr>
<td></td>
<td>FLOAT</td>
<td>4-byte single-precision floating-point number</td>
<td>1.0</td>
</tr>
<tr>
<td></td>
<td>DOUBLE</td>
<td>8-byte single-precision floating-point number</td>
<td>1.0</td>
</tr>
<tr>
<td></td>
<td>DEICIMAL</td>
<td>signed decimal numbers of arbitrary precision</td>
<td>1.0</td>
</tr>
<tr>
<td></td>
<td>STRING</td>
<td>String, variable-length</td>
<td>abc</td>
</tr>
<tr>
<td></td>
<td>VARCHAR</td>
<td>Variable-length string</td>
<td>abc</td>
</tr>
<tr>
<td></td>
<td>CHAR</td>
<td>fixed-length string</td>
<td>abc</td>
</tr>
<tr>
<td></td>
<td>BINARY</td>
<td>byte arrays</td>
<td>unrepresentable</td>
</tr>
<tr>
<td></td>
<td>TIMESTAMP</td>
<td>c</td>
<td>1642123232761</td>
</tr>
<tr>
<td></td>
<td>DATE</td>
<td>date</td>
<td>2022-01-14</td>
</tr>
<tr>
<td></td>
<td>INTERVAL</td>
<td>time frequency interval</td>
<td></td>
</tr>
<tr>
<td>complex type</td>
<td>ARRAY</td>
<td>ordered sets of the same type</td>
<td>array(1,2)</td>
</tr>
<tr>
<td></td>
<td>MAP</td>
<td>key-value,key must be primitive,value can be of any type</td>
<td>map(&lsquo;a&rsquo;,1,&lsquo;b&rsquo;,2)</td>
</tr>
<tr>
<td></td>
<td>STRUCT</td>
<td>collection of fields, type can be different</td>
<td>struct(&lsquo;1&rsquo;,1,1.0), named_stract(&lsquo;col1&rsquo;,&lsquo;1 &lsquo;,&lsquo;col2&rsquo;,1,&lsquo;clo3&rsquo;,1.0)</td>
</tr>
<tr>
<td></td>
<td>UNION</td>
<td>a value within a finite range of values</td>
<td>create_union(1,&lsquo;a&rsquo;,63)</td>
</tr>
</tbody>
</table>
<p>decimal usage: Usage: decimal(11,2) represents a maximum of 11 digits, of which the last 2 are decimal and the integer part is 9; if the integer part is more than 9, the field becomes null; if the decimal part is less than 2, it is followed by 0 to make up the two digits, if the decimal part is more than two, the excess is rounded up. You can also write decimal directly without specifying the number of digits, the default is decimal(10,0) 10 integers, no decimals</p>
<h2 id="introduction-to-hive-sql">Introduction to Hive SQL</h2>
<h3 id="hive-query-statements">Hive query statements</h3>
<p>Hive Select syntax is almost the same as that of Mysql and other RDBMS SQL, the following syntax format is attached, no detailed explanation will be given.</p>
<p><strong>SELECT Syntax and Sequence</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">SELECT</span><span class="w"> </span><span class="p">[</span><span class="k">ALL</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="k">DISTINCT</span><span class="p">]</span><span class="w"> </span><span class="n">select_expr</span><span class="p">,</span><span class="w"> </span><span class="n">select_expr</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w">
</span><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">table_reference</span><span class="w">
</span><span class="w"></span><span class="p">[</span><span class="k">WHERE</span><span class="w"> </span><span class="n">where_condition</span><span class="p">]</span><span class="w">
</span><span class="w"></span><span class="p">[</span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">col_list</span><span class="p">]</span><span class="w">
</span><span class="w"></span><span class="p">[</span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">order_condition</span><span class="p">]</span><span class="w">
</span><span class="w"></span><span class="p">[</span><span class="n">DISTRIBUTE</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">distribute_condition</span><span class="w"> </span><span class="p">[</span><span class="n">SORT</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">sort_condition</span><span class="p">]</span><span class="w"> </span><span class="p">]</span><span class="w">
</span><span class="w"></span><span class="p">[</span><span class="k">LIMIT</span><span class="w"> </span><span class="nb">number</span><span class="p">]</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><strong>Multidimensional aggregation analysis grouping sets/cube/roolup</strong></p>
<p>Without the multidimensional aggregation method.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">SELECT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w"> </span><span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">requests</span><span class="w">
</span><span class="w"></span><span class="k">UNION</span><span class="w"> </span><span class="k">ALL</span><span class="w">
</span><span class="w"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">os</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w"> </span><span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">requests</span><span class="w"> </span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">os</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="w">
</span><span class="w"></span><span class="k">UNION</span><span class="w"> </span><span class="k">ALL</span><span class="w">
</span><span class="w"></span><span class="k">SELECT</span><span class="w"> </span><span class="k">null</span><span class="p">,</span><span class="w"> </span><span class="k">null</span><span class="p">,</span><span class="w"> </span><span class="n">city</span><span class="p">,</span><span class="w"> </span><span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">requests</span><span class="w"> </span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">city</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>Using grouping sets.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">SELECT</span><span class="w"> </span><span class="n">os</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">city</span><span class="w"> </span><span class="p">,</span><span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">requests</span><span class="w">
</span><span class="w"></span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">os</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">city</span><span class="w"> </span><span class="k">GROUPING</span><span class="w"> </span><span class="k">SETS</span><span class="p">((</span><span class="n">os</span><span class="p">,</span><span class="w"> </span><span class="n">device</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="n">city</span><span class="p">),</span><span class="w"> </span><span class="p">());</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>The cube will enumerate all possible combinations of the specified columns as grouping sets, while roolup will generate grouping sets in a hierarchical aggregation manner. e.g.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="k">CUBE</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="k">c</span><span class="p">)</span><span class="w">  
</span><span class="w"></span><span class="c1">--等价于以下语句。  
</span><span class="c1"></span><span class="k">GROUPING</span><span class="w"> </span><span class="k">SETS</span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="k">c</span><span class="p">),(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">),(</span><span class="n">a</span><span class="p">,</span><span class="k">c</span><span class="p">),(</span><span class="n">b</span><span class="p">,</span><span class="k">c</span><span class="p">),(</span><span class="n">a</span><span class="p">),(</span><span class="n">b</span><span class="p">),(</span><span class="k">c</span><span class="p">),())</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="k">ROLLUP</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="k">c</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="c1">--等价于以下语句。  
</span><span class="c1"></span><span class="k">GROUPING</span><span class="w"> </span><span class="k">SETS</span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="k">c</span><span class="p">),(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">),(</span><span class="n">a</span><span class="p">),</span><span class="w"> </span><span class="p">())</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><strong>The regular method specifies SELECT field columns</strong></p>
<p>It says specify, but it&rsquo;s actually exclude, e.g. <code>(num|uid)? +. +</code> excludes the num and uid columns. Alternatively, where can be used with a regular like this: where A Rlike B, where A Regexp B.</p>
<p><strong>Lateral View (one row to many rows)</strong></p>
<p>Lateral View is used in conjunction with table generation functions such as Split, Explode, etc., which can split a row of data into multiple rows of data and aggregate the split data.</p>
<p>Suppose you have a table pageAds with two columns of data, the first column is the pageid string and the second column is the adid_list, a comma-separated collection of ad IDs. Now you need to count the number of times all the ads appear on all the pages, so you start by using Lateral View + explode to do the normal grouping and aggregation.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">SELECT</span><span class="w"> </span><span class="n">pageid</span><span class="p">,</span><span class="w"> </span><span class="n">adid</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">pageAds</span><span class="w"> </span><span class="k">LATERAL</span><span class="w"> </span><span class="k">VIEW</span><span class="w"> </span><span class="n">explode</span><span class="p">(</span><span class="n">adid_list</span><span class="p">)</span><span class="w"> </span><span class="n">adTable</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">adid</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><strong>Window Functions</strong></p>
<p>Hive has a rich set of window functions, the most common of which is row_number() over(partition by col order col_2), which allows you to sort by a specified group of fields.</p>
<ul>
<li>COUNT calculates the count value.</li>
<li>AVG calculates the average value.</li>
<li>MAX Calculates the maximum value.</li>
<li>MIN Calculates the minimum value.</li>
<li>MEDIAN Calculates the median.</li>
<li>STDDEV Calculates the overall standard deviation.</li>
<li>STDDEV_SAMP Calculates the sample standard deviation.</li>
<li>SUM Calculates the summary value.</li>
<li>DENSE_RANK Calculates the continuous ranking.</li>
<li>RANK Calculates jump ranking.</li>
<li>LAG Takes the value of the row before the current row by offset.</li>
<li>LEAD Takes the value of the row after the current row by offset.</li>
<li>PERCENT_RANK Calculates the relative rank of a row in a set of data.</li>
<li>ROW_NUMBER Calculates the row number.</li>
<li>CLUSTER_SAMPLE Used for group sampling.</li>
<li>CUME_DIST Calculates the cumulative distribution.</li>
<li>NTILE Slices grouped data in order and returns the slice value.</li>
</ul>
<p><strong>Hive definition variables</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">SET</span><span class="w"> </span><span class="n">aa</span><span class="o">=</span><span class="s1">&#39;10&#39;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">SELECT</span><span class="w"> </span><span class="err">${</span><span class="n">hiveconf</span><span class="p">:</span><span class="n">aa</span><span class="err">}</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">SET</span><span class="w"> </span><span class="n">hivevar</span><span class="p">:</span><span class="n">aa</span><span class="o">=</span><span class="s1">&#39;10&#39;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">SELECT</span><span class="w"> </span><span class="err">${</span><span class="n">hivevar</span><span class="p">:</span><span class="n">aa</span><span class="err">}</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">SET</span><span class="w"> </span><span class="n">hiveconf</span><span class="p">:</span><span class="n">aa</span><span class="o">=</span><span class="s1">&#39;10&#39;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">SELECT</span><span class="w"> </span><span class="err">${</span><span class="n">hiveconf</span><span class="p">:</span><span class="n">aa</span><span class="err">}</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><strong>CTE syntax and definition of variables</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">with</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="k">as</span><span class="p">(</span><span class="w">
</span><span class="w">    </span><span class="k">select</span><span class="w"> </span><span class="n">user_id</span><span class="w">
</span><span class="w">    </span><span class="k">from</span><span class="w"> </span><span class="k">user</span><span class="w">
</span><span class="w">    </span><span class="k">where</span><span class="w"> </span><span class="p">...</span><span class="w">
</span><span class="w"></span><span class="p">)</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="o">@</span><span class="n">var</span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="k">select</span><span class="w">
</span><span class="w">         </span><span class="n">shop_id</span><span class="w">
</span><span class="w">       </span><span class="k">from</span><span class="w"> </span><span class="n">shop</span><span class="w">
</span><span class="w">       </span><span class="k">where</span><span class="w"> </span><span class="p">...;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w">
</span><span class="w"></span><span class="k">from</span><span class="w"> </span><span class="n">user_shop</span><span class="w">
</span><span class="w"></span><span class="k">where</span><span class="w"> </span><span class="n">user_id</span><span class="w"> </span><span class="k">in</span><span class="p">(</span><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">t1</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="k">and</span><span class="w"> </span><span class="n">shop_id</span><span class="w"> </span><span class="k">in</span><span class="p">(</span><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="o">@</span><span class="n">var</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h3 id="hive-definition-statements-ddl">Hive Definition Statements (DDL)</h3>
<p><strong>Hive table build statement format</strong></p>
<p>Method 1: Standalone statement</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">CREATE</span><span class="w"> </span><span class="p">[</span><span class="k">EXTERNAL</span><span class="p">]</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="p">[</span><span class="k">IF</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">EXISTS</span><span class="p">]</span><span class="w"> </span><span class="k">table_name</span><span class="w">
</span><span class="w"></span><span class="p">[(</span><span class="n">col_name</span><span class="w"> </span><span class="n">data_type</span><span class="w"> </span><span class="p">[</span><span class="k">DEFAULT</span><span class="w"> </span><span class="n">value</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="k">COMMENT</span><span class="w"> </span><span class="n">col_comment</span><span class="p">],</span><span class="w"> </span><span class="p">...)]</span><span class="w">
</span><span class="w"></span><span class="p">[</span><span class="k">COMMENT</span><span class="w"> </span><span class="n">table_comment</span><span class="p">]</span><span class="w">
</span><span class="w"></span><span class="p">[</span><span class="n">PARTITIONED</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="p">(</span><span class="n">col_name</span><span class="w"> </span><span class="n">data_type</span><span class="w"> </span><span class="p">[</span><span class="k">COMMENT</span><span class="w"> </span><span class="n">col_comment</span><span class="p">],</span><span class="w"> </span><span class="p">...)]</span><span class="w">
</span><span class="w"></span><span class="p">[</span><span class="n">CLUSTERED</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="p">(</span><span class="n">col_name</span><span class="w"> </span><span class="p">[,</span><span class="w"> </span><span class="n">col_name</span><span class="p">,</span><span class="w"> </span><span class="p">...])</span><span class="w"> </span><span class="p">[</span><span class="n">SORTED</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="p">(</span><span class="n">col_name</span><span class="w"> </span><span class="p">[</span><span class="k">ASC</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="k">DESC</span><span class="p">]</span><span class="w"> </span><span class="p">[,</span><span class="w"> </span><span class="n">col_name</span><span class="w"> </span><span class="p">[</span><span class="k">ASC</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="k">DESC</span><span class="p">]</span><span class="w"> </span><span class="p">...])]</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">number_of_buckets</span><span class="w"> </span><span class="n">BUCKETS</span><span class="p">]</span><span class="w"> 
</span><span class="w"></span><span class="p">[</span><span class="n">STORED</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">StorageHandler</span><span class="p">]</span><span class="w"> </span><span class="c1">-- 仅限外部表
</span><span class="c1"></span><span class="p">[</span><span class="k">WITH</span><span class="w"> </span><span class="n">SERDEPROPERTIES</span><span class="w"> </span><span class="p">(</span><span class="k">Options</span><span class="p">)]</span><span class="w"> </span><span class="c1">-- 仅限外部表
</span><span class="c1"></span><span class="p">[</span><span class="k">LOCATION</span><span class="w"> </span><span class="n">OSSLocation</span><span class="p">];</span><span class="w"> </span><span class="c1">-- 仅限外部表
</span><span class="c1"></span><span class="p">[</span><span class="n">LIFECYCLE</span><span class="w"> </span><span class="n">days</span><span class="p">]</span><span class="w">
</span><span class="w"></span><span class="p">[</span><span class="k">AS</span><span class="w"> </span><span class="n">select_statement</span><span class="p">]</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>Method 2: Copy directly from an existing table</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="p">[</span><span class="k">IF</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">EXISTS</span><span class="p">]</span><span class="w"> </span><span class="k">table_name</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="n">existing_table_name</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>The following is an explanation of the key declarations.</p>
<ul>
<li>[EXTERNAL]: declared as an external table, often declared when the table needs to be shared by multiple tools, external table deletion will not delete data, only metadata.</li>
<li>col_name datatype: data_type must be strictly defined to avoid the lazy practice of using string for bigint, double, etc., otherwise the data will be wrong some day. (A colleague in the team has made this mistake)</li>
<li>[if not exists]: if not specified when creating, an error will be returned if a table with the same name exists. Specify this option to ignore subsequent tables with the same name if they exist, and create them if they don&rsquo;t.</li>
<li>[DEFAULT value]: Specify the default value for the column, which is written to the default value when the INSERT operation does not specify the column.</li>
<li>[PARTITIONED BY]: Specifies the partition field of the table. When partitioning a table using the partition field, adding a new partition, updating data within the partition and reading data from the partition do not require a full table scan, which can improve processing efficiency.</li>
<li>[LIFECYCLE]: is the life cycle of the table, partitioned tables have the same life cycle as the table life cycle for each partition</li>
<li>[AS select_statement]: means that data can be inserted directly with the select statement</li>
</ul>
<p>Simple example: Create a table sale_detail to hold sales records, which uses sale_date and sale_region as partition columns.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">create</span><span class="w"> </span><span class="k">table</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="k">exists</span><span class="w"> </span><span class="n">sale_detail</span><span class="w">
</span><span class="w"></span><span class="p">(</span><span class="w">
</span><span class="w"></span><span class="n">shop_name</span><span class="w">     </span><span class="n">string</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="n">customer_id</span><span class="w">   </span><span class="n">string</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="n">total_price</span><span class="w">   </span><span class="n">double</span><span class="w">
</span><span class="w"></span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="n">partitioned</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="p">(</span><span class="n">sale_date</span><span class="w"> </span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="n">region</span><span class="w"> </span><span class="n">string</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>A successfully created table can be viewed as defined by the following desc</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">desc</span><span class="w"> </span><span class="o">&lt;</span><span class="k">table_name</span><span class="o">&gt;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">desc</span><span class="w"> </span><span class="n">extended</span><span class="w"> </span><span class="o">&lt;</span><span class="k">table_name</span><span class="o">&gt;</span><span class="p">;</span><span class="w"> </span><span class="c1">--查看外部表信息。
</span></code></pre></td></tr></table>
</div>
</div><p>If you do not remember the full table name, you can look it up within the db (database) by using show tables.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="n">use</span><span class="w"> </span><span class="n">db_name</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">show</span><span class="w"> </span><span class="n">tables</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;tb.*&#39;</span><span class="p">);</span><span class="w"> </span><span class="c1">--- tb.* 为正则表达式
</span></code></pre></td></tr></table>
</div>
</div><p><strong>Hive delete table statement format</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">DROP</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="p">[</span><span class="k">IF</span><span class="w"> </span><span class="k">EXISTS</span><span class="p">]</span><span class="w"> </span><span class="k">table_name</span><span class="p">;</span><span class="w">  </span><span class="c1">--- 删除表
</span><span class="c1"></span><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="k">table_name</span><span class="w"> </span><span class="k">DROP</span><span class="w"> </span><span class="p">[</span><span class="k">IF</span><span class="w"> </span><span class="k">EXISTS</span><span class="p">]</span><span class="w"> </span><span class="n">PARTITION</span><span class="w"> </span><span class="p">(</span><span class="n">partition_col1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">partition_col_value1</span><span class="p">,</span><span class="w">  </span><span class="p">...);</span><span class="w"> </span><span class="c1">--- 删除某分区
</span></code></pre></td></tr></table>
</div>
</div><p><strong>Hive change table definition statement format</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="k">table_name</span><span class="w"> </span><span class="k">RENAME</span><span class="w"> </span><span class="k">TO</span><span class="w"> </span><span class="n">table_name_new</span><span class="p">;</span><span class="w">  </span><span class="c1">--- 重命名表
</span><span class="c1"></span><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="k">table_name</span><span class="w"> </span><span class="k">ADD</span><span class="w"> </span><span class="p">[</span><span class="k">IF</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">EXISTS</span><span class="p">]</span><span class="w"> </span><span class="n">PARTITION</span><span class="w"> </span><span class="p">(</span><span class="n">partition_col1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">partition_col_value1</span><span class="w"> </span><span class="p">...);</span><span class="w">  </span><span class="c1">--- 增加分区
</span><span class="c1"></span><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="k">table_name</span><span class="w"> </span><span class="k">ADD</span><span class="w"> </span><span class="n">COLUMNS</span><span class="w"> </span><span class="p">(</span><span class="n">col_name1</span><span class="w"> </span><span class="n">type1</span><span class="w"> </span><span class="k">comment</span><span class="w"> </span><span class="s1">&#39;XXX&#39;</span><span class="p">);</span><span class="w">  </span><span class="c1">--- 增加列，同时定义类型与注释
</span><span class="c1"></span><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="k">table_name</span><span class="w"> </span><span class="n">CHANGE</span><span class="w"> </span><span class="k">COLUMN</span><span class="w"> </span><span class="n">old_col_name</span><span class="w"> </span><span class="n">new_col_name</span><span class="w"> </span><span class="n">column_type</span><span class="w"> </span><span class="k">COMMENT</span><span class="w"> </span><span class="n">column_comment</span><span class="p">;</span><span class="w">  </span><span class="c1">--- 修改列名和注释
</span><span class="c1"></span><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="k">table_name</span><span class="w"> </span><span class="k">SET</span><span class="w"> </span><span class="n">lifecycle</span><span class="w"> </span><span class="n">days</span><span class="p">;</span><span class="w">  </span><span class="c1">--- 修改生命周期
</span></code></pre></td></tr></table>
</div>
</div><h3 id="hive-operation-statements">Hive operation statements</h3>
<p>Hive insert statement format.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">INSERT</span><span class="w"> </span><span class="n">OVERWRITE</span><span class="o">|</span><span class="k">INTO</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">tablename</span><span class="w"> </span><span class="p">[</span><span class="n">PARTITION</span><span class="w"> </span><span class="p">(</span><span class="n">partcol1</span><span class="o">=</span><span class="n">val1</span><span class="p">...]</span><span class="w">
</span><span class="w"></span><span class="n">select_statement</span><span class="w">
</span><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">from_statement</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>The following is an explanation of the key declarative statements.</p>
<ul>
<li>into|overwrite: into- appends data directly to a table or partition of a table; clears the table of existing data before inserting data into the table or partition.</li>
<li>[PARTITION (partcol1=val1&hellip;]: expressions such as functions are not allowed, only constants.</li>
</ul>
<p>About PARTITION: Specified partition inserts and dynamic partition inserts are explained here</p>
<ul>
<li>Output to the specified partition: Specify the partition value directly in the INSERT statement and insert the data into the specified partition.</li>
<li>Output to dynamic partition: Instead of specifying the partition value directly in the INSERT statement, only the partition column name is specified. The value of the partition column is provided in the SELECT clause and the system automatically inserts the data into the corresponding partition based on the value of the partition field.</li>
</ul>
<h3 id="hive-sql-optimisation">HIVE SQL Optimisation</h3>
<p><strong>Column Trimming</strong></p>
<p>For example, if a table has five fields a,b,c,d,e, but we only need a and b, then use select a,b from table instead of select * from table</p>
<p><strong>Partition Trimming</strong></p>
<p>Reduce unnecessary partitioning during the query, i.e. try to specify partitions</p>
<p><strong>small tables before large tables after</strong></p>
<p>When writing code statements with joins, tables/subqueries with few entries should be placed before the join operator</p>
<p>Because the table to the left of the join operator will be loaded into memory first during the Reduce phase, loading a table with fewer entries can effectively prevent an overflow of memory (OOM). So for the same key, the smaller value is put first and the larger one is put second</p>
<p><strong>Avoid using distinct as much as possible</strong></p>
<p>Try to avoid using distinct for reordering, especially for large tables, which are prone to data skewing (key like in a reduce process). Use group by instead.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">select</span><span class="w"> </span><span class="k">distinct</span><span class="w"> </span><span class="k">key</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">a</span><span class="w">
</span><span class="w"></span><span class="k">select</span><span class="w"> </span><span class="k">key</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">group</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="k">key</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div>
    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/hive/">hive</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-01/docker-mysql/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Docker install mysql</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-01/android-interfaces-for-any-screen-size/">
            <span class="next-text nav-default">Building Android interfaces for any screen size</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
