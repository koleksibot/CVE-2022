<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>An interesting problem with the Lua next function - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Anyone familiar with Lua knows that Lua allows you to modify and delete elements in a for ... pairs loop. pairs` loops to modify and delete elements in a table. There is nothing wrong with the following code:
1 2 3 4 5 6  local t = {a = 1, b = 2, c = 3} for k, v in pairs(t) do if v == 1 then t[k] = nil end end   However, if we delete elements and add new elements while traversing, there will be a problem." /><meta name="keywords" content="Lua, next" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-01/lua-next/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="An interesting problem with the Lua next function" />
<meta property="og:description" content="Anyone familiar with Lua knows that Lua allows you to modify and delete elements in a for ... pairs loop. pairs` loops to modify and delete elements in a table. There is nothing wrong with the following code:
1 2 3 4 5 6  local t = {a = 1, b = 2, c = 3} for k, v in pairs(t) do if v == 1 then t[k] = nil end end   However, if we delete elements and add new elements while traversing, there will be a problem." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-01/lua-next/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-01-03T11:34:05+08:00" />
<meta property="article:modified_time" content="2022-01-03T11:34:05+08:00" />

<meta itemprop="name" content="An interesting problem with the Lua next function">
<meta itemprop="description" content="Anyone familiar with Lua knows that Lua allows you to modify and delete elements in a for ... pairs loop. pairs` loops to modify and delete elements in a table. There is nothing wrong with the following code:
1 2 3 4 5 6  local t = {a = 1, b = 2, c = 3} for k, v in pairs(t) do if v == 1 then t[k] = nil end end   However, if we delete elements and add new elements while traversing, there will be a problem."><meta itemprop="datePublished" content="2022-01-03T11:34:05+08:00" />
<meta itemprop="dateModified" content="2022-01-03T11:34:05+08:00" />
<meta itemprop="wordCount" content="2465">
<meta itemprop="keywords" content="lua," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="An interesting problem with the Lua next function"/>
<meta name="twitter:description" content="Anyone familiar with Lua knows that Lua allows you to modify and delete elements in a for ... pairs loop. pairs` loops to modify and delete elements in a table. There is nothing wrong with the following code:
1 2 3 4 5 6  local t = {a = 1, b = 2, c = 3} for k, v in pairs(t) do if v == 1 then t[k] = nil end end   However, if we delete elements and add new elements while traversing, there will be a problem."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">An interesting problem with the Lua next function</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-01-03 11:34:05 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 2465 words </span>
          <span class="more-meta"> 12 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#puzzling-behavior">Puzzling behavior</a></li>
        <li><a href="#implementation-of-next-function">Implementation of next function</a></li>
        <li><a href="#luas-gc-mechanism">Lua&rsquo;s GC mechanism</a></li>
        <li><a href="#conclusion">Conclusion</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>Anyone familiar with Lua knows that Lua allows you to modify and delete elements in a <code>for ... pairs</code> loop. pairs` loops to modify and delete elements in a table. There is nothing wrong with the following code:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="kd">local</span> <span class="n">t</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">}</span>
<span class="kr">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="kr">in</span> <span class="n">pairs</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="kr">do</span>
    <span class="kr">if</span> <span class="n">v</span> <span class="o">==</span> <span class="mi">1</span> <span class="kr">then</span>
        <span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="kc">nil</span>
    <span class="kr">end</span>
<span class="kr">end</span>
</code></pre></td></tr></table>
</div>
</div><p>However, if we delete elements and add new elements while traversing, there will be a problem. For example:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="kd">local</span> <span class="n">t</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">}</span>
<span class="kr">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="kr">in</span> <span class="n">pairs</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="kr">do</span>
    <span class="kr">if</span> <span class="n">v</span> <span class="o">==</span> <span class="mi">1</span> <span class="kr">then</span>
        <span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="kc">nil</span>
        <span class="n">t</span><span class="p">[</span><span class="n">k</span> <span class="o">..</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="kr">end</span>
<span class="kr">end</span>
</code></pre></td></tr></table>
</div>
</div><p>Running the above code will give you this error:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">invalid key to &#39;next&#39;
stack traceback:
        [C]: in function &#39;next&#39;
        stdin:1: in main chunk
        [C]: in ?
</code></pre></td></tr></table>
</div>
</div><p>Anyone familiar with Lua will be familiar with this error. The solution is to avoid adding new elements to the table during the traversal. The <a href="https://www.lua.org/manual/5.3/manual.html#pdf-next">official Lua documentation</a> also makes it clear: if any value is assigned to a field in the table that does not exist during the traversal, the behavior of <code>next</code> is undefined. But the error itself is interesting, as it involves many aspects of Lua&rsquo;s mechanics, and I think it&rsquo;s a good opportunity to understand Lua&rsquo;s internal implementation.</p>
<h2 id="puzzling-behavior">Puzzling behavior</h2>
<p>Why is it interesting? First of all this error doesn&rsquo;t always occur (the documentation also says &ldquo;behavior undefined&rdquo;), for example the following code doesn&rsquo;t have this problem:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="kd">local</span> <span class="n">t</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="mi">6</span><span class="p">}</span>
<span class="kr">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="kr">in</span> <span class="n">pairs</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="kr">do</span>
    <span class="kr">if</span> <span class="n">v</span> <span class="o">==</span> <span class="mi">1</span> <span class="kr">then</span>
        <span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="kc">nil</span>
        <span class="n">t</span><span class="p">[</span><span class="n">k</span> <span class="o">..</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="kr">end</span>
<span class="kr">end</span>
</code></pre></td></tr></table>
</div>
</div><p>On the other hand, we know that the <code>for ... pairs</code> loop essentially calls <code>next</code> at each iteration, passing in the table and the key of the previous iteration to get the key-value pair for the current loop.pairs loop is essentially calling <code>next</code> at each iteration, passing in the table and the key of the previous iteration, and getting the key-value pair of the current loop. The meaning of the <code>next(t, k)</code> function is that, for a given table <code>t</code>, it returns the next key-value pair adjacent to the given key <code>k</code>. If <code>k</code> is the last element of <code>t</code>, then <code>nil</code> is returned; if <code>k</code> is <code>nil</code>, then the first element of <code>t</code> is returned. What if <code>k</code> is not in <code>t</code>? Naturally, an error should be reported:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">&gt; next({a = 1, b = 2}, &#39;c&#39;)
invalid key to &#39;next&#39;
stack traceback:
        [C]: in function &#39;next&#39;
        stdin:1: in main chunk
        [C]: in ?
</code></pre></td></tr></table>
</div>
</div><p>The familiar error. In that case, the code at the beginning of this article should also report an error, because when <code>v</code> equals 1, the corresponding key is deleted, causing the next iteration to call <code>next</code> to try to find the next element for a key that does not exist in the table. But not only does it work, the following code also works:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="kd">local</span> <span class="n">t</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">}</span>
<span class="n">print</span><span class="p">(</span><span class="n">next</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">))</span> <span class="c1">-- b    2</span>
<span class="n">t.a</span> <span class="o">=</span> <span class="kc">nil</span>
<span class="n">print</span><span class="p">(</span><span class="n">next</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">))</span> <span class="c1">-- b    2</span>
</code></pre></td></tr></table>
</div>
</div><p>The second <code>next</code> call returns normally, as if <code>a</code> were still in <code>t</code>. The error occurs when we delete and then insert a new element:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="kd">local</span> <span class="n">t</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">}</span>
<span class="n">print</span><span class="p">(</span><span class="n">next</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">))</span> <span class="c1">-- b    2</span>
<span class="n">t.a</span> <span class="o">=</span> <span class="kc">nil</span>
<span class="n">t.a1</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">print</span><span class="p">(</span><span class="n">next</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">))</span> <span class="c1">-- error: invalid key to &#39;next&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p>Of course there&rsquo;s more fun, to get this error, you don&rsquo;t have to insert a new element, sometimes it comes out with a GC:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="kd">local</span> <span class="n">k</span> <span class="o">=</span> <span class="s1">&#39;a&#39;</span><span class="o">..</span><span class="s1">&#39;b&#39;</span>
<span class="kd">local</span> <span class="n">t</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">}</span>
<span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="kc">nil</span>
<span class="n">k</span> <span class="o">=</span> <span class="kc">nil</span>
<span class="n">collectgarbage</span><span class="p">(</span><span class="s2">&#34;collect&#34;</span><span class="p">)</span>
<span class="n">next</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="o">..</span><span class="s1">&#39;b&#39;</span><span class="p">)</span> <span class="c1">-- error: invalid key to &#39;next&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p>It&rsquo;s written in a strange way to accommodate certain Lua mechanisms. If you change the above code a bit, for example by changing <code>next(t, 'a'...' b')</code> to <code>next(t, 'ab')</code>, the error will not appear.</p>
<h2 id="implementation-of-next-function">Implementation of next function</h2>
<p>When calling <code>next(t, k)</code>, <code>k</code> should exist in <code>t</code>; but it seems to work if <code>k</code> has just been deleted. How can this be done? Let&rsquo;s look at the implementation of the <code>next</code> function:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* ltable.c */</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">findindex</span> <span class="p">(</span><span class="n">lua_State</span> <span class="o">*</span><span class="n">L</span><span class="p">,</span> <span class="n">Table</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="n">StkId</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ttisnil</span><span class="p">(</span><span class="n">key</span><span class="p">))</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  <span class="cm">/* first iteration */</span>
  <span class="n">i</span> <span class="o">=</span> <span class="n">arrayindex</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">sizearray</span><span class="p">)</span>  <span class="cm">/* is &#39;key&#39; inside array part? */</span>
    <span class="k">return</span> <span class="n">i</span><span class="p">;</span>  <span class="cm">/* yes; that&#39;s the index */</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">nx</span><span class="p">;</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">mainposition</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>  <span class="cm">/* check whether &#39;key&#39; is somewhere in the chain */</span>
      <span class="cm">/* key may be dead already, but it is ok to use it in &#39;next&#39; */</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">luaV_rawequalobj</span><span class="p">(</span><span class="n">gkey</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">key</span><span class="p">)</span> <span class="o">||</span>
            <span class="p">(</span><span class="n">ttisdeadkey</span><span class="p">(</span><span class="n">gkey</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">iscollectable</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
             <span class="n">deadvalue</span><span class="p">(</span><span class="n">gkey</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="o">==</span> <span class="n">gcvalue</span><span class="p">(</span><span class="n">key</span><span class="p">)))</span> <span class="p">{</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">cast_int</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">gnode</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>  <span class="cm">/* key index in hash table */</span>
        <span class="cm">/* hash elements are numbered after array ones */</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">sizearray</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">nx</span> <span class="o">=</span> <span class="n">gnext</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">nx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">luaG_runerror</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="s">&#34;invalid key to &#39;next&#39;&#34;</span><span class="p">);</span>  <span class="cm">/* key not found */</span>
      <span class="k">else</span> <span class="n">n</span> <span class="o">+=</span> <span class="n">nx</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">luaH_next</span> <span class="p">(</span><span class="n">lua_State</span> <span class="o">*</span><span class="n">L</span><span class="p">,</span> <span class="n">Table</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="n">StkId</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">findindex</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>  <span class="cm">/* find original element */</span>
  <span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">sizearray</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>  <span class="cm">/* try first array part */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ttisnil</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>  <span class="cm">/* a non-nil value? */</span>
      <span class="n">setivalue</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
      <span class="n">setobj2s</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">key</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
      <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">-=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">sizearray</span><span class="p">;</span> <span class="n">cast_int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">sizenode</span><span class="p">(</span><span class="n">t</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>  <span class="cm">/* hash part */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ttisnil</span><span class="p">(</span><span class="n">gval</span><span class="p">(</span><span class="n">gnode</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="p">))))</span> <span class="p">{</span>  <span class="cm">/* a non-nil value? */</span>
      <span class="n">setobj2s</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">gkey</span><span class="p">(</span><span class="n">gnode</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="p">)));</span>
      <span class="n">setobj2s</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">key</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">gval</span><span class="p">(</span><span class="n">gnode</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="p">)));</span>
      <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  <span class="cm">/* no more elements */</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>You can see that <code>luaH_next</code> first calls <code>findindex</code> to find the position of a given <code>key</code> in table <code>t</code>, and then looks backwards from that position to the next element. In <code>findindex</code>, several things are done:</p>
<ul>
<li>Line 5 determines that if <code>key</code> is <code>nil</code>, it returns 0;</li>
<li>Lines 6 to 8, if <code>key</code> is a positive integer and is in the array field, return the array index;</li>
<li>Otherwise, look in the hash field. First line 11 gets the primary location of <code>key</code>;</li>
<li>In the loop from line 12 to 25, lines 14 to 16 check if the value of the current position is equal to <code>key</code>, if so, the lookup succeeds, line 19 returns directly; otherwise, line 21 checks the next position;</li>
<li>If the node equal to <code>key</code> is not found until the end of the chain, the search fails and an error <code>invalid key to 'next'</code> is thrown on line 23.</li>
</ul>
<p>As we saw earlier, calling <code>next</code> immediately after an element is set to <code>nil</code>, returns it normally. This means that <code>findindex</code> has successfully found the position of the element. Notice the comment on line 13: &ldquo;key may be dead already, but it is ok to use it in &lsquo;next&rsquo;&rdquo;, which means that a deleted key is fine for <code>next</code>? With this in mind, let&rsquo;s first see what happens when we execute <code>t[k] = nil</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* lvm.h */</span>

<span class="cp">#define luaV_fastset(L,t,k,slot,f,v) \
</span><span class="cp">  (!ttistable(t) \
</span><span class="cp">   ? (slot = NULL, 0) \
</span><span class="cp">   : (slot = f(hvalue(t), k), \
</span><span class="cp">     ttisnil(slot) ? 0 \
</span><span class="cp">     : (luaC_barrierback(L, hvalue(t), v), \
</span><span class="cp">        setobj2t(L, cast(TValue *,slot), v), \
</span><span class="cp">        1)))
</span><span class="cp"></span>
<span class="cm">/* lvm.c */</span>

<span class="cp">#define settableProtected(L,t,k,v) { const TValue *slot; \
</span><span class="cp">  if (!luaV_fastset(L,t,k,slot,luaH_get,v)) \
</span><span class="cp">    Protect(luaV_finishset(L,t,k,v,slot)); }
</span><span class="cp"></span>
<span class="kt">void</span> <span class="nf">luaV_execute</span> <span class="p">(</span><span class="n">lua_State</span> <span class="o">*</span><span class="n">L</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="cm">/* main loop of interpreter */</span>
  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="n">Instruction</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">StkId</span> <span class="n">ra</span><span class="p">;</span>
    <span class="n">vmfetch</span><span class="p">();</span>
    <span class="n">vmdispatch</span> <span class="p">(</span><span class="n">GET_OPCODE</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
      <span class="p">...</span>
      <span class="n">vmcase</span><span class="p">(</span><span class="n">OP_SETTABLE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">TValue</span> <span class="o">*</span><span class="n">rb</span> <span class="o">=</span> <span class="n">RKB</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="n">TValue</span> <span class="o">*</span><span class="n">rc</span> <span class="o">=</span> <span class="n">RKC</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="n">settableProtected</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">ra</span><span class="p">,</span> <span class="n">rb</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
        <span class="n">vmbreak</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="p">...</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>We know that <code>t[k] = nil</code> executes the <code>OP_SETTABLE</code> instruction, so we find the <code>lvm.c</code> where the <code>luaV_execute</code> function executes <code>OP_SETTABLE</code>, which is lines 27 to 32 above, and see that it does several things:</p>
<ul>
<li>Get the operands, <code>ra</code> , <code>rb</code> , and <code>rc</code> for table, key, and value, respectively;</li>
<li>Line 30 calls the macro <code>settableProtected</code> ;</li>
<li>line 15 <code>settableProtected</code> first tries to call <code>luaV_fastset</code> ;</li>
<li><code>luaV_fastset</code> determines that <code>luaV_fastset</code> fails when <code>t</code> is not a table (line 4), or <code>k</code> is not in <code>t</code> (line 7), and returns 0. Otherwise, the value is assigned directly in line 9;</li>
<li>If <code>luaV_fastset</code> fails, then <code>luaV_finishset</code> is called instead at line 16.</li>
</ul>
<p>When we delete an element using <code>t[k] = nil</code>, <code>k</code> is obviously in <code>t</code>, so it will execute to line 9, assigning a value directly to <code>slot</code>. Notice that <code>slot</code> is actually the return value of <code>luaH_get</code>, which will be equal to the value of <code>k</code>. So when <code>t[k] = nil</code> is executed, it will only assign the value of <code>k</code> to <code>nil</code>, and will not change the key. This also gives the <code>next</code> function an opportunity to do so.</p>
<p>Let&rsquo;s go back to <code>luaH_next</code> . It does this in <code>findindex</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="n">luaV_rawequalobj</span><span class="p">(</span><span class="n">gkey</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">key</span><span class="p">)</span> <span class="o">||</span>
      <span class="p">(</span><span class="n">ttisdeadkey</span><span class="p">(</span><span class="n">gkey</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">iscollectable</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
       <span class="n">deadvalue</span><span class="p">(</span><span class="n">gkey</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="o">==</span> <span class="n">gcvalue</span><span class="p">(</span><span class="n">key</span><span class="p">)))</span> <span class="p">{</span>
    <span class="p">...</span>
</code></pre></td></tr></table>
</div>
</div><p>to determine if the current position is equal to <code>key</code>. If our key is not a GCObject, such as a number or a boolean, it can be accessed even if it is deleted, and <code>luaV_rawequalobj</code> always gives the correct result; even if the key is a GCObject, it can be compared properly as long as it is not GC&rsquo;d. However, if the position of the key is occupied by an element inserted later, the lookup will fail. This is why it is possible to get an error like &ldquo;invalid key to &lsquo;next&rsquo;&rdquo; when traversing both deleted and new elements.</p>
<p>When using the <code>for ... pairs</code> loop, you don&rsquo;t have to worry about the key being GC&rsquo;d, because the iterator always holds a reference to the current key. So in a <code>for ... pairs</code> loop, you can safely perform the delete operation.</p>
<h2 id="luas-gc-mechanism">Lua&rsquo;s GC mechanism</h2>
<p><code>(ttisdeadkey(gkey(n)) &amp;&amp; iscollectable(key) &amp;&amp; deadvalue(gkey(n)) == gcvalue(key))</code> is used to handle the case when the key is GC&rsquo;d. If the current location is a deadkey, and <code>key</code> is a GCObject, compare <code>deadvalue(gkey(n)) == gcvalue(key)</code> , i.e. compare the address of the key at the current location (i.e. <code>gkey(n)</code> ) and the incoming <code>key</code> to see if they are equal. So what is deadkey? This brings us to Lua&rsquo;s GC mechanism.</p>
<p>Lua GC works by stringing all the GCObjects into a chain; then periodically scanning and marking all the objects in the VM, and the ones that are not marked are the ones that need to be recycled. Let&rsquo;s look at the function that scans the table:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* lgc.c */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">traversestrongtable</span> <span class="p">(</span><span class="n">global_State</span> <span class="o">*</span><span class="n">g</span><span class="p">,</span> <span class="n">Table</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Node</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="o">*</span><span class="n">limit</span> <span class="o">=</span> <span class="n">gnodelast</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">sizearray</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>  <span class="cm">/* traverse array part */</span>
    <span class="n">markvalue</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">gnode</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>  <span class="cm">/* traverse hash part */</span>
    <span class="n">checkdeadkey</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ttisnil</span><span class="p">(</span><span class="n">gval</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span>  <span class="cm">/* entry is empty? */</span>
      <span class="n">removeentry</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>  <span class="cm">/* remove it */</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="n">lua_assert</span><span class="p">(</span><span class="o">!</span><span class="n">ttisnil</span><span class="p">(</span><span class="n">gkey</span><span class="p">(</span><span class="n">n</span><span class="p">)));</span>
      <span class="n">markvalue</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">gkey</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>  <span class="cm">/* mark key */</span>
      <span class="n">markvalue</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">gval</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>  <span class="cm">/* mark value */</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>To be precise, this is a function that scans non-weak tables. This function is relatively straightforward, and it does the following:</p>
<ul>
<li>Lines 6 to 7 scan the array fields, all marked;</li>
<li>Lines 8 to 17 scan the hash field, where:
<ul>
<li>lines 10 to 11 check if the value of the current position is <code>nil</code>, and if so, call <code>removeentry</code> ;</li>
<li>Otherwise lines 13 to 15 mark the key and value of the current location.</li>
</ul>
</li>
</ul>
<p>Objects that are not marked are reclaimed, so if the value of an element is <code>nil</code>, it will be reclaimed in this GC. But before it is reclaimed, <code>removeentry</code> is also called, and what does it do?</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* lobject.h */</span>

<span class="cp">#define settt_(o,t)	((o)-&gt;tt_=(t))
</span><span class="cp"></span>
<span class="cp">#define setdeadvalue(obj)	settt_(obj, LUA_TDEADKEY)
</span><span class="cp"></span>

<span class="cm">/* lgc.c */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">removeentry</span> <span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">lua_assert</span><span class="p">(</span><span class="n">ttisnil</span><span class="p">(</span><span class="n">gval</span><span class="p">(</span><span class="n">n</span><span class="p">)));</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">valiswhite</span><span class="p">(</span><span class="n">gkey</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span>
    <span class="n">setdeadvalue</span><span class="p">(</span><span class="n">wgkey</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>  <span class="cm">/* unused and unmarked key; remove it */</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>It will mark the key of the element as dead. Note that this marker actually sets the object&rsquo;s type <code>tt_</code> field to <code>LUA_TDEADKEY</code> . This way when calling <code>luaV_rawequalobj</code> to compare a deadkey with a regular object it always returns false. This way when <code>deadvalue(gkey(n)) == gcvalue(key)</code> is executed, the key of element <code>n</code> must have been GC&rsquo;d.</p>
<p>For table, function, thread, userdata, two objects are equal if and only if their addresses are equal. When an object is GC&rsquo;d, it doesn&rsquo;t have any references, so it can&rsquo;t be passed into <code>next</code>.</p>
<p>This is not the case with strings, where the equality of two strings depends on the content of the string, not on its address. So when a string is GC&rsquo;d, we can still construct a string that is equal to it, but with a different address. Passing the newly constructed string into <code>next</code>, will cause an error. In the previous example, the reason for using <code>'a'...' b'' is because we want him to construct a different object. Just change any of the ''a'...' b'</code> anywhere in it, then the string <code>ab'</code> will be in the constant table, so it won&rsquo;t be GC&rsquo;d; Lua has a short string reuse mechanism, so <code>'a'...' b'</code> and <code>'ab'</code> are actually the same object, so this error will not occur.</p>
<h2 id="conclusion">Conclusion</h2>
<p>I was surprised when I first discovered that <code>next</code> could pass in a key that had just been deleted, because a deleted key should be something like a wild pointer and should not be used anymore. But after a closer look, everything is fine. This made me feel the subtlety of Lua design once again. This little problem involves the Lua table implementation, the GC mechanism, the constant table mechanism, and short string reuse. It is rather boring to gnaw on Lua source code, so we can explore Lua implementation from some interesting phenomena.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/lua/">lua</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-01/lpeg/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Parsing syntax using LPeg</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-01/go-socket5/">
            <span class="next-text nav-default">Implementing a Socks5 Secure Proxy with Go</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
