<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>《Righting Software》 reading notes - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Righting software is a book published by Pearson in 2020 by Juval Löwy, and it was introduced in China this year.
I finished reading the part of the book that I cared about during the mid-autumn festival, and this article extracts some core ideas from it.
The author first summed up his decades of experience (first expressing his envy), and proposed a reliable software design method, called The Method (translated into Chinese as meta-method)." /><meta name="keywords" content="nerighting softwarety" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2021-09/righting-software-notes/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="《Righting Software》 reading notes" />
<meta property="og:description" content="Righting software is a book published by Pearson in 2020 by Juval Löwy, and it was introduced in China this year.
I finished reading the part of the book that I cared about during the mid-autumn festival, and this article extracts some core ideas from it.
The author first summed up his decades of experience (first expressing his envy), and proposed a reliable software design method, called The Method (translated into Chinese as meta-method)." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2021-09/righting-software-notes/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-09-24T15:36:05+08:00" />
<meta property="article:modified_time" content="2021-09-24T15:36:05+08:00" />

<meta itemprop="name" content="《Righting Software》 reading notes">
<meta itemprop="description" content="Righting software is a book published by Pearson in 2020 by Juval Löwy, and it was introduced in China this year.
I finished reading the part of the book that I cared about during the mid-autumn festival, and this article extracts some core ideas from it.
The author first summed up his decades of experience (first expressing his envy), and proposed a reliable software design method, called The Method (translated into Chinese as meta-method)."><meta itemprop="datePublished" content="2021-09-24T15:36:05+08:00" />
<meta itemprop="dateModified" content="2021-09-24T15:36:05+08:00" />
<meta itemprop="wordCount" content="3121">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="《Righting Software》 reading notes"/>
<meta name="twitter:description" content="Righting software is a book published by Pearson in 2020 by Juval Löwy, and it was introduced in China this year.
I finished reading the part of the book that I cared about during the mid-autumn festival, and this article extracts some core ideas from it.
The author first summed up his decades of experience (first expressing his envy), and proposed a reliable software design method, called The Method (translated into Chinese as meta-method)."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">《Righting Software》 reading notes</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-09-24 15:36:05 </span>
        
          <span class="more-meta"> 3121 words </span>
          <span class="more-meta"> 15 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#why-do-you-disagree-with-feature-based-splitting">Why do you disagree with feature-based splitting?</a>
          <ul>
            <li><a href="#services-are-difficult-to-reuse">Services are difficult to reuse</a></li>
            <li><a href="#excessive-numbers-or-excessive-size">Excessive numbers or excessive size</a></li>
            <li><a href="#client-side-bloat-coupling">Client-side bloat coupling</a></li>
            <li><a href="#logical-redundancy-due-to-high-number-of-services">Logical redundancy due to high number of services</a></li>
            <li><a href="#service-bloat-coupling">Service bloat coupling</a></li>
          </ul>
        </li>
        <li><a href="#why-do-you-disagree-with-domain-splitting">Why do you disagree with domain splitting?</a></li>
        <li><a href="#volatility-based-decomposition">Volatility-based decomposition</a></li>
        <li><a href="#be-a-little-more-specific">Be a little more specific</a></li>
        <li><a href="#open-vs-closed-architectures">Open vs. closed architectures</a>
          <ul>
            <li><a href="#open-architecture">Open Architecture</a></li>
            <li><a href="#closed-architecture">Closed Architecture</a></li>
            <li><a href="#semi-closed-and-semi-development-architecture">Semi-closed and semi-development architecture</a></li>
            <li><a href="#relaxing-the-rules-of-closed-architecture-a-bit">Relaxing the rules of closed architecture a bit</a></li>
          </ul>
        </li>
        <li><a href="#design-taboos">Design taboos</a></li>
        <li><a href="#composable-architecture-and-architecture-validation">Composable architecture and architecture validation</a></li>
        <li><a href="#cases">Cases</a></li>
        <li><a href="#summary">Summary</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>Righting software is a book published by Pearson in 2020 by Juval Löwy, and it was introduced in China this year.</p>
<p>I finished reading the part of the book that I cared about during the mid-autumn festival, and this article extracts some core ideas from it.</p>
<p>The author first summed up his decades of experience (first expressing his envy), and proposed a reliable software design method, called The Method (translated into Chinese as meta-method).</p>
<p>The Method = System Design + Project Design</p>
<p>The book is also divided into these two parts, System Design and Project Design.</p>
<p>First of all, Project Design, which is actually project planning, this part of most companies in project management training have science, is to split the project work tasks, draw a network diagram, find the critical path of iteration, and allocate different development resources for different stages. Take a look at this diagram and you&rsquo;ll basically understand.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/09/24/8b2a32d6a41a4fd8b8ec1dd3336aac3a.png" alt=""></p>
<p>Although the authors also put project management within the responsibilities of the architect, but <strong>these things are generally the project manager to do (many projects into the middle and late stages, the daily iterations actually do not need to do any analysis, are heaps of well)</strong>, the authors also did not put forward a bright point of view, this article will first ignore should not be much interest in this part, most of the company&rsquo;s project management approach is also relatively sloppy, routine to do based on the network scheduling companies are very few and far between.</p>
<p>System Design is more important to us, the daily work of front-line software developers and architects will more or less involve a little design. The section on System Design is the first half of the book, and the Chinese version is 102 pages long, so it&rsquo;s a quick read.</p>
<p>The microservice model is already the premise of the backend architecture model, and the most familiar view of microservice modeling is generally &ldquo;function-based&rdquo; or &ldquo;domain-based&rdquo; split microservices. The actual situation is that most front-line engineers are still clamoring for DDD, because the books on DDD are too hard to read. After that, I have the opportunity to write a popular article on DDD, it should not be so difficult.</p>
<p>This book is amazing, the author neither <strong>disagrees with splitting based on functionality nor domain splitting</strong>.</p>
<h2 id="why-do-you-disagree-with-feature-based-splitting">Why do you disagree with feature-based splitting?</h2>
<p>Five reasons are given here.</p>
<h3 id="services-are-difficult-to-reuse">Services are difficult to reuse</h3>
<p>For example, if you split three services A, B, and C, they look like three separate services, but when <strong>executing B, you actually need the client to access A first to get the parameters needed by B. To access C, you need to get some parameters from B first</strong> .</p>
<p>So A, B, and C are not independent services, they are a set of services, and you can&rsquo;t reuse any of them individually.</p>
<h3 id="excessive-numbers-or-excessive-size">Excessive numbers or excessive size</h3>
<p>We see this more in large companies, such as several large companies in China, the number of services are more than 10 w, <strong>like the scale of the people will be more happy to see these numbers</strong> . Some services are only a few thousand lines of code in total, to achieve a single function of simple logic.</p>
<p>There are also those who have not split, a single service of hundreds of thousands of lines ~ 100w lines of code, I have actually seen the service.</p>
<h3 id="client-side-bloat-coupling">Client-side bloat coupling</h3>
<p>The explosion in the number of services will make integration more difficult, and the client will become more complex as the number of services expands. The author doesn&rsquo;t mention BFF here, but <strong>BFF doesn&rsquo;t actually reduce the integration complexity, it just moves the part from client to BFF</strong>.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/09/24/0e3efdd6ab604507a1065e99756bf111.png" alt=""></p>
<p>The following graph shows the combined statistics of the lap complexity on the client side of a system based on functional splitting, after a period of iteration.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/09/24/3d57400bd63049b69e15627a5e1bcfcd.png" alt=""></p>
<p>The complexity of the modules is extremely unevenly distributed and there are many components, <strong>the Resources module here becomes large because of the number of back-end services</strong>.</p>
<h3 id="logical-redundancy-due-to-high-number-of-services">Logical redundancy due to high number of services</h3>
<p>The above exposes many services directly to the client, resulting in the need for each service to integrate authentication, authorization, scalability, transaction propagation, and so on and so forth.</p>
<p>This article actually has a BFF will be fine.</p>
<h3 id="service-bloat-coupling">Service bloat coupling</h3>
<p>If you don&rsquo;t want the client to access each service to implement the business, then you can have the client call only A, but A, B and C have to integrate themselves, such as this chain.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/09/24/def0a013185944bb97bfe7d28ab3384f.png" alt=""></p>
<p>This actually allows A to fulfill the integration role, which needs to prepare all the parameters needed for subsequent services, and the complexity of the integration falls on A.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/09/24/4d367bfea02d4cf19afc69d3046a3209.png" alt=""></p>
<p>If a workflow, transactional nature of the business is involved, then perhaps C will also be concerned with whether or not to call back for logical compensation when the process in A and B fails to execute.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/09/24/6e8ee5daf8cf4f6d897057d0f9f146b0.png" alt=""></p>
<p>The author gives another real-life example that if we were to build a house from the point of view of its function, then maybe the house would end up looking like this.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/09/24/0598847f03c34a3fabb92106fade8f02.png" alt=""></p>
<p>Create a module for each functional requirement. Just compare the real-world house design with the diagram here to see how ridiculous this design is.</p>
<h2 id="why-do-you-disagree-with-domain-splitting">Why do you disagree with domain splitting?</h2>
<p>Still the example of the house, if split by domain, then the probability will be divided into the following structure.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/09/24/21c9fe6d4de2464d8c7a517ba1537e2e.png" alt=""></p>
<p>The authors argue that <strong>if we were to implement sleep as a function under such modeling, then we would need to implement it all over again in each domain</strong> . (Here I actually think the analogy with software domains is slightly far-fetched)</p>
<p>The domain itself cannot operate independently, and to deliver it must be delivered in its entirety, so <strong>if you start with domain modeling, it will result in part of the domain being rebuilt over and over again</strong> . For example, if you get the kitchen done first, and later on when you do other modules, you find that there is a problem with the drain, then the kitchen needs to be torn down and rebuilt. And then later found that the electrical wiring problems, again need to tear down and rebuild. This will produce a lot of waste of resources, and this waste is hidden (this makes sense, if it is a relatively large project, the development phase of a few modules because of integration problems, repeatedly rework is indeed very common).</p>
<p>In addition ** unit testing in the field is basically useless, business requirements are the result of the joint action of different areas, even if a certain area of unit testing 100% pass**, ** can not guarantee that the business logic can run properly **. (Another point of view not quite the same as the conventional idea)</p>
<h2 id="volatility-based-decomposition">Volatility-based decomposition</h2>
<p>The 6-page paper <a href="https://www.win.tue.nl/~wstomv/edu/2ip30/references/criteria_for_modularization.pdf">criteria for modularization</a> by David Parnas in 1972  already contains most of the elements of modern software engineering, including encapsulation, information hiding, cohesion, modules, and loose coupling. This article points out that finding points of change is the key criterion for decomposition, and that functionality itself is not the key criterion for decomposition.</p>
<p>This is also the core point of the book &ldquo;righting software&rdquo;, a decomposition based on volatility (volatility). There is also a counter-intuitive point here: our architecture should not be designed according to requirements, <strong>because requirements are generally requirements for functionality, and following a step-by-step approach will only produce a &ldquo;function-based decomposition&rdquo; of the system</strong>.</p>
<p>Consider volatility from two perspectives.</p>
<ul>
<li>the requirements of the same customer, which change over time</li>
<li>the difference between the needs of different customers at the same moment</li>
</ul>
<p>In the book, these two aspects are called two separate axes, but I personally think it is more appropriate to say that the impact of time and space may be more appropriate ~</p>
<p>For example, the following is the same house over time, may produce changes in some elements, the</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/09/24/94e14b5be1e149d18d42aed3e030623b.png" alt=""></p>
<p>Furniture gets old to be replaced, appliances get old to be replaced, subsequent sale to someone else if the owner wants to change, one day the owner is unhappy may want to paint a wall appearance will change, and so on.</p>
<p>The following are the possible differences between different houses at the same moment.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/09/24/efc0d541a9c04ae8b2a5e3170e8eca52.png" alt=""></p>
<p>As in the case of the fickleness of the housing structure, the neighbors of different houses are certainly different, and different houses may be in different cities.</p>
<p>Any kind of fallibility can be classified into the first aspect (time) or the second aspect (space), and we analyze the project according to these two aspects (or axes). If not, then encapsulate that fallibility into module B; and then perhaps go on to ask ourselves, at the same moment, <strong>do all users have access to the same B</strong>? If not, then you need to continue to encapsulate that variability, forming A, B, C.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/09/24/8016eef00c964f3a81bfae481acfbebd.png" alt=""></p>
<p>When you receive the list of requirements, you should also note that some requirements describe not a requirement, but a solution, such as <strong>cooking is not a requirement, eating is a requirement, cooking is just a solution, when doing variability analysis to convert these solutions, to find the root cause of the requirements, in order to analyze the variability to</strong> , such as cooking will be encapsulated into the eating component, the component is responsible for handling a variety of variability in eating (you can also not cook yourself, order take-out well).</p>
<p>The project design phase should list all the future variability of the project, such as a trading system, which has the following variability</p>
<ul>
<li>user volatility</li>
<li>Client program variability</li>
<li>Security volatility</li>
<li>Notification volatility</li>
<li>Storage volatility</li>
<li>Connection and synchronization variability</li>
<li>Duration and Device Volatility</li>
<li>Transaction Item Variability</li>
<li>Workflow Variability</li>
<li>Regional and Regulatory Volatility</li>
<li>Market information source variability</li>
</ul>
<p>Once you have the variables, you can design the system based on these variables, making sure that each variability is encapsulated in a module as much as possible, such as the structure given in the book.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/09/24/8d442faf305f4bd99cdfaa4e802da82c.png" alt=""></p>
<p>When designing the architecture, pay attention to <strong>the nature of the business itself is not supposed to be encapsulated</strong> , for example, you are engaged in the taxi business, you still want to do a set of microblogging in the same architecture, this is unlikely, the cost of iterating on the old architecture may be higher than the new set of all. The book also gives two criteria to judge.</p>
<ul>
<li>If a change is extremely rare and has a low probability of occurring, then it does not necessarily have to be encapsulated</li>
<li>If the attempt to encapsulate the change has a huge economic cost (that is, you design a system that costs the company a lot of money), then it should not be encapsulated either</li>
</ul>
<h2 id="be-a-little-more-specific">Be a little more specific</h2>
<p>The example structure given earlier is a very typical hierarchy given in this book.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/09/24/0aa0aa9c429245f5a4c8ddc963aa7245.png" alt=""></p>
<p>It goes without saying that the client, the business logic layer is divided into Manager and Engine layer, Manager is responsible for managing the process class volatility, Engine is responsible for the volatility of an activity node itself.</p>
<p>Process variability is well understood, that is, workflow (the author of this book should have a connection with the early WCF).</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/09/24/4314aff5946d4620a3d661c2b374ab25.png" alt=""></p>
<p>The two processes below are identical, except that the activities used in the second step are different. If B and D are doing the same thing, then B and D should be encapsulated in the same Engine.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/09/24/a193f329b31e468381b68d2e47435adb.png" alt=""></p>
<p>Of course, if the functions of B and D are not the same, then the two processes are not the same, another discussion.</p>
<p>Resource Access This layer is the resource access layer, responsible for some storage resource encapsulation, that is to say, when the company&rsquo;s infrastructure to change, should not affect the upper layer of business, this kind of DDD community also has Repo Pattern and so on, relatively good understanding.</p>
<p>Utilities, those purple components, are generally some common non-functional SDKs, also better understood.</p>
<p>Most of the modules in the architecture diagram are services.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/09/24/4395a57e76d1465f8393e10a9601effd.png" alt=""></p>
<p>Each of these stratifications addresses the four questions of Who, What, How, and Where.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/09/24/748bcda190e44ec6a1e061c5c4b4b634.png" alt=""></p>
<p><strong>From top to bottom, the ease of change is gradually decreasing</strong> , we can think about, the company most often modified are some of the business logic above, the underlying infrastructure changes once every few years is good.</p>
<p><strong>top-down reusability is gradually increasing, Manager often do changes, refactoring, completely rewritten, are quite normal.</strong></p>
<p>The authors here again critique hard the decomposition of microservices by function, leading to the problem of functional decomposition and service-oriented complexity without gaining any benefit from modularity. This double whammy is more than many enterprises can afford. The authors express concern that microservices will be the biggest failure in the history of software.</p>
<h2 id="open-vs-closed-architectures">Open vs. closed architectures</h2>
<h3 id="open-architecture">Open Architecture</h3>
<p>Any component can call any other component, regardless of the layer the component is on. Calls can be made upwards and downwards.</p>
<p>The development architecture has a lot of flexibility, but it obviously leads to coupling between layers, and lateral calls within layers lead to coupling within layers, which makes the project unmaintainable.</p>
<p>The authors believe that lateral calls are one of the consequences of the decomposition of the architecture by function.</p>
<h3 id="closed-architecture">Closed Architecture</h3>
<p>Closed architectures prohibit horizontal calls within layers and prohibit lower layers from calling higher layer systems. This takes the advantage of layering and decouples layers from each other. A closed architecture only allows components in one layer to call components in a lower adjacent layer. Components in lower layers encapsulate logic from lower layers.</p>
<h3 id="semi-closed-and-semi-development-architecture">Semi-closed and semi-development architecture</h3>
<p>It is sometimes difficult to avoid calling each other for critical parts of the infrastructure. Because infrastructure has performance issues to consider, maximum optimization must be performed, and sometimes down conversion can cause performance problems.</p>
<p>There are also systems that basically don&rsquo;t change much, and the coupling is coupled, so what do you care. The author here gives an example of a network stack is basically not much change in the code.</p>
<p>But most systems do not need to be half open and half closed, just closed.</p>
<h3 id="relaxing-the-rules-of-closed-architecture-a-bit">Relaxing the rules of closed architecture a bit</h3>
<p>Because the requirements of the closed architecture are so demanding, problems do occur in actual development, and can be relaxed as appropriate in the following cases.</p>
<ul>
<li>Calling utilities</li>
<li>accessing resource access by business logic, i.e., the manager layer calls the resource access layer directly</li>
<li>manager components calling less adjacent engines</li>
<li>manager component communicates with other manager components via MQ, in which case the manager component does not need to know about the other components, just send a message.</li>
</ul>
<h2 id="design-taboos">Design taboos</h2>
<p>The following actions are not allowed.</p>
<ul>
<li>client should not call multiple managers in a single use case</li>
<li>client should not call the engine directly</li>
<li>a manager should not wait for the return of multiple managers in the same use case, in which case the pub/sub model should be used</li>
<li>the engine should not subscribe to message queues</li>
<li>the resource access layer should not subscribe to message queues</li>
<li>client should not publish messages to the message queue</li>
<li>the engine should not publish messages</li>
<li>resource access should not publish messages</li>
<li>resource should also not publish messages</li>
<li>engines should not call each other</li>
<li>managers should not call each other</li>
</ul>
<h2 id="composable-architecture-and-architecture-validation">Composable architecture and architecture validation</h2>
<p>Here again, the counter-intuitive point is made, <strong>Must not design based on requirements, but rather on fallibility</strong> .</p>
<p>When designing a system, find the core requirements from the list of requirements, and after the design is complete, use the core use cases to validate the architecture first. For example, in the Trade system described in the book, the core use case is transaction aggregation.</p>
<p>When new requirements are added, there should be less need to change the architecture, which shows that the architecture is designed correctly.</p>
<p>The functionality in the system is the result of integration, not implementation. (A little abstract, want to see understand here or read the good).</p>
<h2 id="cases">Cases</h2>
<p>The last part of the system design gives the process of validating the relatively complete core use cases of the Trade system as described earlier on the design according to the fallibility.</p>
<p>First, the relevant concepts are listed according to the analytical framework of the previous four questions.</p>
<p>Who</p>
<ul>
<li>
<p>Technician</p>
</li>
<li>
<p>Contractor</p>
</li>
<li>
<p>TradeMe customer representative</p>
</li>
<li>
<p>Education Center</p>
</li>
<li>
<p>Back office program (i.e., scheduler for payment)</p>
</li>
<li>
<p>What</p>
</li>
<li>
<p>Tradesmen and Contractor Memberships</p>
</li>
<li>
<p>Construction projects marketplace</p>
</li>
<li>
<p>Education certificates and training</p>
</li>
<li>
<p>How</p>
</li>
<li>
<p>Search</p>
</li>
<li>
<p>Compliance</p>
</li>
<li>
<p>Access Resources</p>
</li>
<li>
<p>Where</p>
</li>
<li>
<p>Local Database</p>
</li>
<li>
<p>Cloud</p>
</li>
<li>
<p>Other systems</p>
</li>
</ul>
<p>The vulnerability is then analyzed and a list of vulnerabilities is made.</p>
<ul>
<li>Client applications</li>
<li>Managing members</li>
<li>Costs</li>
<li>Projects</li>
<li>Dispute Handling</li>
<li>Matching and Approval</li>
<li>Education</li>
<li>Regulations</li>
<li>Reporting</li>
<li>Localization</li>
<li>Resources</li>
<li>Resource Access</li>
<li>Deployment Model</li>
<li>Authentication and authorization</li>
</ul>
<p>In addition there are two relatively weak vulnerabilities.</p>
<ul>
<li>Notifications</li>
<li>Data analysis</li>
</ul>
<p>A reasonable mapping of the fallibilities results in a static architecture designed as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/09/24/a544cabd481d4e99a956bc8caf09e003.png" alt=""></p>
<p>Then identify the core use cases from the requirements, which are.</p>
<ul>
<li>Adding a mechanic/contractor use case</li>
<li>Request Mechanic use case</li>
<li>Matching mechanic use cases</li>
<li>Assign a mechanic use case</li>
<li>Terminate a mechanic use case</li>
<li>Pay for a mechanic use case</li>
</ul>
<p>With the swim lane diagram, it is possible to verify the core use cases one by one.</p>
<h2 id="summary">Summary</h2>
<p>The book &ldquo;righting software&rdquo; gives us a new way of thinking about designing system architecture, just by reading the author&rsquo;s description is more reliable than the previous functional decomposition and DDD, but <strong>considering the actual situation that domestic Internet companies even use or not to use DDD, the design method based on variability may be more difficult to be accepted</strong>.</p>
<p>The author did not pull a bunch of big brothers on board like the DDD community, despite decades of experience, but compared to those big brothers in the DDD community who can shout, this methodology should not be particularly well known, and the relevant practice cases should be relatively small. There is only one case in the book, and the second half of the book is about project management, which is a bit unfortunate.</p>
<p>During the reading process, I also combined with my previous development experience in the company and kept thinking about it, I can see that the author&rsquo;s theory should be able to be self-consistent without political influence.</p>
<p>There is one key problem with this theory, however, <strong>the possibility of architects missing variability in the process of fallibility analysis</strong>. This has happened in countless projects I&rsquo;ve seen before, where the architect has walked away and the front-line engineers are complaining about the architect&rsquo;s inability to design something to meet the new requirements.</p>
<p>If you are doing <strong>innovative business, you may be doing something disruptive all the time</strong>, it is still quite difficult to make a stable architecture through analysis.</p>
<p>The above is not mentioned first, the new point of view is still worth learning.</p>

    </div>

    
<footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/post/2021-09/react-16-error-boundaries/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Error Boundaries and Global Error Handling in React 16</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2021-09/netty-traffic-control/">
            <span class="next-text nav-default">Analyzing Netty Traffic Control from Occasional Downtime Events</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
