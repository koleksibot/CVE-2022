<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>golang netpoll Explained - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Computer io models are distinguished into a variety of, currently the most used is also nio, epoll, select. Combining different scenarios with different io models is the right solution. Network io in golang golang is naturally suited for concurrency, why? One is the lightweight concurrency, and the other is the abstraction of complex io, which simplifies the process. For example, if we simply access an http service, a few simple" /><meta name="keywords" content="Golang, Netpoll" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2021-09/golang-netpoll/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="golang netpoll Explained" />
<meta property="og:description" content="Computer io models are distinguished into a variety of, currently the most used is also nio, epoll, select. Combining different scenarios with different io models is the right solution. Network io in golang golang is naturally suited for concurrency, why? One is the lightweight concurrency, and the other is the abstraction of complex io, which simplifies the process. For example, if we simply access an http service, a few simple" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2021-09/golang-netpoll/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-09-24T11:24:15+08:00" />
<meta property="article:modified_time" content="2021-09-24T11:24:15+08:00" />

<meta itemprop="name" content="golang netpoll Explained">
<meta itemprop="description" content="Computer io models are distinguished into a variety of, currently the most used is also nio, epoll, select. Combining different scenarios with different io models is the right solution. Network io in golang golang is naturally suited for concurrency, why? One is the lightweight concurrency, and the other is the abstraction of complex io, which simplifies the process. For example, if we simply access an http service, a few simple"><meta itemprop="datePublished" content="2021-09-24T11:24:15+08:00" />
<meta itemprop="dateModified" content="2021-09-24T11:24:15+08:00" />
<meta itemprop="wordCount" content="3377">
<meta itemprop="keywords" content="golang," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="golang netpoll Explained"/>
<meta name="twitter:description" content="Computer io models are distinguished into a variety of, currently the most used is also nio, epoll, select. Combining different scenarios with different io models is the right solution. Network io in golang golang is naturally suited for concurrency, why? One is the lightweight concurrency, and the other is the abstraction of complex io, which simplifies the process. For example, if we simply access an http service, a few simple"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">golang netpoll Explained</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-09-24 11:24:15 </span>
        <div class="post-category">
            <a href="/categories/implementation-details/"> implementation-details </a>
            </div>
          <span class="more-meta"> 3377 words </span>
          <span class="more-meta"> 7 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#network-io-in-golang">Network io in golang</a></li>
        <li><a href="#groutinue-scheduling-for-io-events">groutinue Scheduling for io events</a></li>
        <li><a href="#netpoll">netpoll</a></li>
        <li><a href="#how-is-the-read-event-triggered">How is the read event triggered?</a></li>
        <li><a href="#summary">Summary</a></li>
        <li><a href="#remarks">Remarks</a>
          <ul>
            <li><a href="#epoll">epoll</a></li>
            <li><a href="#constants">Constants</a></li>
            <li><a href="#gc">gc</a></li>
            <li><a href="#sysmon">sysmon</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>Computer io models are distinguished into a variety of, currently the most used is also nio, epoll, select.</p>
<p>Combining different scenarios with different io models is the right solution.</p>
<h2 id="network-io-in-golang">Network io in golang</h2>
<p>golang is naturally suited for concurrency, why? One is the lightweight concurrency, and the other is the abstraction of complex io, which simplifies the process.</p>
<p>For example, if we simply access an http service, a few simple lines of code will do the trick:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">tr</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">recordingTransport</span><span class="p">{}</span>
<span class="nx">client</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Client</span><span class="p">{</span><span class="nx">Transport</span><span class="p">:</span> <span class="nx">tr</span><span class="p">}</span>
<span class="nx">url</span> <span class="o">:=</span> <span class="s">&#34;http://dummy.faketld/&#34;</span>
<span class="nx">client</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span> <span class="c1">// Note: doesn&#39;t hit network
</span></code></pre></td></tr></table>
</div>
</div><p>So what optimizations does golang make for Io? What about the ability to achieve such a simple switch?</p>
<h2 id="groutinue-scheduling-for-io-events">groutinue Scheduling for io events</h2>
<p>We assume here that you already have some knowledge of groutinue scheduling.</p>
<p>We know that in go, each process is bound to a virtual machine, and in the machine, it has a g0 that traverses its own queue locally to get g or gets g from the global queue.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/09/24/b6526812bc5647129a9639cb1f734e8e.png" alt=""></p>
<p>We also know that when g is running, g hands over execution to g0 for rescheduling, so how does g hand back events to g0 in io events? This is when it comes to our main character today &mdash;-netpoll.</p>
<h2 id="netpoll">netpoll</h2>
<p>The go language uses the I/O multiplexing model in the network poller to handle I/O operations, but it does not choose the most common system call, <code>select</code>. <code>select</code> can also provide I/O multiplexing capabilities, but there are more limitations to its use.</p>
<ul>
<li>Limited listening capability - can only listen to a maximum of 1024 file descriptors, which can be changed by manually modifying the limit, but at a relatively high cost in all respects.</li>
<li>High memory copy overhead - a larger data structure needs to be maintained to store the file descriptors, which needs to be copied to the kernel.</li>
<li>time complexity - after returning the number of ready events, all file descriptors need to be traversed.</li>
</ul>
<p>golang officially encapsulates a network event poll in a unified way, independent of platform, providing a specific implementation for epoll/kqueue/port/AIX/Windows.</p>
<ul>
<li><code>src/runtime/netpoll_epoll.go</code></li>
<li><code>src/runtime/netpoll_kqueue.go</code></li>
<li><code>src/runtime/netpoll_solaris.go</code></li>
<li><code>src/runtime/netpoll_windows.go</code></li>
<li><code>src/runtime/netpoll_aix.go</code></li>
<li><code>src/runtime/netpoll_fake.go</code></li>
</ul>
<p>These modules, which implement the same functionality on different platforms, form a common tree structure. When the compiler compiles a Go language program, it selects specific branches in the tree for compilation based on the target platform</p>
<p>The methods that must be implemented are</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">​netpollinit 初始化网络轮询器，通过 `sync.Once` 和 `netpollInited` 变量保证函数只会调用一次
​netpollopen 监听文件描述符上的边缘触发事件，创建事件并加入监听poll_runtime_pollOpen函数，这个函数将用户态协程的pollDesc信息写入到epoll所在的单独线程，从而实现用户态和内核态的关联。
​netpoll  轮询网络并返回一组已经准备就绪的 Goroutine，传入的参数会决定它的行为：
  - 如果参数小于0，阻塞等待文件就绪
  - 如果参数等于0，非阻塞轮询
  - 如果参数大于0，阻塞定期轮询
​netpollBreak 唤醒网络轮询器，例如：计时器向前修改时间时会通过该函数中断网络轮询器
​netpollIsPollDescriptor  判断文件描述符是否被轮询器使用
</code></pre></td></tr></table>
</div>
</div><p>There are 2 important structures in netpoll.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//pollCache  
</span><span class="c1">//pollDesc
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">pollDesc</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">link</span> <span class="o">*</span><span class="nx">pollDesc</span> <span class="c1">// in pollcache, protected by pollcache.lock
</span><span class="c1"></span>
	<span class="c1">// The lock protects pollOpen, pollSetDeadline, pollUnblock and deadlineimpl operations.
</span><span class="c1"></span>	<span class="c1">// This fully covers seq, rt and wt variables. fd is constant throughout the PollDesc lifetime.
</span><span class="c1"></span>	<span class="c1">// pollReset, pollWait, pollWaitCanceled and runtime·netpollready (IO readiness notification)
</span><span class="c1"></span>	<span class="c1">// proceed w/o taking the lock. So closing, everr, rg, rd, wg and wd are manipulated
</span><span class="c1"></span>	<span class="c1">// in a lock-free way by all operations.
</span><span class="c1"></span>	<span class="c1">// NOTE(dvyukov): the following code uses uintptr to store *g (rg/wg),
</span><span class="c1"></span>	<span class="c1">// that will blow up when GC starts moving objects.
</span><span class="c1"></span>	<span class="nx">lock</span>    <span class="nx">mutex</span> <span class="c1">// protects the following fields
</span><span class="c1"></span>	<span class="nx">fd</span>      <span class="kt">uintptr</span>
	<span class="nx">closing</span> <span class="kt">bool</span>
	<span class="nx">everr</span>   <span class="kt">bool</span>      <span class="c1">// marks event scanning error happened
</span><span class="c1"></span>	<span class="nx">user</span>    <span class="kt">uint32</span>    <span class="c1">// user settable cookie
</span><span class="c1"></span>	<span class="nx">rseq</span>    <span class="kt">uintptr</span>   <span class="c1">// protects from stale read timers
</span><span class="c1"></span>	<span class="nx">rg</span>      <span class="kt">uintptr</span>   <span class="c1">// pdReady, pdWait, G waiting for read or nil
</span><span class="c1"></span>	<span class="nx">rt</span>      <span class="nx">timer</span>     <span class="c1">// read deadline timer (set if rt.f != nil)
</span><span class="c1"></span>	<span class="nx">rd</span>      <span class="kt">int64</span>     <span class="c1">// read deadline
</span><span class="c1"></span>	<span class="nx">wseq</span>    <span class="kt">uintptr</span>   <span class="c1">// protects from stale write timers
</span><span class="c1"></span>	<span class="nx">wg</span>      <span class="kt">uintptr</span>   <span class="c1">// pdReady, pdWait, G waiting for write or nil
</span><span class="c1"></span>	<span class="nx">wt</span>      <span class="nx">timer</span>     <span class="c1">// write deadline timer
</span><span class="c1"></span>	<span class="nx">wd</span>      <span class="kt">int64</span>     <span class="c1">// write deadline
</span><span class="c1"></span>	<span class="nx">self</span>    <span class="o">*</span><span class="nx">pollDesc</span> <span class="c1">// storage for indirect interface. See (*pollDesc).makeArg.
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">pollCache</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">lock</span>  <span class="nx">mutex</span>
	<span class="nx">first</span> <span class="o">*</span><span class="nx">pollDesc</span>
	<span class="c1">// PollDesc objects must be type-stable,
</span><span class="c1"></span>	<span class="c1">// because we can get ready notification from epoll/kqueue
</span><span class="c1"></span>	<span class="c1">// after the descriptor is closed/reused.
</span><span class="c1"></span>	<span class="c1">// Stale notifications are detected using seq variable,
</span><span class="c1"></span>	<span class="c1">// seq is incremented when deadlines are changed or descript
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li><code>rseq</code> and <code>wseq</code> - indicate that the file descriptor is reused or the timer is reset.</li>
<li><code>rg</code> and <code>wg</code> - indicate binary semaphores, possibly <code>pdReady</code>, <code>pdWait</code>, goroutine waiting for the file descriptor to become readable or writable, and <code>nil</code>.</li>
<li><code>rd</code> and <code>wd</code> - deadlines for waiting for file descriptors to become readable or writable.</li>
<li><code>rt</code> and <code>wt</code> - timers for waiting for file descriptors.</li>
</ul>
<p>golang on io time to do a lot of unified encapsulation under runtime/netpoll (actually called under the internal/poll package), and then through the internal package to the runtime package to call, the internal package also encapsulates a pollDesc object of the same name, but is a pointer (there is a detail about the internal is that this package can not be called externally).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">pollDesc</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">runtimeCtx</span> <span class="kt">uintptr</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>In fact, it is ultimately a call under the runtime, but encapsulates some easy-to-use methods, such as read, write, and do some abstraction.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">runtime_pollServerInit</span><span class="p">()</span>  <span class="c1">//初始化
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">runtime_pollOpen</span><span class="p">(</span><span class="nx">fd</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">(</span><span class="kt">uintptr</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span>  <span class="c1">//打开
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">runtime_pollClose</span><span class="p">(</span><span class="nx">ctx</span> <span class="kt">uintptr</span><span class="p">)</span>   <span class="c1">//关闭
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">runtime_pollWait</span><span class="p">(</span><span class="nx">ctx</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">mode</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="c1">//等待
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">runtime_pollWaitCanceled</span><span class="p">(</span><span class="nx">ctx</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">mode</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>  <span class="c1">//等待并（失败时）退出
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">runtime_pollReset</span><span class="p">(</span><span class="nx">ctx</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">mode</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>  <span class="c1">//重置状态,复用
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">runtime_pollSetDeadline</span><span class="p">(</span><span class="nx">ctx</span> <span class="kt">uintptr</span><span class="p">,</span> <span class="nx">d</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">mode</span> <span class="kt">int</span><span class="p">)</span> <span class="c1">//设置读/写超时时间
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">runtime_pollUnblock</span><span class="p">(</span><span class="nx">ctx</span> <span class="kt">uintptr</span><span class="p">)</span>  <span class="c1">// 解锁 
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">runtime_isPollServerDescriptor</span><span class="p">(</span><span class="nx">fd</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">bool</span>  
<span class="c1">// 这里的ctx实际上是一个io fd，不是上下文
</span><span class="c1">// mod 是 r 或者 w  ,io事件毕竟只有有这两种
</span><span class="c1">// d 意义和time.d差不多，就是关于时间的
</span></code></pre></td></tr></table>
</div>
</div><p>The specific implementation of these methods is under runtime, so let&rsquo;s pick a few important ones.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//将就绪好得io事件，写入就绪的grotion对列
</span><span class="c1">// netpollready is called by the platform-specific netpoll function.
</span><span class="c1">// It declares that the fd associated with pd is ready for I/O.
</span><span class="c1">// The toRun argument is used to build a list of goroutines to return
</span><span class="c1">// from netpoll. The mode argument is &#39;r&#39;, &#39;w&#39;, or &#39;r&#39;+&#39;w&#39; to indicate
</span><span class="c1">// whether the fd is ready for reading or writing or both.
</span><span class="c1">//
</span><span class="c1">// This may run while the world is stopped, so write barriers are not allowed.
</span><span class="c1">//go:nowritebarrier
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">netpollready</span><span class="p">(</span><span class="nx">toRun</span> <span class="o">*</span><span class="nx">gList</span><span class="p">,</span> <span class="nx">pd</span> <span class="o">*</span><span class="nx">pollDesc</span><span class="p">,</span> <span class="nx">mode</span> <span class="kt">int32</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">rg</span><span class="p">,</span> <span class="nx">wg</span> <span class="o">*</span><span class="nx">g</span>
	<span class="k">if</span> <span class="nx">mode</span> <span class="o">==</span> <span class="sc">&#39;r&#39;</span> <span class="o">||</span> <span class="nx">mode</span> <span class="o">==</span> <span class="sc">&#39;r&#39;</span><span class="o">+</span><span class="sc">&#39;w&#39;</span> <span class="p">{</span>
		<span class="nx">rg</span> <span class="p">=</span> <span class="nf">netpollunblock</span><span class="p">(</span><span class="nx">pd</span><span class="p">,</span> <span class="sc">&#39;r&#39;</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">mode</span> <span class="o">==</span> <span class="sc">&#39;w&#39;</span> <span class="o">||</span> <span class="nx">mode</span> <span class="o">==</span> <span class="sc">&#39;r&#39;</span><span class="o">+</span><span class="sc">&#39;w&#39;</span> <span class="p">{</span>
		<span class="nx">wg</span> <span class="p">=</span> <span class="nf">netpollunblock</span><span class="p">(</span><span class="nx">pd</span><span class="p">,</span> <span class="sc">&#39;w&#39;</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">rg</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">toRun</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">rg</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">wg</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">toRun</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">wg</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//轮询时调用的方法，如果io就绪了返回ok，如果没就绪，返回flase
</span><span class="c1">// returns true if IO is ready, or false if timedout or closed
</span><span class="c1">// waitio - wait only for completed IO, ignore errors
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">netpollblock</span><span class="p">(</span><span class="nx">pd</span> <span class="o">*</span><span class="nx">pollDesc</span><span class="p">,</span> <span class="nx">mode</span> <span class="kt">int32</span><span class="p">,</span> <span class="nx">waitio</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">gpp</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">pd</span><span class="p">.</span><span class="nx">rg</span>
	<span class="k">if</span> <span class="nx">mode</span> <span class="o">==</span> <span class="sc">&#39;w&#39;</span> <span class="p">{</span>
		<span class="nx">gpp</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">pd</span><span class="p">.</span><span class="nx">wg</span>
	<span class="p">}</span>

	<span class="c1">// set the gpp semaphore to pdWait
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">old</span> <span class="o">:=</span> <span class="o">*</span><span class="nx">gpp</span>
		<span class="k">if</span> <span class="nx">old</span> <span class="o">==</span> <span class="nx">pdReady</span> <span class="p">{</span>
			<span class="o">*</span><span class="nx">gpp</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="k">return</span> <span class="kc">true</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">old</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: double wait&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Casuintptr</span><span class="p">(</span><span class="nx">gpp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">pdWait</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// need to recheck error states after setting gpp to pdWait
</span><span class="c1"></span>	<span class="c1">// this is necessary because runtime_pollUnblock/runtime_pollSetDeadline/deadlineimpl
</span><span class="c1"></span>	<span class="c1">// do the opposite: store to closing/rd/wd, membarrier, load of rg/wg
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">waitio</span> <span class="o">||</span> <span class="nf">netpollcheckerr</span><span class="p">(</span><span class="nx">pd</span><span class="p">,</span> <span class="nx">mode</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
	  <span class="c1">//gopark是很重要得一个方法，本质上是让出当前协程执行权，一般是返回到g0让g0重新调度
</span><span class="c1"></span>		<span class="nf">gopark</span><span class="p">(</span><span class="nx">netpollblockcommit</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">gpp</span><span class="p">),</span> <span class="nx">waitReasonIOWait</span><span class="p">,</span> <span class="nx">traceEvGoBlockNet</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// be careful to not lose concurrent pdReady notification
</span><span class="c1"></span>	<span class="nx">old</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xchguintptr</span><span class="p">(</span><span class="nx">gpp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">old</span> <span class="p">&gt;</span> <span class="nx">pdWait</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: corrupted polldesc&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">old</span> <span class="o">==</span> <span class="nx">pdReady</span>
<span class="p">}</span>

<span class="c1">//获取到当前io所在的协程，如果协程已关闭，直接返回nil
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">netpollunblock</span><span class="p">(</span><span class="nx">pd</span> <span class="o">*</span><span class="nx">pollDesc</span><span class="p">,</span> <span class="nx">mode</span> <span class="kt">int32</span><span class="p">,</span> <span class="nx">ioready</span> <span class="kt">bool</span><span class="p">)</span> <span class="o">*</span><span class="nx">g</span> <span class="p">{</span>
	<span class="nx">gpp</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">pd</span><span class="p">.</span><span class="nx">rg</span>
	<span class="k">if</span> <span class="nx">mode</span> <span class="o">==</span> <span class="sc">&#39;w&#39;</span> <span class="p">{</span>
		<span class="nx">gpp</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">pd</span><span class="p">.</span><span class="nx">wg</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">old</span> <span class="o">:=</span> <span class="o">*</span><span class="nx">gpp</span>
		<span class="k">if</span> <span class="nx">old</span> <span class="o">==</span> <span class="nx">pdReady</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">old</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">ioready</span> <span class="p">{</span>
			<span class="c1">// Only set pdReady for ioready. runtime_pollWait
</span><span class="c1"></span>			<span class="c1">// will check for timeout/cancel before waiting.
</span><span class="c1"></span>			<span class="k">return</span> <span class="kc">nil</span>
		<span class="p">}</span>
		<span class="kd">var</span> <span class="nx">new</span> <span class="kt">uintptr</span>
		<span class="k">if</span> <span class="nx">ioready</span> <span class="p">{</span>
			<span class="nx">new</span> <span class="p">=</span> <span class="nx">pdReady</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Casuintptr</span><span class="p">(</span><span class="nx">gpp</span><span class="p">,</span> <span class="nx">old</span><span class="p">,</span> <span class="nx">new</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">old</span> <span class="o">==</span> <span class="nx">pdWait</span> <span class="p">{</span>
				<span class="nx">old</span> <span class="p">=</span> <span class="mi">0</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="nx">g</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">old</span><span class="p">))</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Think about.</p>
<ol>
<li>a, b two co-processes, b io blocking, finished, has not obtained the scheduling rights, what will happen.</li>
<li>a, b two co-processes, b io blocking, 2s time out, but a has been occupying the execution rights, b has not obtained the scheduling rights, 5s before obtaining to, b to the use of the end has timed out, this time is time out or not time out</li>
</ol>
<p>So set the time out, not necessarily the real io waiting, may not get the right to execute.</p>
<h2 id="how-is-the-read-event-triggered">How is the read event triggered?</h2>
<p>Because write io is an active operation for us, how does read perform the operation? This is a passive state</p>
<p>First we understand a structure. golang identifies all network events and file reads and writes with fd (located under the internal package).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// FD is a file descriptor. The net and os packages use this type as a
</span><span class="c1">// field of a larger type representing a network connection or OS file.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">FD</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// Lock sysfd and serialize access to Read and Write methods.
</span><span class="c1"></span>	<span class="nx">fdmu</span> <span class="nx">fdMutex</span>

	<span class="c1">// System file descriptor. Immutable until Close.
</span><span class="c1"></span>	<span class="nx">Sysfd</span> <span class="kt">int</span>

	<span class="c1">// I/O poller.
</span><span class="c1"></span>	<span class="nx">pd</span> <span class="nx">pollDesc</span>

	<span class="c1">// Writev cache.
</span><span class="c1"></span>	<span class="nx">iovecs</span> <span class="o">*</span><span class="p">[]</span><span class="nx">syscall</span><span class="p">.</span><span class="nx">Iovec</span>

	<span class="c1">// Semaphore signaled when file is closed.
</span><span class="c1"></span>	<span class="nx">csema</span> <span class="kt">uint32</span>

	<span class="c1">// Non-zero if this file has been set to blocking mode.
</span><span class="c1"></span>	<span class="nx">isBlocking</span> <span class="kt">uint32</span>

	<span class="c1">// Whether this is a streaming descriptor, as opposed to a
</span><span class="c1"></span>	<span class="c1">// packet-based descriptor like a UDP socket. Immutable.
</span><span class="c1"></span>	<span class="nx">IsStream</span> <span class="kt">bool</span>

	<span class="c1">// Whether a zero byte read indicates EOF. This is false for a
</span><span class="c1"></span>	<span class="c1">// message based socket connection.
</span><span class="c1"></span>	<span class="nx">ZeroReadIsEOF</span> <span class="kt">bool</span>

	<span class="c1">// Whether this is a file rather than a network socket.
</span><span class="c1"></span>	<span class="nx">isFile</span> <span class="kt">bool</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>We see that the pollDesc associated with the fd calls the various platform io events implemented inside the runtime package through the pollDesc.</p>
<p>When we do a read operation (here is the code capture)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="p">{</span>
	<span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">ignoringEINTRIO</span><span class="p">(</span><span class="nx">syscall</span><span class="p">.</span><span class="nx">Read</span><span class="p">,</span> <span class="nx">fd</span><span class="p">.</span><span class="nx">Sysfd</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">n</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">EAGAIN</span> <span class="o">&amp;&amp;</span> <span class="nx">fd</span><span class="p">.</span><span class="nx">pd</span><span class="p">.</span><span class="nf">pollable</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">fd</span><span class="p">.</span><span class="nx">pd</span><span class="p">.</span><span class="nf">waitRead</span><span class="p">(</span><span class="nx">fd</span><span class="p">.</span><span class="nx">isFile</span><span class="p">);</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="k">continue</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">err</span> <span class="p">=</span> <span class="nx">fd</span><span class="p">.</span><span class="nf">eofError</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Will block the call waiteRead method, the method is mainly called inside the runtime_pollWait.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">poll_runtime_pollWait</span><span class="p">(</span><span class="nx">pd</span> <span class="o">*</span><span class="nx">pollDesc</span><span class="p">,</span> <span class="nx">mode</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">errcode</span> <span class="o">:=</span> <span class="nf">netpollcheckerr</span><span class="p">(</span><span class="nx">pd</span><span class="p">,</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">mode</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">errcode</span> <span class="o">!=</span> <span class="nx">pollNoError</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">errcode</span>
	<span class="p">}</span>
	<span class="c1">// As for now only Solaris, illumos, and AIX use level-triggered IO.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;solaris&#34;</span> <span class="o">||</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;illumos&#34;</span> <span class="o">||</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;aix&#34;</span> <span class="p">{</span>
		<span class="nf">netpollarm</span><span class="p">(</span><span class="nx">pd</span><span class="p">,</span> <span class="nx">mode</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">!</span><span class="nf">netpollblock</span><span class="p">(</span><span class="nx">pd</span><span class="p">,</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">mode</span><span class="p">),</span> <span class="kc">false</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">errcode</span> <span class="p">=</span> <span class="nf">netpollcheckerr</span><span class="p">(</span><span class="nx">pd</span><span class="p">,</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">mode</span><span class="p">))</span>
		<span class="k">if</span> <span class="nx">errcode</span> <span class="o">!=</span> <span class="nx">pollNoError</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">errcode</span>
		<span class="p">}</span>
		<span class="c1">// Can happen if timeout has fired and unblocked us,
</span><span class="c1"></span>		<span class="c1">// but before we had a chance to run, timeout has been reset.
</span><span class="c1"></span>		<span class="c1">// Pretend it has not happened and retry.
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">pollNoError</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Here is mainly controlled by netpollblock,netpollblock method we have said above, when the io is not yet ready, directly release the current execution rights, otherwise it is already read and write the io event, directly read the operation can be.</p>
<h2 id="summary">Summary</h2>
<p>Overall flow listenStream -&gt; bind&amp;listen&amp;init -&gt; pollDesc.Init -&gt; poll_runtime_pollOpen -&gt; runtime.netpollopen - &gt; epollctl(EPOLL_CTL_ADD)</p>
<p>Draw a diagram to understand more easily, of course, I was lazy to find the diagram</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/09/24/b068bfd61f21470c868696b75bf6f456.png" alt=""></p>
<p>When g io events are encountered in golang, they are encapsulated in a unified way, first establishing a system event (this article focuses on epoll), then giving up the cpu (gopark), and then executing other g&rsquo;s in a concurrent scheduling process. when the g io event is completed, it will interact with epoll to see if it is ready (epoll ready list), and if it is ready, pop will take out a g and execute it down the line. (Actually, there is some logic in the pop ready list, such as delayed processing)</p>
<p>runtime/proc.go.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Finds a runnable goroutine to execute.
</span><span class="c1">// Tries to steal from other P&#39;s, get g from local or global queue, poll network.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">findrunnable</span><span class="p">()</span> <span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">inheritTime</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="c1">// The conditions here and in handoffp must agree: if
</span><span class="c1"></span>	<span class="c1">// findrunnable would return a G to run, handoffp must start
</span><span class="c1"></span>	<span class="c1">// an M.
</span><span class="c1"></span>
<span class="nx">top</span><span class="p">:</span>
	<span class="nx">_p_</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
	<span class="c1">//......
</span><span class="c1"></span>	<span class="c1">// Poll network.
</span><span class="c1"></span>	<span class="c1">// This netpoll is only an optimization before we resort to stealing.
</span><span class="c1"></span>	<span class="c1">// We can safely skip it if there are no waiters or a thread is blocked
</span><span class="c1"></span>	<span class="c1">// in netpoll already. If there is any kind of logical race with that
</span><span class="c1"></span>	<span class="c1">// blocked thread (e.g. it has already returned from netpoll, but does
</span><span class="c1"></span>	<span class="c1">// not set lastpoll yet), this thread will do blocking netpoll below
</span><span class="c1"></span>	<span class="c1">// anyway.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">netpollinited</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">netpollWaiters</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lastpoll</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">list</span> <span class="o">:=</span> <span class="nf">netpoll</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="p">!</span><span class="nx">list</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// non-blocking
</span><span class="c1"></span>			<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">list</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
			<span class="nf">injectglist</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">list</span><span class="p">)</span>
			<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
				<span class="nf">traceGoUnpark</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="nx">gp</span><span class="p">,</span> <span class="kc">false</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">//......
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Also in sysmon, netpoll is scheduled.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Always runs without a P, so write barriers are not allowed.
</span><span class="c1">//
</span><span class="c1">//go:nowritebarrierrec
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">sysmon</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="nx">sched</span><span class="p">.</span><span class="nx">nmsys</span><span class="o">++</span>
	<span class="nf">checkdead</span><span class="p">()</span>
	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
	<span class="c1">//......
</span><span class="c1"></span>	<span class="c1">// poll network if not polled for more than 10ms
</span><span class="c1"></span>	<span class="nx">lastpoll</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lastpoll</span><span class="p">))</span>
	<span class="k">if</span> <span class="nf">netpollinited</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nx">lastpoll</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">lastpoll</span><span class="o">+</span><span class="mi">10</span><span class="o">*</span><span class="mi">1000</span><span class="o">*</span><span class="mi">1000</span> <span class="p">&lt;</span> <span class="nx">now</span> <span class="p">{</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lastpoll</span><span class="p">,</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">lastpoll</span><span class="p">),</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">now</span><span class="p">))</span>
		<span class="nx">list</span> <span class="o">:=</span> <span class="nf">netpoll</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// non-blocking - returns list of goroutines
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nx">list</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
			<span class="c1">// Need to decrement number of idle locked M&#39;s
</span><span class="c1"></span>			<span class="c1">// (pretending that one more is running) before injectglist.
</span><span class="c1"></span>			<span class="c1">// Otherwise it can lead to the following situation:
</span><span class="c1"></span>			<span class="c1">// injectglist grabs all P&#39;s but before it starts M&#39;s to run the P&#39;s,
</span><span class="c1"></span>			<span class="c1">// another M returns from syscall, finishes running its G,
</span><span class="c1"></span>			<span class="c1">// observes that there is no work to do and no other running M&#39;s
</span><span class="c1"></span>			<span class="c1">// and reports deadlock.
</span><span class="c1"></span>			<span class="nf">incidlelocked</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="nf">injectglist</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">list</span><span class="p">)</span>
			<span class="nf">incidlelocked</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">//......
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="remarks">Remarks</h2>
<h3 id="epoll">epoll</h3>
<p>epoll is a separate thread maintained by the system kernel, not by go itself</p>
<h3 id="constants">Constants</h3>
<p>FD_CLOEXEC is used to set the close-on-exec status criteria of the file. This, emm, is quite difficult to understand.</p>
<h3 id="gc">gc</h3>
<p>pollDesc is maintained by pollCache and is not monitored by GC (persistentalloc method allocation), so in the normal case about io operations, we must perform a manual shutdown to clean up the reference objects in epoll (specific implementation in poll_runtime_Semrelease).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Must be in non-GC memory because can be referenced
</span><span class="c1">// only from epoll/kqueue internals.
</span><span class="c1"></span><span class="nx">mem</span> <span class="o">:=</span> <span class="nf">persistentalloc</span><span class="p">(</span><span class="nx">n</span><span class="o">*</span><span class="nx">pdSize</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">memstats</span><span class="p">.</span><span class="nx">other_sys</span><span class="p">)</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
	<span class="nx">pd</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">pollDesc</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">mem</span><span class="p">,</span> <span class="nx">i</span><span class="o">*</span><span class="nx">pdSize</span><span class="p">))</span>
	<span class="nx">pd</span><span class="p">.</span><span class="nx">link</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">first</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">first</span> <span class="p">=</span> <span class="nx">pd</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="sysmon">sysmon</h3>
<p>Go&rsquo;s standard library provides a thread to monitor your application and help you (find) any bottlenecks your application may encounter. This thread is called sysmon, the system monitor. In the GMP model, this (special) thread is not linked to any P, which means that the scheduler does not take it into account, and is therefore always running.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/09/24/7ebb38990f984a3ba32ee88f3d43c0da.png" alt=""></p>
<p>The sysmon thread has a wide range of roles, mainly in the following areas:</p>
<ul>
<li>Timers (timers) created by the application. The sysmon thread looks at timers that should be running but are still waiting for execution time. In this case, Go will look at the list of idle M and P timers so that it can run them as fast as possible.</li>
<li><strong>Network pollers and system calls. It will run goroutines that are blocked during network operations.</strong></li>
<li>Garbage collector (if it has not been running for a long time). If the garbage collector has not run for two minutes, sysmon will force a round of garbage collection (GC).</li>
<li>Preemption of long-running goroutines. Any goroutine that runs for more than 10 milliseconds will be preempted, leaving the running time for other goroutines.</li>
</ul>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/golang/">golang</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2021-09/web-page-resource-integrity-checks/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Detailed Guide to Web Page Sub-resource Integrity Checks</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2021-09/gin-get-client-real-ip/">
            <span class="next-text nav-default">How to get the client&#39;s real IP, starting with a &#34;bug&#34; in Gin</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
