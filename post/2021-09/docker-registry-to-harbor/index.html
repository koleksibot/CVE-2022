<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>docker registry migration to harbor - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Registry Docker Distribution Docker Distribution is the first tool that implements packaging, distribution, storage and image distribution, acting as a Docker registry. (Currently Distribution has been donated to CNCF). The spec specification in Docker Distribution has since become the OCI distribution-spec specification. It can be assumed that Docker Distribution implements most of the OCI image distribution specifications, and that the two are largely compatible. OCI&amp;rsquo;s guiding philosophy is to have" /><meta name="keywords" content="docker, harbor" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2021-09/docker-registry-to-harbor/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="docker registry migration to harbor" />
<meta property="og:description" content="Registry Docker Distribution Docker Distribution is the first tool that implements packaging, distribution, storage and image distribution, acting as a Docker registry. (Currently Distribution has been donated to CNCF). The spec specification in Docker Distribution has since become the OCI distribution-spec specification. It can be assumed that Docker Distribution implements most of the OCI image distribution specifications, and that the two are largely compatible. OCI&rsquo;s guiding philosophy is to have" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2021-09/docker-registry-to-harbor/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-09-29T16:25:26+08:00" />
<meta property="article:modified_time" content="2021-09-29T16:25:26+08:00" />

<meta itemprop="name" content="docker registry migration to harbor">
<meta itemprop="description" content="Registry Docker Distribution Docker Distribution is the first tool that implements packaging, distribution, storage and image distribution, acting as a Docker registry. (Currently Distribution has been donated to CNCF). The spec specification in Docker Distribution has since become the OCI distribution-spec specification. It can be assumed that Docker Distribution implements most of the OCI image distribution specifications, and that the two are largely compatible. OCI&rsquo;s guiding philosophy is to have"><meta itemprop="datePublished" content="2021-09-29T16:25:26+08:00" />
<meta itemprop="dateModified" content="2021-09-29T16:25:26+08:00" />
<meta itemprop="wordCount" content="3404">
<meta itemprop="keywords" content="docker,harbor," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="docker registry migration to harbor"/>
<meta name="twitter:description" content="Registry Docker Distribution Docker Distribution is the first tool that implements packaging, distribution, storage and image distribution, acting as a Docker registry. (Currently Distribution has been donated to CNCF). The spec specification in Docker Distribution has since become the OCI distribution-spec specification. It can be assumed that Docker Distribution implements most of the OCI image distribution specifications, and that the two are largely compatible. OCI&rsquo;s guiding philosophy is to have"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">docker registry migration to harbor</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-09-29 16:25:26 </span>
        <div class="post-category">
            <a href="/categories/skills/"> skills </a>
            </div>
          <span class="more-meta"> 3404 words </span>
          <span class="more-meta"> 7 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#registry">Registry</a>
          <ul>
            <li><a href="#docker-distribution">Docker Distribution</a></li>
            <li><a href="#harbor">Harbor</a></li>
            <li><a href="#docker-registry-to-harbor">docker registry to harbor</a></li>
          </ul>
        </li>
        <li><a href="#get-a-list-of-all-mirrors-in-the-registry">Get a list of all mirrors in the registry</a></li>
        <li><a href="#harbor-create-project">harbor create project</a></li>
        <li><a href="#option-1-docker-retag">Option 1: docker retag</a></li>
        <li><a href="#option-2-skopeo">Option 2: skopeo</a></li>
        <li><a href="#option-3-migrate-the-storage-directory">Option 3: Migrate the storage directory</a></li>
        <li><a href="#option-4">Option 4</a>
          <ul>
            <li><a href="#skopeo-dir">skopeo dir</a></li>
            <li><a href="#retrieve-the-image-from-the-registry-storage-directory">Retrieve the image from the registry storage directory</a></li>
            <li><a href="#shell-script">Shell Script</a></li>
          </ul>
        </li>
        <li><a href="#contrast">Contrast</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="registry">Registry</h2>
<h3 id="docker-distribution">Docker Distribution</h3>
<p><a href="https://github.com/distribution/distribution">Docker Distribution</a> is the first tool that implements packaging, distribution, storage and image distribution, acting as a Docker registry. (Currently Distribution has been donated to CNCF). The <a href="https://github.com/distribution/distribution/tree/main/docs/spec">spec specification</a> in Docker Distribution has since become the OCI <a href="https://github.com/opencontainers/distribution-spec">distribution-spec</a> specification. It can be assumed that Docker Distribution implements most of the OCI image distribution specifications, and that the two are largely compatible. OCI&rsquo;s guiding philosophy is to have industry practices first and then summarize those practices into technical specifications, so while OCI&rsquo;s <a href="https://github.com/opencontainers/distribution-spec">distribution-spec</a> specification has not yet been officially released (the current version is <a href="https://github.com/opencontainers/distribution-spec/releases/tag/v1.0.0-rc1">v1.0.0-rc1</a>), the Docker Distribution-based image repository has become a commonly adopted solution. The Docker registry HTTP API V2 has become the de facto standard.</p>
<h3 id="harbor">Harbor</h3>
<p>Harbor also uses Docker Distribution (docker registry) as the back-end image storage service. In versions prior to Harbor 2.0, most of the image related functions were handled by Docker Distribution, and metadata for images and OCI artifacts were extracted from the docker registry by the harbor component. After Harbor 2.0, metadata related to mirrors and OCI artifacts is maintained by Harbor itself, and <strong>metadata is written to harbor&rsquo;s database when PUSHing these artifacts</strong>. Thanks to this, Harbor is no longer just a service for storing and managing mirrors, but a cloud-native repository service that can store and manage a wide range of OCI-compliant Artifacts such as Helm Chart, CNAB, OPA Bundle, etc.</p>
<h3 id="docker-registry-to-harbor">docker registry to harbor</h3>
<p>Well, after all these useless concepts, let&rsquo;s get back to the problem we are trying to solve in this article: <strong>How to migrate images from docker registry to harbor?</strong></p>
<p>Suppose there are two machines in the intranet environment, one machine is running docker registry with the domain name registry.k8s.li. The other machine is running harbor, assuming the domain name is harbor.k8s.li. docker registry now holds 5,000 images. harbor has just been deployed and there are no images in it yet. How can I efficiently migrate the images in the docker registry to harbor without disk and network limitations?</p>
<h2 id="get-a-list-of-all-mirrors-in-the-registry">Get a list of all mirrors in the registry</h2>
<p>First of all, before migration we have to pull the list and get a list of images in the docker registry, so that we can ensure that no images are lost after migration. In the registry storage directory, the tag of each mirror is pointed to by the <code>current/index</code> file, so we can get the tags of all mirrors by traversing the <code>current/index</code> file in the registry storage directory, and thus get the list of all mirrors in the registry. Note that we can only get the mirrors with tags, but not the other mirrors without tags.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/09/29/9e1a2c77fd33445ba6063b1f52ac2237.png" alt=""></p>
<p>A list of mirrors can be obtained from the registry storage directory with the following command.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># 首先进入到 registry 存储的主目录下</span>
<span class="nb">cd</span>  /var/lib/registry
find docker -type d -name <span class="s2">&#34;current&#34;</span> <span class="p">|</span> sed <span class="s1">&#39;s|docker/registry/v2/repositories/||g;s|/_manifests/tags/|:|g;s|/current||g&#39;</span> &gt; images.list
</code></pre></td></tr></table>
</div>
</div><h2 id="harbor-create-project">harbor create project</h2>
<p>For new harbor deployments, there will only be a project with a default library on it, so you need to manually create the corresponding project in the docker registry on the harbor. repositories` in the registry storage directory.</p>
<p>Once we have the list of mirrors and the corresponding project created on harbor, we are ready to do the official migration. Depending on the scenario, the following options can be used.</p>
<h2 id="option-1-docker-retag">Option 1: docker retag</h2>
<p>Option 1 is probably the first way most people think of, and it&rsquo;s also the easiest and most brutal way. It is to use docker to pull all the images in the docker registry on one machine, then docker retag, and then docker push to the harbor.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># 假设其中的一个镜像为 library/alpine:latest</span>

docker pull registry.k8s.li/library/alpine:latest

docker tag registry.k8s.li/library/alpine:latest harbor.k8s.li/library/alpine:latest

docker push harbor.k8s.li/library/alpine:latest
</code></pre></td></tr></table>
</div>
</div><p>This solution is a bit silly, because the docker pull -&gt; docker tag -&gt; docker pull process decompresses the image&rsquo;s layer. For just copying images from one registry to another, these dockers are doing a lot of useless work in these processes. We won&rsquo;t go into the details here.</p>
<p>So, in order to pursue efficiency, we will not use docker retag such a stupid way, so we will talk about option 2.</p>
<h2 id="option-2-skopeo">Option 2: skopeo</h2>
<p>You can use skopeo copy to copy image raw blobs directly from one registry to another registry without involving image layer decompression during the process. As for performance and time consumption, it is much better than using docker 😂.</p>
<ul>
<li>Use skopeo copy</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">skopeo copy --insecure-policy --src-tls-verify<span class="o">=</span><span class="nb">false</span> --dest-tls-verify<span class="o">=</span><span class="nb">false</span> --src docker://registry.k8s.li/library/alpine:latest docker://harbor.k8s.li/library/alpine:latest
</code></pre></td></tr></table>
</div>
</div><ul>
<li>Using skopeo sync</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">skopeo sync --insecure-policy --src-tls-verify<span class="o">=</span><span class="nb">false</span> --dest-tls-verify<span class="o">=</span><span class="nb">false</span> --src docker --dest docker registry.k8s.li/library/alpine:latest harbor.k8s.li/library/alpine:latest
</code></pre></td></tr></table>
</div>
</div><p>But is there a better way? You know that both docker and skopeo are essentially downloading and uploading images through the registry&rsquo;s HTTP API, and there are still a lot of HTTP requests in the process. So is there a better way?</p>
<h2 id="option-3-migrate-the-storage-directory">Option 3: Migrate the storage directory</h2>
<p>As mentioned at the beginning of the article, harbor&rsquo;s back-end image storage also uses the docker registry. For a registry, as long as it uses Docker Distribution V2, its back-end storage directory structure looks exactly the same. Then why not copy the registry storage directory and extract it to the harbor registry storage directory? This way you can make sure that all the images are migrated and no one is left behind.</p>
<p>For harbor 1.x, migrate the docker registry storage directly to harbor&rsquo;s registry storage, delete harbor&rsquo;s redis data (because harbor&rsquo;s redis caches the image&rsquo;s metadata information), restart harbor, and you&rsquo;re done. After restarting harbor, harbor will call the back-end registry to extract the mirror&rsquo;s metadata information and store it in redis. This completes the migration.</p>
<p>Back up the registry storage directory on the docker registry machine</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># 切换到 docker registry 的存储目录</span>
<span class="nb">cd</span>  /var/lib/registry

<span class="c1"># 注意，进行备份时无需进行压缩，因为 registry 中镜像的 layer 都是压缩过的</span>
tar -cpf docker.tar docker
</code></pre></td></tr></table>
</div>
</div><p>After the backup is complete, scp the docker.tar to the harbor machine and restore the registry storage directory on the harbor machine</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># 切换到 harbor 的存储目录</span>
<span class="nb">cd</span> /data/harbor

<span class="c1"># 将备份的 docker 目录解压到 harbor 的 registry 目录下，目录层级一定要对应好</span>
tar -xpf docker.tar -C ./registry

<span class="c1"># 删除 harbor 的 regis 数据，重启 harbor 后会重建 redis 数据。</span>
rm -f redis/dump.rdb

<span class="c1"># 切换到 harbor 的安装目录重启 harbor</span>
<span class="nb">cd</span> /opt/harbor
docker-compose restart
</code></pre></td></tr></table>
</div>
</div><p>After this migration, you may encounter the problem of not being able to push images to harbor. Because the registry storage directory in the docker registry container belongs to root and the registry storage directory in the harbor registry container belongs to 10000:10000, the permissions are not the same, so harbor cannot push the image. Therefore, you need to change the ownership and group of the harbor registry directory after the migration is completed.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># 切换到 harbor 的存储目录</span>
<span class="nb">cd</span> /data/harbor

<span class="c1"># 修改 registry 存储目录的所属和所属组为 10000</span>
chown -R 10000:10000 ./registry
</code></pre></td></tr></table>
</div>
</div><h2 id="option-4">Option 4</h2>
<p>For harbor 2.x, because harbor has enhanced the metadata management capabilities of Artifacts, that is, metadata is written to harbor&rsquo;s own database when it is pushed or synced to harbor. In harbor&rsquo;s view, as long as there is no manifest information for the Artifact or layer in the database, harbor will assume that the Artifact or layer does not exist and return a 404 error. The direct method of extracting the docker registry storage directory to harbor&rsquo;s registry storage directory does not work according to option 3. Since the image is extracted to the registry storage, even though the image appears to be there in the harbor registry container, harbor will think there is no image because there is no image in the harbor database. So now it seems that we can only use skopeo to push the mirrors to harbor one by one by option 2.</p>
<p>But for some specific scenarios, you can&rsquo;t have a docker registry HTTP service like in Scenario 2, but only a docker registry zip, so how do you migrate the mirrors from the docker registry storage directory to harbor 2.0?</p>
<p>The <code>mirror formats</code> supported by skopeo are as follows.</p>
<table>
<thead>
<tr>
<th>IMAGE NAMES</th>
<th>example</th>
</tr>
</thead>
<tbody>
<tr>
<td>containers-storage:</td>
<td>containers-storage:</td>
</tr>
<tr>
<td>dir:</td>
<td>dir:/PATH</td>
</tr>
<tr>
<td>docker://</td>
<td>docker://k8s.gcr.io/kube-apiserver:v1.17.5</td>
</tr>
<tr>
<td>docker-daemon:</td>
<td>docker-daemon:alpine:latest</td>
</tr>
<tr>
<td>docker-archive:</td>
<td>docker-archive:alpine.tar (docker save)</td>
</tr>
<tr>
<td>oci:</td>
<td>oci:alpine:latest</td>
</tr>
</tbody>
</table>
<p>For example, <code>docker://</code> is a registry; <code>docker-daemon:</code> is a local docker pull; and <code>docker- archive</code> is the image saved by docker; and <code>dir:</code> is the image saved as a folder. The same image has these ways of existence, just like water has gas, liquid, and solid. You can understand it this way, they all represent the same image, but in different ways.</p>
<p>Since the image is stored in the registry storage directory, using the dir format to read the image directly from the filesystem is theoretically better than option 2. Although skopeo supports mirrors in dir format, skopeo does not currently support direct use of the registry storage directory, so you still need to find a way to convert each image in the docker registry storage directory into a skopeo dir format.</p>
<h3 id="skopeo-dir">skopeo dir</h3>
<p>So let&rsquo;s take a look at what skopeo dir looks like.</p>
<p>To test the feasibility of the solution, first pull an image from the docker hub and save it as a dir using the skopeo command as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">skopeo copy docker://alpine:latest dir:./alpine
</code></pre></td></tr></table>
</div>
</div><p>Use the tree command to look at the directory structure of the alpine folder, as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">╭─root@sg-02 /var/lib/registry
╰─# tree -h alpine
alpine
├── <span class="o">[</span>2.7M<span class="o">]</span>  4c0d98bf9879488e0407f897d9dd4bf758555a78e39675e72b5124ccf12c2580
├── <span class="o">[</span>1.4K<span class="o">]</span>  e50c909a8df2b7c8b92a6e8730e210ebe98e5082871e66edd8ef4d90838cbd25
├── <span class="o">[</span> 528<span class="o">]</span>  manifest.json
└── <span class="o">[</span>  33<span class="o">]</span>  version

<span class="m">0</span> directories, <span class="m">4</span> files
╭─root@sg-02 /var/lib/registry
╰─# file alpine/e50c909a8df2b7c8b92a6e8730e210ebe98e5082871e66edd8ef4d90838cbd25
alpine/e50c909a8df2b7c8b92a6e8730e210ebe98e5082871e66edd8ef4d90838cbd25: ASCII text, with very long lines, with no line terminators

╭─root@sg-02 /var/lib/registry
╰─# file alpine/4c0d98bf9879488e0407f897d9dd4bf758555a78e39675e72b5124ccf12c2580
alpine/4c0d98bf9879488e0407f897d9dd4bf758555a78e39675e72b5124ccf12c2580: gzip compressed data
</code></pre></td></tr></table>
</div>
</div><p>From the file name and size as well as the introspection of the file, we can tell that the manifest file corresponds to the manifests file of the image; the file of type <code>ASCII text</code> is the image config file of the image, which contains the metadata information of the image. The other <code>gzip compressed data</code> file is the image layer that has been compressed by gzip. A look at the contents of the manifest file also reaffirms this conclusion.</p>
<ul>
<li>The config field of the image corresponds to exactly e50c909a8df2, and the file type is exactly <code>image.v1+json</code> text file.</li>
<li>The layer field of the image corresponds to exactly 4c0d98bf9879 and the file type is exactly <code>.tar.gzip</code> gzip compressed file.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">alpine/4c0d98bf9879488e0407f897d9dd4bf758555a78e39675e72b5124ccf12c2580: gzip compressed data
╭─root@sg-02 /var/lib/registry
╰─# cat alpine/manifest.json
<span class="o">{</span>
   <span class="s2">&#34;schemaVersion&#34;</span>: 2,
   <span class="s2">&#34;mediaType&#34;</span>: <span class="s2">&#34;application/vnd.docker.distribution.manifest.v2+json&#34;</span>,
   <span class="s2">&#34;config&#34;</span>: <span class="o">{</span>
      <span class="s2">&#34;mediaType&#34;</span>: <span class="s2">&#34;application/vnd.docker.container.image.v1+json&#34;</span>,
      <span class="s2">&#34;size&#34;</span>: 1471,
      <span class="s2">&#34;digest&#34;</span>: <span class="s2">&#34;sha256:e50c909a8df2b7c8b92a6e8730e210ebe98e5082871e66edd8ef4d90838cbd25&#34;</span>
   <span class="o">}</span>,
   <span class="s2">&#34;layers&#34;</span>: <span class="o">[</span>
      <span class="o">{</span>
         <span class="s2">&#34;mediaType&#34;</span>: <span class="s2">&#34;application/vnd.docker.image.rootfs.diff.tar.gzip&#34;</span>,
         <span class="s2">&#34;size&#34;</span>: 2811321,
         <span class="s2">&#34;digest&#34;</span>: <span class="s2">&#34;sha256:4c0d98bf9879488e0407f897d9dd4bf758555a78e39675e72b5124ccf12c2580&#34;</span>
      <span class="o">}</span>
   <span class="o">]</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="retrieve-the-image-from-the-registry-storage-directory">Retrieve the image from the registry storage directory</h3>
<p>Now comes the better part of this article. How to get the image out of the registry storage and into the dir format supported by skopeo.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/09/29/9bff6bcaff914e7bb0222f45332316bd.png" alt=""></p>
<ul>
<li>The first thing to do is to get the manifests file of the image, from which you can get all the blob files of the image. For example, for the <code>library/alpine:latest</code> image in the registry storage directory, it is stored in the registry like this.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">╭─root@sg-02 /var/lib/registry/docker/registry/v2
╰─# tree
.
├── blobs
│   └── sha256
│       ├── 21
│       │   └── 21c83c5242199776c232920ddb58cfa2a46b17e42ed831ca9001c8dbc532d22d
│       │       └── data
│       ├── a1
│       │   └── a143f3ba578f79e2c7b3022c488e6e12a35836cd4a6eb9e363d7f3a07d848590
│       │       └── data
│       └── be
│           └── be4e4bea2c2e15b403bb321562e78ea84b501fb41497472e91ecb41504e8a27c
│               └── data
└── repositories
    └── library
        └── alpine
            ├── _layers
            │   └── sha256
            │       ├── 21c83c5242199776c232920ddb58cfa2a46b17e42ed831ca9001c8dbc532d22d
            │       │   └── link
            │       └── be4e4bea2c2e15b403bb321562e78ea84b501fb41497472e91ecb41504e8a27c
            │           └── link
            ├── _manifests
            │   ├── revisions
            │   │   └── sha256
            │   │       └── a143f3ba578f79e2c7b3022c488e6e12a35836cd4a6eb9e363d7f3a07d848590
            │   │           └── link
            │   └── tags
            │       └── latest
            │           ├── current
            │           │   └── link
            │           └── index
            │               └── sha256
            │                   └── a143f3ba578f79e2c7b3022c488e6e12a35836cd4a6eb9e363d7f3a07d848590
            │                       └── link
            └── _uploads

26 directories, 8 files
</code></pre></td></tr></table>
</div>
</div><ol>
<li>get the sha256 value of the manifests file of the alpine mirror lasts tag from the <code>repositories/library/alpine/_manifests/tags/latest/current/link</code> file, and then go to blobs to find the manifests file of the mirror;</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">╭─root@sg-02 /var/lib/registry/docker/registry/v2/repositories/library/alpine/_manifests/tags/latest/current/
╰─# cat link
sha256:39eda93d15866957feaee28f8fc5adb545276a64147445c64992ef69804dbf01#
</code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>Find the corresponding file in the blobs directory according to the sha256 value in the <code>current/link</code> file, the corresponding manifests file in the blobs directory is blobs/sha256/39/ 39eda93d15866957feaee28f8fc5adb545276a64147445c64992ef69804dbf01/data;</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">╭─root@sg-02 /var/lib/registry/docker/registry/v2/repositories/library/alpine/_manifests/tags/latest/current
╰─# cat /var/lib/registry/docker/registry/v2/blobs/sha256/39/39eda93d15866957feaee28f8fc5adb545276a64147445c64992ef69804dbf01/data
<span class="o">{</span>
   <span class="s2">&#34;schemaVersion&#34;</span>: 2,
   <span class="s2">&#34;mediaType&#34;</span>: <span class="s2">&#34;application/vnd.docker.distribution.manifest.v2+json&#34;</span>,
   <span class="s2">&#34;config&#34;</span>: <span class="o">{</span>
      <span class="s2">&#34;mediaType&#34;</span>: <span class="s2">&#34;application/vnd.docker.container.image.v1+json&#34;</span>,
      <span class="s2">&#34;size&#34;</span>: 1507,
      <span class="s2">&#34;digest&#34;</span>: <span class="s2">&#34;sha256:f70734b6a266dcb5f44c383274821207885b549b75c8e119404917a61335981a&#34;</span>
   <span class="o">}</span>,
   <span class="s2">&#34;layers&#34;</span>: <span class="o">[</span>
      <span class="o">{</span>
         <span class="s2">&#34;mediaType&#34;</span>: <span class="s2">&#34;application/vnd.docker.image.rootfs.diff.tar.gzip&#34;</span>,
         <span class="s2">&#34;size&#34;</span>: 2813316,
         <span class="s2">&#34;digest&#34;</span>: <span class="s2">&#34;sha256:cbdbe7a5bc2a134ca8ec91be58565ec07d037386d1f1d8385412d224deafca08&#34;</span>
      <span class="o">}</span>
   <span class="o">]</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>Using regular matching, all sha256 values in the manifests file are filtered out, and these sha256 values correspond to the image config file and the image layer file in the blobs directory;</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">╭─root@sg-02 /var/lib/registry/docker/registry/v2/repositories/library/alpine/_manifests/tags/latest/current
╰─# grep -Eo <span class="s2">&#34;\b[a-f0-9]{64}\b&#34;</span> /var/lib/registry/docker/registry/v2/blobs/sha256/39/39eda93d15866957feaee28f8fc5adb545276a64147445c64992ef69804dbf01/data
f70734b6a266dcb5f44c383274821207885b549b75c8e119404917a61335981a
cbdbe7a5bc2a134ca8ec91be58565ec07d037386d1f1d8385412d224deafca08
</code></pre></td></tr></table>
</div>
</div><ol start="4">
<li>Based on the manifests file, you can get all the layer and image config files of the image in the blobs directory, and then put these files together into a dir format, where the image is copied from the registry storage directory using the cp method, as follows.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># 首先创建一个文件夹，为了保留镜像的 name 和 tag，文件夹的名称就对应的是 NAME:TAG</span>
╭─root@sg-02 /var/lib/registry/docker
╰─# mkdir -p skopeo/library/alpine:latest

<span class="c1"># 复制镜像的 manifest 文件</span>
╭─root@sg-02 /var/lib/registry/docker
╰─# cp /var/lib/registry/docker/registry/v2/blobs/sha256/39/39eda93d15866957feaee28f8fc5adb545276a64147445c64992ef69804dbf01/data skopeo/library/alpine:latest/manifest

<span class="c1"># 复制镜像的 blob 文件</span>
<span class="c1"># cp /var/lib/registry/docker/registry/v2/blobs/sha256/f7/f70734b6a266dcb5f44c383274821207885b549b75c8e119404917a61335981a/data skopeo/library/alpine:latest/f70734b6a266dcb5f44c383274821207885b549b75c8e119404917a61335981a</span>
<span class="c1"># cp /var/lib/registry/docker/registry/v2/blobs/sha256/cb/cbdbe7a5bc2a134ca8ec91be58565ec07d037386d1f1d8385412d224deafca08/data skopeo/library/alpine:latest/cbdbe7a5bc2a134ca8ec91be58565ec07d037386d1f1d8385412d224deafca08</span>
</code></pre></td></tr></table>
</div>
</div><p>The final image format obtained is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">╭─root@sg-02 /var/lib/registry/docker
╰─# tree skopeo/library/alpine:latest
skopeo/library/alpine:latest
├── cbdbe7a5bc2a134ca8ec91be58565ec07d037386d1f1d8385412d224deafca08
├── f70734b6a266dcb5f44c383274821207885b549b75c8e119404917a61335981a
└── manifest

<span class="m">0</span> directories, <span class="m">3</span> files
</code></pre></td></tr></table>
</div>
</div><p>Compare with the dir folder copied from skopeo above, everything is exactly the same except for an insignificant version file.</p>
<ol start="5">
<li>To optimize this, change the cp operation in step 4 to a hard link operation, which will greatly reduce the IO operations on the disk. Note that hard-linked files cannot span partitions, so they must be in the same partition as the registry storage directory.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">╭─root@sg-02 /var/lib/registry/docker
╰─# ln /var/lib/registry/docker/registry/v2/blobs/sha256/39/39eda93d15866957feaee28f8fc5adb545276a64147445c64992ef69804dbf01/data skopeo/library/alpine:latest/manifest
<span class="c1"># ln /var/lib/registry/docker/registry/v2/blobs/sha256/f7/f70734b6a266dcb5f44c383274821207885b549b75c8e119404917a61335981a/data skopeo/library/alpine:latest/f70734b6a266dcb5f44c383274821207885b549b75c8e119404917a61335981a</span>
<span class="c1"># ln /var/lib/registry/docker/registry/v2/blobs/sha256/cb/cbdbe7a5bc2a134ca8ec91be58565ec07d037386d1f1d8385412d224deafca08/data skopeo/library/alpine:latest/cbdbe7a5bc2a134ca8ec91be58565ec07d037386d1f1d8385412d224deafca08</span>
╭─root@sg-02 /var/lib/registry/docker
╰─# tree skopeo/library/alpine:latest
skopeo/library/alpine:latest
├── cbdbe7a5bc2a134ca8ec91be58565ec07d037386d1f1d8385412d224deafca08
├── f70734b6a266dcb5f44c383274821207885b549b75c8e119404917a61335981a
└── manifest

<span class="m">0</span> directories, <span class="m">3</span> files
</code></pre></td></tr></table>
</div>
</div><p>Then use skopeo copy or skopeo sync to push the retrieved image to harbor</p>
<ul>
<li>Use skopeo copy</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">skopeo copy  --insecure-policy --src-tls-verify<span class="o">=</span><span class="nb">false</span> --dest-tls-verify<span class="o">=</span><span class="nb">false</span> <span class="se">\
</span><span class="se"></span>dir:skopeo/library/alpine:latest docker://harbor.k8s.li/library/alpine:latest
</code></pre></td></tr></table>
</div>
</div><ul>
<li>Using skopeo sync</li>
</ul>
<p>Note that the skopeo sync method synchronizes the project level, and the name and tag of the image correspond to the name of the directory</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">skopeo sync --insecure-policy --src-tls-verify<span class="o">=</span><span class="nb">false</span> --dest-tls-verify<span class="o">=</span><span class="nb">false</span> <span class="se">\
</span><span class="se"></span>--src dir --dest docker skopeo/library/ harbor.k8s.li/library/
</code></pre></td></tr></table>
</div>
</div><h3 id="shell-script">Shell Script</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SH" data-lang="SH"><span class="cp">#!/bin/bash
</span><span class="cp"></span><span class="nv">REGISTRY_DOMAIN</span><span class="o">=</span><span class="s2">&#34;harbor.k8s.li&#34;</span>
<span class="nv">REGISTRY_PATH</span><span class="o">=</span><span class="s2">&#34;/var/lib/registry&#34;</span>

<span class="c1"># 切换到 registry 存储主目录下</span>
<span class="nb">cd</span> <span class="si">${</span><span class="nv">REGISTRY_PATH</span><span class="si">}</span>

gen_skopeo_dir<span class="o">()</span> <span class="o">{</span>
   <span class="c1"># 定义 registry 存储的 blob 目录 和 repositories 目录，方便后面使用</span>
    <span class="nv">BLOB_DIR</span><span class="o">=</span><span class="s2">&#34;docker/registry/v2/blobs/sha256&#34;</span>
    <span class="nv">REPO_DIR</span><span class="o">=</span><span class="s2">&#34;docker/registry/v2/repositories&#34;</span>
    <span class="c1"># 定义生成 skopeo 目录</span>
    <span class="nv">SKOPEO_DIR</span><span class="o">=</span><span class="s2">&#34;docker/skopeo&#34;</span>
    <span class="c1"># 通过 find 出 current 文件夹可以得到所有带 tag 的镜像，因为一个 tag 对应一个 current 目录</span>
    <span class="k">for</span> image in <span class="k">$(</span>find <span class="si">${</span><span class="nv">REPO_DIR</span><span class="si">}</span> -type d -name <span class="s2">&#34;current&#34;</span><span class="k">)</span><span class="p">;</span> <span class="k">do</span>
        <span class="c1"># 根据镜像的 tag 提取镜像的名字</span>
        <span class="nv">name</span><span class="o">=</span><span class="k">$(</span><span class="nb">echo</span> <span class="si">${</span><span class="nv">image</span><span class="si">}</span> <span class="p">|</span> awk -F <span class="s1">&#39;/&#39;</span> <span class="s1">&#39;{print $5&#34;/&#34;$6&#34;:&#34;$9}&#39;</span><span class="k">)</span>
        <span class="nv">link</span><span class="o">=</span><span class="k">$(</span>cat <span class="si">${</span><span class="nv">image</span><span class="si">}</span>/link <span class="p">|</span> sed <span class="s1">&#39;s/sha256://&#39;</span><span class="k">)</span>
        <span class="nv">mfs</span><span class="o">=</span><span class="s2">&#34;</span><span class="si">${</span><span class="nv">BLOB_DIR</span><span class="si">}</span><span class="s2">/</span><span class="si">${</span><span class="nv">link</span><span class="p">:</span><span class="nv">0</span><span class="p">:</span><span class="nv">2</span><span class="si">}</span><span class="s2">/</span><span class="si">${</span><span class="nv">link</span><span class="si">}</span><span class="s2">/data&#34;</span>
        <span class="c1"># 创建镜像的硬链接需要的目录</span>
        mkdir -p <span class="s2">&#34;</span><span class="si">${</span><span class="nv">SKOPEO_DIR</span><span class="si">}</span><span class="s2">/</span><span class="si">${</span><span class="nv">name</span><span class="si">}</span><span class="s2">&#34;</span>
        <span class="c1"># 硬链接镜像的 manifests 文件到目录的 manifest 文件</span>
        ln <span class="si">${</span><span class="nv">mfs</span><span class="si">}</span> <span class="si">${</span><span class="nv">SKOPEO_DIR</span><span class="si">}</span>/<span class="si">${</span><span class="nv">name</span><span class="si">}</span>/manifest.json
        <span class="c1"># 使用正则匹配出所有的 sha256 值，然后排序去重</span>
        <span class="nv">layers</span><span class="o">=</span><span class="k">$(</span>grep -Eo <span class="s2">&#34;\b[a-f0-9]{64}\b&#34;</span> <span class="si">${</span><span class="nv">mfs</span><span class="si">}</span> <span class="p">|</span> sort -n <span class="p">|</span> uniq<span class="k">)</span>
        <span class="k">for</span> layer in <span class="si">${</span><span class="nv">layers</span><span class="si">}</span><span class="p">;</span> <span class="k">do</span>
          <span class="c1"># 硬链接 registry 存储目录里的镜像 layer 和 images config 到镜像的 dir 目录</span>
            ln <span class="si">${</span><span class="nv">BLOB_DIR</span><span class="si">}</span>/<span class="si">${</span><span class="nv">layer</span><span class="p">:</span><span class="nv">0</span><span class="p">:</span><span class="nv">2</span><span class="si">}</span>/<span class="si">${</span><span class="nv">layer</span><span class="si">}</span>/data <span class="si">${</span><span class="nv">SKOPEO_DIR</span><span class="si">}</span>/<span class="si">${</span><span class="nv">name</span><span class="si">}</span>/<span class="si">${</span><span class="nv">layer</span><span class="si">}</span>
        <span class="k">done</span>
    <span class="k">done</span>
<span class="o">}</span>

sync_image<span class="o">()</span> <span class="o">{</span>
    <span class="c1"># 使用 skopeo sync 将 dir 格式的镜像同步到 harbor</span>
    <span class="k">for</span> project in <span class="k">$(</span>ls <span class="si">${</span><span class="nv">SKOPEO_DIR</span><span class="si">}</span><span class="k">)</span><span class="p">;</span> <span class="k">do</span>
        skopeo sync --insecure-policy --src-tls-verify<span class="o">=</span><span class="nb">false</span> --dest-tls-verify<span class="o">=</span><span class="nb">false</span> <span class="se">\
</span><span class="se"></span>        --src dir --dest docker <span class="si">${</span><span class="nv">SKOPEO_DIR</span><span class="si">}</span>/<span class="si">${</span><span class="nv">project</span><span class="si">}</span> <span class="si">${</span><span class="nv">REGISTRY_DOMAIN</span><span class="si">}</span>/<span class="si">${</span><span class="nv">project</span><span class="si">}</span>
    <span class="k">done</span>
<span class="o">}</span>

gen_skopeo_dir
sync_image
</code></pre></td></tr></table>
</div>
</div><p>In fact, it is possible to seamlessly support registry storage directories with some magic changes to skopeo&rsquo;s source code, which is currently under study 😃.</p>
<h2 id="contrast">Contrast</h2>
<table>
<thead>
<tr>
<th></th>
<th>Option</th>
<th>Scope of application</th>
<th>Disadvantages</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>docker retag</td>
<td>Synchronizing mirrors between two registries</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>skopeo</td>
<td>Synchronizing mirrors between two registries</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>Decompression directory</td>
<td>registry stores the directory to another registry</td>
<td>harbor 1.x</td>
</tr>
<tr>
<td>4</td>
<td>skopeo dir</td>
<td>registry stores the directory to another registry</td>
<td>Applicable to harbor 2.x</td>
</tr>
</tbody>
</table>
<p>Compare and summarize the above options.</p>
<ul>
<li>Scheme 1: low start-up cost, applicable to the case where the number of mirrors is relatively small and there is no need to install skopeo, with the disadvantage of poor performance.</li>
<li>Option 1: For synchronous copy of mirrors between two registries, such as copying some public mirrors in docker hub to the company&rsquo;s intranet mirror repository.</li>
<li>Option 3: It is suitable for migration between mirror repositories, and the performance is the best among all the options, but it should be noted that if the destination mirror repository is harbor 2.x, it is not possible to use this method.</li>
<li>Option 4: is a compromise version of Option 3, in order to adapt to harbor 2.0, because you need to push the mirror to harbor again, so the performance is worse than Option 3.</li>
</ul>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/docker/">docker</a>
          <a href="/tags/harbor/">harbor</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2021-09/nginx-proxy-remove-prefixes/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">nginx reverse proxy configuration to remove prefixes</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2021-09/detecting-mobile-browser/">
            <span class="next-text nav-default">Detecting Mobile Browser</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
