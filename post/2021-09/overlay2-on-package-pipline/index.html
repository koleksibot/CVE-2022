<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Application of overlay2 in a packaged release pipeline - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Since I joined the company in May last year, I have been responsible for the packaging and deployment of PaaS toB products, which is somewhat similar to the Kubernetes community&amp;rsquo;s SIG Release Team. The main work during the trial period is to optimize our existing packaging and release process. Many optimizations were made to the product packaging and release pipeline during this period, most notably the optimization of mirror synchronization," /><meta name="keywords" content="Overlay2, Package Pipline" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2021-09/overlay2-on-package-pipline/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Application of overlay2 in a packaged release pipeline" />
<meta property="og:description" content="Since I joined the company in May last year, I have been responsible for the packaging and deployment of PaaS toB products, which is somewhat similar to the Kubernetes community&rsquo;s SIG Release Team. The main work during the trial period is to optimize our existing packaging and release process. Many optimizations were made to the product packaging and release pipeline during this period, most notably the optimization of mirror synchronization," />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2021-09/overlay2-on-package-pipline/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-09-26T19:02:35+08:00" />
<meta property="article:modified_time" content="2021-09-26T19:02:35+08:00" />

<meta itemprop="name" content="Application of overlay2 in a packaged release pipeline">
<meta itemprop="description" content="Since I joined the company in May last year, I have been responsible for the packaging and deployment of PaaS toB products, which is somewhat similar to the Kubernetes community&rsquo;s SIG Release Team. The main work during the trial period is to optimize our existing packaging and release process. Many optimizations were made to the product packaging and release pipeline during this period, most notably the optimization of mirror synchronization,"><meta itemprop="datePublished" content="2021-09-26T19:02:35+08:00" />
<meta itemprop="dateModified" content="2021-09-26T19:02:35+08:00" />
<meta itemprop="wordCount" content="3364">
<meta itemprop="keywords" content="overlay," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Application of overlay2 in a packaged release pipeline"/>
<meta name="twitter:description" content="Since I joined the company in May last year, I have been responsible for the packaging and deployment of PaaS toB products, which is somewhat similar to the Kubernetes community&rsquo;s SIG Release Team. The main work during the trial period is to optimize our existing packaging and release process. Many optimizations were made to the product packaging and release pipeline during this period, most notably the optimization of mirror synchronization,"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Application of overlay2 in a packaged release pipeline</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-09-26 19:02:35 </span>
        <div class="post-category">
            <a href="/categories/skills/"> skills </a>
            </div>
          <span class="more-meta"> 3364 words </span>
          <span class="more-meta"> 7 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#question">Question</a>
          <ul>
            <li><a href="#docker-performance-issues">docker Performance Issues</a></li>
            <li><a href="#unable-to-reuse-old-data">Unable to reuse old data</a></li>
          </ul>
        </li>
        <li><a href="#optimization">Optimization</a>
          <ul>
            <li><a href="#skopeo-alternative-to-docker">skopeo Alternative to docker</a></li>
            <li><a href="#overlay2-reuse-old-data">overlay2 Reuse old data</a></li>
          </ul>
        </li>
        <li><a href="#overlay2">overlay2</a>
          <ul>
            <li><a href="#registry-storage-structure">registry storage structure</a></li>
            <li><a href="#mirror-image-in-the-mirror-image">mirror image in the mirror image?</a></li>
            <li><a href="#container-mount-overlay2-merged-directory">Container mount overlay2 merged directory</a></li>
            <li><a href="#registry-gc-question">registry gc question?</a></li>
          </ul>
        </li>
        <li><a href="#process">Process</a></li>
        <li><a href="#ending">Ending</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>Since I joined the company in May last year, I have been responsible for the packaging and deployment of PaaS toB products, which is somewhat similar to the Kubernetes community&rsquo;s <a href="https://github.com/kubernetes/sig-release">SIG Release Team</a>. The main work during the trial period is to optimize our existing packaging and release process. Many optimizations were made to the product packaging and release pipeline during this period, most notably the optimization of mirror synchronization, which improved the speed of mirror synchronization by a factor of 5 to 15. This greatly shortened the release time of the whole product and was well received by our colleagues. So today I thought I would share this optimization and the rationale behind it.</p>
<p>Our product is packaged with a list of mirrors, and based on this list, the mirrors are synchronized in the CI/CD pipeline mirror repository to a release archive mirror repository and a packaged mirror repository. The registry storage directory of the packaged image repository is eventually packaged in an ungzip-compressed tarball. This tarball is eventually extracted to the deployed image repository storage directory during deployment of the client environment for cluster deployment and component deployment. As to why this is possible during deployment, please refer to my previous article <a href="https://blog.k8s.li/docker-registry-to-harbor.html">docker registry migration to harbor</a> for the rationale.</p>
<p>During the packaging process, the images are synchronized twice, each time to a different image repository based on a list of images.list, using <code>docker pull -&gt; docker tag -&gt; docker push</code>. The flow of the image synchronization is shown in the following diagram.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/09/26/7a7fec8cb22f4eeb9990fcd3b06e5fae.png" alt=""></p>
<p>The first time we pull the image from the CI/CD streamline image repository (cicd.registry.local) and push it to the release archive image repository (archive.registry.local), the purpose of which is to archive and backup the image we have already released, this step is called save sync.</p>
<p>The second time, we sync the image from the archive.registry.local repository to the package.registry.local repository. Unlike the first mirror synchronization, this time the mirror repository is cleaned up, first the storage directory of the package mirror repository is cleaned up, and then the container registry container allows the registry to re-fetch the metadata information of the mirror into memory. The purpose is to clean up old data and prevent historical mirrors from being brought into the installer for this release.</p>
<p>Once the image synchronization is complete, the entire repository of packaged images (/var/lib/registry) is packaged into a tarball and placed in the product installer.</p>
<h2 id="question">Question</h2>
<p>When I first joined the company, our product release took the longest to synchronize with the mirror phase, remembering that the longest time took 2h30min. the main reason for this time is as follows.</p>
<h3 id="docker-performance-issues">docker Performance Issues</h3>
<p>When doing image synchronization, we use the <code>docker pull -&gt; docker tag -&gt; docker push</code> method. During the process of docker pull and docker push, the docker daemon will decompress the image layer, which is very time consuming and wasteful of CPU resources.</p>
<p>And because the disk performance of our intranet machine is so bad, sometimes it&rsquo;s not even as fast as USB 2.0 (57MB/s)! So imagine how slow it is. This results in a long time to synchronize one or two hundred images each time, the longest time being two and a half hours.</p>
<h3 id="unable-to-reuse-old-data">Unable to reuse old data</h3>
<p>The second mirror sync will clean up the packaged mirror repository, making it impossible to reuse the historical mirrors. In fact, each time a release is made, the number of mirrors changed and added is very small, averaging about 1/10 of the original, and the number of mirrors synchronized incrementally is only a little. Because we need to ensure that the mirror repository for this release can only contain the required mirrors, and cannot contain mirrors that are not related to this release, we need to clean up the mirror repository every time, which is unavoidable. I have not been able to find a way to reuse these historical mirrors.</p>
<h2 id="optimization">Optimization</h2>
<p>According to the two problems mentioned above, after repeated research and testing, they were finally solved perfectly and the mirror synchronization was optimized from the original maximum of two and a half hours to an average of five minutes.</p>
<h3 id="skopeo-alternative-to-docker">skopeo Alternative to docker</h3>
<p>The first solution to the performance problem of <code>docker pull -&gt; docker tag -&gt; docker push</code> was to use skopeo instead. Use <code>skopeo copy</code> to copy images directly from one registry to another. This avoids the performance loss caused by the docker daemon decompressing the image&rsquo;s layer. After using skopeo, mirror synchronization is much faster than before, about 5 times faster on average.</p>
<h3 id="overlay2-reuse-old-data">overlay2 Reuse old data</h3>
<p>After solving the performance problem of docker, the remaining problem is the inability to reuse old data. It was a pain in the ass to keep the historical images. <strong>I don&rsquo;t know why I thought of the overlay2 feature</strong>: <code>copy on write</code>. For example, if you run docker and start a container, you can modify and delete files inside the container without affecting the image itself. This is because docker uses overlay2 co-mounting to mount each layer of the image as a merged layer. What you see inside the container is the merged layer, and modifications and deletions of files on the merged layer inside the container are done through the upper layer of overlay2, and do not affect the image itself, which is located on the lower layer. An image stolen from the official docker documentation <a href="https://docs.docker.com/storage/storagedriver/overlayfs-driver/">Use the OverlayFS storage driver</a>.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/09/26/a5e87cf2d7144118a279db2baf5b51df.png" alt=""></p>
<p>As for the role of these Dir&rsquo;s in the above diagram, here is an explanation lifted from <a href="https://stackoverflow.com/questions/56550890/docker-image-merged-diff-work-lowerdir-components-of-graphdriver">StackOverflow</a>. For a detailed explanation of the overlayfs file system, see this document <a href="https://www.kernel.org/doc/Documentation/filesystems/overlayfs.txt">overlayfs.txt</a> on the official Linux kernel web site.</p>
<blockquote>
<p>LowerDir: these are the read-only layers of an overlay filesystem. For docker, these are the image layers assembled in order.</p>
<p>UpperDir: this is the read-write layer of an overlay filesystem. For docker, that is the equivalent of the container specific layer that contains changes made by that container.</p>
<p>WorkDir: this is a required directory for overlay, it needs an empty directory for internal use.</p>
<p>MergedDir: this is the result of the overlay filesystem. Docker effectively chroot’s into this directory when running the container.</p>
</blockquote>
<p>Anyway, overlay2 is good! By the nature of overlay2, we can use the historical data as the lowerdir in overlay2. The upperdir is the incremental data for this mirror sync, and the merged is the actual data that will be needed in the end.</p>
<h2 id="overlay2">overlay2</h2>
<p>Although the option of using overlay2 was mentioned above, there is still no mature solution so far. The problems that need to be solved are as follows.</p>
<ul>
<li>How to clean up old data</li>
<li>How to reuse the historical mirrors?</li>
<li>How to distinguish the historical mirror from the current one?</li>
<li>How to guarantee that the result of this mirror synchronization contains only the mirror needed this time?</li>
</ul>
<h3 id="registry-storage-structure">registry storage structure</h3>
<p>Since we want to use the historical mirror repository data as the lowerdir for overlay2, how do we solve the previously mentioned problem of cleaning up old data and using historical mirrors? Then we need to review the registry storage directory structure again.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/09/26/03642173dc0a4b088d58762ae52c59d0.png" alt=""></p>
<p>According to the storage structure of registry, we can know that the blob files of the image are stored in the blobs directory. blob files have three kinds: manifests of the image; image config files of the image; and layer files of the image. The manifests and images config files are text files in json format, and the image layer files are compressed tarball files (usually gzip). If you want to reuse historical images, you should reuse the layer layer files of the image to a large extent, because these files are the largest among the images, and the layer layer files of the image are decompressed during docker pull and docker push.</p>
<p>For the same mirror repository, the files under blobs are pointed to the corresponding data file by the link file under repositories. This means that multiple mirrors can use the same layer, for example, if the base image of multiple mirrors is <code>debian:cluster</code>, then for the whole registry mirror repository, only one <code>debian:cluster</code> image should be stored.</p>
<p>Similarly, when using a historical mirror, can we just use its layer? This may be difficult to understand 😂. Let&rsquo;s use the following example to illustrate.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">k8s.gcr.io/kube-apiserver:v1.18.3
k8s.gcr.io/kube-controller-manager:v1.18.3
k8s.gcr.io/kube-scheduler:v1.18.3
k8s.gcr.io/kube-proxy:v1.v1.18.3
</code></pre></td></tr></table>
</div>
</div><p>When we copy these images from <code>k8s.gcr.io</code> to a local image repository using skopeo copy, after copying the first image, the log message <code>Copying blob 83b4483280e5 skipped: already exists</code> is displayed when copying the subsequent images. This is because these mirrors are using the same base image, which contains only one layer, the <code>83b4483280e5</code> blob file. Although there is no base image for these mirrors in the local mirror repository, there is a layer for the base image, and skopeo will not copy the same blob again.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">╭─root@sg-02 /home/ubuntu
╰─# skopeo copy docker://k8s.gcr.io/kube-apiserver:v1.18.3 docker://localhost/kube-apiserver:v1.18.3 --dest-tls-verify=false
Getting image source signatures
Copying blob 83b4483280e5 done
Copying blob 2bfb66b13a96 done
Copying config 7e28efa976 done
Writing manifest to image destination
Storing signatures
╭─root@sg-02 /home/ubuntu
╰─# skopeo copy docker://k8s.gcr.io/kube-controller-manager:v1.18.3 docker://localhost/kube-controller-manager:v1.18.3 --dest-tls-verify=false
Getting image source signatures
Copying blob 83b4483280e5 skipped: already exists
Copying blob 7a73c2c3b85e done
Copying config da26705ccb done
Writing manifest to image destination
Storing signatures
╭─root@sg-02 /home/ubuntu
╰─# skopeo copy docker://k8s.gcr.io/kube-scheduler:v1.18.3 docker://localhost/kube-scheduler:v1.18.3 --dest-tls-verify=false
Getting image source signatures
Copying blob 83b4483280e5 skipped: already exists
Copying blob 133c4d2f432a done
Copying config 76216c34ed done
Writing manifest to image destination
Storing signatures
╭─root@sg-02 /home/ubuntu
╰─# skopeo copy docker://k8s.gcr.io/kube-proxy:v1.18.3 docker://localhost/kube-proxy:v1.18.3 --dest-tls-verify=false
Getting image source signatures
Copying blob 83b4483280e5 skipped: already exists
Copying blob ffa39a529ef3 done
Copying config 3439b7546f done
Writing manifest to image destination
Storing signatures
</code></pre></td></tr></table>
</div>
</div><p>From the above experiment, we can learn that skopeo will not copy the same blob as long as the same blob exists in the registry, so how to let skopeo and the registry know that these layers exist?</p>
<p>This is where we need to review the following registry storage structure again. Under repositories, there is a directory <code>_layers</code> in each image&rsquo;s folder, and the contents of this directory is the link file to the image layer and image config. That is to say, as long as there is a link file pointing to a blob under <code>_layers</code> of an image, and the data file under blobs pointed by the link file does exist, then when pushing the image, the registry will return to the client that the blob already exists, and skopeo will skip processing the existing blob. In this way, we can reuse historical data.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/09/26/809d9383c6464cda9877a082d716a6a9.png" alt=""></p>
<p>In the history image repository files: blobs directory is all you need; repositories directory only need each image <code>_layers</code> directory can; <code>_manifests</code> directory is the image tag we do not need them; <code>_uploads</code> directory is the push image when the temporary directory also do not need. Then we end up needing the files in the history mirror repository as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/09/26/305c6503e8fd4e73a510642515b00732.png" alt=""></p>
<p>So far we have solved the problem of how to clean up old data and how to reuse historical mirrors. The next step is to use overlay2 to build the filesystem needed for the mirror repository.</p>
<h3 id="mirror-image-in-the-mirror-image">mirror image in the mirror image?</h3>
<p>When it comes to overlay2, the first solution that comes to mind is container mirroring: using the nesting method, the historical mirror repository storage directory is copied to a registry image, and then this image is used to start the registry container of the packaged mirror repository. The <code>Dockerfile</code> of this image repository is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="k">FROM</span><span class="s"> registry:latest</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="c"># 将历史镜像仓库的目录打包成 tar 包，放到 registry 的镜像中， ADD 指令会自动解开这个 tar 包</span><span class="err">
</span><span class="err"></span><span class="k">ADD</span> docker.tar /var/lib/registry/<span class="err">
</span><span class="err">
</span><span class="err"></span><span class="c"># 删除掉所有镜像的 _manifests 目录，让 registry 认为里面没有镜像只有 blobs 数据</span><span class="err">
</span><span class="err"></span><span class="k">RUN</span> find /var/lib/registry/docker/registry/v2/repositories -type d -name <span class="s2">&#34;_manifests&#34;</span> -exec rm -rf <span class="o">{}</span> <span class="se">\;</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>Then use this Dockerfile to build an image named registry:v0.1.0-base and use this image to docker run a container.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">docker run -d --name registry -p 127.0.0.1:443:5000 registry:v0.1.0-base
</code></pre></td></tr></table>
</div>
</div><ul>
<li>Then synchronize the mirror</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">cat images.list <span class="p">|</span> xargs -L1 -I <span class="o">{}</span> skopeo copy  docker://cidi.registry.local/<span class="o">{}</span> docker://package.registry.local/<span class="o">{}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>After synchronizing the mirrors, you need to delete the mirrors that do not have a <code>_manifests</code> directory under repositories. If the mirror is in the repositories directory, the _manifests directory will be generated again. This can solve the problem of how to distinguish the historical mirrors from the current mirrors, which in turn can ensure that the result of this mirror sync only contains the mirrors needed this time.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="k">for</span> project in <span class="k">$(</span>ls repositories/<span class="k">)</span><span class="p">;</span> <span class="k">do</span>
  <span class="k">for</span> image in <span class="k">$(</span>ls repositories/<span class="si">${</span><span class="nv">project</span><span class="si">}</span><span class="k">)</span><span class="p">;</span> <span class="k">do</span>
    <span class="k">if</span> <span class="o">[[</span> ! -d <span class="s2">&#34;repositories/</span><span class="si">${</span><span class="nv">project</span><span class="si">}</span><span class="s2">/</span><span class="si">${</span><span class="nv">image</span><span class="si">}</span><span class="s2">/_manifests&#34;</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
    rm -rf repositories/<span class="si">${</span><span class="nv">project</span><span class="si">}</span>/<span class="si">${</span><span class="nv">image</span><span class="si">}</span>
  <span class="k">fi</span>
<span class="k">done</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>Finally, you need to use registry GC to remove the files that are not referenced in the blobs directory.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">docker <span class="nb">exec</span> -it registry registry garbage-collect /etc/docker/registry/config.yml
</code></pre></td></tr></table>
</div>
</div><ul>
<li>Then use docker cp to copy the image out of the container and pack it into a tarball</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">docker cp registry:/var/lib/registry/docker docker
tar -cf docker.tar docker
</code></pre></td></tr></table>
</div>
</div><p>I did a simple test using this approach, because when using skopeo copy image will prompt a lot of blobs already exist, so the actual copy of the image is only a small part, the performance is indeed much faster than before. However, there are many disadvantages of this solution: one is that the registry image needs to be maintained and built manually; the second is that using docker cp to copy the registry storage directory in the container to the container host is a bit poor in performance; the third is that different products need different base images, which is troublesome to maintain. So we also need to use overlay2 technology in a simpler way.</p>
<h3 id="container-mount-overlay2-merged-directory">Container mount overlay2 merged directory</h3>
<p>If you think about it, you can put historical mirror data into a registry image and use it to start a registry container. Synchronizing the image and performing registry gc are actually read/write/delete operations on the merged layer of overlay2. So why don&rsquo;t we just create the directories needed by overlay2 on the host and then mount them as a merged directory using overlay2 federated mounts. When we start the registry container, we can bind the merged directory to the registry container with the <code>docker run -v</code> parameter. Let&rsquo;s do a simple verification and test.</p>
<ul>
<li>First create the directory needed for overlay2</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">cd</span> /var/lib/registry
mkdir -p lower upper work merged
</code></pre></td></tr></table>
</div>
</div><ul>
<li>Place historical mirror repository data in the lower directory</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">tar -cf docker.tar -C /var/lib/registry/lower
</code></pre></td></tr></table>
</div>
</div><ul>
<li>Delete the _manifests directory of all mirrors, so that the registry thinks there are no mirrors in there, only blobs data.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">find /var/lib/registry/lower/docker/registry/v2/repositories -type d -name <span class="s2">&#34;_manifests&#34;</span> -exec rm -rf <span class="o">{}</span> <span class="se">\;</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>Simulate the start of a container, using overlay2 co-mounted as a merged layer</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">mount -t overlay overlay -o <span class="nv">lowerdir</span><span class="o">=</span>lower,upperdir<span class="o">=</span>upper,workdir<span class="o">=</span>work merged
</code></pre></td></tr></table>
</div>
</div><ul>
<li>docker run starts a registry and mounts the merged directory to the /var/lib/registry/docker directory inside the container</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">docker run -d -name registry -p 127.0.0.1:443:5000 <span class="se">\
</span><span class="se"></span>-v /var/lib/registry/merged/docker:/var/lib/registry/docker
</code></pre></td></tr></table>
</div>
</div><ul>
<li>Synchronize mirrors, synchronize the mirrors needed for this release to the registry</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">cat images.list <span class="p">|</span> xargs -L1 -I <span class="o">{}</span> skopeo copy --insecure-policy --src-tls-verify<span class="o">=</span><span class="nb">false</span> --dest-tls-verify<span class="o">=</span><span class="nb">false</span> docker://cicd.registry.local/<span class="o">{}</span> docker://package.registry.local/<span class="o">{}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>After synchronizing the image, do a registry gc to delete the useless blob data</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">docker <span class="nb">exec</span> -it registry registry garbage-collect /etc/docker/registry/config.yml
</code></pre></td></tr></table>
</div>
</div><ul>
<li>The final package merged directory is the final result of this</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">cd</span> /var/lib/registry/merged
tar -cf docker.tar docker
</code></pre></td></tr></table>
</div>
</div><p>I followed the above steps locally and verified that it works! The second time I synced the image, I was prompted that many blob already existed and the image synced about 5 times faster than before. Then write the above steps as a script and you can use it again and again.</p>
<h3 id="registry-gc-question">registry gc question?</h3>
<p>I&rsquo;ve encountered the problem of registry GCs not cleaning up: after a GC, some image layer and config files have been deleted from the blobs storage directory, but the link files pointing to it are still stored in the repositories directory 🙄. There is a PR on GitHub <a href="https://github.com/docker/distribution/issues/2288">Remove the layer&rsquo;s link by garbage-collect #2288</a> is dedicated to cleaning up these useless layer link files. The earliest one is from three years ago, but it hasn&rsquo;t been merged yet 😂.</p>
<p>The solution is to use the solution mentioned in my <a href="https://blog.k8s.li/registry-gc.html">docker registry GC schema analysis</a> article: homebrew registry GC script 🙃 .</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="cp">#!/bin/bash
</span><span class="cp"></span><span class="nv">v2</span><span class="o">=</span><span class="nv">$1</span>
<span class="nv">v2</span><span class="o">=</span><span class="si">${</span><span class="nv">v2</span><span class="p">:=</span><span class="s2">&#34;/var/lib/registry/docker/registry/v2&#34;</span><span class="si">}</span>
<span class="nb">cd</span> <span class="si">${</span><span class="nv">v2</span><span class="si">}</span>
<span class="nv">all_blobs</span><span class="o">=</span>/tmp/all_blobs.list
: &gt; <span class="si">${</span><span class="nv">all_blobs</span><span class="si">}</span>
<span class="c1"># delete unlink blob&#39;s link file in _layers</span>
<span class="k">for</span> link in <span class="k">$(</span>find repositories -type f -name <span class="s2">&#34;link&#34;</span> <span class="p">|</span> grep -E <span class="s2">&#34;_layers\/sha256\/.*&#34;</span><span class="k">)</span><span class="p">;</span> <span class="k">do</span>
    <span class="nv">link_sha256</span><span class="o">=</span><span class="k">$(</span><span class="nb">echo</span> <span class="si">${</span><span class="nv">link</span><span class="si">}</span> <span class="p">|</span> grep -Eo <span class="s2">&#34;_layers\/sha256\/.*&#34;</span> <span class="p">|</span> sed <span class="s1">&#39;s/_layers\/sha256\///g;s/\/link//g&#39;</span><span class="k">)</span>
    <span class="nv">link_short</span><span class="o">=</span><span class="si">${</span><span class="nv">link</span><span class="p">:</span><span class="nv">0</span><span class="p">:</span><span class="nv">2</span><span class="si">}</span>
    <span class="nv">link_dir</span><span class="o">=</span><span class="k">$(</span><span class="nb">echo</span> <span class="si">${</span><span class="nv">link</span><span class="si">}</span> <span class="p">|</span> sed <span class="s1">&#39;s/\/link//&#39;</span><span class="k">)</span>
    <span class="nv">data_file</span><span class="o">=</span>blobs/sha256/<span class="si">${</span><span class="nv">link_short</span><span class="si">}</span>/<span class="si">${</span><span class="nv">link</span><span class="si">}</span>
    <span class="k">if</span> <span class="o">[[</span> ! -d <span class="si">${</span><span class="nv">data_file</span><span class="si">}</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span> rm -rf <span class="si">${</span><span class="nv">link_dir</span><span class="si">}</span><span class="p">;</span> <span class="k">fi</span>
<span class="k">done</span>
<span class="c1">#marking all the blob by all images manifest</span>
<span class="k">for</span> tag in <span class="k">$(</span>find repositories -name <span class="s2">&#34;link&#34;</span> <span class="p">|</span> grep current<span class="k">)</span><span class="p">;</span> <span class="k">do</span>
    <span class="nv">link</span><span class="o">=</span><span class="k">$(</span>cat <span class="si">${</span><span class="nv">tag</span><span class="si">}</span> <span class="p">|</span> cut -c8-71<span class="k">)</span>
    <span class="nv">mfs</span><span class="o">=</span>blobs/sha256/<span class="si">${</span><span class="nv">link</span><span class="p">:</span><span class="nv">0</span><span class="p">:</span><span class="nv">2</span><span class="si">}</span>/<span class="si">${</span><span class="nv">link</span><span class="si">}</span>/data
    <span class="nb">echo</span> <span class="si">${</span><span class="nv">link</span><span class="si">}</span> &gt;&gt; <span class="si">${</span><span class="nv">all_blobs</span><span class="si">}</span>
    grep -Eo <span class="s2">&#34;\b[a-f0-9]{64}\b&#34;</span> <span class="si">${</span><span class="nv">mfs</span><span class="si">}</span> <span class="p">|</span> sort -n <span class="p">|</span> uniq <span class="p">|</span> cut -c1-12 &gt;&gt; <span class="si">${</span><span class="nv">all_blobs</span><span class="si">}</span>
<span class="k">done</span>
<span class="c1">#delete blob if the blob doesn&#39;t exist in all_blobs.list</span>
<span class="k">for</span> blob in <span class="k">$(</span>find blobs -name <span class="s2">&#34;data&#34;</span> <span class="p">|</span> cut -d <span class="s2">&#34;/&#34;</span> -f4<span class="k">)</span><span class="p">;</span> <span class="k">do</span>
    <span class="k">if</span> ! grep <span class="si">${</span><span class="nv">blob</span><span class="si">}</span> <span class="si">${</span><span class="nv">all_blobs</span><span class="si">}</span><span class="p">;</span> <span class="k">then</span>
        rm -rf blobs/sha256/<span class="si">${</span><span class="nv">blob</span><span class="p">:</span><span class="nv">0</span><span class="p">:</span><span class="nv">2</span><span class="si">}</span>/<span class="si">${</span><span class="nv">blob</span><span class="si">}</span>
    <span class="k">fi</span>
<span class="k">done</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="process">Process</h2>
<p>Well, so far the final optimization plan has been set, its process on the following.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/09/26/76e22cdebe314637bae600b1b75af756.png" alt=""></p>
<ul>
<li>The first time you synchronize the image, you will not synchronize the image to the archive backup image repository (archive.registry.local), but to the overlay2 image repository, which will be used as the lower layer for the second image synchronization.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">cat images.list <span class="p">|</span> xargs -L1 -I <span class="o">{}</span> skopeo copy --insecure-policy --src-tls-verify<span class="o">=</span><span class="nb">false</span> --dest-tls-verify<span class="o">=</span><span class="nb">false</span> docker://cicd.registry.local/<span class="o">{}</span> docker://overlay2.registry.local/<span class="o">{}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>After the first mirror sync is done, clean up the merged, upper, and work layers of overlay2 and keep only the lower layer. This is because the lower layer contains the result of the first mirror sync.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">umount /var/lib/registry/merged
rm -rf /var/lib/registry/<span class="o">{</span>merged,upper,work<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>The next step is to mount overlay2 using mount, and then go to the merged level and delete all the _manifests directories</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">mount -t overlay overlay -o <span class="nv">lowerdir</span><span class="o">=</span>lower,upperdir<span class="o">=</span>upper,workdir<span class="o">=</span>work merged
<span class="nb">cd</span> /var/lib/registry/merged
find registry/v2/repositories -type d -name <span class="s2">&#34;_manifests&#34;</span> -exec rm -rf <span class="o">{}</span> <span class="se">\;</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>Next, a second mirror sync is performed, this time to recreate the _manifests directory</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">cat images.list <span class="p">|</span> xargs -L1 -I <span class="o">{}</span> skopeo copy --insecure-policy --src-tls-verify<span class="o">=</span><span class="nb">false</span> --dest-tls-verify<span class="o">=</span><span class="nb">false</span> docker://overlay2.registry.local/<span class="o">{}</span> docker://package.registry.local/<span class="o">{}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>After the second sync, use the homemade registry GC script to remove unnecessary blob files and link files.</li>
<li>Finally, pack the image repository directory and you have the image you need.</li>
</ul>
<h2 id="ending">Ending</h2>
<p>Although the process is much more complex than before, the result of the optimization is very obvious - it is 5 to 15 times faster than before and has been working steadily in our production environment for most of the year.</p>
<p>After reading this article, you may feel confused as to what is being said. What mirror synchronization, mirror blob, layer, overlay2, co-mount, copy-on-write, etc., confused by the complex background and concepts 😂. This article is really not very good understanding, because the background may be more special and complex, few people will encounter such scenarios. In order to understand the content and the principles behind this article well, I will write a separate blog in a while to understand the technical principles mentioned in this article through best practices. Stay tuned 😝!</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/overlay/">overlay</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2021-09/containerd-usage/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Understanding the Container Runtime Containerd in one article</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2021-09/jenkins-with-kubernetes/">
            <span class="next-text nav-default">Jenkins With Kubernetes</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
