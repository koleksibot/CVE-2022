<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>How to get the client&#39;s real IP, starting with a &#34;bug&#34; in Gin - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Request IP, as one of the user&amp;rsquo;s identity attributes, is a very important basic data. In many scenarios, we will do network security attack prevention or access risk control based on the client request IP. Usually, we can get the real IP through the X-Forwarded-For header in the HTTP protocol Request Headers, but is it really reliable to get the real IP through the X-Forwarded-For header? Concept The X-Forwarded-For is" /><meta name="keywords" content="golang, gin, Client Real Ip" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2021-09/gin-get-client-real-ip/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="How to get the client&#39;s real IP, starting with a &#34;bug&#34; in Gin" />
<meta property="og:description" content="Request IP, as one of the user&rsquo;s identity attributes, is a very important basic data. In many scenarios, we will do network security attack prevention or access risk control based on the client request IP. Usually, we can get the real IP through the X-Forwarded-For header in the HTTP protocol Request Headers, but is it really reliable to get the real IP through the X-Forwarded-For header? Concept The X-Forwarded-For is" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2021-09/gin-get-client-real-ip/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-09-24T10:45:55+08:00" />
<meta property="article:modified_time" content="2021-09-24T10:45:55+08:00" />

<meta itemprop="name" content="How to get the client&#39;s real IP, starting with a &#34;bug&#34; in Gin">
<meta itemprop="description" content="Request IP, as one of the user&rsquo;s identity attributes, is a very important basic data. In many scenarios, we will do network security attack prevention or access risk control based on the client request IP. Usually, we can get the real IP through the X-Forwarded-For header in the HTTP protocol Request Headers, but is it really reliable to get the real IP through the X-Forwarded-For header? Concept The X-Forwarded-For is"><meta itemprop="datePublished" content="2021-09-24T10:45:55+08:00" />
<meta itemprop="dateModified" content="2021-09-24T10:45:55+08:00" />
<meta itemprop="wordCount" content="2536">
<meta itemprop="keywords" content="golang,gin," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="How to get the client&#39;s real IP, starting with a &#34;bug&#34; in Gin"/>
<meta name="twitter:description" content="Request IP, as one of the user&rsquo;s identity attributes, is a very important basic data. In many scenarios, we will do network security attack prevention or access risk control based on the client request IP. Usually, we can get the real IP through the X-Forwarded-For header in the HTTP protocol Request Headers, but is it really reliable to get the real IP through the X-Forwarded-For header? Concept The X-Forwarded-For is"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">How to get the client&#39;s real IP, starting with a &#34;bug&#34; in Gin</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-09-24 10:45:55 </span>
        <div class="post-category">
            <a href="/categories/skills/"> skills </a>
            </div>
          <span class="more-meta"> 2536 words </span>
          <span class="more-meta"> 6 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#concept">Concept</a></li>
        <li><a href="#analysis">Analysis</a>
          <ul>
            <li><a href="#can-x-forwarded-for-be-forged">Can X-Forwarded-For be forged?</a></li>
            <li><a href="#how-can-i-get-the-real-client-ip">How can I get the real client IP?</a></li>
          </ul>
        </li>
        <li><a href="#summary">Summary</a>
          <ul>
            <li><a href="#continue-trying-to-get-the-clients-real-ip-via-x-forwarded-for">Continue trying to get the client&rsquo;s real IP via X-Forwarded-For</a></li>
            <li><a href="#try-to-get-the-clients-real-ip-through-custom-header">Try to get the client&rsquo;s real IP through custom Header</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>Request IP, as one of the user&rsquo;s identity attributes, is a very important basic data. In many scenarios, we will do network security attack prevention or access risk control based on the client request IP. Usually, we can get the real IP through the <code>X-Forwarded-For</code> header in the HTTP protocol Request Headers, but is it really reliable to get the real IP through the <code>X-Forwarded-For</code> header?</p>
<h2 id="concept">Concept</h2>
<p>The <code>X-Forwarded-For</code> is an HTTP extension header that is not defined in the HTTP/1.1 (RFC 2616) standard and was first introduced by Squid, a caching proxy, to represent the real IP of an HTTP request. It is now a de facto standard and is widely used by major HTTP proxies, load balancing and other forwarding services, and is written into the RFC 7239 (Forwarded HTTP Extension) standard.</p>
<p>We found a &ldquo;bug&rdquo; after upgrading the Gin framework to 1.7.2 in one of our HTTP services, where the server could not get the correct client IP after the upgrade, but instead the Nginx Ingress IP in the Kubernetes cluster, so we decided to get the client source code from Gin to investigate.</p>
<p>The business-side service was previously using version v1.6.3, so let&rsquo;s look at the <code>Context.ClientIP()</code> method implementation.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// ClientIP 方法可以获取到请求客户端的IP
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">ClientIP</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
   <span class="c1">// 1. ForwardedByClientIP 默认为 true，此处会优先取 X-Forwarded-For 值，
</span><span class="c1"></span>   <span class="c1">// 如果 X-Forwarded-For 为空，则会再尝试取 X-Real-Ip
</span><span class="c1"></span>   <span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">engine</span><span class="p">.</span><span class="nx">ForwardedByClientIP</span> <span class="p">{</span>
      <span class="nx">clientIP</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">requestHeader</span><span class="p">(</span><span class="s">&#34;X-Forwarded-For&#34;</span><span class="p">)</span>
      <span class="nx">clientIP</span> <span class="p">=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">TrimSpace</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nf">Split</span><span class="p">(</span><span class="nx">clientIP</span><span class="p">,</span> <span class="s">&#34;,&#34;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
      <span class="k">if</span> <span class="nx">clientIP</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
         <span class="nx">clientIP</span> <span class="p">=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">TrimSpace</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">requestHeader</span><span class="p">(</span><span class="s">&#34;X-Real-Ip&#34;</span><span class="p">))</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="nx">clientIP</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
         <span class="k">return</span> <span class="nx">clientIP</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="c1">// 2. 如果我们手动配置 ForwardedByClientIP 为 false 且 X-Appengine-Remote-Addr 不为空，则取 X-Appengine-Remote-Addr 作为客户端IP
</span><span class="c1"></span>   <span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">engine</span><span class="p">.</span><span class="nx">AppEngine</span> <span class="p">{</span>
      <span class="k">if</span> <span class="nx">addr</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">requestHeader</span><span class="p">(</span><span class="s">&#34;X-Appengine-Remote-Addr&#34;</span><span class="p">);</span> <span class="nx">addr</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
         <span class="k">return</span> <span class="nx">addr</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="c1">// 3. 最终才考虑取对端 IP 兜底
</span><span class="c1"></span>   <span class="k">if</span> <span class="nx">ip</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">SplitHostPort</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nf">TrimSpace</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">RemoteAddr</span><span class="p">));</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">ip</span>
<span class="p">}</span>
   <span class="k">return</span> <span class="s">&#34;&#34;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Looking at the v1.7.2 version, the <code>Contexnt.ClientIP()</code> method implements.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">RemoteIP</span><span class="p">()</span> <span class="p">(</span><span class="nx">net</span><span class="p">.</span><span class="nx">IP</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
   <span class="o">...</span>
   <span class="nx">remoteIP</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">ParseIP</span><span class="p">(</span><span class="nx">ip</span><span class="p">)</span> <span class="c1">// 获取客户端 IP
</span><span class="c1"></span>   <span class="o">...</span>
   <span class="c1">// trustedCIDRs 由 engine 启动时配置的 TrustedProxies 数组解析而来，表示可以信任的前置代理 CIDR 列表。只有配置了 engine.TrustedProxies 才有可能解析出正确的可信任 CIDR 列表。
</span><span class="c1"></span>   <span class="c1">// 只有 CIDR 列表不为空，这里才会将 remoteIP 和已配置可信 CIDR 列表进行比对。CIDR 列表中任一 CIDR 包含对端 IP，则将第二个返回值置为 true，表示对端 IP 可信任。
</span><span class="c1"></span>   <span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">engine</span><span class="p">.</span><span class="nx">trustedCIDRs</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">cidr</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">c</span><span class="p">.</span><span class="nx">engine</span><span class="p">.</span><span class="nx">trustedCIDRs</span> <span class="p">{</span>
         <span class="k">if</span> <span class="nx">cidr</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="nx">remoteIP</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">remoteIP</span><span class="p">,</span> <span class="kc">true</span>
         <span class="p">}</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="nx">remoteIP</span><span class="p">,</span> <span class="kc">false</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">ClientIP</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
   <span class="c1">// 1. AppEngine 默认为 false，如果应用通过 Google Cloud App Engine 部署，或用户手动设置为 true 且 X-Appengine-Remote-Addr 不为空，则会取 X-Appengine-Remote-Addr 值作为客户端 IP。
</span><span class="c1"></span>   <span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">engine</span><span class="p">.</span><span class="nx">AppEngine</span> <span class="p">{</span>
      <span class="k">if</span> <span class="nx">addr</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">requestHeader</span><span class="p">(</span><span class="s">&#34;X-Appengine-Remote-Addr&#34;</span><span class="p">);</span> <span class="nx">addr</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
         <span class="k">return</span> <span class="nx">addr</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="c1">// 2. 否则通过 RemoteIP() 方法判断对端 IP 是否可信，trusted 为 true 表示可信
</span><span class="c1"></span>   <span class="c1">// 详见上文 Context.RemoteIP() 方法内部注释。
</span><span class="c1"></span>   <span class="nx">remoteIP</span><span class="p">,</span> <span class="nx">trusted</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">RemoteIP</span><span class="p">()</span>
   <span class="k">if</span> <span class="nx">remoteIP</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="s">&#34;&#34;</span>
   <span class="p">}</span>
   <span class="c1">// 3. 如对端 IP 可信，且 ForwardedByClientIP 为 true(默认为 true），且
</span><span class="c1"></span>   <span class="c1">// RemoteIPHeaders 不为空（默认不为空），则根据 RemoteIPHeaders 中配置的获取 ClientIP 的 Headers 列表中依次获取。默认读取顺序：1. X-Forwarded-For；2. X-Real-IP。
</span><span class="c1"></span>   <span class="k">if</span> <span class="nx">trusted</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">engine</span><span class="p">.</span><span class="nx">ForwardedByClientIP</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">engine</span><span class="p">.</span><span class="nx">RemoteIPHeaders</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">headerName</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">c</span><span class="p">.</span><span class="nx">engine</span><span class="p">.</span><span class="nx">RemoteIPHeaders</span> <span class="p">{</span>
         <span class="c1">// 对header进行处理，先通过&#34;,&#34;进行分割，并返回分割后 IP 列表的第一个合法 IP
</span><span class="c1"></span>         <span class="nx">ip</span><span class="p">,</span> <span class="nx">valid</span> <span class="o">:=</span> <span class="nf">validateHeader</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">requestHeader</span><span class="p">(</span><span class="nx">headerName</span><span class="p">))</span>
         <span class="k">if</span> <span class="nx">valid</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">ip</span>
         <span class="p">}</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="c1">// 3. 最终才考虑取对端 IP 兜底。
</span><span class="c1"></span>   <span class="k">return</span> <span class="nx">remoteIP</span><span class="p">.</span><span class="nf">String</span><span class="p">()</span>
<span class="p">}</span>
<span class="c1">// validateHeader 会对入参header进行校验，先通过&#34;,&#34;进行分割成 IP 列表后，对每个 IP 进行合法性检查，如果任一 IP 不合法，则此Header不合法；否则返回 IP 列表中第一个 IP。
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">validateHeader</span><span class="p">(</span><span class="nx">header</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">clientIP</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">valid</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="nx">header</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
      <span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="kc">false</span>
   <span class="p">}</span>
   <span class="nx">items</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Split</span><span class="p">(</span><span class="nx">header</span><span class="p">,</span> <span class="s">&#34;,&#34;</span><span class="p">)</span>
   <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">ipStr</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">items</span> <span class="p">{</span>
      <span class="nx">ipStr</span> <span class="p">=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">TrimSpace</span><span class="p">(</span><span class="nx">ipStr</span><span class="p">)</span>
      <span class="nx">ip</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">ParseIP</span><span class="p">(</span><span class="nx">ipStr</span><span class="p">)</span>
      <span class="o">...</span>
      <span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
         <span class="nx">clientIP</span> <span class="p">=</span> <span class="nx">ipStr</span>
         <span class="nx">valid</span> <span class="p">=</span> <span class="kc">true</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="k">return</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>A detailed discussion of this &ldquo;bug&rdquo; can be found at <a href="https://github.com/gin-gonic/gin/issues/2697">https://github.com/gin-gonic/gin/issues/2697</a></p>
<h2 id="analysis">Analysis</h2>
<p>Let&rsquo;s start by introducing a few concepts/terms that may be covered later.</p>
<ul>
<li><code>$remote_addr</code>: This is the real address of the client that Nginx obtains during the TCP connection with the client. Remote Address cannot be forged because it takes three handshakes to establish a TCP connection. If you forge the source IP, you cannot establish a TCP connection, and there will be no subsequent HTTP requests.</li>
<li><code>X-Client-Real-IP</code> ：This feature is basically supported by most of the cloud vendors (Ali cloud, Huawei cloud, Tencent cloud, etc.). This feature is basically supported by most cloud vendors (Ali cloud, Huawei cloud, Tencent cloud, etc).</li>
</ul>
<p>Network requests are usually sent by browsers (or other clients), forwarded through layers of network devices, and finally reach the server. Then the <code>$remote_addr</code> in the request received by each link must be the real IP of the upstream link, which cannot be faked. Then from the whole link, if the source of the final request is needed, it is traced by <code>X-Forwarded-For</code>, and the IP (<code>$remote_addr</code>) of each link is added to the <code>X-Forwarded-For</code> field, so that <code>X-Forwarded-For</code> can connect the whole link in series. That is.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">X-Forwarded-For: client_ip, proxy1_ip, proxy2_ip
</code></pre></td></tr></table>
</div>
</div><h3 id="can-x-forwarded-for-be-forged">Can X-Forwarded-For be forged?</h3>
<p>Whether or not a client can spoof IP depends on how the Edge Node handles the X-Forwarded-For field. The first Proxy node to which a client connects directly is called an Edge Node, whether it is a gateway, CDN, LB, etc. As long as this layer is accessed directly by the client, then it is an Edge Node.</p>
<ul>
<li>Edge nodes that do not override X-Forwarded-For Edge nodes are insecure if they pass through the <code>X-Forwarded-For</code> header of HTTP, and the client can forge the <code>X-Forwarded-For</code> value in the HTTP request, and the value will be passed backwards.</li>
</ul>
<p>Thus an edge node that does not override <code>X-Forwarded-For</code> is an insecure edge node and the user can forge <code>X-Forwarded-For</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"># 不安全
X-Forwareded-For：clientX-Forwarded-For(用户请求中的 X-Forwarded-For)，proxy1，proxy2，proxy3...
</code></pre></td></tr></table>
</div>
</div><ul>
<li>Edge nodes that override X-Forwarded-For Edge nodes are secure if they override <code>$remote_addr</code> to <code>X-Forwarded-For</code>. The <code>remote_addr</code> obtained by the edge node is the real IP of the client, so an edge node that overrides <code>X-Forwarded-For</code> is a secure edge node and the user cannot forge <code>X-Forwarded-For</code>.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"># 边缘节点用 $remote_addr 来覆盖用户请求中的 X-Forwarded-For：
proxy_set_header X-Forwarded-For $remote_addr; 
# 安全
X-Forwareded-For：ClientX-Forwarded-For(边缘节点获取的 remote_addr)，proxy1，proxy2，proxy3...
</code></pre></td></tr></table>
</div>
</div><h3 id="how-can-i-get-the-real-client-ip">How can I get the real client IP?</h3>
<p>We consider solutions that can obtain real client IPs under common network topologies on public clouds.</p>
<h4 id="client-waf-slb-ingress-pod">Client-&gt;WAF-&gt;SLB-&gt;Ingress-&gt;Pod</h4>
<h5 id="using-the-nginx-real-ip-module">Using the Nginx real-ip module</h5>
<p>To get it using the Nginx real-ip module, configure proxy-real-ip-cidr on Ingress to add both the WAF and SLB (layer 7) addresses. After this operation, the server can fetch real IPs using X-Forwarded-For and fake IPs using X-Original-Forwarded-For.</p>
<p>This option has the following disadvantages.</p>
<p>Since the WAF is maintained by the cloud vendor, the WAF address pool is large and the addresses change, making it extremely difficult to maintain this dynamic configuration, and inaccurate client IPs can be obtained if not updated in a timely manner. -Even with this solution, if the business side wants to use the new version of Gin&rsquo;s ctx.ClientIP() method, it still needs to change the code to configure all trusted proxies to TrustedProxies, which will lead to coupling of infrastructure and business services, and this solution is obviously unacceptable unless the business side is willing to lock the relying Gin version locked at v1.6.3.</p>
<h5 id="customizing-header-with-waf">Customizing Header with WAF</h5>
<p>Many cloud vendors provide custom Header to get the client real IP ($remote_addr) capability. We can configure custom Header headers in advance in the cloud vendor WAF endpoint, such as X-Appengine-Remote-Addr or X-Client-Real-IP, etc., to get the client real IP.</p>
<p>This option has the following drawbacks.</p>
<p>If you reuse the <code>X-Appengine-Remote-Addr</code> header directly, you need to set <code>engine.AppEngine=true</code> to get the client IP with the <code>ctx.ClientIP()</code> method - if you use other header, such as <code>X -Client-Real-IP</code>, you need to encapsulate the client IP method from <code>X-Client-Real-IP</code>, and you need to do the modification with the business.</p>
<p>The architecture is roughly as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/09/24/16a3e09b31c743bc8b2bdb1e214b4a15.png" alt=""></p>
<h4 id="client-cdn-waf-slb-ingress-pod">Client-&gt;CDN-&gt;WAF-&gt;SLB-&gt;Ingress-&gt;Pod</h4>
<h5 id="use-real-ip">Use real-ip</h5>
<p>Using the <code>real-ip</code> module, you need to configure <code>proxy-real-ip-cidr</code> on ingress to add CDN, WAF and SLB (layer 7) addresses, and the server can fetch real IPs using <code>X-Forwarded-For</code> and fake IPs via <code>X-Original-Forwarded-For</code>.</p>
<p>Advantages and disadvantages of this scenario.</p>
<p>This scenario has more CDN layers than 3.2.1, the CDN address pool is larger than WAF, the address pool changes more frequently, and the vendor does not provide a CDN address pool, so it is basically impossible to maintain Ingress configuration. -Even with this solution, if the business side wants to use the new version of Gin&rsquo;s <code>ctx.ClientIP()</code> method, <strong>it still needs to change the code to configure all trusted proxies to TrustedProxies</strong>, which will lead to coupling of infrastructure and business services, which is definitely unacceptable unless the business side will Gin version locked at 1.6.3.</p>
<h5 id="customizing-header-with-cdn">Customizing Header with CDN</h5>
<p>The advantages and disadvantages of this solution are the same as in 3.1.1. The architecture is approximately as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/09/24/822baf9ae20c42feafc819021c0b7c57.png" alt=""></p>
<h4 id="client-slb-ingress-pod">Client-&gt;SLB-&gt;Ingress-&gt;Pod</h4>
<p>You can prevent <code>X-Forwarded-For</code> forgery by setting <code>use-forwarded-headers</code> on Ingress.</p>
<ul>
<li>use-forwarded-headers=false</li>
</ul>
<p>For Ingress without a proxy layer in front of it, e.g. directly on a Layer 4 SLB, ingress rewrites <code>X-Forwarded-For</code> to <code>$remote_addr</code> by default, which prevents forging <code>X-Forwarded-For</code>.</p>
<ul>
<li>use-forwarded-headers=true</li>
</ul>
<p>For Ingress with a pre-proxy layer, such as a Layer 7 SLB or WAF, CDN, etc., this is equivalent to adding the following configuration to nginx.conf.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-nginx" data-lang="nginx"><span class="k">real_ip_header</span>      <span class="s">X-Forwarded-For</span><span class="p">;</span> 
<span class="k">real_ip_recursive</span>   <span class="no">on</span><span class="p">;</span> 
<span class="k">set_real_ip_from</span>    <span class="mi">0</span><span class="s">.0.0.0/0</span><span class="p">;</span> <span class="k">//</span> <span class="s">默认信任所有</span> <span class="s">IP，无法避免伪造</span> <span class="s">X-Forwarded-For</span>
</code></pre></td></tr></table>
</div>
</div><p>The architecture is roughly as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/09/24/4a0ac93e0a254b48ac4c0572e344b5e9.png" alt=""></p>
<h2 id="summary">Summary</h2>
<p>As we can see from the above, with the complex and changing network topology on the cloud, we have to frequently maintain multiple network configurations such as CDN, WAF, SLB, Ingress, etc. If <code>X-Forwarded-For</code> is not forged, there are only two options for upgrading the Go service of the Gin framework.</p>
<p>Keep trying to get the client&rsquo;s real IP through <code>X-Forwarded-For</code>. - Try to get the client&rsquo;s real IP through another Header.</p>
<h3 id="continue-trying-to-get-the-clients-real-ip-via-x-forwarded-for">Continue trying to get the client&rsquo;s real IP via X-Forwarded-For</h3>
<p>The business needs to configure all the front agents of the infrastructure into TrustedProxies, including CDN address pools, WAF address pools, and Kunernetest Nginx Ingress address pools, and this solution is basically impossible to implement.</p>
<ul>
<li>
<p>The configuration is too complex and difficult to troubleshoot once the IP is not available.</p>
</li>
<li>
<p>If the infrastructure makes changes to the CDN, WAF, or Ingress, the business code must be changed simultaneously. -Some of the trusted proxy IPs are not configurable at all, such as CDN address pools.</p>
</li>
</ul>
<h3 id="try-to-get-the-clients-real-ip-through-custom-header">Try to get the client&rsquo;s real IP through custom Header</h3>
<p>The infrastructure team provides a custom Header to get the client&rsquo;s real IP, such as <code>X-Client-Real-IP</code> or <code>X-Appengine-Remote-Addr</code>. This scenario requires the infrastructure team to configure the cloud vendor CDN or WAF endpoint accordingly. This solution is.</p>
<ul>
<li>
<p>Simple and reliable configuration, low maintenance cost, only need to configure custom Header in CDN, WAF endpoint. -If you use <code>X-Appengine-Remote-Addr</code>, you don&rsquo;t need to make any changes to the services using Google Cloud&rsquo;s App Engine. If you are using a domestic cloud vendor&rsquo;s service, you need to explicitly configure <code>engine.AppEngine = true</code> and then continue with the <code>ctx.ClientIP()</code> method.</p>
</li>
<li>
<p>If you use other custom Header, such as <code>X-Client-Real-IP</code> to get the real IP of the client, it is recommended to consider wrapping <code>ClientIP(*gin.Context) string</code> function to get the client IP from <code>X-Client-Real-IP</code> by yourself.</p>
</li>
</ul>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/golang/">golang</a>
          <a href="/tags/gin/">gin</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2021-09/golang-netpoll/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">golang netpoll Explained</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2021-09/websocket-mock/">
            <span class="next-text nav-default">Solution for websocket service proxy and data mock</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
