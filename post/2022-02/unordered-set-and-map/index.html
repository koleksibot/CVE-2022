<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>C&#43;&#43; Standard Library Explanation - Unordered Associative Containers - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Starting with C&#43;&#43;11, the standard library has been extended for associative containers to provide associative containers based on hash table implementations. A hash table will take up more memory than the stored elements in exchange for evenly spreading O(1) performance. Hash Tables There are many strategies for resolving conflicts, the standard library chooses to use the separate linking method, where conflicting elements are placed in one location and stored in" /><meta name="keywords" content="Unordered, Set Map" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-02/unordered-set-and-map/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="C&#43;&#43; Standard Library Explanation - Unordered Associative Containers" />
<meta property="og:description" content="Starting with C&#43;&#43;11, the standard library has been extended for associative containers to provide associative containers based on hash table implementations. A hash table will take up more memory than the stored elements in exchange for evenly spreading O(1) performance. Hash Tables There are many strategies for resolving conflicts, the standard library chooses to use the separate linking method, where conflicting elements are placed in one location and stored in" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-02/unordered-set-and-map/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-02-19T12:02:18+08:00" />
<meta property="article:modified_time" content="2022-02-19T12:02:18+08:00" />

<meta itemprop="name" content="C&#43;&#43; Standard Library Explanation - Unordered Associative Containers">
<meta itemprop="description" content="Starting with C&#43;&#43;11, the standard library has been extended for associative containers to provide associative containers based on hash table implementations. A hash table will take up more memory than the stored elements in exchange for evenly spreading O(1) performance. Hash Tables There are many strategies for resolving conflicts, the standard library chooses to use the separate linking method, where conflicting elements are placed in one location and stored in"><meta itemprop="datePublished" content="2022-02-19T12:02:18+08:00" />
<meta itemprop="dateModified" content="2022-02-19T12:02:18+08:00" />
<meta itemprop="wordCount" content="2382">
<meta itemprop="keywords" content="c&#43;&#43;," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="C&#43;&#43; Standard Library Explanation - Unordered Associative Containers"/>
<meta name="twitter:description" content="Starting with C&#43;&#43;11, the standard library has been extended for associative containers to provide associative containers based on hash table implementations. A hash table will take up more memory than the stored elements in exchange for evenly spreading O(1) performance. Hash Tables There are many strategies for resolving conflicts, the standard library chooses to use the separate linking method, where conflicting elements are placed in one location and stored in"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">C&#43;&#43; Standard Library Explanation - Unordered Associative Containers</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-02-19 12:02:18 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 2382 words </span>
          <span class="more-meta"> 5 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#hash-tables">Hash Tables</a>
          <ul>
            <li><a href="#data-structure">Data structure</a></li>
            <li><a href="#prime-number-selection">Prime number selection</a></li>
            <li><a href="#declarations">Declarations</a></li>
          </ul>
        </li>
        <li><a href="#iterators">Iterators</a></li>
        <li><a href="#function-implementation">Function implementation</a>
          <ul>
            <li><a href="#element-mapping">Element Mapping</a></li>
            <li><a href="#memory-management">Memory management</a></li>
            <li><a href="#inserting-elements">Inserting elements</a></li>
          </ul>
        </li>
        <li><a href="#unordered_set">unordered_set</a>
          <ul>
            <li><a href="#identity">identity</a></li>
          </ul>
        </li>
        <li><a href="#unordered_map">unordered_map</a>
          <ul>
            <li><a href="#select1st">select1st</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>Starting with C++11, the standard library has been extended for associative containers to provide associative containers based on <strong>hash table</strong> implementations. A hash table will take up more memory than the stored elements in exchange for evenly spreading O(1) performance.</p>
<h2 id="hash-tables">Hash Tables</h2>
<p>There are many strategies for resolving conflicts, the standard library chooses to use the <strong>separate linking method</strong>, where conflicting elements are placed in one location and stored in a linked table.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/19/287dec4e7e354bd09d49990395856709.png" alt="sobyte"></p>
<h3 id="data-structure">Data structure</h3>
<p>Here each element in the hash table is called a bucket, and each inserted element is mapped to the corresponding bucket using the hash function and then placed into it as a node.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Value</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">_hash_table_node</span>
<span class="p">{</span>
    <span class="n">Value</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">_hash_table_node</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>

    <span class="n">_hash_table_node</span><span class="p">(</span><span class="n">Value</span> <span class="n">v</span><span class="p">)</span> <span class="o">:</span><span class="n">val</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">next</span><span class="p">(</span><span class="k">nullptr</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="prime-number-selection">Prime number selection</h3>
<p>Hash table for better performance, the number of buckets needs to be prime, and a batch is predefined in order to get prime numbers quickly.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">_stl_num_primes</span> <span class="o">=</span> <span class="mi">28</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">size_t</span> <span class="n">_stl_prime_list</span><span class="p">[</span><span class="n">_stl_num_primes</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
  <span class="mi">53ul</span><span class="p">,</span>         <span class="mi">97ul</span><span class="p">,</span>         <span class="mi">193ul</span><span class="p">,</span>        <span class="mi">389ul</span><span class="p">,</span>
  <span class="mi">769ul</span><span class="p">,</span>        <span class="mi">1543ul</span><span class="p">,</span>       <span class="mi">3079ul</span><span class="p">,</span>       <span class="mi">6151ul</span><span class="p">,</span>      <span class="mi">12289ul</span><span class="p">,</span>
  <span class="mi">24593ul</span><span class="p">,</span>      <span class="mi">49157ul</span><span class="p">,</span>      <span class="mi">98317ul</span><span class="p">,</span>      <span class="mi">196613ul</span><span class="p">,</span>    <span class="mi">393241ul</span><span class="p">,</span>
  <span class="mi">786433ul</span><span class="p">,</span>     <span class="mi">1572869ul</span><span class="p">,</span>    <span class="mi">3145739ul</span><span class="p">,</span>    <span class="mi">6291469ul</span><span class="p">,</span>   <span class="mi">12582917ul</span><span class="p">,</span>
  <span class="mi">25165843ul</span><span class="p">,</span>   <span class="mi">50331653ul</span><span class="p">,</span>   <span class="mi">100663319ul</span><span class="p">,</span>  <span class="mi">201326611ul</span><span class="p">,</span> <span class="mi">402653189ul</span><span class="p">,</span>
  <span class="mi">805306457ul</span><span class="p">,</span>  <span class="mi">1610612741ul</span><span class="p">,</span> <span class="mi">3221225473ul</span><span class="p">,</span> <span class="mi">4294967291ul</span>
<span class="p">};</span>

<span class="kr">inline</span> <span class="n">size_t</span> <span class="nf">max_bucket_count</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">_stl_prime_list</span><span class="p">[</span><span class="n">_stl_num_primes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="n">size_t</span> <span class="nf">_stl_next_prime</span><span class="p">(</span><span class="n">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">size_t</span><span class="o">*</span> <span class="n">first</span> <span class="o">=</span> <span class="n">_stl_prime_list</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">size_t</span><span class="o">*</span> <span class="n">last</span> <span class="o">=</span> <span class="n">_stl_prime_list</span> <span class="o">+</span> <span class="n">_stl_num_primes</span><span class="p">;</span>
    <span class="c1">// lower_bound 用于找到 [first,last) 中第一个不小于 n 的元素
</span><span class="c1"></span>    <span class="k">const</span> <span class="n">size_t</span><span class="o">*</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">lower_bound</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">pos</span> <span class="o">==</span> <span class="n">last</span> <span class="o">?</span> <span class="o">*</span><span class="p">(</span><span class="n">last</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="declarations">Declarations</h3>
<p>To allow the number of buckets to grow dynamically, vector is used as the container for the buckets.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Value</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">HashFunc</span><span class="p">,</span> <span class="k">class</span> <span class="nc">ExtractKey</span><span class="p">,</span>
    <span class="k">class</span> <span class="nc">EqualKey</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">allocator</span><span class="o">&lt;</span><span class="n">Value</span><span class="o">&gt;&gt;</span>
<span class="k">class</span> <span class="nc">hash_table</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">using</span> <span class="n">hasher</span> <span class="o">=</span> <span class="n">HashFunc</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">key_equal</span> <span class="o">=</span> <span class="n">EqualKey</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">size_type</span> <span class="o">=</span> <span class="n">size_t</span><span class="p">;</span>

    <span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="n">Value</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">key_type</span> <span class="o">=</span> <span class="n">Key</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">iterator</span> <span class="o">=</span> <span class="n">_hash_table_iterator</span><span class="o">&lt;</span><span class="n">Value</span><span class="p">,</span> <span class="n">Key</span><span class="p">,</span> <span class="n">HashFunc</span><span class="p">,</span>
                        <span class="n">ExtractKey</span><span class="p">,</span> <span class="n">EqualKey</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">hasher</span> <span class="n">hash_</span><span class="p">;</span>
    <span class="n">key_equal</span> <span class="n">equal_</span><span class="p">;</span>
    <span class="n">ExtractKey</span> <span class="n">get_key_</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">node</span><span class="o">*&gt;</span> <span class="n">buckets</span><span class="p">;</span>
    <span class="n">size_type</span> <span class="n">num_elements</span><span class="p">;</span>
    <span class="n">node_allocator</span> <span class="n">alloc_</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>Template parameters reflect the core of the entire hash table.</p>
<ul>
<li><code>Value</code>: the value type. It is worth noting that this is not the value in the key-value pair concept, but the type that is actually stored in the node, as you can see the difference later when we introduce map.</li>
<li><code>Key</code>: The key type.</li>
<li><code>HashFunc</code> : Hash function. Used to map elements to buckets, as defined in the standard library.</li>
<li><code>ExtractKey</code> : A method to extract a key from a value, you can see exactly what it does later.</li>
<li><code>EqualKey</code> : A method to determine if keys are identical.</li>
<li><code>Alloc</code> : Memory allocator.</li>
</ul>
<p>Internally, except for the member type declarations common to STL containers, the data members are instances corresponding to the template parameters.</p>
<h2 id="iterators">Iterators</h2>
<p>Iterators are an integral part of a container, but elements in a hash table are mapped to different buckets, meaning that storage is unordered.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Value</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">HashFunc</span><span class="p">,</span> 
    <span class="k">class</span> <span class="nc">ExtractKey</span><span class="p">,</span> <span class="k">class</span> <span class="nc">EqualKey</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">_hash_table_iterator</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">node</span> <span class="o">=</span> <span class="n">_hash_table_node</span><span class="o">&lt;</span><span class="n">Value</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">hashtable</span> <span class="o">=</span> <span class="n">hash_table</span><span class="o">&lt;</span><span class="n">Value</span><span class="p">,</span> <span class="n">Key</span><span class="p">,</span> <span class="n">HashFunc</span><span class="p">,</span>
                         <span class="n">ExtractKey</span><span class="p">,</span> <span class="n">EqualKey</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">iterator</span> <span class="o">=</span> <span class="n">_hash_table_iterator</span><span class="o">&lt;</span><span class="n">Value</span><span class="p">,</span> <span class="n">Key</span><span class="p">,</span> <span class="n">HashFunc</span><span class="p">,</span>
                         <span class="n">ExtractKey</span><span class="p">,</span> <span class="n">EqualKey</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="k">using</span> <span class="n">iterator_category</span> <span class="o">=</span> <span class="n">forward_iterator_tag</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="n">Value</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">difference_type</span> <span class="o">=</span> <span class="n">ptrdiff_t</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">size_type</span> <span class="o">=</span> <span class="n">size_t</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">reference</span> <span class="o">=</span> <span class="n">value_type</span> <span class="o">&amp;</span> <span class="p">;</span>
    <span class="k">using</span> <span class="n">pointer</span> <span class="o">=</span> <span class="n">value_type</span> <span class="o">*</span> <span class="p">;</span>

    <span class="n">node</span><span class="o">*</span> <span class="n">cur</span><span class="p">;</span>
    <span class="n">hashtable</span><span class="o">*</span> <span class="n">ht</span><span class="p">;</span>
    <span class="n">_hash_table_iterator</span><span class="p">(</span><span class="n">node</span><span class="o">*</span> <span class="n">nodeptr</span><span class="p">,</span> <span class="n">hashtable</span><span class="o">*</span> <span class="n">htptr</span><span class="p">)</span> 
        <span class="o">:</span><span class="n">cur</span><span class="p">(</span><span class="n">nodeptr</span><span class="p">),</span> <span class="n">ht</span><span class="p">(</span><span class="n">htptr</span><span class="p">)</span> <span class="p">{}</span>

    <span class="n">reference</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">pointer</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">&amp;</span><span class="p">(</span><span class="k">operator</span><span class="o">*</span><span class="p">());</span> <span class="p">}</span>
    <span class="n">iterator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">();</span>
    <span class="n">iterator</span> <span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">iterator</span><span class="o">&amp;</span> <span class="n">it</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">cur</span> <span class="o">==</span> <span class="n">it</span><span class="p">.</span><span class="n">cur</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">iterator</span><span class="o">&amp;</span> <span class="n">it</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">cur</span> <span class="o">!=</span> <span class="n">it</span><span class="p">.</span><span class="n">cur</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>A common member type declaration in iterators, where the iterator is unidirectional and can only move forward, so <code>iterator_category</code> is declared as <code>forward_iterator_tag</code>. Because of this, the key to iterator implementation is the self-incrementing operator.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="n">iterator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">node</span><span class="o">*</span> <span class="n">old</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
    <span class="c1">//用 next 指针获得下一个元素
</span><span class="c1"></span>    <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">cur</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//如果到达了桶底，就去下一个有元素的桶
</span><span class="c1"></span>        <span class="n">cur</span> <span class="o">=</span> <span class="n">ht</span><span class="o">-&gt;</span><span class="n">next_bkt</span><span class="p">(</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">iterator</span> <span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">iterator</span> <span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="o">++*</span><span class="k">this</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="function-implementation">Function implementation</h2>
<h3 id="element-mapping">Element Mapping</h3>
<p>The most central aspect of a hash table is the hash function, which determines where elements will be placed.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">// n 代表桶的数量
</span><span class="c1"></span><span class="n">size_type</span> <span class="nf">bkt_num</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">bkt_num_key</span><span class="p">(</span><span class="n">get_key_</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span> <span class="n">n</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">size_type</span> <span class="nf">bkt_num</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">bkt_num_key</span><span class="p">(</span><span class="n">get_key_</span><span class="p">(</span><span class="n">obj</span><span class="p">));</span>
<span class="p">}</span>

<span class="n">size_type</span> <span class="nf">bkt_num_key</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">bkt_num_key</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">buckets</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="p">}</span>

<span class="n">size_type</span> <span class="nf">bkt_num_key</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">hash_</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>In total, there are four versions, whether they provide keys or values, the number of buckets provided or not can be mapped, and eventually it all comes down to the fourth version calling the hash function.</p>
<h3 id="memory-management">Memory management</h3>
<p>buckets is a container for storing <code>node*</code>, and it has its own well-established constructor and destructor, so there is no need to think much about its memory. So the core of memory management here is <code>node</code>, using allocator&rsquo;s to allocate (free) memory and construct (destructure).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="n">node</span><span class="o">*</span> <span class="nf">new_node</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">node</span><span class="o">*</span> <span class="n">n</span> <span class="o">=</span> <span class="n">node_allocator</span><span class="o">::</span><span class="n">allocate</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>  <span class="c1">//分配内存
</span><span class="c1"></span>    <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">node_allocator</span><span class="o">&gt;::</span><span class="n">construct</span><span class="p">(</span><span class="n">alloc_</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">obj</span><span class="p">);</span>  <span class="c1">//构造
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">delete_node</span><span class="p">(</span><span class="n">node</span><span class="o">*</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">node_allocator</span><span class="o">&gt;::</span><span class="n">destroy</span><span class="p">(</span><span class="n">alloc_</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>  <span class="c1">//析构
</span><span class="c1"></span>    <span class="n">node_allocator</span><span class="o">::</span><span class="n">deallocate</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>  <span class="c1">//释放内存
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The general size of a vector is specified internally, but here we require it to be a prime number, so we need to call the corresponding function to display it.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="nf">initialize_buckets</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//保留大于 n 的质数大小的空间
</span><span class="c1"></span>    <span class="n">buckets</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">next_size</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>   
    <span class="c1">//以空指针填充
</span><span class="c1"></span>    <span class="n">buckets</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">buckets</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">buckets</span><span class="p">.</span><span class="n">capacity</span><span class="p">(),</span> <span class="k">nullptr</span><span class="p">);</span>  
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>This way you can have a perfect constructor.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="n">hash_table</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">HashFunc</span><span class="o">&amp;</span> <span class="n">func</span><span class="p">,</span> <span class="k">const</span> <span class="n">EqualKey</span><span class="o">&amp;</span> <span class="n">eql</span><span class="p">)</span>
    <span class="o">:</span><span class="n">hash_</span><span class="p">(</span><span class="n">func</span><span class="p">),</span> <span class="n">equal_</span><span class="p">(</span><span class="n">eql</span><span class="p">),</span> <span class="n">get_key_</span><span class="p">(</span><span class="n">ExtractKey</span><span class="p">()),</span> 
     <span class="n">num_elements</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">alloc_</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">initialize_buckets</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="inserting-elements">Inserting elements</h3>
<p>Whether the inserted element is repeatable or not is optional, so two versions are provided as with the associative container <code>insert_unique</code> and <code>insert_equal</code>.</p>
<p>For the insert operation, there are two steps, first determining whether the table size needs to be expanded, and then inserting the element afterwards.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert_unique</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//扩充大小
</span><span class="c1"></span>    <span class="n">resize</span><span class="p">(</span><span class="n">num_elements</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="c1">//实施插入
</span><span class="c1"></span>    <span class="k">return</span> <span class="nf">insert_unique_aux</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="resize">resize</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="nf">resize</span><span class="p">(</span><span class="n">size_type</span> <span class="n">num_elements_hint</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">size_type</span> <span class="n">old_n</span> <span class="o">=</span> <span class="n">buckets</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="c1">// 这里 resize 权衡的是元素数量与桶数量之间大小关系
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">num_elements_hint</span> <span class="o">&gt;</span> <span class="n">old_n</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">const</span> <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="n">next_size</span><span class="p">(</span><span class="n">num_elements_hint</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">old_n</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">//构造一个新的 vector 作为新的 buckets
</span><span class="c1"></span>            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">node</span><span class="o">*&gt;</span> <span class="n">tmp</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">);</span>  
            <span class="k">for</span> <span class="p">(</span><span class="n">size_type</span> <span class="n">bucket</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">bucket</span> <span class="o">&lt;</span> <span class="n">old_n</span><span class="p">;</span> <span class="o">++</span><span class="n">bucket</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">node</span><span class="o">*</span> <span class="n">first</span> <span class="o">=</span> <span class="n">buckets</span><span class="p">[</span><span class="n">bucket</span><span class="p">];</span>
                <span class="k">while</span> <span class="p">(</span><span class="n">first</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">size_type</span> <span class="n">new_bucket</span> <span class="o">=</span> <span class="n">bkt_num</span><span class="p">(</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
                    <span class="c1">//将元素移动到 tmp 中
</span><span class="c1"></span>                    <span class="n">buckets</span><span class="p">[</span><span class="n">bucket</span><span class="p">]</span> <span class="o">=</span> <span class="n">first</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
                    <span class="n">first</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="n">new_bucket</span><span class="p">];</span>
                    <span class="n">tmp</span><span class="p">[</span><span class="n">new_bucket</span><span class="p">]</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
                    <span class="n">first</span> <span class="o">=</span> <span class="n">buckets</span><span class="p">[</span><span class="n">bucket</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="c1">// 与新的交换，tmp 就会成为旧的 buckets，随着函数结束析构
</span><span class="c1"></span>            <span class="n">buckets</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Here resize is an implementation in the SGI STL, and there is no standard condition for what happens. If the expansion function is not needed it will return directly, so there is no need to care about space as long as it is called in the insert operation.</p>
<h4 id="insert_unique">insert_unique</h4>
<p>The irreducible version returns a pair, an iterator pointing to the inserted element (even if the element itself exists), and a bool indicating whether it is a new element.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert_unique_aux</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="n">bkt_num</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
    <span class="n">node</span><span class="o">*</span> <span class="n">first</span> <span class="o">=</span> <span class="n">buckets</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">node</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span> <span class="n">cur</span><span class="p">;</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">equal_</span><span class="p">(</span><span class="n">get_key_</span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">),</span><span class="n">get_key_</span><span class="p">(</span><span class="n">val</span><span class="p">)))</span> <span class="p">{</span>
            <span class="c1">//发现存在键值相同的则返回
</span><span class="c1"></span>            <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">iterator</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="k">this</span><span class="p">),</span> <span class="nb">false</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">//插入新节点
</span><span class="c1"></span>    <span class="n">node</span><span class="o">*</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
    <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
    <span class="n">buckets</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
    <span class="o">++</span><span class="n">num_elements</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">iterator</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="k">this</span><span class="p">),</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="insert_equal">insert_equal</h4>
<p>The implementation that allows key duplication is similar to the one that does not allow it, except that it inserts immediately when it finds the same instead of returning false, and always returns the iterator of the inserted element.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert_equal_aux</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="n">bkt_num</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
    <span class="n">node</span><span class="o">*</span> <span class="n">first</span> <span class="o">=</span> <span class="n">buckets</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">node</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span> <span class="n">cur</span><span class="p">;</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">equals</span><span class="p">(</span><span class="n">get_key</span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">),</span> <span class="n">get_key_</span><span class="p">(</span><span class="n">val</span><span class="p">)))</span> <span class="p">{</span>
            <span class="c1">//发现存在键值相同的则立即插入
</span><span class="c1"></span>            <span class="n">node</span><span class="o">*</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
            <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
            <span class="o">++</span><span class="n">num_elements</span><span class="p">;</span>
            <span class="k">return</span> <span class="nf">iterator</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">node</span><span class="o">*</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
    <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
    <span class="n">buckets</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
    <span class="o">++</span><span class="n">num_elements</span><span class="p">;</span>
    <span class="k">return</span> <span class="nf">iterator</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="unordered_set">unordered_set</h2>
<p>With a sound hash table implementation in place, designing a set is simply a matter of re-calling the hash table function.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="k">class</span> <span class="nc">KeyEqual</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">equal_to</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Allocator</span> <span class="o">=</span> <span class="n">allocator</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;&gt;</span>
    <span class="k">class</span> <span class="nc">unordered_set</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="k">using</span> <span class="n">hashtable</span> <span class="o">=</span> <span class="n">hash_table</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> 
                        <span class="n">identity</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">KeyEqual</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
    <span class="k">using</span> <span class="n">key_type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">hashtable</span><span class="o">::</span><span class="n">key_type</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">hashtable</span><span class="o">::</span><span class="n">value_type</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">hasher</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">hashtable</span><span class="o">::</span><span class="n">hasher</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">key_equal</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">hashtable</span><span class="o">::</span><span class="n">key_equal</span><span class="p">;</span>

    <span class="k">using</span> <span class="n">size_type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">hashtable</span><span class="o">::</span><span class="n">size_type</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">iterator</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">hashtable</span><span class="o">::</span><span class="n">iterator</span><span class="p">;</span>

    <span class="n">unordered_set</span><span class="p">()</span> <span class="o">:</span><span class="n">ht</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">hasher</span><span class="p">(),</span> <span class="n">key_equal</span><span class="p">())</span> <span class="p">{}</span>
    <span class="k">explicit</span> <span class="nf">unordered_set</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="o">:</span><span class="n">ht</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">hasher</span><span class="p">(),</span> <span class="n">key_equal</span><span class="p">())</span> <span class="p">{}</span>

    <span class="n">size_type</span> <span class="nf">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ht</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="p">}</span>
    <span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ht</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span> <span class="p">}</span>

    <span class="n">iterator</span> <span class="nf">begin</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ht</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="p">}</span>
    <span class="n">iterator</span> <span class="nf">end</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ht</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">ht</span><span class="p">.</span><span class="n">insert_unique</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">iterator</span> <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ht</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">val</span><span class="p">);</span> <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">hashtable</span> <span class="n">ht</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="identity">identity</h3>
<p>It can be said that this implementation is not very bright, the only noteworthy thing is the declaration of hashtable.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">using</span> <span class="n">hashtable</span> <span class="o">=</span> <span class="n">hash_table</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> <span class="n">identity</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">KeyEqual</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>What is <code>identity&lt;Key&gt;</code> here?</p>
<p>As mentioned before, this parameter is <code>ExtractKey</code>, which is the method used to convert a value to a key. So for a set, the key is the value, so the conversion returns the value.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">identity</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="n">T</span><span class="o">&amp;&amp;</span> <span class="k">operator</span><span class="p">()(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>The <code>()</code> operator is overloaded here, making it possible to have a function-like call method, where the return value is the return of the incoming one.</p>
<h2 id="unordered_map">unordered_map</h2>
<p>The call to hashtable is the same as unordered_set, with more changes to the declaration of hashtable.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Key</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Hash</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="k">class</span> <span class="nc">KeyEqual</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">equal_to</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Allocator</span> <span class="o">=</span> <span class="n">allocator</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;&gt;</span>
    <span class="k">class</span> <span class="nc">unordered_map</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="k">using</span> <span class="n">hashtable</span> <span class="o">=</span> <span class="n">hash_table</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> 
                        <span class="n">select1st</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">KeyEqual</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
    <span class="k">using</span> <span class="n">key_type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">hashtable</span><span class="o">::</span><span class="n">key_type</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">hashtable</span><span class="o">::</span><span class="n">value_type</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">hasher</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">hashtable</span><span class="o">::</span><span class="n">hasher</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">key_equal</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">hashtable</span><span class="o">::</span><span class="n">key_equal</span><span class="p">;</span>

    <span class="k">using</span> <span class="n">size_type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">hashtable</span><span class="o">::</span><span class="n">size_type</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">iterator</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">hashtable</span><span class="o">::</span><span class="n">iterator</span><span class="p">;</span>

    <span class="n">unordered_map</span><span class="p">()</span> <span class="o">:</span><span class="n">ht</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">hasher</span><span class="p">(),</span> <span class="n">key_equal</span><span class="p">())</span> <span class="p">{}</span>
    <span class="k">explicit</span> <span class="nf">unordered_map</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="o">:</span><span class="n">ht</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">hasher</span><span class="p">(),</span> <span class="n">key_equal</span><span class="p">())</span> <span class="p">{}</span>

    <span class="n">size_type</span> <span class="nf">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ht</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="p">}</span>
    <span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ht</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span> <span class="p">}</span>

    <span class="n">iterator</span> <span class="nf">begin</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ht</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="p">}</span>
    <span class="n">iterator</span> <span class="nf">end</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ht</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">ht</span><span class="p">.</span><span class="n">insert_unique</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">iterator</span> <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="n">Key</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ht</span><span class="p">.</span><span class="n">find_by_key</span><span class="p">(</span><span class="n">val</span><span class="p">);</span> <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">hashtable</span> <span class="n">ht</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>Let&rsquo;s take a closer look at this membership type.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">using</span> <span class="n">hashtable</span> <span class="o">=</span> <span class="n">hash_table</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Key</span><span class="p">,</span> <span class="n">Hash</span><span class="p">,</span> 
                    <span class="n">select1st</span><span class="o">&lt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">KeyEqual</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>Here <code>Value</code> uses <code>std::pair&lt;Key, T&gt;</code> instead of simply <code>Value</code>. As mentioned before, the template parameter is the type of data stored in the node, so if I store a Value alone, I won&rsquo;t find the corresponding element when I map it to the corresponding bucket using Key. Here the hashtable is linked separately, which means that all conflicting ones are stored in it, so there must be a Key stored together with the Value to distinguish it. At the same time, it would be a burden on the set implementation if only the original types of Key and Value were provided in the hashtable with template parameters and then stored internally directly in pairs, so now the hashtable must provide the type of internal storage. However, these details should be encapsulated when using unordered_map, so you don&rsquo;t have to think too much about it.</p>
<h3 id="select1st">select1st</h3>
<p>Here <code>ExtractKey</code> uses a method called <code>select1st</code>. Since we are storing a <code>pair&lt;Key, Value&gt;</code> of type, the method to extract the key from it is to extract the first element, which is what the name of the method means.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T1</span><span class="p">,</span><span class="k">class</span> <span class="nc">T2</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">select1st</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="n">T1</span> <span class="nf">operator</span><span class="p">()(</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="o">&gt;</span> <span class="n">t</span><span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">t</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div>
    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/c&#43;&#43;/">c&#43;&#43;</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-02/async-in-map/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Using async functions in Map traversal</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-02/move-and-forward/">
            <span class="next-text nav-default">std::move() and std::forward()</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
