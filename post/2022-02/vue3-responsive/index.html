<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Vue3 - Responsive Principle Explained - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Vue3.0 pre-alpha version was officially released on October 5, 2019, followed by more than 500 PRs and 1000 commits over the next few months, and finally Vue3.0 alpha.1 was released on January 4, 2020. the core code of Vue3.0 is basically complete, and the main work left so far is server-side rendering, which the Vue team is actively working on. The Vue team is also actively working on it. The" /><meta name="keywords" content="vue3, Responsive, Explained" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-02/vue3-responsive/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Vue3 - Responsive Principle Explained" />
<meta property="og:description" content="Vue3.0 pre-alpha version was officially released on October 5, 2019, followed by more than 500 PRs and 1000 commits over the next few months, and finally Vue3.0 alpha.1 was released on January 4, 2020. the core code of Vue3.0 is basically complete, and the main work left so far is server-side rendering, which the Vue team is actively working on. The Vue team is also actively working on it. The" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-02/vue3-responsive/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-02-09T11:23:03+08:00" />
<meta property="article:modified_time" content="2022-02-09T11:23:03+08:00" />

<meta itemprop="name" content="Vue3 - Responsive Principle Explained">
<meta itemprop="description" content="Vue3.0 pre-alpha version was officially released on October 5, 2019, followed by more than 500 PRs and 1000 commits over the next few months, and finally Vue3.0 alpha.1 was released on January 4, 2020. the core code of Vue3.0 is basically complete, and the main work left so far is server-side rendering, which the Vue team is actively working on. The Vue team is also actively working on it. The"><meta itemprop="datePublished" content="2022-02-09T11:23:03+08:00" />
<meta itemprop="dateModified" content="2022-02-09T11:23:03+08:00" />
<meta itemprop="wordCount" content="9021">
<meta itemprop="keywords" content="vue," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Vue3 - Responsive Principle Explained"/>
<meta name="twitter:description" content="Vue3.0 pre-alpha version was officially released on October 5, 2019, followed by more than 500 PRs and 1000 commits over the next few months, and finally Vue3.0 alpha.1 was released on January 4, 2020. the core code of Vue3.0 is basically complete, and the main work left so far is server-side rendering, which the Vue team is actively working on. The Vue team is also actively working on it. The"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Vue3 - Responsive Principle Explained</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-02-09 11:23:03 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 9021 words </span>
          <span class="more-meta"> 19 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#responsive-api-for-vue-30">Responsive API for Vue 3.0</a></li>
        <li><a href="#source-code-structure">Source code structure</a></li>
        <li><a href="#data-hijacking">Data hijacking</a>
          <ul>
            <li><a href="#data-interception-for-proxy">Data Interception for Proxy</a></li>
            <li><a href="#vue30-responsive-schematic">Vue3.0 Responsive Schematic</a></li>
          </ul>
        </li>
        <li><a href="#reactive">Reactive</a>
          <ul>
            <li><a href="#basehandlers">baseHandlers</a></li>
            <li><a href="#collectionhandlers">collectionHandlers</a></li>
            <li><a href="#reactive-summary">Reactive Summary</a></li>
          </ul>
        </li>
        <li><a href="#ref">Ref</a></li>
        <li><a href="#effect">Effect</a>
          <ul>
            <li><a href="#track">Track</a></li>
            <li><a href="#trigger">Trigger</a></li>
            <li><a href="#effect-summary">Effect Summary</a></li>
          </ul>
        </li>
        <li><a href="#computed">Computed</a></li>
        <li><a href="#summary">Summary</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>Vue3.0 pre-alpha version was officially released on October 5, 2019, followed by more than 500 PRs and 1000 commits over the next few months, and finally Vue3.0 alpha.1 was released on January 4, 2020. the core code of Vue3.0 is basically complete, and the main work left so far is server-side rendering, which the Vue team is actively working on. The Vue team is also actively working on it.
The responsive API code is basically stable and will not change much (the reactivity package in packages), so I will analyze the responsive principle of Vue3.0 from the source code.</p>
<h2 id="responsive-api-for-vue-30">Responsive API for Vue 3.0</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="o">&lt;</span><span class="nx">template</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="p">{{</span> <span class="nx">count</span> <span class="p">}}</span> <span class="p">{{</span> <span class="nx">object</span><span class="p">.</span><span class="nx">foo</span> <span class="p">}}</span><span class="o">&lt;</span><span class="err">/div&gt;</span>
  <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="p">{{</span> <span class="nx">plusOne</span> <span class="p">}}</span><span class="o">&lt;</span><span class="err">/div&gt;</span>
<span class="o">&lt;</span><span class="err">/template&gt;</span>

<span class="o">&lt;</span><span class="nx">script</span><span class="o">&gt;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">ref</span><span class="p">,</span> <span class="nx">reactive</span><span class="p">,</span> <span class="nx">computed</span><span class="p">,</span> <span class="nx">watch</span><span class="p">,</span> <span class="nx">onMounted</span><span class="p">,</span> <span class="nx">onUpdated</span><span class="p">,</span> <span class="nx">onUpdated</span><span class="p">,</span> <span class="nx">onUnmounted</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;vue&#39;</span>

<span class="kr">export</span> <span class="k">default</span> <span class="p">{</span>
  <span class="nx">setup</span><span class="p">()</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">count</span> <span class="o">=</span> <span class="nx">ref</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="kr">const</span> <span class="nx">plusOne</span> <span class="o">=</span> <span class="nx">computed</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">count</span><span class="p">.</span><span class="nx">value</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="kr">const</span> <span class="nx">object</span> <span class="o">=</span> <span class="nx">reactive</span><span class="p">({</span> <span class="nx">foo</span><span class="o">:</span> <span class="s1">&#39;bar&#39;</span> <span class="p">})</span>
    <span class="nx">watch</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">count</span><span class="p">.</span><span class="nx">value</span><span class="p">))</span>
    <span class="nx">onMounted</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;mounted!&#39;</span><span class="p">))</span>
    <span class="nx">onUpdated</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;updated!&#39;</span><span class="p">))</span>
    <span class="nx">onUnmounted</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;onUnmounted!&#39;</span><span class="p">))</span>

    <span class="k">return</span> <span class="p">{</span>
      <span class="nx">count</span><span class="p">,</span>
      <span class="nx">plusOne</span><span class="p">,</span>
      <span class="nx">object</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="o">&lt;</span><span class="err">/script&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>Vue3.0 uses the <code>setup</code> function as the entry point for the entire component, uses the directly imported <code>onXXX</code> function to register lifecycle hooks, and uses the variables from the <code>return</code> in the page. There are some changes in the whole writeup compared to Vue 2.0, so we won&rsquo;t discuss the lifecycle code related to the component here (it belongs to the <code>packages/runtime-core</code> package).</p>
<p>The most important thing in responsive is the remaining 4 APIs. <code>ref</code> and <code>reactive</code> are both methods to convert incoming parameters into responsive objects, the difference is that <code>ref</code> converts basic data types (string, number, bool, etc.) into responsive data, while <code>reactive</code> converts other data types into responsive data. To ensure that the basic data is responsive, <code>ref</code> wraps the basic data in a layer, so in the code above, you need to use <code>count.value</code> to get the value of <code>count</code>, but in the template, it is automatically unwrapped (unwrap), so you can use <code>count</code> directly. <code>computed</code> has the same role as vue2.0 and represents the computed property. <code>watch</code> is used to listen for state in the internal logic and will be executed once for each dependency change.</p>
<p>One of the features of Vue is data-driven view updates. By responsive, we mean that when data changes, the part of the view that needs to change is automatically updated. Unlike Vue 2.0, Vue 3.0 uses a monorepo structure that pulls the responsive code into a separate package - <code>reactivity</code> - which means you can reference this package separately in non-Vue projects to use responsive data.</p>
<h2 id="source-code-structure">Source code structure</h2>
<p>Let&rsquo;s explain the structure of the source code to make it clearer.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">// packages/reactivity
src
├── baseHandlers.ts  // Proxy 针对普通数据的 handler 函数的实现
├── collectionHandlers.ts  // Proxy 针对集合类型数据的 handler 函数的实现
├── computed.ts  // computed 的实现
├── effect.ts   // effect 的实现，watch 是基于 effect
├── index.ts  // 对外暴露所有 API
├── lock.ts  // 全局锁
├── operations.ts // 操作类型的常量
├── reactive.ts  // reactive 的实现
└── ref.ts  // ref 的实现
</code></pre></td></tr></table>
</div>
</div><p>In fact, the code logic is basically in <code>baseHandlers.ts</code> , <code>collectionHandlers.ts</code> , <code>computed.ts</code> , <code>effect.ts</code> , <code>reactive.ts</code> , <code>ref.ts</code> which are 6 files. <code>index</code> is the file that exposes the API to the public, <code>lock</code> contains the variables and methods that can modify the global responsiveness, and <code>operations</code> are the constants corresponding to the types of dependency changes triggered by method hijacking. Of course, there are some utility functions used here, all of which come from <code>packages/shared</code>, and I will analyze them directly in the code when I explain them later.</p>
<h2 id="data-hijacking">Data hijacking</h2>
<p>Vue2.0 uses Object.defineProperty for data hijacking, which actually proxies each property of the object during initialization, while Vue3.0 uses a combination of Proxy and Reflect to proxy the entire object directly. The difference is that in Vue 3.0 you no longer need to add and delete properties responsively via the <code>vm.$set</code> and <code>vm.$delete</code> methods, you don&rsquo;t need to override the array&rsquo;s native methods, and listening to the array doesn&rsquo;t break the JS engine&rsquo;s rendering, which results in better performance.</p>
<h3 id="data-interception-for-proxy">Data Interception for Proxy</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;kpl&#39;</span> <span class="p">}</span>
<span class="kr">const</span> <span class="nx">handler</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">get</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">)</span>
  <span class="p">},</span>
  <span class="nx">set</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">handler</span><span class="p">)</span>
<span class="nx">p</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s1">&#39;123&#39;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="c1">// { name: &#39;123&#39; }
</span></code></pre></td></tr></table>
</div>
</div><p>The specific usage of Proxy and Reflect can be seen in Mr. Nguyen&rsquo;s <a href="http://es6.ruanyifeng.com/#docs/proxy">ES6 Primer</a>. Why doesn&rsquo;t the get function in Proxy return the intercepted property directly, but instead calls the Reflect API?</p>
<p>First, Proxy supports 13 methods for interception, and Reflect has the same 13 methods. These methods include some language-internal methods (such as <code>Object.defineProperty</code>) that sometimes throw errors during use, and Reflect returns <code>false</code> in this case.
The Proxy object can easily call the corresponding Reflect method to complete the default behavior as a basis for modifying the behavior. That is, no matter how Proxy modifies the default behavior, you can always get the default behavior on Reflect.</p>
<h3 id="vue30-responsive-schematic">Vue3.0 Responsive Schematic</h3>
<p>I combed through the flow of data proxying, method hijacking, dependency collection and triggering in Vue 3.0 and drew the following schematic. It may be a little bit roundabout at first, but you will have a clearer understanding when you look at this diagram after reading the source code parsing behind it.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/09/01753bc7d9f748dfb04ba3739b4dd4af.png" alt="vue"></p>
<h2 id="reactive">Reactive</h2>
<p>Although Proxy can directly proxy objects, it can only proxy one layer of properties, and you need to manually recursively implement it for deeper detection inside objects. Of course, recursive Proxy has performance pitfalls. How does Vue3.0 avoid excess performance loss?</p>
<p>Vue3.0 caches the set of mapping relationships between the original data and the proxy data to prevent the same data from being repeatedly proxied. Also, when generating responsive data using <code>reactive</code>, it is not recursive, and only when the trap of <code>get</code> is triggered by accessing the responsive data, it nests recursive properties for proxy hijacking (unlike Vue2.0 where dependency collection is done at initialization, which will be explained in detail in the handler function).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">rawToReactive</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WeakMap</span><span class="o">&lt;</span><span class="nx">any</span><span class="p">,</span> <span class="nx">any</span><span class="o">&gt;</span><span class="p">()</span>  <span class="c1">// 原始数据 -&gt; 响应式数据
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">reactiveToRaw</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WeakMap</span><span class="o">&lt;</span><span class="nx">any</span><span class="p">,</span> <span class="nx">any</span><span class="o">&gt;</span><span class="p">()</span>  <span class="c1">// 响应式数据 -&gt; 原始数据
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">rawToReadonly</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WeakMap</span><span class="o">&lt;</span><span class="nx">any</span><span class="p">,</span> <span class="nx">any</span><span class="o">&gt;</span><span class="p">()</span>  <span class="c1">// 原始数据 -&gt; 只读响应式数据
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">readonlyToRaw</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WeakMap</span><span class="o">&lt;</span><span class="nx">any</span><span class="p">,</span> <span class="nx">any</span><span class="o">&gt;</span><span class="p">()</span>  <span class="c1">// 只读响应式数据 -&gt; 原始数据
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">readonlyValues</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WeakSet</span><span class="o">&lt;</span><span class="nx">any</span><span class="o">&gt;</span><span class="p">()</span>      <span class="c1">// 手动标记的只读数据集合
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">nonReactiveValues</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WeakSet</span><span class="o">&lt;</span><span class="nx">any</span><span class="o">&gt;</span><span class="p">()</span>   <span class="c1">// 不可响应式数据集合
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">collectionTypes</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="o">&lt;</span><span class="nb">Function</span><span class="o">&gt;</span><span class="p">([</span><span class="nx">Set</span><span class="p">,</span> <span class="nx">Map</span><span class="p">,</span> <span class="nx">WeakMap</span><span class="p">,</span> <span class="nx">WeakSet</span><span class="p">])</span>  <span class="c1">// 集合数据类型
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">isObservableType</span> <span class="o">=</span> <span class="nx">makeMap</span><span class="p">(</span><span class="s1">&#39;Object,Array,Map,Set,WeakMap,WeakSet&#39;</span><span class="p">)</span>  <span class="c1">// 判断传入的对象是否为响应式数据类型
</span></code></pre></td></tr></table>
</div>
</div><p>Why do we use <code>WeakMap</code> and <code>WeakSet</code> to hold mapped data collections? Because <code>WeakMap</code> and <code>WeakSet</code> hold objects that are weakly referenced, and the garbage collection mechanism will release the memory occupied by the referenced object as soon as all other references to the object are cleared. Therefore, using these two data structures can better reduce memory overhead, in addition to having a higher search query efficiency.</p>
<p>Vue 3.0 uses three main responsive methods, <code>reactive</code> , <code>readonly</code> and <code>shallowReadonly</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">export</span> <span class="kd">function</span> <span class="nx">reactive</span><span class="o">&lt;</span><span class="nx">T</span> <span class="kr">extends</span> <span class="nx">object</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">target</span><span class="o">:</span> <span class="nx">T</span><span class="p">)</span><span class="o">:</span> <span class="nx">UnwrapNestedRefs</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span>
<span class="kr">export</span> <span class="kd">function</span> <span class="nx">reactive</span><span class="p">(</span><span class="nx">target</span><span class="o">:</span> <span class="nx">object</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">readonlyToRaw</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">target</span><span class="p">))</span> <span class="k">return</span> <span class="nx">target</span>  <span class="c1">// 如果是只读响应式数据，直接返回
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nx">readonlyValues</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">target</span><span class="p">))</span> <span class="k">return</span> <span class="nx">readonly</span><span class="p">(</span><span class="nx">target</span><span class="p">)</span> <span class="c1">// 如果是手动标记的只读数据，使用 readonly 去代理
</span><span class="c1"></span>  <span class="k">return</span> <span class="nx">createReactiveObject</span><span class="p">(</span>
    <span class="nx">target</span><span class="p">,</span>
    <span class="nx">rawToReactive</span><span class="p">,</span>
    <span class="nx">reactiveToRaw</span><span class="p">,</span>
    <span class="nx">mutableHandlers</span><span class="p">,</span>
    <span class="nx">mutableCollectionHandlers</span>
  <span class="p">)</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="kd">function</span> <span class="nx">readonly</span><span class="o">&lt;</span><span class="nx">T</span> <span class="kr">extends</span> <span class="nx">object</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">target</span><span class="o">:</span> <span class="nx">T</span><span class="p">)</span><span class="o">:</span> <span class="nx">Readonly</span><span class="o">&lt;</span><span class="nx">UnwrapNestedRefs</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">reactiveToRaw</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">target</span><span class="p">))</span> <span class="nx">target</span> <span class="o">=</span> <span class="nx">reactiveToRaw</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">target</span><span class="p">)</span> <span class="c1">// 如果已经是响应式数据，则使用原始数据
</span><span class="c1"></span>  <span class="k">return</span> <span class="nx">createReactiveObject</span><span class="p">(</span>
    <span class="nx">target</span><span class="p">,</span>
    <span class="nx">rawToReadonly</span><span class="p">,</span>
    <span class="nx">readonlyToRaw</span><span class="p">,</span>
    <span class="nx">readonlyHandlers</span><span class="p">,</span>
    <span class="nx">readonlyCollectionHandlers</span>
  <span class="p">)</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="kd">function</span> <span class="nx">shallowReadonly</span><span class="o">&lt;</span><span class="nx">T</span> <span class="kr">extends</span> <span class="nx">object</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">target</span><span class="o">:</span> <span class="nx">T</span><span class="p">)</span><span class="o">:</span> <span class="nx">Readonly</span><span class="o">&lt;</span><span class="p">{</span> <span class="p">[</span><span class="nx">K</span> <span class="k">in</span> <span class="nx">keyof</span> <span class="nx">T</span><span class="p">]</span><span class="o">:</span> <span class="nx">UnwrapNestedRefs</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">[</span><span class="nx">K</span><span class="p">]</span><span class="o">&gt;</span> <span class="p">}</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">createReactiveObject</span><span class="p">(</span>
    <span class="nx">target</span><span class="p">,</span>
    <span class="nx">rawToReadonly</span><span class="p">,</span>
    <span class="nx">readonlyToRaw</span><span class="p">,</span>
    <span class="nx">shallowReadonlyHandlers</span><span class="p">,</span>
    <span class="nx">readonlyCollectionHandlers</span>
  <span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Here you can see that all three methods actually call the <code>createReactiveObject</code> method, and we&rsquo;ll take a look at this method later. <code>reactive</code> returns responsive data, <code>readonly</code> returns read-only responsive data, so what does the <code>shallowReadonly</code> method do? It returns an object with only the outermost read-only responsive data, and it does not recursively proxy the internal data responsively. It is mainly used for props proxy objects created in stateful components.</p>
<p>Let&rsquo;s start with a few of the tool functions that will be used in the later methods.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="c1">// 判断是否是对象
</span><span class="c1"></span><span class="kr">export</span> <span class="kr">const</span> <span class="nx">isObject</span> <span class="o">=</span> <span class="p">(</span><span class="nx">val</span><span class="o">:</span> <span class="nx">unknown</span><span class="p">)</span><span class="o">:</span> <span class="nx">val</span> <span class="nx">is</span> <span class="nx">Record</span><span class="o">&lt;</span><span class="nx">any</span><span class="p">,</span> <span class="nx">any</span><span class="o">&gt;</span> <span class="p">=&gt;</span> <span class="nx">val</span> <span class="o">!==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="k">typeof</span> <span class="nx">val</span> <span class="o">===</span> <span class="s1">&#39;object&#39;</span>

<span class="c1">// 判断是否为可观察数据
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">canObserve</span> <span class="o">=</span> <span class="p">(</span><span class="nx">value</span><span class="o">:</span> <span class="nx">any</span><span class="p">)</span><span class="o">:</span> <span class="kr">boolean</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">!</span><span class="nx">value</span><span class="p">.</span><span class="nx">_isVue</span> <span class="o">&amp;&amp;</span>
    <span class="o">!</span><span class="nx">value</span><span class="p">.</span><span class="nx">_isVNode</span> <span class="o">&amp;&amp;</span>
    <span class="nx">isObservableType</span><span class="p">(</span><span class="nx">toRawType</span><span class="p">(</span><span class="nx">value</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
    <span class="o">!</span><span class="nx">nonReactiveValues</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>
  <span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>In fact, I have written a lot of TS code in my projects, but after reading the source code, I realized that my TS is only half-assed, and I learned a lot from it.
The <code>isObject</code> function uses the top-level type <code>unknown</code> for the input, not <code>any</code>, to avoid arbitrary operations on the input (which cannot be assigned by types other than <code>unknown</code> and <code>any</code>). Also, the function return type uses a type predicate, <code>Record&lt;any, any&gt;</code> instead of <code>object</code>, because TS allows access to arbitrary properties of objects of type <code>Record&lt;any, any&gt;</code> without errors.
<code>canObserve</code> specifies which data is observable. Non-Vue components, non-dom nodes, of the type defined by <code>isObservableType</code> and not unresponsive data.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">createReactiveObject</span><span class="p">(</span>
  <span class="nx">target</span><span class="o">:</span> <span class="nx">unknown</span><span class="p">,</span>
  <span class="nx">toProxy</span><span class="o">:</span> <span class="nx">WeakMap</span><span class="o">&lt;</span><span class="nx">any</span><span class="p">,</span> <span class="nx">any</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="nx">toRaw</span><span class="o">:</span> <span class="nx">WeakMap</span><span class="o">&lt;</span><span class="nx">any</span><span class="p">,</span> <span class="nx">any</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="nx">baseHandlers</span><span class="o">:</span> <span class="nx">ProxyHandler</span><span class="o">&lt;</span><span class="nx">any</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="nx">collectionHandlers</span><span class="o">:</span> <span class="nx">ProxyHandler</span><span class="o">&lt;</span><span class="nx">any</span><span class="o">&gt;</span>
<span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">isObject</span><span class="p">(</span><span class="nx">target</span><span class="p">))</span> <span class="k">return</span> <span class="nx">target</span>      <span class="c1">// 如果不是对象，直接返回原始数据
</span><span class="c1"></span>  <span class="kd">let</span> <span class="nx">observed</span> <span class="o">=</span> <span class="nx">toProxy</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">target</span><span class="p">)</span>        <span class="c1">// 获取 target 对应的响应式数据
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nx">observed</span> <span class="o">!==</span> <span class="k">void</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nx">observed</span>  <span class="c1">// 如果存在响应式数据（已经被代理过），直接返回响应式数据
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nx">toRaw</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">target</span><span class="p">))</span> <span class="k">return</span> <span class="nx">target</span>      <span class="c1">// 如果 target 是响应式数据，直接返回 target
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">canObserve</span><span class="p">(</span><span class="nx">target</span><span class="p">))</span> <span class="k">return</span> <span class="nx">target</span>    <span class="c1">// 如果target 不可被观察，直接返回 target
</span><span class="c1"></span>  <span class="kr">const</span> <span class="nx">handlers</span> <span class="o">=</span> <span class="nx">collectionTypes</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">target</span><span class="p">.</span><span class="nx">constructor</span><span class="p">)</span>
    <span class="o">?</span> <span class="nx">collectionHandlers</span>
    <span class="o">:</span> <span class="nx">baseHandlers</span>
  <span class="nx">observed</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">handlers</span><span class="p">)</span>    <span class="c1">// 集合数据类型使用 collectionHandlers，其它类型使用 baseHandlers
</span><span class="c1"></span>  <span class="nx">toProxy</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">observed</span><span class="p">)</span>             <span class="c1">// 缓存原始数据 -&gt; 响应式数据的映射关系
</span><span class="c1"></span>  <span class="nx">toRaw</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">observed</span><span class="p">,</span> <span class="nx">target</span><span class="p">)</span>               <span class="c1">// 缓存响应式数据 -&gt; 原始数据的映射关系
</span><span class="c1"></span>  <span class="k">return</span> <span class="nx">observed</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Although the code is not much, we still have several questions.</p>
<ol>
<li>
<p>what does <code>void 0</code> mean?
Actually it is <code>undefined</code>. The source code uses <code>void 0</code> instead of <code>undefined</code>, first of all because <code>undefined</code> is rewritten under local scope, while <code>void</code> is not rewritten and <code>void 0</code> has fewer bytes. In fact, many JavaScript compression tools replace <code>undefined</code> with <code>void 0</code> in the compression process.</p>
</li>
<li>
<p>Why do we use different handler functions for different data types?
Vue 3.0 uses two files, <code>baseHandlers</code> and <code>collectionHandlers</code>, to handle handler functions. The <code>collectionHandlers</code> file is dedicated to handling collection type data (Map, Set, WeakMap, WeakSet), why do collection type data need separate handler functions?
Because these collection types use the so-called &ldquo;internal slots&rdquo; to access properties directly through the built-in method (this), not through <code>[[Get]]/[[Set]]</code>, which the Proxy cannot intercept. This is because after using Proxy to proxy a collection type, this=Proxy, not the original object, will not be accessible. So we need to do a layer of function hijacking and just modify the pointing of this to the original mapping.</p>
</li>
</ol>
<h3 id="basehandlers">baseHandlers</h3>
<p><code>baseHandlers.ts</code> exposes a total of three methods, <code>mutableHandlers</code> , <code>readonlyHandlers</code> and <code>shallowReadonlyHandlers</code>. This corresponds to the three responsive methods mentioned above, <code>reactive</code> , <code>readonly</code> and <code>shallowReadonly</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="c1">// LOCKED 是一个全局开关，锁住情况下数据不可变
</span><span class="c1"></span><span class="kr">export</span> <span class="kd">let</span> <span class="nx">LOCKED</span> <span class="o">=</span> <span class="kc">true</span>
<span class="kr">export</span> <span class="kr">const</span> <span class="nx">lock</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">LOCKED</span> <span class="o">=</span> <span class="kc">true</span>
<span class="kr">export</span> <span class="kr">const</span> <span class="nx">unlock</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">LOCKED</span> <span class="o">=</span> <span class="kc">false</span>

<span class="kr">export</span> <span class="kr">const</span> <span class="nx">mutableHandlers</span><span class="o">:</span> <span class="nx">ProxyHandler</span><span class="o">&lt;</span><span class="nx">object</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">get</span><span class="o">:</span> <span class="nx">createGetter</span><span class="p">(),</span>
  <span class="nx">set</span><span class="o">:</span> <span class="nx">createSetter</span><span class="p">(),</span>
  <span class="nx">deleteProperty</span><span class="p">,</span>
  <span class="nx">has</span><span class="p">,</span>
  <span class="nx">ownKeys</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="kr">const</span> <span class="nx">readonlyHandlers</span><span class="o">:</span> <span class="nx">ProxyHandler</span><span class="o">&lt;</span><span class="nx">object</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">get</span><span class="o">:</span> <span class="nx">createGetter</span><span class="p">(</span><span class="kc">true</span><span class="p">),</span>
  <span class="nx">set</span><span class="o">:</span> <span class="nx">createSetter</span><span class="p">(</span><span class="kc">true</span><span class="p">),</span>
  <span class="nx">has</span><span class="p">,</span>
  <span class="nx">ownKeys</span><span class="p">,</span>
  <span class="nx">deleteProperty</span><span class="p">(</span><span class="nx">target</span><span class="o">:</span> <span class="nx">object</span><span class="p">,</span> <span class="nx">key</span><span class="o">:</span> <span class="nx">string</span> <span class="o">|</span> <span class="nx">symbol</span><span class="p">)</span><span class="o">:</span> <span class="kr">boolean</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">LOCKED</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 数据被锁住的情况
</span><span class="c1"></span>      <span class="k">return</span> <span class="kc">true</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">deleteProperty</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="kr">const</span> <span class="nx">shallowReadonlyHandlers</span><span class="o">:</span> <span class="nx">ProxyHandler</span><span class="o">&lt;</span><span class="nx">object</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span>
  <span class="p">...</span><span class="nx">readonlyHandlers</span><span class="p">,</span>
  <span class="nx">get</span><span class="o">:</span> <span class="nx">createGetter</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="kc">true</span><span class="p">),</span>
  <span class="nx">set</span><span class="o">:</span> <span class="nx">createSetter</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>In fact, you can see that the three exposed handler methods actually only hijack the <code>get</code>, <code>set</code>, <code>has</code>, <code>ownKeys</code> and <code>deleteProperty</code> methods. <code>get</code> and <code>set</code> are easy to understand, <code>has</code> actually hijacks the <code>propKey in proxy</code> operation, <code>ownKeys</code> can hijack <code>Object.getOwnPropertyNames(proxy)</code> , <code>Object.getOwnPropertySymbols(proxy )</code> , <code>Object.keys(proxy)</code> , <code>for... .in</code> method, <code>deleteProperty</code> hijacks the <code>delete proxy[propKey]</code> method.</p>
<h4 id="get">Get</h4>
<p>Let&rsquo;s look at the get hijacking method <code>createGetter</code> :</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">export</span> <span class="kr">const</span> <span class="nx">isArray</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span>
<span class="kr">export</span> <span class="kr">const</span> <span class="nx">isSymbol</span> <span class="o">=</span> <span class="p">(</span><span class="nx">val</span><span class="o">:</span> <span class="nx">unknown</span><span class="p">)</span><span class="o">:</span> <span class="nx">val</span> <span class="nx">is</span> <span class="nx">symbol</span> <span class="p">=&gt;</span> <span class="k">typeof</span> <span class="nx">val</span> <span class="o">===</span> <span class="s1">&#39;symbol&#39;</span>
<span class="kr">export</span> <span class="kr">const</span> <span class="nx">isObject</span> <span class="o">=</span> <span class="p">(</span><span class="nx">val</span><span class="o">:</span> <span class="nx">unknown</span><span class="p">)</span><span class="o">:</span> <span class="nx">val</span> <span class="nx">is</span> <span class="nx">Record</span><span class="o">&lt;</span><span class="nx">any</span><span class="p">,</span> <span class="nx">any</span><span class="o">&gt;</span> <span class="p">=&gt;</span> <span class="nx">val</span> <span class="o">!==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="k">typeof</span> <span class="nx">val</span> <span class="o">===</span> <span class="s1">&#39;object&#39;</span>
<span class="kr">export</span> <span class="kr">const</span> <span class="nx">hasOwn</span> <span class="o">=</span> <span class="p">(</span><span class="nx">val</span><span class="o">:</span> <span class="nx">object</span><span class="p">,</span> <span class="nx">key</span><span class="o">:</span> <span class="nx">string</span> <span class="o">|</span> <span class="nx">symbol</span><span class="p">)</span><span class="o">:</span> <span class="nx">key</span> <span class="nx">is</span> <span class="nx">keyof</span> <span class="k">typeof</span> <span class="nx">val</span> <span class="p">=&gt;</span> <span class="nx">hasOwnProperty</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">val</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
<span class="kr">export</span> <span class="kd">function</span> <span class="nx">isRef</span><span class="p">(</span><span class="nx">r</span><span class="o">:</span> <span class="nx">any</span><span class="p">)</span><span class="o">:</span> <span class="nx">r</span> <span class="nx">is</span> <span class="nx">Ref</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">r</span> <span class="o">?</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_isRef</span> <span class="o">===</span> <span class="kc">true</span> <span class="o">:</span> <span class="kc">false</span>
<span class="p">}</span>
<span class="kr">export</span> <span class="kd">function</span> <span class="nx">toRaw</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">observed</span><span class="o">:</span> <span class="nx">T</span><span class="p">)</span><span class="o">:</span> <span class="nx">T</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">reactiveToRaw</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">observed</span><span class="p">)</span> <span class="o">||</span> <span class="nx">readonlyToRaw</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">observed</span><span class="p">)</span> <span class="o">||</span> <span class="nx">observed</span>  <span class="c1">// 获取原始数据
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// ES6 提供了 11 个内置的 Symbol 值，指向语言内部使用的方法
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">builtInSymbols</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">(</span>
  <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyNames</span><span class="p">(</span><span class="nx">Symbol</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">key</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="nx">Symbol</span> <span class="nx">as</span> <span class="nx">any</span><span class="p">)[</span><span class="nx">key</span><span class="p">])</span>
    <span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">isSymbol</span><span class="p">)</span>
<span class="p">)</span>

<span class="c1">// 数组的 includes, indexOf, lastIndexOf 三个方法不走代理
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">arrayIdentityInstrumentations</span><span class="o">:</span> <span class="nx">Record</span><span class="o">&lt;</span><span class="nx">string</span><span class="p">,</span> <span class="nb">Function</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{}</span>
<span class="p">;[</span><span class="s1">&#39;includes&#39;</span><span class="p">,</span> <span class="s1">&#39;indexOf&#39;</span><span class="p">,</span> <span class="s1">&#39;lastIndexOf&#39;</span><span class="p">].</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">key</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">arrayIdentityInstrumentations</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span>
    <span class="nx">value</span><span class="o">:</span> <span class="nx">unknown</span><span class="p">,</span>
    <span class="p">...</span><span class="nx">args</span><span class="o">:</span> <span class="nx">any</span><span class="p">[]</span>
  <span class="p">)</span><span class="o">:</span> <span class="nx">any</span> <span class="p">{</span>
    <span class="c1">// 获得原始数据并执行原生方法
</span><span class="c1"></span>    <span class="k">return</span> <span class="nx">toRaw</span><span class="p">(</span><span class="k">this</span><span class="p">)[</span><span class="nx">key</span><span class="p">](</span><span class="nx">toRaw</span><span class="p">(</span><span class="nx">value</span><span class="p">),</span> <span class="p">...</span><span class="nx">args</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">})</span>

<span class="kd">function</span> <span class="nx">createGetter</span><span class="p">(</span><span class="nx">isReadonly</span> <span class="o">=</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">shallow</span> <span class="o">=</span> <span class="kc">false</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="nx">get</span><span class="p">(</span><span class="nx">target</span><span class="o">:</span> <span class="nx">object</span><span class="p">,</span> <span class="nx">key</span><span class="o">:</span> <span class="nx">string</span> <span class="o">|</span> <span class="nx">symbol</span><span class="p">,</span> <span class="nx">receiver</span><span class="o">:</span> <span class="nx">object</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 数组的 includes, indexOf, lastIndexOf 三个方法不走代理，同时不收集依赖
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">target</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">hasOwn</span><span class="p">(</span><span class="nx">arrayIdentityInstrumentations</span><span class="p">,</span> <span class="nx">key</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">arrayIdentityInstrumentations</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="kr">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">)</span>
    <span class="c1">// ES6 内置的 Symbol 属性无法被收集依赖，这里直接返回值，不再收集依赖
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">isSymbol</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">builtInSymbols</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">key</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">res</span>
    <span class="p">}</span>
    <span class="c1">// 如果是 shallowReadonly，不需要递归收集内层依赖，只收集最外层依赖
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">shallow</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">track</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">TrackOpTypes</span><span class="p">.</span><span class="nx">GET</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>  <span class="c1">// 收集依赖
</span><span class="c1"></span>      <span class="k">return</span> <span class="nx">res</span>
    <span class="p">}</span>
    <span class="c1">// 如果是 Ref 数据，直接返回原始数据的值（Ref 的结构会在后文分析）
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">isRef</span><span class="p">(</span><span class="nx">res</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nx">value</span>
    <span class="p">}</span>
    <span class="nx">track</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">TrackOpTypes</span><span class="p">.</span><span class="nx">GET</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>  <span class="c1">// 收集依赖
</span><span class="c1"></span>    <span class="k">return</span> <span class="nx">isObject</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span>
      <span class="o">?</span> <span class="nx">isReadonly</span>
        <span class="o">?</span> <span class="nx">readonly</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span>
        <span class="o">:</span> <span class="nx">reactive</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span>
      <span class="o">:</span> <span class="nx">res</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The processing functions for get interceptions are still relatively clear.</p>
<p>When I first saw the <code>arrayIdentityInstrumentations</code> function, I didn&rsquo;t understand what its role was, so I had to go to the repository and check the corresponding <a href="https://github.com/vuejs/vue-next/commit/aefb7d282ed716923ca1a288a63a83a94af87ebc">commit</a>. From that <a href="https://github.com/vuejs/vue-next/blob/77103e1fd7a51dff06f6c8fc63d2451a4be0351a/packages/reactivity/__tests__/reactive.spec.ts#L53">single test</a>, we found that since the three methods <code>includes</code> , <code>indexOf</code> , <code>lastIndexOf</code> all use strict equality to determine the relationship of the found elements, if the responsive data (array) is pushed into a reference type of data, using the above three methods will find no match to the added data. Therefore, it is possible to get the correct matching relationship without proxying these three methods.</p>
<p>After that, the built-in Symbol property of ES6 does not collect dependencies, the data of shallowReadonly is only responsively proxied to the outermost layer, and the data of Ref is not recursively processed because it is a wrapper for basic type data and there is no nested data inside, so the rest needs to be manually recursively proxied. Vue 3.0 collects dependencies through the <code>track</code> function, which will be analyzed when we talk about the <code>effect</code> file.</p>
<h4 id="set">Set</h4>
<p>Let&rsquo;s look at the set hijacking method <code>createSetter</code> :</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">export</span> <span class="kr">const</span> <span class="nx">hasChanged</span> <span class="o">=</span> <span class="p">(</span><span class="nx">value</span><span class="o">:</span> <span class="nx">any</span><span class="p">,</span> <span class="nx">oldValue</span><span class="o">:</span> <span class="nx">any</span><span class="p">)</span><span class="o">:</span> <span class="kr">boolean</span> <span class="p">=&gt;</span>
  <span class="nx">value</span> <span class="o">!==</span> <span class="nx">oldValue</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">value</span> <span class="o">===</span> <span class="nx">value</span> <span class="o">||</span> <span class="nx">oldValue</span> <span class="o">===</span> <span class="nx">oldValue</span><span class="p">)</span> <span class="c1">// 排除 NaN 的干扰
</span><span class="c1"></span>  
<span class="kd">function</span> <span class="nx">createSetter</span><span class="p">(</span><span class="nx">isReadonly</span> <span class="o">=</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">shallow</span> <span class="o">=</span> <span class="kc">false</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="nx">set</span><span class="p">(</span><span class="nx">target</span><span class="o">:</span> <span class="nx">object</span><span class="p">,</span> <span class="nx">key</span><span class="o">:</span> <span class="nx">string</span> <span class="o">|</span> <span class="nx">symbol</span><span class="p">,</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">unknown</span><span class="p">,</span> <span class="nx">receiver</span><span class="o">:</span> <span class="nx">object</span><span class="p">)</span><span class="o">:</span> <span class="kr">boolean</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">isReadonly</span> <span class="o">&amp;&amp;</span> <span class="nx">LOCKED</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 如果是只读响应式数据或被锁住，则直接返回
</span><span class="c1"></span>      <span class="k">return</span> <span class="kc">true</span>
    <span class="p">}</span>

    <span class="kr">const</span> <span class="nx">oldValue</span> <span class="o">=</span> <span class="p">(</span><span class="nx">target</span> <span class="nx">as</span> <span class="nx">any</span><span class="p">)[</span><span class="nx">key</span><span class="p">]</span>  <span class="c1">// 获取旧值
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">shallow</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 非 shallowReadonly 时
</span><span class="c1"></span>      <span class="nx">value</span> <span class="o">=</span> <span class="nx">toRaw</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>  <span class="c1">// 获得新值的原始数据
</span><span class="c1"></span>      <span class="k">if</span> <span class="p">(</span><span class="nx">isRef</span><span class="p">(</span><span class="nx">oldValue</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">isRef</span><span class="p">(</span><span class="nx">value</span><span class="p">))</span> <span class="p">{</span>  <span class="c1">// 如果旧值是 Ref 数据，新值不是，就直接更新旧值数据的 value，并返回
</span><span class="c1"></span>        <span class="nx">oldValue</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span>
        <span class="k">return</span> <span class="kc">true</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="kr">const</span> <span class="nx">hadKey</span> <span class="o">=</span> <span class="nx">hasOwn</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>  <span class="c1">// 判断响应式数据上是否有这个 key
</span><span class="c1"></span>    <span class="kr">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">target</span> <span class="o">===</span> <span class="nx">toRaw</span><span class="p">(</span><span class="nx">receiver</span><span class="p">))</span> <span class="p">{</span>  <span class="c1">// 如果是原始数据原型链上的数据操作，不做任何触发监听函数的行为。
</span><span class="c1"></span>      <span class="k">if</span> <span class="p">(</span><span class="nx">__DEV__</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 开发环境会多传额外信息
</span><span class="c1"></span>        <span class="kr">const</span> <span class="nx">extraInfo</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">oldValue</span><span class="p">,</span> <span class="nx">newValue</span><span class="o">:</span> <span class="nx">value</span> <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">hadKey</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">trigger</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">TriggerOpTypes</span><span class="p">.</span><span class="nx">ADD</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">extraInfo</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">hasChanged</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">oldValue</span><span class="p">))</span> <span class="p">{</span>
          <span class="nx">trigger</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">TriggerOpTypes</span><span class="p">.</span><span class="nx">SET</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">extraInfo</span><span class="p">)</span>
        <span class="p">}</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">hadKey</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 如果不存在该 key，触发新赠属性操作
</span><span class="c1"></span>          <span class="nx">trigger</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">TriggerOpTypes</span><span class="p">.</span><span class="nx">ADD</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">hasChanged</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">oldValue</span><span class="p">))</span> <span class="p">{</span>  <span class="c1">// 如果存在该 key，触发更新属性操作
</span><span class="c1"></span>          <span class="nx">trigger</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">TriggerOpTypes</span><span class="p">.</span><span class="nx">SET</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">result</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The source code of <code>createSetter</code> is quite easy to understand with the official comments, and Vue 3.0 implements dependency triggering through <code>trigger</code> (which will also be analyzed in the <code>effect</code> file). Beyond that, there are of course a few confusing points.</p>
<ol>
<li>
<p>why is there <code>(value === value || oldValue === oldValue)</code> logic in the <code>hasChanged</code> function?
Because <code>NaN ! == NaN</code>, so this logic is added to exclude the interference of NaN.</p>
</li>
<li>
<p>why <code>isRef(oldValue) &amp;&amp; !isRef(value)</code> does not need to trigger the dependency?
Because the <code>Ref</code> data structure itself has the logic to hijack the <code>set</code> function (which triggers the dependency), so there is no need to trigger the dependency again.</p>
</li>
<li>
<p><code>target === toRaw(receiver)</code> What does this logic mean?</p>
</li>
</ol>
<blockquote>
<p>// don&rsquo;t trigger if target is something up in the prototype chain of original</p>
</blockquote>
<p>There is this comment on the source code that means don&rsquo;t do anything to trigger the listener function if it is a data operation in the prototype chain of original data. Still don&rsquo;t quite understand, so I commented out this line, ran through the single test, and got this <a href="https://github.com/vuejs/vue-next/blob/77103e1fd7a51dff06f6c8fc63d2451a4be0351a/packages/reactivity/__tests__/effect.spec.ts#L321">test case</a>, I finally understood it. The <code>receiver</code> is generally an object that has been proxied by the Proxy, but the handler&rsquo;s set method may also be called indirectly in the prototype chain or in some other way (so not necessarily by the proxy itself).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">child</span><span class="p">,</span> <span class="nx">parent</span><span class="p">)</span> <span class="c1">// child.__proto__ === parent true
</span></code></pre></td></tr></table>
</div>
</div><p>If child and parent are 2 Proxy proxies, <code>target</code> is not equal to <code>toRaw(receiver)</code> for child. A set operation on child should not change the data on parent, so no listener function will be triggered for data operations on the original data prototype chain.</p>
<h4 id="deleteproperty-has-ownkeys">deleteProperty, has, ownKeys</h4>
<p>There are three more functions to hijack. The source code is very simple, add a few lines of comments, no more analysis.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">deleteProperty</span><span class="p">(</span><span class="nx">target</span><span class="o">:</span> <span class="nx">object</span><span class="p">,</span> <span class="nx">key</span><span class="o">:</span> <span class="nx">string</span> <span class="o">|</span> <span class="nx">symbol</span><span class="p">)</span><span class="o">:</span> <span class="kr">boolean</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">hadKey</span> <span class="o">=</span> <span class="nx">hasOwn</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
  <span class="kr">const</span> <span class="nx">oldValue</span> <span class="o">=</span> <span class="p">(</span><span class="nx">target</span> <span class="nx">as</span> <span class="nx">any</span><span class="p">)[</span><span class="nx">key</span><span class="p">]</span>
  <span class="kr">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">deleteProperty</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">result</span> <span class="o">&amp;&amp;</span> <span class="nx">hadKey</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 存在指定 key 且不报错情况触发删除依赖项的执行
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">__DEV__</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">trigger</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">TriggerOpTypes</span><span class="p">.</span><span class="nx">DELETE</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="p">{</span> <span class="nx">oldValue</span> <span class="p">})</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">trigger</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">TriggerOpTypes</span><span class="p">.</span><span class="nx">DELETE</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">has</span><span class="p">(</span><span class="nx">target</span><span class="o">:</span> <span class="nx">object</span><span class="p">,</span> <span class="nx">key</span><span class="o">:</span> <span class="nx">string</span> <span class="o">|</span> <span class="nx">symbol</span><span class="p">)</span><span class="o">:</span> <span class="kr">boolean</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
  <span class="nx">track</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">TrackOpTypes</span><span class="p">.</span><span class="nx">HAS</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>  <span class="c1">// 触发依赖
</span><span class="c1"></span>  <span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">ownKeys</span><span class="p">(</span><span class="nx">target</span><span class="o">:</span> <span class="nx">object</span><span class="p">)</span><span class="o">:</span> <span class="p">(</span><span class="nx">string</span> <span class="o">|</span> <span class="nx">number</span> <span class="o">|</span> <span class="nx">symbol</span><span class="p">)[]</span> <span class="p">{</span>
  <span class="nx">track</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">TrackOpTypes</span><span class="p">.</span><span class="nx">ITERATE</span><span class="p">,</span> <span class="nx">ITERATE_KEY</span><span class="p">)</span> <span class="c1">// 触发依赖
</span><span class="c1"></span>  <span class="k">return</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">ownKeys</span><span class="p">(</span><span class="nx">target</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="collectionhandlers">collectionHandlers</h3>
<p>As already mentioned, the four data types Map, Set, WeakMap, WeakSet Proxy can not properly intercept all properties. For example, the proxy set, delete and other methods will directly report an error, but of course the get method of access can still be intercepted normally. Therefore, we can implement a new object, which has all the APIs corresponding to the set data type, and just hijack the proxy to this new object by get.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">createInstrumentationGetter</span><span class="p">(</span><span class="nx">instrumentations</span><span class="o">:</span> <span class="nx">Record</span><span class="o">&lt;</span><span class="nx">string</span><span class="p">,</span> <span class="nb">Function</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="nx">target</span><span class="o">:</span> <span class="nx">CollectionTypes</span><span class="p">,</span> <span class="nx">key</span><span class="o">:</span> <span class="nx">string</span> <span class="o">|</span> <span class="nx">symbol</span><span class="p">,</span> <span class="nx">receiver</span><span class="o">:</span> <span class="nx">CollectionTypes</span><span class="p">)</span> <span class="p">=&gt;</span>
    <span class="nx">Reflect</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span>  <span class="c1">// 如果新对象有该 key 且原始数据中也有该 key，就代理到新对象，否则使用原始数据
</span><span class="c1"></span>      <span class="nx">hasOwn</span><span class="p">(</span><span class="nx">instrumentations</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">key</span> <span class="k">in</span> <span class="nx">target</span>
        <span class="o">?</span> <span class="nx">instrumentations</span>
        <span class="o">:</span> <span class="nx">target</span><span class="p">,</span>
      <span class="nx">key</span><span class="p">,</span>
      <span class="nx">receiver</span>
    <span class="p">)</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="kr">const</span> <span class="nx">mutableCollectionHandlers</span><span class="o">:</span> <span class="nx">ProxyHandler</span><span class="o">&lt;</span><span class="nx">CollectionTypes</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">get</span><span class="o">:</span> <span class="nx">createInstrumentationGetter</span><span class="p">(</span><span class="nx">mutableInstrumentations</span><span class="p">)</span>  <span class="c1">// 代理到可变的新对象
</span><span class="c1"></span><span class="p">}</span>

<span class="kr">export</span> <span class="kr">const</span> <span class="nx">readonlyCollectionHandlers</span><span class="o">:</span> <span class="nx">ProxyHandler</span><span class="o">&lt;</span><span class="nx">CollectionTypes</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">get</span><span class="o">:</span> <span class="nx">createInstrumentationGetter</span><span class="p">(</span><span class="nx">readonlyInstrumentations</span><span class="p">)</span>  <span class="c1">// 代理到只读的新对象
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The next step is to look at the internal implementation of the two new objects <code>mutableInstrumentations</code> and <code>readonlyInstrumentations</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">mutableInstrumentations</span><span class="o">:</span> <span class="nx">Record</span><span class="o">&lt;</span><span class="nx">string</span><span class="p">,</span> <span class="nb">Function</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">get</span><span class="p">(</span><span class="k">this</span><span class="o">:</span> <span class="nx">MapTypes</span><span class="p">,</span> <span class="nx">key</span><span class="o">:</span> <span class="nx">unknown</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">get</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">toReactive</span><span class="p">)</span>
  <span class="p">},</span>
  <span class="nx">get</span> <span class="nx">size</span><span class="p">(</span><span class="k">this</span><span class="o">:</span> <span class="nx">IterableCollections</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">size</span><span class="p">(</span><span class="k">this</span><span class="p">)</span>
  <span class="p">},</span>
  <span class="nx">has</span><span class="p">,</span>
  <span class="nx">add</span><span class="p">,</span>
  <span class="nx">set</span><span class="p">,</span>
  <span class="k">delete</span><span class="o">:</span> <span class="nx">deleteEntry</span><span class="p">,</span>
  <span class="nx">clear</span><span class="p">,</span>
  <span class="nx">forEach</span><span class="o">:</span> <span class="nx">createForEach</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">readonlyInstrumentations</span><span class="o">:</span> <span class="nx">Record</span><span class="o">&lt;</span><span class="nx">string</span><span class="p">,</span> <span class="nb">Function</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">get</span><span class="p">(</span><span class="k">this</span><span class="o">:</span> <span class="nx">MapTypes</span><span class="p">,</span> <span class="nx">key</span><span class="o">:</span> <span class="nx">unknown</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">get</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">toReadonly</span><span class="p">)</span>
  <span class="p">},</span>
  <span class="nx">get</span> <span class="nx">size</span><span class="p">(</span><span class="k">this</span><span class="o">:</span> <span class="nx">IterableCollections</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">size</span><span class="p">(</span><span class="k">this</span><span class="p">)</span>
  <span class="p">},</span>
  <span class="nx">has</span><span class="p">,</span>
  <span class="nx">add</span><span class="o">:</span> <span class="nx">createReadonlyMethod</span><span class="p">(</span><span class="nx">add</span><span class="p">,</span> <span class="nx">TriggerOpTypes</span><span class="p">.</span><span class="nx">ADD</span><span class="p">),</span>
  <span class="nx">set</span><span class="o">:</span> <span class="nx">createReadonlyMethod</span><span class="p">(</span><span class="nx">set</span><span class="p">,</span> <span class="nx">TriggerOpTypes</span><span class="p">.</span><span class="nx">SET</span><span class="p">),</span>
  <span class="k">delete</span><span class="o">:</span> <span class="nx">createReadonlyMethod</span><span class="p">(</span><span class="nx">deleteEntry</span><span class="p">,</span> <span class="nx">TriggerOpTypes</span><span class="p">.</span><span class="nx">DELETE</span><span class="p">),</span>
  <span class="nx">clear</span><span class="o">:</span> <span class="nx">createReadonlyMethod</span><span class="p">(</span><span class="nx">clear</span><span class="p">,</span> <span class="nx">TriggerOpTypes</span><span class="p">.</span><span class="nx">CLEAR</span><span class="p">),</span>
  <span class="nx">forEach</span><span class="o">:</span> <span class="nx">createForEach</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">iteratorMethods</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;keys&#39;</span><span class="p">,</span> <span class="s1">&#39;values&#39;</span><span class="p">,</span> <span class="s1">&#39;entries&#39;</span><span class="p">,</span> <span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]</span>
<span class="nx">iteratorMethods</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">method</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">mutableInstrumentations</span><span class="p">[</span><span class="nx">method</span> <span class="nx">as</span> <span class="nx">string</span><span class="p">]</span> <span class="o">=</span> <span class="nx">createIterableMethod</span><span class="p">(</span><span class="nx">method</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
  <span class="nx">readonlyInstrumentations</span><span class="p">[</span><span class="nx">method</span> <span class="nx">as</span> <span class="nx">string</span><span class="p">]</span> <span class="o">=</span> <span class="nx">createIterableMethod</span><span class="p">(</span><span class="nx">method</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
<span class="p">})</span>
</code></pre></td></tr></table>
</div>
</div><p>You can see that in the new object is a proxy for <code>get</code> , <code>size</code> , <code>has</code> , <code>add</code> , <code>set</code> , <code>delete</code> , <code>clear</code> , <code>forEach</code> and some methods related to iterators (keys, values, entries, Symbol.iterator).</p>
<p>Let&rsquo;s start with a few instrumental functions.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">export</span> <span class="kd">function</span> <span class="nx">toRaw</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">observed</span><span class="o">:</span> <span class="nx">T</span><span class="p">)</span><span class="o">:</span> <span class="nx">T</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">reactiveToRaw</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">observed</span><span class="p">)</span> <span class="o">||</span> <span class="nx">readonlyToRaw</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">observed</span><span class="p">)</span> <span class="o">||</span> <span class="nx">observed</span>
<span class="p">}</span>
<span class="kr">export</span> <span class="kr">const</span> <span class="nx">hasChanged</span> <span class="o">=</span> <span class="p">(</span><span class="nx">value</span><span class="o">:</span> <span class="nx">any</span><span class="p">,</span> <span class="nx">oldValue</span><span class="o">:</span> <span class="nx">any</span><span class="p">)</span><span class="o">:</span> <span class="kr">boolean</span> <span class="p">=&gt;</span>
  <span class="nx">value</span> <span class="o">!==</span> <span class="nx">oldValue</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">value</span> <span class="o">===</span> <span class="nx">value</span> <span class="o">||</span> <span class="nx">oldValue</span> <span class="o">===</span> <span class="nx">oldValue</span><span class="p">)</span> <span class="c1">// 排除 NaN 的干扰
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">toReactive</span> <span class="o">=</span> <span class="o">&lt;</span><span class="nx">T</span> <span class="kr">extends</span> <span class="nx">unknown</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">value</span><span class="o">:</span> <span class="nx">T</span><span class="p">)</span><span class="o">:</span> <span class="nx">T</span> <span class="p">=&gt;</span> <span class="nx">isObject</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="o">?</span> <span class="nx">reactive</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="o">:</span> <span class="nx">value</span>
<span class="kr">const</span> <span class="nx">toReadonly</span> <span class="o">=</span> <span class="o">&lt;</span><span class="nx">T</span> <span class="kr">extends</span> <span class="nx">unknown</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">value</span><span class="o">:</span> <span class="nx">T</span><span class="p">)</span><span class="o">:</span> <span class="nx">T</span> <span class="p">=&gt;</span> <span class="nx">isObject</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="o">?</span> <span class="nx">readonly</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="o">:</span> <span class="nx">value</span>
<span class="kr">const</span> <span class="nx">getProto</span> <span class="o">=</span> <span class="o">&lt;</span><span class="nx">T</span> <span class="kr">extends</span> <span class="nx">CollectionTypes</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">v</span><span class="o">:</span> <span class="nx">T</span><span class="p">)</span><span class="o">:</span> <span class="nx">any</span> <span class="p">=&gt;</span> <span class="nx">Reflect</span><span class="p">.</span><span class="nx">getPrototypeOf</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>

</code></pre></td></tr></table>
</div>
</div><p>The first two methods are described in the previous section, <code>toReactive</code> converts raw data into mutable responsive data, <code>toReadonly</code> converts raw data into read-only responsive data, and <code>getProto</code> reads the object&rsquo;s <strong>proto</strong> property (to get the prototype object).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">get</span><span class="p">(</span><span class="nx">target</span><span class="o">:</span> <span class="nx">MapTypes</span><span class="p">,</span> <span class="nx">key</span><span class="o">:</span> <span class="nx">unknown</span><span class="p">,</span> <span class="nx">wrap</span><span class="o">:</span> <span class="k">typeof</span> <span class="nx">toReactive</span> <span class="o">|</span> <span class="k">typeof</span> <span class="nx">toReadonly</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">target</span> <span class="o">=</span> <span class="nx">toRaw</span><span class="p">(</span><span class="nx">target</span><span class="p">)</span>  <span class="c1">// 获得原始数据
</span><span class="c1"></span>  <span class="nx">key</span> <span class="o">=</span> <span class="nx">toRaw</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>  <span class="c1">// 获得 key 的原始数据（key 也可能为响应式对象）
</span><span class="c1"></span>  <span class="nx">track</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">TrackOpTypes</span><span class="p">.</span><span class="nx">GET</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">wrap</span><span class="p">(</span><span class="nx">getProto</span><span class="p">(</span><span class="nx">target</span><span class="p">).</span><span class="nx">get</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">))</span>  <span class="c1">// 获取原始数据的 key 值并转化为响应式数据
</span><span class="c1"></span><span class="p">}</span>

<span class="p">...</span>  <span class="c1">// size, has, add, set, delete, clear 等方法的逻辑都跟前面的一致，很好理解，这里就不再赘述
</span><span class="c1"></span>
<span class="kd">function</span> <span class="nx">createForEach</span><span class="p">(</span><span class="nx">isReadonly</span><span class="o">:</span> <span class="kr">boolean</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="nx">forEach</span><span class="p">(</span><span class="k">this</span><span class="o">:</span> <span class="nx">IterableCollections</span><span class="p">,</span> <span class="nx">callback</span><span class="o">:</span> <span class="nb">Function</span><span class="p">,</span> <span class="nx">thisArg</span><span class="o">?:</span> <span class="nx">unknown</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">observed</span> <span class="o">=</span> <span class="k">this</span>
    <span class="kr">const</span> <span class="nx">target</span> <span class="o">=</span> <span class="nx">toRaw</span><span class="p">(</span><span class="nx">observed</span><span class="p">)</span>  <span class="c1">// 获取原始数据
</span><span class="c1"></span>    <span class="kr">const</span> <span class="nx">wrap</span> <span class="o">=</span> <span class="nx">isReadonly</span> <span class="o">?</span> <span class="nx">toReadonly</span> <span class="o">:</span> <span class="nx">toReactive</span>
    <span class="nx">track</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">TrackOpTypes</span><span class="p">.</span><span class="nx">ITERATE</span><span class="p">,</span> <span class="nx">ITERATE_KEY</span><span class="p">)</span>
    <span class="c1">// 将 callback 的数据都转化成响应式数据
</span><span class="c1"></span>    <span class="kd">function</span> <span class="nx">wrappedCallback</span><span class="p">(</span><span class="nx">value</span><span class="o">:</span> <span class="nx">unknown</span><span class="p">,</span> <span class="nx">key</span><span class="o">:</span> <span class="nx">unknown</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">callback</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">observed</span><span class="p">,</span> <span class="nx">wrap</span><span class="p">(</span><span class="nx">value</span><span class="p">),</span> <span class="nx">wrap</span><span class="p">(</span><span class="nx">key</span><span class="p">),</span> <span class="nx">observed</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">getProto</span><span class="p">(</span><span class="nx">target</span><span class="p">).</span><span class="nx">forEach</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">wrappedCallback</span><span class="p">,</span> <span class="nx">thisArg</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">createIterableMethod</span><span class="p">(</span><span class="nx">method</span><span class="o">:</span> <span class="nx">string</span> <span class="o">|</span> <span class="nx">symbol</span><span class="p">,</span> <span class="nx">isReadonly</span><span class="o">:</span> <span class="kr">boolean</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="k">this</span><span class="o">:</span> <span class="nx">IterableCollections</span><span class="p">,</span> <span class="p">...</span><span class="nx">args</span><span class="o">:</span> <span class="nx">unknown</span><span class="p">[])</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">target</span> <span class="o">=</span> <span class="nx">toRaw</span><span class="p">(</span><span class="k">this</span><span class="p">)</span>
    <span class="kr">const</span> <span class="nx">isPair</span> <span class="o">=</span> <span class="nx">method</span> <span class="o">===</span> <span class="s1">&#39;entries&#39;</span> <span class="o">||</span> <span class="p">(</span><span class="nx">method</span> <span class="o">===</span> <span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span> <span class="o">&amp;&amp;</span> <span class="nx">target</span> <span class="k">instanceof</span> <span class="nx">Map</span><span class="p">)</span>  <span class="c1">// 判断是否为 key/value 结构
</span><span class="c1"></span>    <span class="kr">const</span> <span class="nx">innerIterator</span> <span class="o">=</span> <span class="nx">getProto</span><span class="p">(</span><span class="nx">target</span><span class="p">)[</span><span class="nx">method</span><span class="p">].</span><span class="nx">apply</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">args</span><span class="p">)</span>  <span class="c1">// 获取原型链上迭代器的方法
</span><span class="c1"></span>    <span class="kr">const</span> <span class="nx">wrap</span> <span class="o">=</span> <span class="nx">isReadonly</span> <span class="o">?</span> <span class="nx">toReadonly</span> <span class="o">:</span> <span class="nx">toReactive</span>
    <span class="nx">track</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">TrackOpTypes</span><span class="p">.</span><span class="nx">ITERATE</span><span class="p">,</span> <span class="nx">ITERATE_KEY</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">{</span>
      <span class="nx">next</span><span class="p">()</span> <span class="p">{</span>
        <span class="kr">const</span> <span class="p">{</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">done</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">innerIterator</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span>
        <span class="k">return</span> <span class="nx">done</span>  <span class="c1">// 迭代器执行到最后一个时值是 { value: undefined, done: false } 不需要再转化成响应式数据
</span><span class="c1"></span>          <span class="o">?</span> <span class="p">{</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">done</span> <span class="p">}</span>
          <span class="o">:</span> <span class="p">{</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">isPair</span> <span class="o">?</span> <span class="p">[</span><span class="nx">wrap</span><span class="p">(</span><span class="nx">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nx">wrap</span><span class="p">(</span><span class="nx">value</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span> <span class="o">:</span> <span class="nx">wrap</span><span class="p">(</span><span class="nx">value</span><span class="p">),</span> <span class="nx">done</span> <span class="p">}</span>
      <span class="p">},</span>
      <span class="p">[</span><span class="nx">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Although the <code>collectionHandlers.ts</code> file is much longer than <code>baseHandlers.ts</code>, it is much easier to understand the code of <code>baseHandlers.ts</code> before looking at the code of <code>collectionHandlers.ts</code>. <code>collectionHandlers.ts</code> creates a new object to hijack all the collection type data, so inside the hijack function you always get the original data and the prototype method of the original data first, and then bind that method to the original data to call it.</p>
<h3 id="reactive-summary">Reactive Summary</h3>
<p><code>reactive</code> implements data proxying through ES6&rsquo;s <code>Proxy</code> and <code>Reflect</code> APIs to convert to responsive data, which naturally has the advantage of better performance and ease of use, but the disadvantage of not supporting browsers below IE11. It also avoids performance problems caused by nested recursive <code>new Proxy</code> through <code>lazy access</code>, unlike Vue2.0 where all dependencies are collected at initialization.</p>
<h2 id="ref">Ref</h2>
<p>As already mentioned, <code>reactive</code> cannot convert basic data types, and <code>Ref</code> solves the problem of basic data types not being converted to responsive data by a layer of wrapping.</p>
<p>Let&rsquo;s look at the data type of <code>Ref</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">isRefSymbol</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">()</span>

<span class="kr">export</span> <span class="kr">interface</span> <span class="nx">Ref</span><span class="o">&lt;</span><span class="nx">T</span> <span class="o">=</span> <span class="nx">any</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="p">[</span><span class="nx">isRefSymbol</span><span class="p">]</span><span class="o">:</span> <span class="kc">true</span>  <span class="c1">// 私有属性用来区分带有 value 字段的普通对象，且不想暴露给用户
</span><span class="c1"></span>  <span class="nx">value</span><span class="o">:</span> <span class="nx">UnwrapRef</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="kd">function</span> <span class="nx">isRef</span><span class="p">(</span><span class="nx">r</span><span class="o">:</span> <span class="nx">any</span><span class="p">)</span><span class="o">:</span> <span class="nx">r</span> <span class="nx">is</span> <span class="nx">Ref</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">r</span> <span class="o">?</span> <span class="nx">r</span><span class="p">.</span><span class="nx">_isRef</span> <span class="o">===</span> <span class="kc">true</span> <span class="o">:</span> <span class="kc">false</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Although there is a private property in <code>Ref</code> that determines whether the target object is a <code>Ref</code> structure, looking up the symbol property on an arbitrary object is much slower than a normal property, so <code>isRef</code> actually determines whether it is <code>Ref</code> data by the <code>_isRef</code> property, which is added when <code>Ref</code> is generated. The <code>value</code> property of <code>Ref</code> is the &ldquo;unwrapped&rdquo; type, which is actually determined by the recursive <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html">infer</a> to achieve this.</p>
<p>This is a brief look at <code>infer</code>, because the unwrapper type is used throughout the <code>Reactive</code> and <code>Ref</code> files, and it can be difficult to read the source code without knowing something about it.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">type</span> <span class="nx">ParamType</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">T</span> <span class="kr">extends</span> <span class="p">(</span><span class="nx">param</span><span class="o">:</span> <span class="nx">infer</span> <span class="nx">P</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">any</span> <span class="o">?</span> <span class="nx">P</span> <span class="o">:</span> <span class="nx">T</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>In this conditional statement <code>T extends (param: infer P) =&gt; any ? P : T</code>, <code>infer P</code> represents the function parameter to be inferred.</p>
<p>The whole statement means that if T can be assigned to <code>(param: infer P) =&gt; any</code>, the result is P in type <code>(param: infer P) =&gt; any</code>, otherwise it returns T.</p>
<p>Next, see an example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">interface</span> <span class="nx">User</span> <span class="p">{</span>
  <span class="nx">name</span><span class="o">:</span> <span class="nx">string</span><span class="p">;</span>
  <span class="nx">age</span><span class="o">:</span> <span class="nx">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">type</span> <span class="nx">Func</span> <span class="o">=</span> <span class="p">(</span><span class="nx">user</span><span class="o">:</span> <span class="nx">User</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="k">void</span><span class="p">;</span>

<span class="nx">type</span> <span class="nx">Param</span> <span class="o">=</span> <span class="nx">ParamType</span><span class="o">&lt;</span><span class="nx">Func</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// Param = User
</span><span class="c1"></span><span class="nx">type</span> <span class="nx">AA</span> <span class="o">=</span> <span class="nx">ParamType</span><span class="o">&lt;</span><span class="nx">string</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// string
</span><span class="c1"></span>
</code></pre></td></tr></table>
</div>
</div><p>In TypeScript 2.8 and later, after the introduction of the <code>infer</code> feature, there are also many built-in mapping types related to <code>infer</code>, such as <code>ReturnType</code> , <code>ConstructorParameters</code> , <code>InstanceType</code> and so on. Next, let&rsquo;s see how the unwrapped types look like.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">type</span> <span class="nx">UnwrapArray</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="nx">P</span> <span class="k">in</span> <span class="nx">keyof</span> <span class="nx">T</span><span class="p">]</span><span class="o">:</span> <span class="nx">UnwrapRef</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">[</span><span class="nx">P</span><span class="p">]</span><span class="o">&gt;</span> <span class="p">}</span>
<span class="nx">type</span> <span class="nx">BaseTypes</span> <span class="o">=</span> <span class="nx">string</span> <span class="o">|</span> <span class="nx">number</span> <span class="o">|</span> <span class="kr">boolean</span>

<span class="c1">// 递归解包装 Ref 类型
</span><span class="c1"></span><span class="kr">export</span> <span class="nx">type</span> <span class="nx">UnwrapRef</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span>
  <span class="c1">// 如果是 ComputedRef 类型，继续解包装
</span><span class="c1"></span>  <span class="nx">cRef</span><span class="o">:</span> <span class="nx">T</span> <span class="kr">extends</span> <span class="nx">ComputedRef</span><span class="o">&lt;</span><span class="nx">infer</span> <span class="nx">V</span><span class="o">&gt;</span> <span class="o">?</span> <span class="nx">UnwrapRef</span><span class="o">&lt;</span><span class="nx">V</span><span class="o">&gt;</span> <span class="o">:</span> <span class="nx">T</span>
  <span class="c1">// 如果是 Ref 类型，继续解包装
</span><span class="c1"></span>  <span class="nx">ref</span><span class="o">:</span> <span class="nx">T</span> <span class="kr">extends</span> <span class="nx">Ref</span><span class="o">&lt;</span><span class="nx">infer</span> <span class="nx">V</span><span class="o">&gt;</span> <span class="o">?</span> <span class="nx">UnwrapRef</span><span class="o">&lt;</span><span class="nx">V</span><span class="o">&gt;</span> <span class="o">:</span> <span class="nx">T</span>
  <span class="c1">// 如果是数组类型，对数组每一项进行解包装
</span><span class="c1"></span>  <span class="nx">array</span><span class="o">:</span> <span class="nx">T</span> <span class="kr">extends</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">infer</span> <span class="nx">V</span><span class="o">&gt;</span> <span class="o">?</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">UnwrapRef</span><span class="o">&lt;</span><span class="nx">V</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span> <span class="nx">UnwrapArray</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">:</span> <span class="nx">T</span>
  <span class="c1">// 如果是对象类型，对对象每一项进行解包装
</span><span class="c1"></span>  <span class="nx">object</span><span class="o">:</span> <span class="p">{</span> <span class="p">[</span><span class="nx">K</span> <span class="k">in</span> <span class="nx">keyof</span> <span class="nx">T</span><span class="p">]</span><span class="o">:</span> <span class="nx">UnwrapRef</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">[</span><span class="nx">K</span><span class="p">]</span><span class="o">&gt;</span> <span class="p">}</span>
<span class="p">}[</span><span class="nx">T</span> <span class="kr">extends</span> <span class="nx">ComputedRef</span><span class="o">&lt;</span><span class="nx">any</span><span class="o">&gt;</span>
  <span class="o">?</span> <span class="s1">&#39;cRef&#39;</span>
  <span class="o">:</span> <span class="nx">T</span> <span class="kr">extends</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">any</span><span class="o">&gt;</span>
    <span class="o">?</span> <span class="s1">&#39;array&#39;</span>
    <span class="o">:</span> <span class="nx">T</span> <span class="kr">extends</span> <span class="nx">Ref</span> <span class="o">|</span> <span class="nb">Function</span> <span class="o">|</span> <span class="nx">CollectionTypes</span> <span class="o">|</span> <span class="nx">BaseTypes</span>  <span class="c1">// 函数，集合类型和基本类型不需要解包装
</span><span class="c1"></span>      <span class="o">?</span> <span class="s1">&#39;ref&#39;</span>
      <span class="o">:</span> <span class="nx">T</span> <span class="kr">extends</span> <span class="nx">object</span> <span class="o">?</span> <span class="s1">&#39;object&#39;</span> <span class="o">:</span> <span class="s1">&#39;ref&#39;</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p>We know from the code that the <code>value</code> structure of <code>Ref</code> can be of any type, but it must not be nested by a <code>Ref</code> type, be it <code>Ref&lt;Ref&lt;T&gt;&gt;</code> or <code>Array&lt;Ref&gt;</code>, <code>{ [key]: Ref }</code> and so on.</p>
<p>After that, let&rsquo;s see how to generate <code>Ref</code> data.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">convert</span> <span class="o">=</span> <span class="o">&lt;</span><span class="nx">T</span> <span class="kr">extends</span> <span class="nx">unknown</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">val</span><span class="o">:</span> <span class="nx">T</span><span class="p">)</span><span class="o">:</span> <span class="nx">T</span> <span class="p">=&gt;</span> <span class="nx">isObject</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span> <span class="o">?</span> <span class="nx">reactive</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span> <span class="o">:</span> <span class="nx">val</span>

<span class="kr">export</span> <span class="kd">function</span> <span class="nx">ref</span><span class="p">(</span><span class="nx">value</span><span class="o">?:</span> <span class="nx">unknown</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">isRef</span><span class="p">(</span><span class="nx">value</span><span class="p">))</span> <span class="p">{</span>  <span class="c1">// 如果已经是 Ref 数据，直接返回该数据
</span><span class="c1"></span>    <span class="k">return</span> <span class="nx">value</span>
  <span class="p">}</span>
  <span class="nx">value</span> <span class="o">=</span> <span class="nx">convert</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>  <span class="c1">// 将 value 转化为响应式数据
</span><span class="c1"></span>  <span class="kr">const</span> <span class="nx">r</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">_isRef</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="nx">get</span> <span class="nx">value</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">track</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="nx">TrackOpTypes</span><span class="p">.</span><span class="nx">GET</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">)</span>  <span class="c1">// 收集依赖
</span><span class="c1"></span>      <span class="k">return</span> <span class="nx">value</span>
    <span class="p">},</span>
    <span class="nx">set</span> <span class="nx">value</span><span class="p">(</span><span class="nx">newVal</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">value</span> <span class="o">=</span> <span class="nx">convert</span><span class="p">(</span><span class="nx">newVal</span><span class="p">)</span>
      <span class="nx">trigger</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="nx">TriggerOpTypes</span><span class="p">.</span><span class="nx">SET</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">,</span> <span class="nx">__DEV__</span> <span class="o">?</span> <span class="p">{</span> <span class="nx">newValue</span><span class="o">:</span> <span class="nx">newVal</span> <span class="p">}</span> <span class="o">:</span> <span class="k">void</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1">// 触发依赖
</span><span class="c1"></span>    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">r</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>When generating <code>Ref</code>, the attribute <code>_isRef</code> is added to the <code>isRef</code> function to identify it. <code>Ref</code> also internally intercepts the get and set functions, which corresponds to the <code>createGetter</code> function in <code>Reactive.ts</code>, which does not collect dependencies on data of type <code>Ref</code> and returns its value directly.</p>
<p>There are also 2 <code>Ref</code> related methods.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="c1">// 将目标对象里的每个 key 都转成 Ref 结构
</span><span class="c1"></span><span class="kr">export</span> <span class="kd">function</span> <span class="nx">toRefs</span><span class="o">&lt;</span><span class="nx">T</span> <span class="kr">extends</span> <span class="nx">object</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">object</span><span class="o">:</span> <span class="nx">T</span><span class="p">)</span><span class="o">:</span> <span class="p">{</span> <span class="p">[</span><span class="nx">K</span> <span class="k">in</span> <span class="nx">keyof</span> <span class="nx">T</span><span class="p">]</span><span class="o">:</span> <span class="nx">Ref</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">[</span><span class="nx">K</span><span class="p">]</span><span class="o">&gt;</span> <span class="p">}</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">__DEV__</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">isReactive</span><span class="p">(</span><span class="nx">object</span><span class="p">))</span> <span class="p">{</span>  <span class="c1">// 必须是响应式数据才可以
</span><span class="c1"></span>    <span class="nx">console</span><span class="p">.</span><span class="nx">warn</span><span class="p">(</span><span class="sb">`toRefs() expects a reactive object but received a plain one.`</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="kr">const</span> <span class="nx">ret</span><span class="o">:</span> <span class="nx">any</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">key</span> <span class="k">in</span> <span class="nx">object</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">ret</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">toProxyRef</span><span class="p">(</span><span class="nx">object</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">toProxyRef</span><span class="o">&lt;</span><span class="nx">T</span> <span class="kr">extends</span> <span class="nx">object</span><span class="p">,</span> <span class="nx">K</span> <span class="kr">extends</span> <span class="nx">keyof</span> <span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">object</span><span class="o">:</span> <span class="nx">T</span><span class="p">,</span> <span class="nx">key</span><span class="o">:</span> <span class="nx">K</span><span class="p">)</span><span class="o">:</span> <span class="nx">Ref</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">[</span><span class="nx">K</span><span class="p">]</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="nx">_isRef</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="nx">get</span> <span class="nx">value</span><span class="p">()</span><span class="o">:</span> <span class="nx">any</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">object</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>  <span class="c1">// 不收集依赖
</span><span class="c1"></span>    <span class="p">},</span>
    <span class="nx">set</span> <span class="nx">value</span><span class="p">(</span><span class="nx">newVal</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">object</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">newVal</span>  <span class="c1">// 不触发依赖
</span><span class="c1"></span>    <span class="p">}</span>
  <span class="p">}</span> <span class="nx">as</span> <span class="nx">any</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>Convert a reactive object to a plain object, where each property on the resulting object is a ref pointing to the corresponding property in the original object.</p>
</blockquote>
<p>As you can see from the official documentation, <code>toRefs</code> is used to convert responsive data into normal objects, but the properties of the resulting objects are of type Ref and still have responsiveness.</p>
<p>Why does the <code>Ref</code> object returned in the <code>toProxyRef</code> function have no collection dependencies or trigger dependencies?</p>
<p>As mentioned before, no dependencies are collected or triggered for <code>Ref</code> types in <code>reactive</code>, so doesn&rsquo;t the value returned by <code>toRefs</code> have responsiveness? Look at the following example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">reactive</span><span class="p">({</span> <span class="nx">x</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="mi">2</span> <span class="p">})</span>
<span class="kr">const</span> <span class="p">{</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">toRefs</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>In fact, x and y are already proxied to a&rsquo;s x and y properties, so when accessing x and y or changing their values, a&rsquo;s <code>set value()</code> and <code>get value()</code> functions will be triggered to collect and trigger the dependencies. Therefore, vue3 deliberately removes the <code>trigger</code> and <code>track</code> functions from the Ref data returned by <code>toRefs</code> to prevent duplicate collection and triggering of dependencies.</p>
<h2 id="effect">Effect</h2>
<p>Both <code>computed</code> and <code>watch</code> are wrapped based on <code>effect</code>. In this file, we focus on collecting and triggering dependencies.</p>
<p>Let&rsquo;s look at the type declaration first.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">export</span> <span class="kr">interface</span> <span class="nx">ReactiveEffect</span><span class="o">&lt;</span><span class="nx">T</span> <span class="o">=</span> <span class="nx">any</span><span class="o">&gt;</span> <span class="p">{</span>  <span class="c1">// 监听函数
</span><span class="c1"></span>  <span class="p">()</span><span class="o">:</span> <span class="nx">T</span>  <span class="c1">// ReactiveEffect 是一个函数，没有入参，返回值为 T
</span><span class="c1"></span>  <span class="nx">_isEffect</span><span class="o">:</span> <span class="kc">true</span>  <span class="c1">// 判断是否为 effect 的标识
</span><span class="c1"></span>  <span class="nx">active</span><span class="o">:</span> <span class="kr">boolean</span>  <span class="c1">// 激活开关
</span><span class="c1"></span>  <span class="nx">raw</span><span class="o">:</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">T</span>  <span class="c1">// 依赖函数的原始函数
</span><span class="c1"></span>  <span class="nx">deps</span><span class="o">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">Dep</span><span class="o">&gt;</span>  <span class="c1">//  存储的依赖
</span><span class="c1"></span>  <span class="nx">options</span><span class="o">:</span> <span class="nx">ReactiveEffectOptions</span>  <span class="c1">// 依赖函数的配置项
</span><span class="c1"></span><span class="p">}</span>

<span class="kr">export</span> <span class="kr">interface</span> <span class="nx">ReactiveEffectOptions</span> <span class="p">{</span>
  <span class="nx">lazy</span><span class="o">?:</span> <span class="kr">boolean</span>  <span class="c1">// 延迟执行的标志
</span><span class="c1"></span>  <span class="nx">computed</span><span class="o">?:</span> <span class="kr">boolean</span>  <span class="c1">// 是否是 computed 的监听函数
</span><span class="c1"></span>  <span class="nx">scheduler</span><span class="o">?:</span> <span class="p">(</span><span class="nx">run</span><span class="o">:</span> <span class="nb">Function</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="k">void</span>  <span class="c1">// 自定义的依赖执行函数
</span><span class="c1"></span>  <span class="nx">onTrack</span><span class="o">?:</span> <span class="p">(</span><span class="nx">event</span><span class="o">:</span> <span class="nx">DebuggerEvent</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="k">void</span>  <span class="c1">// 调试中收集依赖时执行
</span><span class="c1"></span>  <span class="nx">onTrigger</span><span class="o">?:</span> <span class="p">(</span><span class="nx">event</span><span class="o">:</span> <span class="nx">DebuggerEvent</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="k">void</span>  <span class="c1">// 调试中触发依赖时执行
</span><span class="c1"></span>  <span class="nx">onStop</span><span class="o">?:</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="k">void</span>  <span class="c1">// 调试中触发 `stop` 函数时执行
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Then look directly at the code for <code>effect</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">export</span> <span class="kr">const</span> <span class="nx">EMPTY_OBJ</span><span class="o">:</span> <span class="p">{</span> <span class="nx">readonly</span> <span class="p">[</span><span class="nx">key</span><span class="o">:</span> <span class="nx">string</span><span class="p">]</span><span class="o">:</span> <span class="nx">any</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">__DEV__</span> <span class="o">?</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">freeze</span><span class="p">({})</span> <span class="o">:</span> <span class="p">{}</span>
<span class="kr">export</span> <span class="kd">function</span> <span class="nx">isEffect</span><span class="p">(</span><span class="nx">fn</span><span class="o">:</span> <span class="nx">any</span><span class="p">)</span><span class="o">:</span> <span class="nx">fn</span> <span class="nx">is</span> <span class="nx">ReactiveEffect</span> <span class="p">=&gt;</span> <span class="nx">fn</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">_isEffect</span> <span class="o">===</span> <span class="kc">true</span>  <span class="c1">// 判断是否为 effect
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">cleanup</span><span class="p">(</span><span class="nx">effect</span><span class="o">:</span> <span class="nx">ReactiveEffect</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 清空 effect 里面的依赖项
</span><span class="c1"></span>  <span class="kr">const</span> <span class="p">{</span> <span class="nx">deps</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">effect</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">deps</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">deps</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">deps</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="k">delete</span><span class="p">(</span><span class="nx">effect</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">deps</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="kd">function</span> <span class="nx">effect</span><span class="o">&lt;</span><span class="nx">T</span> <span class="o">=</span> <span class="nx">any</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">fn</span><span class="o">:</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">T</span><span class="p">,</span> <span class="nx">options</span><span class="o">:</span> <span class="nx">ReactiveEffectOptions</span> <span class="o">=</span> <span class="nx">EMPTY_OBJ</span><span class="p">)</span><span class="o">:</span> <span class="nx">ReactiveEffect</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">isEffect</span><span class="p">(</span><span class="nx">fn</span><span class="p">))</span> <span class="p">{</span>  <span class="c1">// 如果是 effect 函数，则使用它的原始函数
</span><span class="c1"></span>    <span class="nx">fn</span> <span class="o">=</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">raw</span>
  <span class="p">}</span>
  <span class="kr">const</span> <span class="nx">effect</span> <span class="o">=</span> <span class="nx">createReactiveEffect</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="nx">options</span><span class="p">)</span>  <span class="c1">// 创建监听函数
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">options</span><span class="p">.</span><span class="nx">lazy</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 如果没有延迟执行的标志，先执行一次 effect 函数
</span><span class="c1"></span>    <span class="nx">effect</span><span class="p">()</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">effect</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="kd">function</span> <span class="nx">stop</span><span class="p">(</span><span class="nx">effect</span><span class="o">:</span> <span class="nx">ReactiveEffect</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">effect</span><span class="p">.</span><span class="nx">active</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 如果 effect 处于激活状态
</span><span class="c1"></span>    <span class="nx">cleanup</span><span class="p">(</span><span class="nx">effect</span><span class="p">)</span>  <span class="c1">// 清空该监听函数的所有依赖
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">effect</span><span class="p">.</span><span class="nx">options</span><span class="p">.</span><span class="nx">onStop</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">effect</span><span class="p">.</span><span class="nx">options</span><span class="p">.</span><span class="nx">onStop</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="nx">effect</span><span class="p">.</span><span class="nx">active</span> <span class="o">=</span> <span class="kc">false</span>  <span class="c1">// 关闭激活开关
</span><span class="c1"></span>  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Here you have seen the role of several properties in the previous <code>effect</code> configuration item, and then you have to see how to create the listener function.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">effectStack</span><span class="o">:</span> <span class="nx">ReactiveEffect</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1">// 存放所有监听函数
</span><span class="c1"></span><span class="kr">export</span> <span class="kd">let</span> <span class="nx">activeEffect</span><span class="o">:</span> <span class="nx">ReactiveEffect</span> <span class="o">|</span> <span class="kc">undefined</span>

<span class="kd">function</span> <span class="nx">createReactiveEffect</span><span class="o">&lt;</span><span class="nx">T</span> <span class="o">=</span> <span class="nx">any</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">fn</span><span class="o">:</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">T</span><span class="p">,</span> <span class="nx">options</span><span class="o">:</span> <span class="nx">ReactiveEffectOptions</span><span class="p">)</span><span class="o">:</span> <span class="nx">ReactiveEffect</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">effect</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">reactiveEffect</span><span class="p">(...</span><span class="nx">args</span><span class="o">:</span> <span class="nx">unknown</span><span class="p">[])</span><span class="o">:</span> <span class="nx">unknown</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">run</span><span class="p">(</span><span class="nx">effect</span><span class="p">,</span> <span class="nx">fn</span><span class="p">,</span> <span class="nx">args</span><span class="p">)</span>
  <span class="p">}</span> <span class="nx">as</span> <span class="nx">ReactiveEffect</span>
  <span class="nx">effect</span><span class="p">.</span><span class="nx">_isEffect</span> <span class="o">=</span> <span class="kc">true</span>
  <span class="nx">effect</span><span class="p">.</span><span class="nx">active</span> <span class="o">=</span> <span class="kc">true</span>
  <span class="nx">effect</span><span class="p">.</span><span class="nx">raw</span> <span class="o">=</span> <span class="nx">fn</span>
  <span class="nx">effect</span><span class="p">.</span><span class="nx">deps</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="nx">effect</span><span class="p">.</span><span class="nx">options</span> <span class="o">=</span> <span class="nx">options</span>
  <span class="k">return</span> <span class="nx">effect</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">run</span><span class="p">(</span><span class="nx">effect</span><span class="o">:</span> <span class="nx">ReactiveEffect</span><span class="p">,</span> <span class="nx">fn</span><span class="o">:</span> <span class="nb">Function</span><span class="p">,</span> <span class="nx">args</span><span class="o">:</span> <span class="nx">unknown</span><span class="p">[])</span><span class="o">:</span> <span class="nx">unknown</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">effect</span><span class="p">.</span><span class="nx">active</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 如果激活开关被关，执行原始函数
</span><span class="c1"></span>    <span class="k">return</span> <span class="nx">fn</span><span class="p">(...</span><span class="nx">args</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">effectStack</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="nx">effect</span><span class="p">))</span> <span class="p">{</span>  <span class="c1">// 如果 effectStack 里没有该监听函数，则收集依赖
</span><span class="c1"></span>    <span class="nx">cleanup</span><span class="p">(</span><span class="nx">effect</span><span class="p">)</span>  <span class="c1">// 清空该 effect 的依赖项
</span><span class="c1"></span>    <span class="k">try</span> <span class="p">{</span>
      <span class="nx">effectStack</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">effect</span><span class="p">)</span>
      <span class="nx">activeEffect</span> <span class="o">=</span> <span class="nx">effect</span>  <span class="c1">// 将 effect 保存到缓存区
</span><span class="c1"></span>      <span class="k">return</span> <span class="nx">fn</span><span class="p">(...</span><span class="nx">args</span><span class="p">)</span>  <span class="c1">// 执行原始函数
</span><span class="c1"></span>    <span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
      <span class="nx">effectStack</span><span class="p">.</span><span class="nx">pop</span><span class="p">()</span>  <span class="c1">// 执行完函数后，将 effect 从全局监听函数的栈中移除
</span><span class="c1"></span>      <span class="nx">activeEffect</span> <span class="o">=</span> <span class="nx">effectStack</span><span class="p">[</span><span class="nx">effectStack</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>If the <code>effect</code> is active, it will be put in the global <code>effectStack</code>, and if the value of the responsive data is changed or accessed during the execution of the original function, it will be triggered and collected by <code>trigger</code> and <code>track</code>.</p>
<p>There is a question here, every time the <code>effect</code> function is executed, it is first pushed into the <code>effectStack</code> and then popped after execution, so under what circumstances does <code>effectStack.includes(effect) === true</code>?
From this <a href="https://github.com/vuejs/vue-next/blob/77103e1fd7a51dff06f6c8fc63d2451a4be0351a/packages/reactivity/__tests__/effect.spec.ts#L355">single test</a>, we know that it happens when there is a cyclic dependency on the execution function of <code>effect</code>, so we need to make sure that the dependency collection and triggering still works when there is a cyclic dependency.</p>
<p>Let&rsquo;s take a look at how the <code>trigger</code> and <code>track</code> functions are implemented.</p>
<h3 id="track">Track</h3>
<p><code>track</code> is the dependency collection function.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">type</span> <span class="nx">Dep</span> <span class="o">=</span> <span class="nx">Set</span><span class="o">&lt;</span><span class="nx">ReactiveEffect</span><span class="o">&gt;</span>  <span class="c1">// 依赖集合
</span><span class="c1"></span><span class="nx">type</span> <span class="nx">KeyToDepMap</span> <span class="o">=</span> <span class="nx">Map</span><span class="o">&lt;</span><span class="nx">any</span><span class="p">,</span> <span class="nx">Dep</span><span class="o">&gt;</span>  <span class="c1">// 原始数据的属性映射的依赖集合
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">targetMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WeakMap</span><span class="o">&lt;</span><span class="nx">any</span><span class="p">,</span> <span class="nx">KeyToDepMap</span><span class="o">&gt;</span><span class="p">()</span>  <span class="c1">// 原始数据映射的依赖集合
</span><span class="c1"></span>
<span class="kd">let</span> <span class="nx">shouldTrack</span> <span class="o">=</span> <span class="kc">true</span>  <span class="c1">// 标志是否收集
</span><span class="c1"></span><span class="kr">export</span> <span class="kd">function</span> <span class="nx">pauseTracking</span><span class="p">()</span> <span class="p">{</span>  <span class="c1">// 暂停收集
</span><span class="c1"></span>  <span class="nx">shouldTrack</span> <span class="o">=</span> <span class="kc">false</span>
<span class="p">}</span>
<span class="kr">export</span> <span class="kd">function</span> <span class="nx">resumeTracking</span><span class="p">()</span> <span class="p">{</span>  <span class="c1">// 恢复收集
</span><span class="c1"></span>  <span class="nx">shouldTrack</span> <span class="o">=</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="kd">function</span> <span class="nx">track</span><span class="p">(</span><span class="nx">target</span><span class="o">:</span> <span class="nx">object</span><span class="p">,</span> <span class="nx">type</span><span class="o">:</span> <span class="nx">TrackOpTypes</span><span class="p">,</span> <span class="nx">key</span><span class="o">:</span> <span class="nx">unknown</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">shouldTrack</span> <span class="o">||</span> <span class="nx">activeEffect</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span>  <span class="c1">// 如果是暂停收集或是未激活状态直接返回
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="kd">let</span> <span class="nx">depsMap</span> <span class="o">=</span> <span class="nx">targetMap</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">target</span><span class="p">)</span>  <span class="c1">// 获取原始数据的依赖集合
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nx">depsMap</span> <span class="o">===</span> <span class="k">void</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 若该原始数据没有对应的依赖集合，则设置一个空的 Map
</span><span class="c1"></span>    <span class="nx">targetMap</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="p">(</span><span class="nx">depsMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">()))</span>
  <span class="p">}</span>
  <span class="kd">let</span> <span class="nx">dep</span> <span class="o">=</span> <span class="nx">depsMap</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>  <span class="c1">// 获取原始对象指定 key 的依赖集合
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nx">dep</span> <span class="o">===</span> <span class="k">void</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 若该 key 没有对应的依赖集合，则设置一个空的 Set
</span><span class="c1"></span>    <span class="nx">depsMap</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="p">(</span><span class="nx">dep</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">()))</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">dep</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">activeEffect</span><span class="p">))</span> <span class="p">{</span>  <span class="c1">// 若依赖集里没有执行原始函数前保存在缓存区的 effect
</span><span class="c1"></span>    <span class="nx">dep</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">activeEffect</span><span class="p">)</span>  <span class="c1">// 添加这个依赖
</span><span class="c1"></span>    <span class="nx">activeEffect</span><span class="p">.</span><span class="nx">deps</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">dep</span><span class="p">)</span>  <span class="c1">// 缓存区里的 effect 同样在内部存储该依赖集
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">__DEV__</span> <span class="o">&amp;&amp;</span> <span class="nx">activeEffect</span><span class="p">.</span><span class="nx">options</span><span class="p">.</span><span class="nx">onTrack</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 开发环境触发钩子函数
</span><span class="c1"></span>      <span class="nx">activeEffect</span><span class="p">.</span><span class="nx">options</span><span class="p">.</span><span class="nx">onTrack</span><span class="p">({</span>
        <span class="nx">effect</span><span class="o">:</span> <span class="nx">activeEffect</span><span class="p">,</span>
        <span class="nx">target</span><span class="p">,</span>
        <span class="nx">type</span><span class="p">,</span>
        <span class="nx">key</span>
      <span class="p">})</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>targetMap</code> is where the dependencies are stored globally, in a three-level nested structure of raw data -&gt; properties -&gt; dependency collections.</p>
<p>Why do we need <code>deps</code> inside each <code>effect</code> to store dependencies when we already have <code>targetMap</code> as the global structure for storing dependencies?
The answer is given in the <code>createReactiveEffect</code> function earlier. Each time the function is executed, when the dependency does not exist in the <code>effectStack</code>, the <code>cleanup</code> function is executed to clear the dependency mapping from the <code>targetMap</code> using the internal <code>deps</code>. The same is true when the <code>stop</code> function is executed.</p>
<p>So here&rsquo;s another question, why do we need to clear our own dependencies before each function execution?
From this <a href="https://github.com/vuejs/vue-next/blob/70dc3e3ae74f08d53243e6f078794c16f359e272/packages/reactivity/__tests__/effect.spec.ts#L443">single test</a> we know that when there is a conditional branch within a function, each execution may cause the dependency data to be different, so we need to collect the dependencies again before each execution.</p>
<h3 id="trigger">Trigger</h3>
<p><code>trigger</code> is the function whose dependency is triggered.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">export</span> <span class="kr">const</span> <span class="nx">ITERATE_KEY</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">(</span><span class="s1">&#39;iterate&#39;</span><span class="p">)</span>

<span class="kr">export</span> <span class="kd">function</span> <span class="nx">trigger</span><span class="p">(</span><span class="nx">target</span><span class="o">:</span> <span class="nx">object</span><span class="p">,</span> <span class="nx">type</span><span class="o">:</span> <span class="nx">TriggerOpTypes</span><span class="p">,</span> <span class="nx">key</span><span class="o">?:</span> <span class="nx">unknown</span><span class="p">,</span> <span class="nx">extraInfo</span><span class="o">?:</span> <span class="nx">DebuggerEventExtraInfo</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">depsMap</span> <span class="o">=</span> <span class="nx">targetMap</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">target</span><span class="p">)</span>  <span class="c1">// 获取原始数据的依赖集合
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nx">depsMap</span> <span class="o">===</span> <span class="k">void</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 如果原始数据没有依赖，则直接返回
</span><span class="c1"></span>    <span class="k">return</span>
  <span class="p">}</span>
  <span class="kr">const</span> <span class="nx">effects</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="o">&lt;</span><span class="nx">ReactiveEffect</span><span class="o">&gt;</span><span class="p">()</span>  <span class="c1">// 普通 effect 需要执行的依赖队列
</span><span class="c1"></span>  <span class="kr">const</span> <span class="nx">computedRunners</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="o">&lt;</span><span class="nx">ReactiveEffect</span><span class="o">&gt;</span><span class="p">()</span>  <span class="c1">// computed 类型的 effect 需要执行的依赖队列
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nx">type</span> <span class="o">===</span> <span class="nx">TriggerOpTypes</span><span class="p">.</span><span class="nx">CLEAR</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// collectionHandlers 里的 clear 函数
</span><span class="c1"></span>    <span class="nx">depsMap</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">dep</span> <span class="p">=&gt;</span> <span class="p">{</span>  <span class="c1">// clear 函数会将原始数据里的 key 清除，因此需要将内部所有 key 的依赖收集依赖队列里
</span><span class="c1"></span>      <span class="nx">addRunners</span><span class="p">(</span><span class="nx">effects</span><span class="p">,</span> <span class="nx">computedRunners</span><span class="p">,</span> <span class="nx">dep</span><span class="p">)</span>
    <span class="p">})</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">key</span> <span class="o">!==</span> <span class="k">void</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// type 为 SET | ADD | DELETE 
</span><span class="c1"></span>      <span class="nx">addRunners</span><span class="p">(</span><span class="nx">effects</span><span class="p">,</span> <span class="nx">computedRunners</span><span class="p">,</span> <span class="nx">depsMap</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">key</span><span class="p">))</span>  <span class="c1">// 将该 key 的依赖收集到依赖队列里
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="c1">// 如果是 Add 或 DELETE 类型，会改变数据的数量，需要新增数组长度或迭代器的监听方法
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">type</span> <span class="o">===</span> <span class="nx">TriggerOpTypes</span><span class="p">.</span><span class="nx">ADD</span> <span class="o">||</span> <span class="nx">type</span> <span class="o">===</span> <span class="nx">TriggerOpTypes</span><span class="p">.</span><span class="nx">DELETE</span><span class="p">)</span> <span class="p">{</span>
      <span class="kr">const</span> <span class="nx">iterationKey</span> <span class="o">=</span> <span class="nx">isArray</span><span class="p">(</span><span class="nx">target</span><span class="p">)</span> <span class="o">?</span> <span class="s1">&#39;length&#39;</span> <span class="o">:</span> <span class="nx">ITERATE_KEY</span>
      <span class="nx">addRunners</span><span class="p">(</span><span class="nx">effects</span><span class="p">,</span> <span class="nx">computedRunners</span><span class="p">,</span> <span class="nx">depsMap</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">iterationKey</span><span class="p">))</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="kr">const</span> <span class="nx">run</span> <span class="o">=</span> <span class="p">(</span><span class="nx">effect</span><span class="o">:</span> <span class="nx">ReactiveEffect</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">scheduleRun</span><span class="p">(</span><span class="nx">effect</span><span class="p">,</span> <span class="nx">target</span><span class="p">,</span> <span class="nx">type</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">extraInfo</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">computedRunners</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">run</span><span class="p">)</span>  <span class="c1">// 执行所有 computed 类型的依赖队列中的方法
</span><span class="c1"></span>  <span class="nx">effects</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">run</span><span class="p">)</span>  <span class="c1">// 执行所有普通类型的依赖队列中的方法
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">function</span> <span class="nx">addRunners</span><span class="p">(</span><span class="nx">effects</span><span class="o">:</span> <span class="nx">Set</span><span class="o">&lt;</span><span class="nx">ReactiveEffect</span><span class="o">&gt;</span><span class="p">,</span> <span class="nx">computedRunners</span><span class="o">:</span> <span class="nx">Set</span><span class="o">&lt;</span><span class="nx">ReactiveEffect</span><span class="o">&gt;</span><span class="p">,</span> <span class="nx">effectsToAdd</span><span class="o">:</span> <span class="nx">Set</span><span class="o">&lt;</span><span class="nx">ReactiveEffect</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">effectsToAdd</span> <span class="o">!==</span> <span class="k">void</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 如果要放入队列里的依赖不为空
</span><span class="c1"></span>    <span class="nx">effectsToAdd</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">effect</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">effect</span><span class="p">.</span><span class="nx">options</span><span class="p">.</span><span class="nx">computed</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 如果是 computed 类型，放到 computedRunners 中
</span><span class="c1"></span>        <span class="nx">computedRunners</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">effect</span><span class="p">)</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>  <span class="c1">// 如果是正常类型，放到 effects 中
</span><span class="c1"></span>        <span class="nx">effects</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">effect</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">})</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">scheduleRun</span><span class="p">(</span><span class="nx">effect</span><span class="o">:</span> <span class="nx">ReactiveEffect</span><span class="p">,</span> <span class="nx">target</span><span class="o">:</span> <span class="nx">object</span><span class="p">,</span> <span class="nx">type</span><span class="o">:</span> <span class="nx">TriggerOpTypes</span><span class="p">,</span> <span class="nx">key</span><span class="o">:</span> <span class="nx">unknown</span><span class="p">,</span> <span class="nx">extraInfo</span><span class="o">?:</span> <span class="nx">DebuggerEventExtraInfo</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">__DEV__</span> <span class="o">&amp;&amp;</span> <span class="nx">effect</span><span class="p">.</span><span class="nx">options</span><span class="p">.</span><span class="nx">onTrigger</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 开发环境触发对应钩子函数
</span><span class="c1"></span>    <span class="kr">const</span> <span class="nx">event</span><span class="o">:</span> <span class="nx">DebuggerEvent</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">effect</span><span class="p">,</span> <span class="nx">target</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">type</span> <span class="p">}</span>
    <span class="nx">effect</span><span class="p">.</span><span class="nx">options</span><span class="p">.</span><span class="nx">onTrigger</span><span class="p">(</span><span class="nx">extraInfo</span> <span class="o">?</span> <span class="nx">extend</span><span class="p">(</span><span class="nx">event</span><span class="p">,</span> <span class="nx">extraInfo</span><span class="p">)</span> <span class="o">:</span> <span class="nx">event</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">effect</span><span class="p">.</span><span class="nx">options</span><span class="p">.</span><span class="nx">scheduler</span> <span class="o">!==</span> <span class="k">void</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 如果有自定义的依赖执行函数，传入依赖执行该方法
</span><span class="c1"></span>    <span class="nx">effect</span><span class="p">.</span><span class="nx">options</span><span class="p">.</span><span class="nx">scheduler</span><span class="p">(</span><span class="nx">effect</span><span class="p">)</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>  <span class="c1">// 否则直接执行依赖函数
</span><span class="c1"></span>    <span class="nx">effect</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>trigger</code> is a process that executes dependencies by maintaining a queue of <code>effects</code> and <code>computedRunners</code> when responsive data changes, and then calling <code>scheduleRun</code> afterwards.</p>
<h3 id="effect-summary">Effect Summary</h3>
<p><code>effect</code> describes how to collect dependencies, manage dependencies and trigger dependencies.
Each time a listener is executed, it is placed in the <code>effectStack</code> queue, cached as <code>activeEffect</code>, popped out of the <code>effectStack</code> queue when execution is complete, and the <code>activeEffect</code> value is changed to the last listener in the <code>effectStack</code> queue. The listener function is put into the dependency of the accessed responsive data by the <code>track</code> function when it is executed for the first time and is saved in the <code>targetMap</code> collection. When the responsive data is modified, it is triggered by the <code>trigger</code> function, and the corresponding dependencies are taken out of the <code>targetMap</code> and put into the <code>computedRunners</code> and <code>effects</code> dependency execution queues according to the listener&rsquo;s category. After that, the listeners in the <code>computedRunners</code> and <code>effects</code> queues are executed in this order.</p>
<h2 id="computed">Computed</h2>
<p>Let&rsquo;s start with a few instrumental functions and type declarations</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">export</span> <span class="kr">const</span> <span class="nx">isFunction</span> <span class="o">=</span> <span class="p">(</span><span class="nx">val</span><span class="o">:</span> <span class="nx">unknown</span><span class="p">)</span><span class="o">:</span> <span class="nx">val</span> <span class="nx">is</span> <span class="nb">Function</span> <span class="p">=&gt;</span> <span class="k">typeof</span> <span class="nx">val</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span>  <span class="c1">// 判断是否为函数
</span><span class="c1"></span><span class="kr">export</span> <span class="kr">const</span> <span class="nx">NOOP</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{}</span>

<span class="kr">export</span> <span class="kr">interface</span> <span class="nx">ComputedRef</span><span class="o">&lt;</span><span class="nx">T</span> <span class="o">=</span> <span class="nx">any</span><span class="o">&gt;</span> <span class="kr">extends</span> <span class="nx">WritableComputedRef</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="nx">readonly</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">UnwrapRef</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="kr">interface</span> <span class="nx">WritableComputedRef</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="kr">extends</span> <span class="nx">Ref</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="nx">readonly</span> <span class="nx">effect</span><span class="o">:</span> <span class="nx">ReactiveEffect</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span>
<span class="p">}</span>

<span class="kr">export</span> <span class="nx">type</span> <span class="nx">ComputedGetter</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">T</span>
<span class="kr">export</span> <span class="nx">type</span> <span class="nx">ComputedSetter</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">(</span><span class="nx">v</span><span class="o">:</span> <span class="nx">T</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="k">void</span>

<span class="kr">export</span> <span class="kr">interface</span> <span class="nx">WritableComputedOptions</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="nx">get</span><span class="o">:</span> <span class="nx">ComputedGetter</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span>
  <span class="nx">set</span><span class="o">:</span> <span class="nx">ComputedSetter</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>As you can see from the type declaration <code>ComputedRef</code> is a read-only <code>Ref</code> that has <code>effect</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">export</span> <span class="kd">function</span> <span class="nx">computed</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">getterOrOptions</span><span class="o">:</span> <span class="nx">ComputedGetter</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">|</span> <span class="nx">WritableComputedOptions</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">getter</span><span class="o">:</span> <span class="nx">ComputedGetter</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span>
  <span class="kd">let</span> <span class="nx">setter</span><span class="o">:</span> <span class="nx">ComputedSetter</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">isFunction</span><span class="p">(</span><span class="nx">getterOrOptions</span><span class="p">))</span> <span class="p">{</span>  <span class="c1">// 如果传入的参数是函数，那么就直接赋值给 getter
</span><span class="c1"></span>    <span class="nx">getter</span> <span class="o">=</span> <span class="nx">getterOrOptions</span>
    <span class="nx">setter</span> <span class="o">=</span> <span class="nx">__DEV__</span>
      <span class="o">?</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">warn</span><span class="p">(</span><span class="s1">&#39;Write operation failed: computed value is readonly&#39;</span><span class="p">)</span> <span class="p">}</span>
      <span class="o">:</span> <span class="nx">NOOP</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>  <span class="c1">// 尽管 computed 是只读的，但是若传入了 get 和 set 的配置函数，也是可以手动改变其数据
</span><span class="c1"></span>    <span class="nx">getter</span> <span class="o">=</span> <span class="nx">getterOrOptions</span><span class="p">.</span><span class="nx">get</span>
    <span class="nx">setter</span> <span class="o">=</span> <span class="nx">getterOrOptions</span><span class="p">.</span><span class="nx">set</span>
  <span class="p">}</span>

  <span class="kd">let</span> <span class="nx">dirty</span> <span class="o">=</span> <span class="kc">true</span>  <span class="c1">// 是否应该收集依赖的标志
</span><span class="c1"></span>  <span class="kd">let</span> <span class="nx">value</span><span class="o">:</span> <span class="nx">T</span>
  <span class="kd">let</span> <span class="nx">computed</span><span class="o">:</span> <span class="nx">ComputedRef</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span>

  <span class="kr">const</span> <span class="nx">runner</span> <span class="o">=</span> <span class="nx">effect</span><span class="p">(</span><span class="nx">getter</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">lazy</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>  <span class="c1">// 延迟执行，初始化时不执行传入的函数
</span><span class="c1"></span>    <span class="nx">computed</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="nx">scheduler</span><span class="o">:</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">dirty</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 只有有效访问计算属性才触发依赖
</span><span class="c1"></span>        <span class="nx">dirty</span> <span class="o">=</span> <span class="kc">true</span>
        <span class="nx">trigger</span><span class="p">(</span><span class="nx">computed</span><span class="p">,</span> <span class="nx">TriggerOpTypes</span><span class="p">.</span><span class="nx">SET</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">})</span>
  <span class="nx">computed</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">_isRef</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="nx">effect</span><span class="o">:</span> <span class="nx">runner</span><span class="p">,</span>
    <span class="nx">get</span> <span class="nx">value</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">dirty</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 多次同时访问计算属性只有第一次会触发依赖
</span><span class="c1"></span>        <span class="nx">value</span> <span class="o">=</span> <span class="nx">runner</span><span class="p">()</span>
        <span class="nx">dirty</span> <span class="o">=</span> <span class="kc">false</span>
      <span class="p">}</span>
      <span class="nx">track</span><span class="p">(</span><span class="nx">computed</span><span class="p">,</span> <span class="nx">TrackOpTypes</span><span class="p">.</span><span class="nx">GET</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">)</span>
      <span class="k">return</span> <span class="nx">value</span>
    <span class="p">},</span>
    <span class="nx">set</span> <span class="nx">value</span><span class="p">(</span><span class="nx">newValue</span><span class="o">:</span> <span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">setter</span><span class="p">(</span><span class="nx">newValue</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="nx">as</span> <span class="nx">any</span>
  <span class="k">return</span> <span class="nx">computed</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>As you can see from the source code, the value that goes into <code>computedRef</code> is read-only, but we can also manually change the value of the computed property after passing in custom set and get functions using <code>computed</code>. (This is consistent with vue2.0, which also provides a custom set method to change the computed property)</p>
<p>By using the dirty flag in the source code, we can avoid the problem of repeatedly triggering dependencies on computed properties. This is because the getter function of <code>computed</code> is triggered when a computed property and a computed property that depends on it are accessed at the same time, which would lead to multiple executions of <code>trigger</code> if the dirty flag bit did not exist. You can see this <a href="https://github.com/vuejs/vue-next/blob/70dc3e3ae74f08d53243e6f078794c16f359e272/packages/reactivity/__tests__/computed.spec.ts#L96">single test</a>.</p>
<h2 id="summary">Summary</h2>
<p>The reason we didn&rsquo;t explain the <code>watch</code> API here is that it is actually part of the runtime code (<code>packages/runtime-core/src/apiWatch.ts</code>), but it is actually underpinned by <code>effect</code>, so we can get an idea of what <code>watch</code> does and how it works. Of course, those who want to understand the <code>watch</code> API thoroughly are advised to look at the runtime code, which is still more extended than <code>effect</code>.</p>
<p>After reading through the article, you can go back to the schematic above to get a deeper understanding.</p>
<p>In fact, the whole process of reading the source code was not easy and took a lot of effort. This includes a lot of advanced usage of TS, figuring out the author&rsquo;s intention, and so on. At the same time, I also read some excellent source code analysis articles on the Internet, and sometimes when I can&rsquo;t understand a certain piece of logic, I can see other people&rsquo;s analysis and ideas and immediately be enlightened. Of course, there will be a lot of wrong interpretation, you have to determine their own context with the code.</p>
<p>Read the source code also has a lot of skills, the first is to understand the author&rsquo;s comments, and then to make reasonable use of the single test, such as a piece of logic commented out, run a single test to see which sample hung, you can go to &ldquo;guess&rdquo; the role of the commented out logic. Vue&rsquo;s projects have always had good commit specifications, making the code highly readable, which is great. I have also promoted Angular&rsquo;s commit specification - <a href="https://github.com/commitizen/cz-cli">commitizen</a> in my team before. If a commit is merged in through a PR, you can also go to the repository and look through the PR, where the author of the PR will clearly state what the PR does.</p>
<p>Vue3.0 is rewritten using TypeScript, replacing <code>Object.defineProperty</code> with <code>Proxy</code> for data detection, improving responsive performance and allowing users to manipulate data more freely. At the same time, the Virtual DOM is refactored to adopt the idea of &ldquo;combining motion and static&rdquo;, which greatly improves the update performance of vdom.</p>
<p>A few months have passed since I started reading the source code to finish this article, and Vue3 has entered the subsequent optimization and finishing work. I am very happy to finally finish this article, of course, there is a lot of content belongs to the author&rsquo;s speculation, if you have questions about any of the code analysis of this module in the statement or have a correction, you are very welcome to contact me, I will correct as soon as possible!</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/vue/">vue</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-02/cpp-pointers-references/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">The underlying implementation of pointers and references in C&#43;&#43;</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-02/bsd-linux/">
            <span class="next-text nav-default">Does anyone remember the ideal and proud BSD before Linux?</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
