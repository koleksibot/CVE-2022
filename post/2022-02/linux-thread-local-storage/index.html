<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Linux Thread Local Storage - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="In C/C&#43;&#43; programs, global variables are shared by all threads by default, and developers need to deal with multi-threaded competition. There are cases where we need to make sure that one thread has an exclusive share of the data and that other threads cannot access it. A typical case is the errno global variable, which always stores the error code of the last call of the current thread, without thread" /><meta name="keywords" content="Linux, Thread Local Storage" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-02/linux-thread-local-storage/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Linux Thread Local Storage" />
<meta property="og:description" content="In C/C&#43;&#43; programs, global variables are shared by all threads by default, and developers need to deal with multi-threaded competition. There are cases where we need to make sure that one thread has an exclusive share of the data and that other threads cannot access it. A typical case is the errno global variable, which always stores the error code of the last call of the current thread, without thread" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-02/linux-thread-local-storage/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-02-11T10:55:15+08:00" />
<meta property="article:modified_time" content="2022-02-11T10:55:15+08:00" />

<meta itemprop="name" content="Linux Thread Local Storage">
<meta itemprop="description" content="In C/C&#43;&#43; programs, global variables are shared by all threads by default, and developers need to deal with multi-threaded competition. There are cases where we need to make sure that one thread has an exclusive share of the data and that other threads cannot access it. A typical case is the errno global variable, which always stores the error code of the last call of the current thread, without thread"><meta itemprop="datePublished" content="2022-02-11T10:55:15+08:00" />
<meta itemprop="dateModified" content="2022-02-11T10:55:15+08:00" />
<meta itemprop="wordCount" content="2580">
<meta itemprop="keywords" content="linux," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Linux Thread Local Storage"/>
<meta name="twitter:description" content="In C/C&#43;&#43; programs, global variables are shared by all threads by default, and developers need to deal with multi-threaded competition. There are cases where we need to make sure that one thread has an exclusive share of the data and that other threads cannot access it. A typical case is the errno global variable, which always stores the error code of the last call of the current thread, without thread"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Linux Thread Local Storage</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-02-11 10:55:15 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 2580 words </span>
          <span class="more-meta"> 6 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li>
          <ul>
            <li><a href="#pthreads-memory-structure">pthread&rsquo;s memory structure</a></li>
            <li><a href="#__thread"><code>__thread</code></a></li>
            <li><a href="#pthread-specific-api">pthread specific API</a></li>
            <li><a href="#__thread-and-pthread-specific-api-comparison"><code>__thread</code> and pthread specific API comparison</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>In C/C++ programs, global variables are shared by all threads by default, and developers need to deal with multi-threaded competition. There are cases where we need to make sure that one thread has an exclusive share of the data and that other threads cannot access it. A typical case is the errno global variable, which always stores the error code of the last call of the current thread, without thread conflicts. This time you need to use thread-local storage (TLS) to solve it.</p>
<h3 id="pthreads-memory-structure">pthread&rsquo;s memory structure</h3>
<p>Before describing TLS, let&rsquo;s understand the memory structure of pthread. glibc/nptl/descr.h defines an important data structure for threads, <code>struct pthread</code>, which describes the complete information of user state threads. The pthread structure is very complex and is related to the TLS by the specific_1stblock array and the specific secondary array, which will be described later.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#define PTHREAD_KEY_2NDLEVEL_SIZE       32
</span><span class="cp">#define PTHREAD_KEY_1STLEVEL_SIZE \
</span><span class="cp">  ((PTHREAD_KEYS_MAX + PTHREAD_KEY_2NDLEVEL_SIZE - 1) \
</span><span class="cp">   / PTHREAD_KEY_2NDLEVEL_SIZE)
</span><span class="cp"></span>
<span class="k">struct</span> <span class="n">pthread</span>
<span class="p">{</span>
    <span class="k">union</span>
  <span class="p">{</span>
<span class="cp">#if !TLS_DTV_AT_TP
</span><span class="cp"></span>    <span class="cm">/* This overlaps the TCB as used for TLS without threads (see tls.h).  */</span>
    <span class="n">tcbhead_t</span> <span class="n">header</span><span class="p">;</span>
<span class="cp">#else
</span><span class="cp"></span>    <span class="k">struct</span>
    <span class="p">{</span>
      <span class="kt">int</span> <span class="n">multiple_threads</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">gscope_flag</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">header</span><span class="p">;</span>
<span class="cp">#endif
</span><span class="cp"></span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">__padding</span><span class="p">[</span><span class="mi">24</span><span class="p">];</span>
  <span class="p">};</span>

  <span class="n">list_t</span> <span class="n">list</span><span class="p">;</span>
  <span class="n">pid_t</span> <span class="n">tid</span><span class="p">;</span>

  <span class="p">...</span>
  <span class="k">struct</span> <span class="n">pthread_key_data</span>
  <span class="p">{</span>
    <span class="cm">/* Sequence number.  We use uintptr_t to not require padding on
</span><span class="cm">       32- and 64-bit machines.  On 64-bit machines it helps to avoid
</span><span class="cm">       wrapping, too.  */</span>
    <span class="n">uintptr_t</span> <span class="n">seq</span><span class="p">;</span>

    <span class="cm">/* Data pointer.  */</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
  <span class="p">}</span> <span class="n">specific_1stblock</span><span class="p">[</span><span class="n">PTHREAD_KEY_2NDLEVEL_SIZE</span><span class="p">];</span>

  <span class="cm">/* Two-level array for the thread-specific data.  */</span>
  <span class="k">struct</span> <span class="n">pthread_key_data</span> <span class="o">*</span><span class="n">specific</span><span class="p">[</span><span class="n">PTHREAD_KEY_1STLEVEL_SIZE</span><span class="p">];</span>

  <span class="cm">/* Flag which is set when specific data is set.  */</span>
  <span class="kt">bool</span> <span class="n">specific_used</span><span class="p">;</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="__thread"><code>__thread</code></h3>
<p>The <code>__thread</code> keyword can be used to declare TLS variables in the GCC/Clang compilation environment. The <code>__thread</code> keyword is not C-standard and has different names from compiler to compiler.</p>
<p>Tested on Xcode 13.2 only i386 architecture does not support <code>__thread</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#if defined(__i386__)
</span><span class="cp"></span><span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">g_thread_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#else
</span><span class="cp"></span><span class="k">static</span> <span class="n">__thread</span> <span class="kt">char</span> <span class="o">*</span><span class="n">g_thread_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif
</span></code></pre></td></tr></table>
</div>
</div><p>Variables declared with the <code>__thread</code> keyword are stored in the memory area between the stack space, after the pthred structure. That is, in terms of memory layout, the memory distribution from the high address to the bottom address is: the pthred structure, the <code>__thread</code> variable area, and the stack area (the bottom of the stack and the top of the <code>__thread</code> variable area are contiguous).</p>
<p>This is illustrated below with a program running on Xcode 13.2/arm64.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">__thread</span> <span class="kt">uint64_t</span> <span class="n">g_tls_int</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
<span class="n">__thread</span> <span class="kt">char</span> <span class="o">*</span><span class="n">g_tls_string</span> <span class="o">=</span> <span class="s">&#34;easeapi.com&#34;</span><span class="p">;;</span>

<span class="kt">void</span> <span class="nf">tls_test</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">value</span> <span class="o">=</span> <span class="n">g_tls_int</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%llu&#34;</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">string</span> <span class="o">=</span> <span class="n">g_tls_string</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%s&#34;</span><span class="p">,</span> <span class="n">string</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Breakpoint at the tls_test entry and view the corresponding assembly program as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm">    <span class="err">0</span><span class="nf">x104235240</span> <span class="err">&lt;+</span><span class="mi">0</span><span class="err">&gt;</span><span class="p">:</span>   <span class="no">sub</span>    <span class="no">sp</span><span class="p">,</span> <span class="no">sp</span><span class="p">,</span> <span class="c">#0x40             ; =0x40 
</span><span class="c"></span>    <span class="mi">0x104235244</span> <span class="err">&lt;+</span><span class="mi">4</span><span class="err">&gt;</span><span class="p">:</span>   <span class="no">stp</span>    <span class="no">x29</span><span class="p">,</span> <span class="no">x30</span><span class="p">,</span> <span class="p">[</span><span class="no">sp</span><span class="p">,</span> <span class="c">#0x30]
</span><span class="c"></span>    <span class="mi">0x104235248</span> <span class="err">&lt;+</span><span class="mi">8</span><span class="err">&gt;</span><span class="p">:</span>   <span class="no">add</span>    <span class="no">x29</span><span class="p">,</span> <span class="no">sp</span><span class="p">,</span> <span class="c">#0x30            ; =0x30 
</span><span class="c"></span>    <span class="mi">0x10423524c</span> <span class="err">&lt;+</span><span class="mi">12</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">adrp</span>   <span class="no">x0</span><span class="p">,</span> <span class="mi">529</span>
    <span class="err">0</span><span class="nf">x104235250</span> <span class="err">&lt;+</span><span class="mi">16</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">add</span>    <span class="no">x0</span><span class="p">,</span> <span class="no">x0</span><span class="p">,</span> <span class="c">#0xd70            ; =0xd70 
</span><span class="c"></span>    <span class="mi">0x104235254</span> <span class="err">&lt;+</span><span class="mi">20</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">ldr</span>    <span class="no">x8</span><span class="p">,</span> <span class="p">[</span><span class="no">x0</span><span class="p">]</span>
    <span class="err">0</span><span class="nf">x104235258</span> <span class="err">&lt;+</span><span class="mi">24</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">blr</span>    <span class="no">x8</span>
    <span class="err">0</span><span class="nf">x10423525c</span> <span class="err">&lt;+</span><span class="mi">28</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">str</span>    <span class="no">x0</span><span class="p">,</span> <span class="p">[</span><span class="no">sp</span><span class="p">,</span> <span class="c">#0x10]
</span><span class="c"></span>    <span class="mi">0x104235260</span> <span class="err">&lt;+</span><span class="mi">32</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">adrp</span>   <span class="no">x0</span><span class="p">,</span> <span class="mi">529</span>
    <span class="err">0</span><span class="nf">x104235264</span> <span class="err">&lt;+</span><span class="mi">36</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">add</span>    <span class="no">x0</span><span class="p">,</span> <span class="no">x0</span><span class="p">,</span> <span class="c">#0xd88            ; =0xd88 
</span><span class="c"></span>    <span class="mi">0x104235268</span> <span class="err">&lt;+</span><span class="mi">40</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">ldr</span>    <span class="no">x8</span><span class="p">,</span> <span class="p">[</span><span class="no">x0</span><span class="p">]</span>
    <span class="err">0</span><span class="nf">x10423526c</span> <span class="err">&lt;+</span><span class="mi">44</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">blr</span>    <span class="no">x8</span>
    <span class="err">0</span><span class="nf">x104235270</span> <span class="err">&lt;+</span><span class="mi">48</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">mov</span>    <span class="no">x8</span><span class="p">,</span> <span class="no">x0</span>
    <span class="err">0</span><span class="nf">x104235274</span> <span class="err">&lt;+</span><span class="mi">52</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">ldr</span>    <span class="no">x0</span><span class="p">,</span> <span class="p">[</span><span class="no">sp</span><span class="p">,</span> <span class="c">#0x10]
</span><span class="c"></span>    <span class="mi">0x104235278</span> <span class="err">&lt;+</span><span class="mi">56</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">str</span>    <span class="no">x8</span><span class="p">,</span> <span class="p">[</span><span class="no">sp</span><span class="p">,</span> <span class="c">#0x18]
</span><span class="c"></span>    <span class="mi">0x10423527c</span> <span class="err">&lt;+</span><span class="mi">60</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">ldr</span>    <span class="no">x8</span><span class="p">,</span> <span class="p">[</span><span class="no">x0</span><span class="p">]</span>
    <span class="err">0</span><span class="nf">x104235280</span> <span class="err">&lt;+</span><span class="mi">64</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">stur</span>   <span class="no">x8</span><span class="p">,</span> <span class="p">[</span><span class="no">x29</span><span class="p">,</span> <span class="c">#-0x8]
</span><span class="c"></span>    <span class="mi">0x104235284</span> <span class="err">&lt;+</span><span class="mi">68</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">ldur</span>   <span class="no">x8</span><span class="p">,</span> <span class="p">[</span><span class="no">x29</span><span class="p">,</span> <span class="c">#-0x8]
</span><span class="c"></span>    <span class="mi">0x104235288</span> <span class="err">&lt;+</span><span class="mi">72</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">adrp</span>   <span class="no">x0</span><span class="p">,</span> <span class="mi">471</span>
    <span class="err">0</span><span class="nf">x10423528c</span> <span class="err">&lt;+</span><span class="mi">76</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">add</span>    <span class="no">x0</span><span class="p">,</span> <span class="no">x0</span><span class="p">,</span> <span class="c">#0x7fc            ; =0x7fc 
</span><span class="c"></span>    <span class="mi">0x104235290</span> <span class="err">&lt;+</span><span class="mi">80</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">mov</span>    <span class="no">x9</span><span class="p">,</span> <span class="no">sp</span>
    <span class="err">0</span><span class="nf">x104235294</span> <span class="err">&lt;+</span><span class="mi">84</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">str</span>    <span class="no">x8</span><span class="p">,</span> <span class="p">[</span><span class="no">x9</span><span class="p">]</span>
    <span class="err">0</span><span class="nf">x104235298</span> <span class="err">&lt;+</span><span class="mi">88</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">bl</span>     <span class="mi">0x104403be0</span>               <span class="c">; symbol stub for: printf
</span><span class="c"></span>    <span class="mi">0x10423529c</span> <span class="err">&lt;+</span><span class="mi">92</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">ldr</span>    <span class="no">x0</span><span class="p">,</span> <span class="p">[</span><span class="no">sp</span><span class="p">,</span> <span class="c">#0x18]
</span><span class="c"></span>    <span class="mi">0x1042352a0</span> <span class="err">&lt;+</span><span class="mi">96</span><span class="err">&gt;</span><span class="p">:</span>  <span class="no">ldr</span>    <span class="no">x8</span><span class="p">,</span> <span class="p">[</span><span class="no">x0</span><span class="p">]</span>
    <span class="err">0</span><span class="nf">x1042352a4</span> <span class="err">&lt;+</span><span class="mi">100</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">stur</span>   <span class="no">x8</span><span class="p">,</span> <span class="p">[</span><span class="no">x29</span><span class="p">,</span> <span class="c">#-0x10]
</span><span class="c"></span>    <span class="mi">0x1042352a8</span> <span class="err">&lt;+</span><span class="mi">104</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">ldur</span>   <span class="no">x8</span><span class="p">,</span> <span class="p">[</span><span class="no">x29</span><span class="p">,</span> <span class="c">#-0x10]
</span><span class="c"></span>    <span class="mi">0x1042352ac</span> <span class="err">&lt;+</span><span class="mi">108</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">adrp</span>   <span class="no">x0</span><span class="p">,</span> <span class="mi">471</span>
    <span class="err">0</span><span class="nf">x1042352b0</span> <span class="err">&lt;+</span><span class="mi">112</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">add</span>    <span class="no">x0</span><span class="p">,</span> <span class="no">x0</span><span class="p">,</span> <span class="c">#0x801            ; =0x801 
</span><span class="c"></span>    <span class="mi">0x1042352b4</span> <span class="err">&lt;+</span><span class="mi">116</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">mov</span>    <span class="no">x9</span><span class="p">,</span> <span class="no">sp</span>
    <span class="err">0</span><span class="nf">x1042352b8</span> <span class="err">&lt;+</span><span class="mi">120</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">str</span>    <span class="no">x8</span><span class="p">,</span> <span class="p">[</span><span class="no">x9</span><span class="p">]</span>
    <span class="err">0</span><span class="nf">x1042352bc</span> <span class="err">&lt;+</span><span class="mi">124</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">bl</span>     <span class="mi">0x104403be0</span>               <span class="c">; symbol stub for: printf
</span><span class="c"></span>    <span class="mi">0x1042352c0</span> <span class="err">&lt;+</span><span class="mi">128</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">ldp</span>    <span class="no">x29</span><span class="p">,</span> <span class="no">x30</span><span class="p">,</span> <span class="p">[</span><span class="no">sp</span><span class="p">,</span> <span class="c">#0x30]
</span><span class="c"></span>    <span class="mi">0x1042352c4</span> <span class="err">&lt;+</span><span class="mi">132</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">add</span>    <span class="no">sp</span><span class="p">,</span> <span class="no">sp</span><span class="p">,</span> <span class="c">#0x40             ; =0x40 
</span><span class="c"></span>    <span class="mi">0x1042352c8</span> <span class="err">&lt;+</span><span class="mi">136</span><span class="err">&gt;</span><span class="p">:</span> <span class="no">ret</span> 
</code></pre></td></tr></table>
</div>
</div><p>At 0x104235274, the sp register is read at offset 0x10 bytes to x0. The value of the x0 register is read at 0x104235278 (g_tls_int).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="err">(</span><span class="nf">lldb</span><span class="p">)</span> <span class="no">register</span> <span class="no">read</span> <span class="no">x0</span>
      <span class="nf">x0</span> <span class="err">=</span> <span class="mi">0x0000000281cf41a0</span>
<span class="err">(</span><span class="nf">lldb</span><span class="p">)</span> <span class="no">memory</span> <span class="no">read</span><span class="err">/</span><span class="mi">1</span><span class="no">xg</span> <span class="mi">0x0000000281cf41a0</span>
<span class="err">0</span><span class="nl">x281cf41a0:</span> <span class="err">0</span><span class="nf">x0000000000000006</span>
</code></pre></td></tr></table>
</div>
</div><p>At 0x10423529c, sp register offset 0x18 bytes read to x0. Read x0 register value at 0x1042352a0 (g_tls_string).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">(lldb) register read x0
      x0 = 0x0000000281cf41a8
(lldb) memory read/1xg 0x0000000281cf41a8
0x281cf41a8: 0x000000010440c7f0
(lldb) memory read 0x000000010440c7f0
0x10440c7f0: 65 61 73 65 61 70 69 2e 63 6f 6d 00 25 6c 6c 75  easeapi.com.%llu
0x10440c800: 00 25 73 00 4d 79 41 70 70 6c 69 63 61 74 69 6f  .%s.MyApplicatio
</code></pre></td></tr></table>
</div>
</div><p>From the above test results, reading <code>__thread</code> variables is done via fp pointer offsets (shifts to higher addresses).</p>
<p>Variables modified by <code>__thread</code> must be of type POD (Plain Old Data) and do not support high-level language features such as class. The <code>__thread</code> variable remains for the life of the thread and is released when the thread is destroyed. Note that since <code>__thread</code> does not specify a destruction method, when we define a <code>__thread</code>-modified pointer variable and malloc memory in the thread, the end of the thread will only set the <code>__thread</code> variable pointer to NULL, requiring the developer to free memory manually.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">__thread</span> <span class="kt">char</span> <span class="o">*</span><span class="n">g_tls_string</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">tls_test</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">g_tls_string</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="n">g_tls_string</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="c1">//线程销毁时，需要手动释放malloc的内存
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>If you want the release of malloc memory to be done automatically when the thread ends, you need to use the pthread specific related API.</p>
<h3 id="pthread-specific-api">pthread specific API</h3>
<p>pthread also provides the following APIs to implement the TLS functionality.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="c1">//nptl/bits/pthreadtypes.h
</span><span class="c1"></span><span class="cm">/* Keys for thread-specific data */</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pthread_key_t</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">pthread_key_create</span><span class="p">(</span><span class="n">pthread_key_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span> <span class="n">_Nullable</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">));</span>
<span class="kt">int</span> <span class="nf">pthread_key_delete</span><span class="p">(</span><span class="n">pthread_key_t</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">pthread_setspecific</span><span class="p">(</span><span class="n">pthread_key_t</span> <span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">_Nullable</span><span class="p">);</span>
<span class="kt">void</span><span class="o">*</span> <span class="n">_Nullable</span> <span class="nf">pthread_getspecific</span><span class="p">(</span><span class="n">pthread_key_t</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>The first parameter of pthread_key_create is the pthread_key_t pointer, which is used to receive the pthread_key_t returned by successful creation, and the second parameter is the data destructor pointer, which will be executed when the thread is destroyed. pthread_key_create obtains the pthread_key_t after successful creation, and then pthread_key_t can be used to read and write thread private data. The sample code is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="c1">//create key
</span><span class="c1"></span><span class="n">pthread_key_t</span> <span class="n">key</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">pthread_key_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span> 

<span class="c1">//write
</span><span class="c1"></span><span class="k">struct</span> <span class="n">easeapi_struct</span> <span class="n">data</span><span class="p">;</span>
<span class="n">pthread_setspecific</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">struct_data</span><span class="p">);</span>

<span class="c1">//read
</span><span class="c1"></span><span class="k">struct</span> <span class="n">easeapi_struct</span><span class="o">*</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">easeapi_struct</span> <span class="o">*</span><span class="p">)</span><span class="n">pthread_getspecific</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Each process has a global array __pthread_keys to manage pthread_key_t.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="c1">//nptl/internaltypes.h:
</span><span class="c1"></span><span class="cm">/* Thread-local data handling.  */</span>
<span class="k">struct</span> <span class="n">pthread_key_struct</span>
<span class="p">{</span>
  <span class="cm">/* Sequence numbers.  Even numbers indicated vacant entries.  Note
</span><span class="cm">     that zero is even.  We use uintptr_t to not require padding on
</span><span class="cm">     32- and 64-bit machines.  On 64-bit machines it helps to avoid
</span><span class="cm">     wrapping, too.  */</span>
  <span class="n">uintptr_t</span> <span class="n">seq</span><span class="p">;</span>

  <span class="cm">/* Destructor for the data.  */</span>
  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destr</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">//sysdeps/unix/sysv/linux/bits/local_lim.h
</span><span class="c1"></span><span class="cm">/* This is the value this implementation supports.  */</span>
<span class="cp">#define PTHREAD_KEYS_MAX 1024
</span><span class="cp"></span>
<span class="c1">//nptl/pthread_keys.c
</span><span class="c1"></span><span class="cm">/* Table of the key information.  */</span>
<span class="k">struct</span> <span class="n">pthread_key_struct</span> <span class="n">__pthread_keys</span><span class="p">[</span><span class="n">PTHREAD_KEYS_MAX</span><span class="p">];</span>
</code></pre></td></tr></table>
</div>
</div><p>The <code>struct pthread_key_struct</code> structure defines the seq and the pointer to the incoming destructor. A program can create up to PTHREAD_KEYS_MAX pthread_key_t at the same time. pthread_key_t is global, but different threads actually operate on different memory when accessing the read/write interface through pthread_key_t.</p>
<p>When pthread_key_create is executed, it finds an unused pthread_key_struct structure from the <code>__pthread_keys</code> array and adds 1 to its seq. The returned pthread_key_t is actually this pthread_key_struct in the <code>__pthread_keys</code> array. pthread_key_t is actually the serial number of this pthread_key_struct in the <code>__pthread_keys</code> array. The following code.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="c1">//nptl/pthread_key_create.c:
</span><span class="c1"></span><span class="kt">int</span>
<span class="nf">___pthread_key_create</span> <span class="p">(</span><span class="n">pthread_key_t</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destr</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
  <span class="cm">/* Find a slot in __pthread_keys which is unused.  */</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">PTHREAD_KEYS_MAX</span><span class="p">;</span> <span class="o">++</span><span class="n">cnt</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">uintptr_t</span> <span class="n">seq</span> <span class="o">=</span> <span class="n">__pthread_keys</span><span class="p">[</span><span class="n">cnt</span><span class="p">].</span><span class="n">seq</span><span class="p">;</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">KEY_UNUSED</span> <span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">KEY_USABLE</span> <span class="p">(</span><span class="n">seq</span><span class="p">)</span>
   <span class="cm">/* We found an unused slot.  Try to allocate it.  */</span>
   <span class="o">&amp;&amp;</span> <span class="o">!</span> <span class="n">atomic_compare_and_exchange_bool_acq</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">__pthread_keys</span><span class="p">[</span><span class="n">cnt</span><span class="p">].</span><span class="n">seq</span><span class="p">,</span>
           <span class="n">seq</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">seq</span><span class="p">))</span>
 <span class="p">{</span>
   <span class="cm">/* Remember the destructor.  */</span>
   <span class="n">__pthread_keys</span><span class="p">[</span><span class="n">cnt</span><span class="p">].</span><span class="n">destr</span> <span class="o">=</span> <span class="n">destr</span><span class="p">;</span>

   <span class="cm">/* Return the key to the caller.  */</span>
   <span class="o">*</span><span class="n">key</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">;</span>

   <span class="cm">/* The call succeeded.  */</span>
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
 <span class="p">}</span>
    <span class="p">}</span>

  <span class="k">return</span> <span class="n">EAGAIN</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>When pthread_key_delete is executed, the corresponding pthread_key_struct is found from __pthread_keys according to the serial number of pthread_key_t, and its seq is added by 1. The following code is used.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="c1">//nptl/pthread_key_delete.c
</span><span class="c1"></span><span class="kt">int</span>
<span class="nf">___pthread_key_delete</span> <span class="p">(</span><span class="n">pthread_key_t</span> <span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">EINVAL</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">__glibc_likely</span> <span class="p">(</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">PTHREAD_KEYS_MAX</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">seq</span> <span class="o">=</span> <span class="n">__pthread_keys</span><span class="p">[</span><span class="n">key</span><span class="p">].</span><span class="n">seq</span><span class="p">;</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="o">!</span> <span class="n">KEY_UNUSED</span> <span class="p">(</span><span class="n">seq</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
   <span class="o">&amp;&amp;</span> <span class="o">!</span> <span class="n">atomic_compare_and_exchange_bool_acq</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">__pthread_keys</span><span class="p">[</span><span class="n">key</span><span class="p">].</span><span class="n">seq</span><span class="p">,</span>
           <span class="n">seq</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">seq</span><span class="p">))</span>
 <span class="cm">/* We deleted a valid key.  */</span>
 <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>Note that <code>atomic_compare_and_exchange_bool_acq</code> is used here to guarantee atomic operations.</p>
</blockquote>
<p>The default value of seq is 0. Either pthread_key_create or pthread_key_delete adds 1 to seq. When the value of seq is even (including 0), it means that the current pthread_key_struct is not in use, and when it is odd, it means that it is in use.</p>
<p>The allocation of pthread_key_t via pthread_key_create is global, but the key-value association is thread-independent. The following definition is available in the <code>struct pthread</code> structure.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"> <span class="k">struct</span> <span class="n">pthread_key_data</span>
  <span class="p">{</span>
    <span class="cm">/* Sequence number.  We use uintptr_t to not require padding on
</span><span class="cm">       32- and 64-bit machines.  On 64-bit machines it helps to avoid
</span><span class="cm">       wrapping, too.  */</span>
    <span class="n">uintptr_t</span> <span class="n">seq</span><span class="p">;</span>

    <span class="cm">/* Data pointer.  */</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
  <span class="p">}</span> <span class="n">specific_1stblock</span><span class="p">[</span><span class="n">PTHREAD_KEY_2NDLEVEL_SIZE</span><span class="p">];</span>

  <span class="cm">/* Two-level array for the thread-specific data.  */</span>
  <span class="k">struct</span> <span class="n">pthread_key_data</span> <span class="o">*</span><span class="n">specific</span><span class="p">[</span><span class="n">PTHREAD_KEY_1STLEVEL_SIZE</span><span class="p">];</span>
</code></pre></td></tr></table>
</div>
</div><p>The <code>struct pthread_key_data</code> structure defines a pointer to data where the current thread stores TLS data, seq and seq of <code>struct pthread_key_struct</code> are the same, which identifies whether the corresponding key is created or not.</p>
<p>The specific_1stblock is not set to the same size as PTHREAD_KEYS_MAX, but to PTHREAD_KEY_2NDLEVEL_SIZE (32), which is supposed to be designed from a memory-saving point of view, as we do not use many TLS variables in most cases.</p>
<p>When pthread_setspecific is executed, when the number of pthread_key_t is smaller than PTHREAD_KEY_2NDLEVEL_SIZE, specific_1stblock array is used directly; when the number of pthread_key_t exceeds PTHREAD_KEY_2NDLEVEL_SIZE, memory space is requested again. SIZE, then apply memory space to use specific secondary array, and store the value in specific[idx1st][idx2nd].data.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="c1">//nptl/pthread_setspecific.c
</span><span class="c1"></span><span class="kt">int</span>
<span class="nf">___pthread_setspecific</span> <span class="p">(</span><span class="n">pthread_key_t</span> <span class="n">key</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">pthread</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idx1st</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idx2nd</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">pthread_key_data</span> <span class="o">*</span><span class="n">level2</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">seq</span><span class="p">;</span>

  <span class="n">self</span> <span class="o">=</span> <span class="n">THREAD_SELF</span><span class="p">;</span>

  <span class="cm">/* Special case access to the first 2nd-level block.  This is the
</span><span class="cm">     usual case.  */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">__glibc_likely</span> <span class="p">(</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">PTHREAD_KEY_2NDLEVEL_SIZE</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="cm">/* Verify the key is sane.  */</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">KEY_UNUSED</span> <span class="p">((</span><span class="n">seq</span> <span class="o">=</span> <span class="n">__pthread_keys</span><span class="p">[</span><span class="n">key</span><span class="p">].</span><span class="n">seq</span><span class="p">)))</span>
 <span class="cm">/* Not valid.  */</span>
 <span class="k">return</span> <span class="n">EINVAL</span><span class="p">;</span>

      <span class="n">level2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">specific_1stblock</span><span class="p">[</span><span class="n">key</span><span class="p">];</span>

      <span class="cm">/* Remember that we stored at least one set of data.  */</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
 <span class="n">THREAD_SETMEM</span> <span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">specific_used</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="k">else</span>
    <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">&gt;=</span> <span class="n">PTHREAD_KEYS_MAX</span>
   <span class="o">||</span> <span class="n">KEY_UNUSED</span> <span class="p">((</span><span class="n">seq</span> <span class="o">=</span> <span class="n">__pthread_keys</span><span class="p">[</span><span class="n">key</span><span class="p">].</span><span class="n">seq</span><span class="p">)))</span>
 <span class="cm">/* Not valid.  */</span>
 <span class="k">return</span> <span class="n">EINVAL</span><span class="p">;</span>

      <span class="n">idx1st</span> <span class="o">=</span> <span class="n">key</span> <span class="o">/</span> <span class="n">PTHREAD_KEY_2NDLEVEL_SIZE</span><span class="p">;</span>
      <span class="n">idx2nd</span> <span class="o">=</span> <span class="n">key</span> <span class="o">%</span> <span class="n">PTHREAD_KEY_2NDLEVEL_SIZE</span><span class="p">;</span>

      <span class="cm">/* This is the second level array.  Allocate it if necessary.  */</span>
      <span class="n">level2</span> <span class="o">=</span> <span class="n">THREAD_GETMEM_NC</span> <span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">specific</span><span class="p">,</span> <span class="n">idx1st</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">level2</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
 <span class="p">{</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
     <span class="cm">/* We don&#39;t have to do anything.  The value would in any case
</span><span class="cm">        be NULL.  We can save the memory allocation.  */</span>
     <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

   <span class="n">level2</span>
     <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pthread_key_data</span> <span class="o">*</span><span class="p">)</span> <span class="n">calloc</span> <span class="p">(</span><span class="n">PTHREAD_KEY_2NDLEVEL_SIZE</span><span class="p">,</span>
        <span class="k">sizeof</span> <span class="p">(</span><span class="o">*</span><span class="n">level2</span><span class="p">));</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">level2</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
     <span class="k">return</span> <span class="n">ENOMEM</span><span class="p">;</span>

   <span class="n">THREAD_SETMEM_NC</span> <span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">specific</span><span class="p">,</span> <span class="n">idx1st</span><span class="p">,</span> <span class="n">level2</span><span class="p">);</span>
 <span class="p">}</span>

      <span class="cm">/* Pointer to the right array element.  */</span>
      <span class="n">level2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">level2</span><span class="p">[</span><span class="n">idx2nd</span><span class="p">];</span>

      <span class="cm">/* Remember that we stored at least one set of data.  */</span>
      <span class="n">THREAD_SETMEM</span> <span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">specific_used</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
    <span class="p">}</span>

  <span class="cm">/* Store the data and the sequence number so that we can recognize
</span><span class="cm">     stale data.  */</span>
  <span class="n">level2</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">=</span> <span class="n">seq</span><span class="p">;</span>
  <span class="n">level2</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">value</span><span class="p">;</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>With the above analysis, the logic of executing pthread_getspecific is relatively clear.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="c1">//nptl/pthread_getspecific.c
</span><span class="c1"></span>
<span class="kt">void</span> <span class="o">*</span>
<span class="nf">___pthread_getspecific</span> <span class="p">(</span><span class="n">pthread_key_t</span> <span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">pthread_key_data</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>

  <span class="cm">/* Special case access to the first 2nd-level block.  This is the
</span><span class="cm">     usual case.  */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">__glibc_likely</span> <span class="p">(</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">PTHREAD_KEY_2NDLEVEL_SIZE</span><span class="p">))</span>
    <span class="n">data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">THREAD_SELF</span><span class="o">-&gt;</span><span class="n">specific_1stblock</span><span class="p">[</span><span class="n">key</span><span class="p">];</span>
  <span class="k">else</span>
    <span class="p">{</span>
      <span class="cm">/* Verify the key is sane.  */</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">&gt;=</span> <span class="n">PTHREAD_KEYS_MAX</span><span class="p">)</span>
 <span class="cm">/* Not valid.  */</span>
 <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idx1st</span> <span class="o">=</span> <span class="n">key</span> <span class="o">/</span> <span class="n">PTHREAD_KEY_2NDLEVEL_SIZE</span><span class="p">;</span>
      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idx2nd</span> <span class="o">=</span> <span class="n">key</span> <span class="o">%</span> <span class="n">PTHREAD_KEY_2NDLEVEL_SIZE</span><span class="p">;</span>

      <span class="cm">/* If the sequence number doesn&#39;t match or the key cannot be defined
</span><span class="cm">  for this thread since the second level array is not allocated
</span><span class="cm">  return NULL, too.  */</span>
      <span class="k">struct</span> <span class="n">pthread_key_data</span> <span class="o">*</span><span class="n">level2</span> <span class="o">=</span> <span class="n">THREAD_GETMEM_NC</span> <span class="p">(</span><span class="n">THREAD_SELF</span><span class="p">,</span>
         <span class="n">specific</span><span class="p">,</span> <span class="n">idx1st</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">level2</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
 <span class="cm">/* Not allocated, therefore no data.  */</span>
 <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

      <span class="cm">/* There is data.  */</span>
      <span class="n">data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">level2</span><span class="p">[</span><span class="n">idx2nd</span><span class="p">];</span>
    <span class="p">}</span>

  <span class="kt">void</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">uintptr_t</span> <span class="n">seq</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span> <span class="p">(</span><span class="n">seq</span> <span class="o">!=</span> <span class="n">__pthread_keys</span><span class="p">[</span><span class="n">key</span><span class="p">].</span><span class="n">seq</span><span class="p">))</span>
 <span class="n">result</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>According to the implementation of glibc, the pthread_key_t obtained when executing pthread_key_create should be a relatively small value in order to use the specific_1stblock array in preference. But I tested in macOS environment and found that the pthread_key_t obtained is relatively large, here should be the specific implementation of macOS and glibc inconsistency?</p>
</blockquote>
<h3 id="__thread-and-pthread-specific-api-comparison"><code>__thread</code> and pthread specific API comparison</h3>
<ul>
<li>Different storage areas/addressing methods</li>
</ul>
<p>The data defined by the pthread specific API is addressed by the specific_1stblock array and the specific secondary array of the <code>struct pthread</code> structure, while the <code>__thread</code> variables are addressed by fp register offsets.</p>
<ul>
<li>Performance/efficiency differences</li>
</ul>
<p>Since <code>__thread</code> is addressed by fp register offset, performance is higher than pthread specific API.</p>
<ul>
<li>Different data can be stored</li>
</ul>
<p><code>__thread</code> can only modify POD type variables, and for pointer type data, you need to destroy it manually when there is a memory request; while pthread specific API supports incoming destruction method and supports all data types.</p>
<ul>
<li>The number of supported data is different</li>
</ul>
<p>Theoretically, as long as the stack is not full, <code>__thread</code> can be defined indefinitely (doubtful?) The pthread specific API can only create PTHREAD_KEYS_MAX keys, but can use a key to store multiple values by means of structures, etc.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/linux/">linux</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-02/elasticsearch8/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">After three years, Elastic 8 is officially released</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-02/simple-java-bean/">
            <span class="next-text nav-default">How Java beans abstract and simplify</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
