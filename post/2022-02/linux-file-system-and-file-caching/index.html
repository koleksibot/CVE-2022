<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Linux file system and file caching knowledge collation - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="File system of Linux Characteristics of the file system  The file system has to be strictly organized so that files can be stored in blocks. The file system should also have indexed areas to make it easy to find out where the multiple blocks of a file are stored. the file system should have a cache layer if there are files that are hot files and have been read and written to frequently in the recent past." /><meta name="keywords" content="File System, File Caching" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-02/linux-file-system-and-file-caching/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Linux file system and file caching knowledge collation" />
<meta property="og:description" content="File system of Linux Characteristics of the file system  The file system has to be strictly organized so that files can be stored in blocks. The file system should also have indexed areas to make it easy to find out where the multiple blocks of a file are stored. the file system should have a cache layer if there are files that are hot files and have been read and written to frequently in the recent past." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-02/linux-file-system-and-file-caching/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-02-13T11:45:12+08:00" />
<meta property="article:modified_time" content="2022-02-13T11:45:12+08:00" />

<meta itemprop="name" content="Linux file system and file caching knowledge collation">
<meta itemprop="description" content="File system of Linux Characteristics of the file system  The file system has to be strictly organized so that files can be stored in blocks. The file system should also have indexed areas to make it easy to find out where the multiple blocks of a file are stored. the file system should have a cache layer if there are files that are hot files and have been read and written to frequently in the recent past."><meta itemprop="datePublished" content="2022-02-13T11:45:12+08:00" />
<meta itemprop="dateModified" content="2022-02-13T11:45:12+08:00" />
<meta itemprop="wordCount" content="3664">
<meta itemprop="keywords" content="linux," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Linux file system and file caching knowledge collation"/>
<meta name="twitter:description" content="File system of Linux Characteristics of the file system  The file system has to be strictly organized so that files can be stored in blocks. The file system should also have indexed areas to make it easy to find out where the multiple blocks of a file are stored. the file system should have a cache layer if there are files that are hot files and have been read and written to frequently in the recent past."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Linux file system and file caching knowledge collation</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-02-13 11:45:12 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 3664 words </span>
          <span class="more-meta"> 18 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#file-system-of-linux">File system of Linux</a>
          <ul>
            <li><a href="#characteristics-of-the-file-system">Characteristics of the file system</a></li>
          </ul>
        </li>
        <li><a href="#the-format-of-the-ext-family-of-file-systems">The format of the ext family of file systems</a>
          <ul>
            <li><a href="#inode-and-block-storage">inode and block storage</a></li>
            <li><a href="#inode-bitmaps-and-block-bitmaps">inode bitmaps and block bitmaps</a></li>
            <li><a href="#format-of-the-file-system">Format of the file system</a></li>
            <li><a href="#the-storage-format-of-directories">The storage format of directories</a></li>
          </ul>
        </li>
        <li><a href="#file-caching-in-linux">File caching in Linux</a>
          <ul>
            <li><a href="#ext4-file-system-layer">ext4 file system layer</a></li>
            <li><a href="#write-operations-with-cache">Write operations with cache</a></li>
            <li><a href="#read-operations-with-cache">Read operations with cache</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="file-system-of-linux">File system of Linux</h2>
<h3 id="characteristics-of-the-file-system">Characteristics of the file system</h3>
<ol>
<li>The file system has to be strictly organized so that files can be stored in blocks.</li>
<li>The file system should also have indexed areas to make it easy to find out where the multiple blocks of a file are stored.</li>
<li>the file system should have a cache layer if there are files that are hot files and have been read and written to frequently in the recent past.</li>
<li>files should be organized in folders for easy management and querying.</li>
<li>The Linux kernel should maintain a set of data structures inside its own memory to keep track of which files are opened and used by which processes.</li>
</ol>
<p>In general, the main functions of the file system are sorted out as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/13/60cafc8a1f4e49a589f22fa4a31a73a0.png" alt="sobybte"></p>
<h2 id="the-format-of-the-ext-family-of-file-systems">The format of the ext family of file systems</h2>
<h3 id="inode-and-block-storage">inode and block storage</h3>
<p>The hard drive is divided into equal-sized units, which we call Blocks. The size of a block is an integer multiple of the sector size, the default is 4K. this value can be set when formatting.</p>
<p>A large hard disk is divided into smaller blocks to hold the data part of the file. This way, if we store a file like this, we don&rsquo;t have to allocate a contiguous block of space to it. We can spread it out into smaller chunks for storage. This is much more flexible and easier to add, delete and insert data.</p>
<p>The inode means file index, and each file corresponds to an inode; a folder is a file, which also corresponds to an inode.</p>
<p>The inode data structure is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">ext4_inode</span> <span class="p">{</span>
    <span class="n">__le16</span>  <span class="n">i_mode</span><span class="p">;</span>     <span class="cm">/* File mode */</span>
    <span class="n">__le16</span>  <span class="n">i_uid</span><span class="p">;</span>      <span class="cm">/* Low 16 bits of Owner Uid */</span>
    <span class="n">__le32</span>  <span class="n">i_size_lo</span><span class="p">;</span>  <span class="cm">/* Size in bytes */</span>
    <span class="n">__le32</span>  <span class="n">i_atime</span><span class="p">;</span>    <span class="cm">/* Access time */</span>
    <span class="n">__le32</span>  <span class="n">i_ctime</span><span class="p">;</span>    <span class="cm">/* Inode Change time */</span>
    <span class="n">__le32</span>  <span class="n">i_mtime</span><span class="p">;</span>    <span class="cm">/* Modification time */</span>
    <span class="n">__le32</span>  <span class="n">i_dtime</span><span class="p">;</span>    <span class="cm">/* Deletion Time */</span>
    <span class="n">__le16</span>  <span class="n">i_gid</span><span class="p">;</span>      <span class="cm">/* Low 16 bits of Group Id */</span>
    <span class="n">__le16</span>  <span class="n">i_links_count</span><span class="p">;</span>  <span class="cm">/* Links count */</span>
    <span class="n">__le32</span>  <span class="n">i_blocks_lo</span><span class="p">;</span>    <span class="cm">/* Blocks count */</span>
    <span class="n">__le32</span>  <span class="n">i_flags</span><span class="p">;</span>    <span class="cm">/* File flags */</span>
<span class="p">......</span>
    <span class="n">__le32</span>  <span class="n">i_block</span><span class="p">[</span><span class="n">EXT4_N_BLOCKS</span><span class="p">];</span><span class="cm">/* Pointers to blocks */</span>
    <span class="n">__le32</span>  <span class="n">i_generation</span><span class="p">;</span>   <span class="cm">/* File version (for NFS) */</span>
    <span class="n">__le32</span>  <span class="n">i_file_acl_lo</span><span class="p">;</span>  <span class="cm">/* File ACL */</span>
    <span class="n">__le32</span>  <span class="n">i_size_high</span><span class="p">;</span>
<span class="p">......</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>inode contains the file read and write permissions i_mode, which user i_uid belongs to, which group i_gid, what size i_size_io is, how many blocks i_blocks_io occupies, i_atime is the access time, which is the last time the file was accessed; i_ctime is the change time, which is the last i_ctime is the change time, which is the last time the inode was changed; i_mtime is the modify time, which is the last time the file was changed, etc.</p>
<p>All the files are saved in i_block. The specific saving rules are determined by EXT4_N_BLOCKS, which has the following definition.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#define EXT4_NDIR_BLOCKS        12
</span><span class="cp">#define EXT4_IND_BLOCK          EXT4_NDIR_BLOCKS
</span><span class="cp">#define EXT4_DIND_BLOCK         (EXT4_IND_BLOCK + 1)
</span><span class="cp">#define EXT4_TIND_BLOCK         (EXT4_DIND_BLOCK + 1)
</span><span class="cp">#define EXT4_N_BLOCKS           (EXT4_TIND_BLOCK + 1)
</span></code></pre></td></tr></table>
</div>
</div><p>In ext2 and ext3, the first 12 of them directly save the location of the block, that is, we can get the block where the file content is saved directly by i_block[0-11].</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/13/4aacedcdcac54e1c8b1439f18fcefb58.png" alt="sobyte"></p>
<p>However, if a file is relatively large, 12 blocks won&rsquo;t fit. When we use i_block[12], we can&rsquo;t put the location of the data block directly, or the i_block will run out soon.</p>
<p>Then we can let i_block[12] point to a block which does not put data blocks inside, but the location of data blocks, and this block we call indirect block. If the file is even bigger, i_block[13] will point to a block, and we can use a secondary indirect block. The secondary indirect block holds the location of the indirect block inside, the indirect block holds the location of the data block inside, and the data block holds the real data inside. If the file is even bigger, then i_block[14] does the same thing.</p>
<p>There is a very significant problem here, for large files, we have to read the hard disk several times to find the corresponding block, so the access speed will be slow.</p>
<p>To solve this problem, ext4 has made some changes. It introduces a new concept called Extents. let&rsquo;s say a file size of 128M, if we use 4k size blocks for storage, we need 32k blocks. If it is scattered as ext2 or ext3, the number is too large. But Extents can be used to store contiguous blocks, that is, we can put 128M inside one Extents. In this way, the performance of reading and writing to large files is improved and file fragmentation is reduced.</p>
<p>Exents is a tree-like structure.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/13/52f21bf2b57f4c239ecff01908886989.png" alt="sobyte"></p>
<p>Each node has a header, ext4_extent_header can be used to describe a certain node.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">ext4_extent_header</span> <span class="p">{</span>
    <span class="n">__le16</span>  <span class="n">eh_magic</span><span class="p">;</span>   <span class="cm">/* probably will support different formats */</span>
    <span class="n">__le16</span>  <span class="n">eh_entries</span><span class="p">;</span> <span class="cm">/* number of valid entries */</span>
    <span class="n">__le16</span>  <span class="n">eh_max</span><span class="p">;</span>     <span class="cm">/* capacity of store in entries */</span>
    <span class="n">__le16</span>  <span class="n">eh_depth</span><span class="p">;</span>   <span class="cm">/* has tree real underlying blocks? */</span>
    <span class="n">__le32</span>  <span class="n">eh_generation</span><span class="p">;</span>  <span class="cm">/* generation of the tree */</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>eh_entries indicates how many items are inside this node. There are two types of items here: if it is a leaf node, this item will point directly to the address of a contiguous block on the hard disk, which we call the data node ext4_extent; if it is a branch node, this item will point to the next level of branch nodes or leaf nodes, which we call the index node ext4_extent_idx. The size of both types of items is 12 bytes.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/*
</span><span class="cm"> * This is the extent on-disk structure.
</span><span class="cm"> * It&#39;s used at the bottom of the tree.
</span><span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ext4_extent</span> <span class="p">{</span>
    <span class="n">__le32</span>  <span class="n">ee_block</span><span class="p">;</span>   <span class="cm">/* first logical block extent covers */</span>
    <span class="n">__le16</span>  <span class="n">ee_len</span><span class="p">;</span>     <span class="cm">/* number of blocks covered by extent */</span>
    <span class="n">__le16</span>  <span class="n">ee_start_hi</span><span class="p">;</span>    <span class="cm">/* high 16 bits of physical block */</span>
    <span class="n">__le32</span>  <span class="n">ee_start_lo</span><span class="p">;</span>    <span class="cm">/* low 32 bits of physical block */</span>
<span class="p">};</span>
<span class="cm">/*
</span><span class="cm"> * This is index on-disk structure.
</span><span class="cm"> * It&#39;s used at all the levels except the bottom.
</span><span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ext4_extent_idx</span> <span class="p">{</span>
    <span class="n">__le32</span>  <span class="n">ei_block</span><span class="p">;</span>   <span class="cm">/* index covers logical blocks from &#39;block&#39; */</span>
    <span class="n">__le32</span>  <span class="n">ei_leaf_lo</span><span class="p">;</span> <span class="cm">/* pointer to the physical block of the next *
</span><span class="cm">                 * level. leaf or next index could be there */</span>
    <span class="n">__le16</span>  <span class="n">ei_leaf_hi</span><span class="p">;</span> <span class="cm">/* high 16 bits of physical block */</span>
    <span class="n">__u16</span>   <span class="n">ei_unused</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>If the file is not big, the i_block inside the inode can fit an ext4_extent_header and 4 ext4_extent. so at this time, eh_depth is 0, that is, the inode inside is the leaf node, and the tree height is 0.</p>
<p>If the file is larger and the 4 extents can&rsquo;t fit, it has to split into a tree. The node with eh_depth&gt;0 is the index node, where the root node has the greatest depth, in the inode. The bottom eh_depth=0 is the leaf node.</p>
<p>In addition to the root node, all other nodes are saved inside a block 4k, 4k minus 12 bytes of ext4_extent_header, the rest can put 340 items, each extent can represent a maximum of 128MB of data, 340 extents will make your representation of the file up to 42.5GB.</p>
<h3 id="inode-bitmaps-and-block-bitmaps">inode bitmaps and block bitmaps</h3>
<p>The inode bitmap is 4k in size, each bit corresponds to an inode. if it is 1, the inode is already used, if it is 0, it is not used. the block bitmap is the same.</p>
<p>In Linux, if you want to create a new file, you call the open function with the parameter O_CREAT, which means that when the file is not found, we need to create one. Then the open function is called roughly as follows: to open a file, first find the folder according to the path. If the file is not found under the folder, and O_CREAT is set, then we need to create a file under the folder.</p>
<p>For the block bitmap, this process is also done when writing to the file.</p>
<h3 id="format-of-the-file-system">Format of the file system</h3>
<p>The bitmap of a data block is placed inside a block of 4k. each bit represents one data block and can represent a total of $4 <em>1024</em> 8 = 2^{15}$ data blocks. If each block is also 4K by default, the maximum representable space is $2^{15} <em>4</em> 1024 = 2^{27}$ bytes, which is 128M, then obviously it is not enough.</p>
<p>This time we need to use block groups, the data structure is ext4_group_desc, which has corresponding member variables for inode bitmap bg_inode_bitmap_lo, block bitmap bg_block_bitmap_lo, and inode list bg_inode_table_lo in a block group.</p>
<p>In this way, one block group after another, basically constitutes the structure of our entire file system. Because there are multiple block groups, the block group descriptors likewise form a list, and we call these the block group descriptor tables.</p>
<p>We also need a data structure that describes the entire file system, which is the superblock ext4_super_block. s_inodes_count contains the total number of inodes in the entire file system, s_inodes_count, the total number of blocks, s_blocks_count_lo, the number of inodes per block group, s_inodes_per_group, and the number of blocks per block group. inodes_per_group, how many blocks per block group, s_blocks_per_group, etc. These are all such global information.</p>
<p>In the end, the whole file system format looks like the following.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/13/5d44a6c1b0a94ccd982efc74ca89af73.png" alt="sobyte"></p>
<p>By default, copies of the superblock and block group descriptor tables are kept inside each block group. This prevents the entire file system from being opened if this data is lost.</p>
<p>Since it is a waste of space to keep a complete copy of the block group descriptor table inside each block group, on the one hand, and on the other hand, since the maximum size of a block group is 128M, and the number of items in the block group descriptor table limits the number of block groups, the total number of 128M * block groups is the size of the whole file system, which is limited.</p>
<p>Therefore Meta Block Groups feature is introduced.</p>
<p>First, the block group descriptor table does not hold the descriptors of all block groups anymore, but divides the block groups into multiple groups, which we call Meta Block Groups. Each Meta Block Group contains only its own block descriptor table, and a Meta Block Group contains 64 block groups, so that the maximum number of block descriptor table items in a Meta Block Group is 64.</p>
<p>Let&rsquo;s assume there are 256 block groups in total, the original is a whole block group descriptor table, there are 256 items in it, to backup the whole backup, now divided into 4 meta block groups, each meta block group inside the block group descriptor table is only 64 items, this is much smaller, and the four meta block groups back up their own.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/13/f1d20e30f9be4bde9dff06c20c6313c9.png" alt="sobyte"></p>
<p>According to the figure, each meta-block group contains 64 block groups and the block group descriptor table is also 64 items, backed up in three copies, at the beginning of the first, second and last block groups of the meta-block group.</p>
<p>If the sparse_super feature is turned on, the copies of super blocks and block group descriptor tables are only saved in integer powers of block group indexes 0, 3, 5, and 7. So the super block in the above figure is only in integer powers with indexes 0, 3, 5, 7, etc.</p>
<h3 id="the-storage-format-of-directories">The storage format of directories</h3>
<p>A directory is actually a file with an inode, which also points to blocks. Unlike normal files, which store file data in blocks, directory files store file-by-file information inside the directory. This information is called ext4_dir_entry.</p>
<p>In the block of directory files, the simplest format is a list, where each item holds the file name and corresponding inode of the next level of the directory, through which the real file can be found. The first item is &ldquo;.&rdquo; for the current directory, the second one is &ldquo;&hellip;&rdquo; for the previous directory, and the next one is the file name and inode.</p>
<p>If the EXT4_INDEX_FL flag is set in the inode, then it means that the file is found according to the index. The index entry maintains a mapping between the hash of a file name and a data block.</p>
<p>If we want to find a file name under a directory, we can take a hash by name. If the hash can match, it means that the information of this file is inside the corresponding block. Then we open the block, and if it is no longer an index, but a leaf node of the index tree, it is still a list of ext4_dir_entry, and we just have to look for the file name one by one. By using the index tree, we can spread more than one file in a directory into many blocks, so we can find them quickly.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/13/5c4e9707853246738a069a965e7f6561.png" alt="sobyte"></p>
<h2 id="file-caching-in-linux">File caching in Linux</h2>
<h3 id="ext4-file-system-layer">ext4 file system layer</h3>
<p>For the ext4 file system, the kernel defines an ext4_file_operations.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">ext4_file_operations</span> <span class="o">=</span> <span class="p">{</span>
<span class="p">......</span>
    <span class="p">.</span><span class="n">read_iter</span>  <span class="o">=</span> <span class="n">ext4_file_read_iter</span><span class="p">,</span>
    <span class="p">.</span><span class="n">write_iter</span> <span class="o">=</span> <span class="n">ext4_file_write_iter</span><span class="p">,</span>
<span class="p">......</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>ext4_file_read_iter will call generic_file_read_iter and ext4_file_write_iter will call __generic_file_write_iter.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">ssize_t</span>
<span class="nf">generic_file_read_iter</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iov_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">......</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_flags</span> <span class="o">&amp;</span> <span class="n">IOCB_DIRECT</span><span class="p">)</span> <span class="p">{</span>
<span class="p">......</span>
        <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>
<span class="p">......</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">direct_IO</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">iter</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">......</span>
    <span class="n">retval</span> <span class="o">=</span> <span class="n">generic_file_buffered_read</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">iter</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">ssize_t</span> <span class="nf">__generic_file_write_iter</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iov_iter</span> <span class="o">*</span><span class="n">from</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">......</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_flags</span> <span class="o">&amp;</span> <span class="n">IOCB_DIRECT</span><span class="p">)</span> <span class="p">{</span>
<span class="p">......</span>
        <span class="n">written</span> <span class="o">=</span> <span class="n">generic_file_direct_write</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">from</span><span class="p">);</span>
<span class="p">......</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="p">......</span>
        <span class="n">written</span> <span class="o">=</span> <span class="n">generic_perform_write</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_pos</span><span class="p">);</span>
<span class="p">......</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>generic_file_read_iter and __generic_file_write_iter have similar logic to distinguish whether cache is used or not. Thus, depending on whether memory is used for caching or not, we can classify file I/O operations into two types.</p>
<p>The first type is cached I/O. The default I/O operation for most file systems is cached I/O. For read operations, the operating system first checks to see if the kernel has the data it needs in its buffers. If the data is already cached, it is returned directly from the cache; otherwise it is read from the disk and cached in the OS cache. For a write operation, <strong>the OS will first copy the data from user space to the kernel space cache</strong> . At this point, the write operation is complete for the user program. It is up to the operating system to decide when to write to disk again, unless the sync synchronization command is explicitly called.</p>
<p>The second type is direct IO, where the application accesses the disk data directly without going through the kernel buffer, thus reducing the need to copy data between the kernel cache and the user program.</p>
<p>If inside the write logic __generic_file_write_iter, it is found that IOCB_DIRECT is set, then generic_file_direct_write is called, which also calls the function of direct_IO of address_space to write the data directly to the hard disk.</p>
<h3 id="write-operations-with-cache">Write operations with cache</h3>
<p>Let&rsquo;s first look at the generic_perform_write function with cached writes.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">ssize_t</span> <span class="nf">generic_perform_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
                <span class="k">struct</span> <span class="n">iov_iter</span> <span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>
    <span class="k">const</span> <span class="k">struct</span> <span class="n">address_space_operations</span> <span class="o">*</span><span class="n">a_ops</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="p">;</span>
    <span class="k">do</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>   <span class="cm">/* Offset into pagecache page */</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bytes</span><span class="p">;</span>    <span class="cm">/* Bytes to write to page */</span>
        <span class="n">status</span> <span class="o">=</span> <span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">write_begin</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span>
                        <span class="o">&amp;</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fsdata</span><span class="p">);</span>
        <span class="n">copied</span> <span class="o">=</span> <span class="n">iov_iter_copy_from_user_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
        <span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
        <span class="n">status</span> <span class="o">=</span> <span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">write_end</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">copied</span><span class="p">,</span>
                        <span class="n">page</span><span class="p">,</span> <span class="n">fsdata</span><span class="p">);</span>
        <span class="n">pos</span> <span class="o">+=</span> <span class="n">copied</span><span class="p">;</span>
        <span class="n">written</span> <span class="o">+=</span> <span class="n">copied</span><span class="p">;</span>

        <span class="n">balance_dirty_pages_ratelimited</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">iov_iter_count</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>These are the main things that are done in the loop.</p>
<ul>
<li>for each page, first call write_begin on address_space to do some preparation.</li>
<li>calling iov_iter_copy_from_user_atomic to copy the write from the user state to the kernel state page.</li>
<li>call write_end of address_space to complete the write operation.</li>
<li>call balance_dirty_pages_ratelimited to see if there are too many dirty pages that need to be written back to the hard disk. A dirty page is a page that is written to the cache but not yet written to the hard disk.</li>
</ul>
<p>For the first step, which is called ext4_write_begin, there are two main things to do.</p>
<p>The first does logging-related work.</p>
<p>ext4 is a logging file system, which was introduced to prevent data loss in case of sudden power failure <strong>(Journal)</strong> mode. The journal file system has an additional Journal area than the non-journal file system. The file is stored in ext4 in two parts, one for the file metadata and the other for the data. Journal is also managed separately for metadata and data operations. You can select the Journal mode when mounting ext4. This mode has to wait until the logs of metadata and data have fallen off the disk before writing data to the file system to function. This is worse in performance, but the safest.</p>
<p>The other mode is Order mode. This mode does not log the data, only the metadata, but you must make sure that the data has fallen off the disk before writing the log of the metadata. This is a compromise and is the default mode.</p>
<p>Another mode is writeback, which does not log the data, only the metadata, and does not guarantee that the data is dropped before the metadata. This has the best performance, but is the least secure.</p>
<p>The second call to grab_cache_page_write_begin comes and gets the cache page that should be written.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">grab_cache_page_write_begin</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
                    <span class="n">pgoff_t</span> <span class="n">index</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">fgp_flags</span> <span class="o">=</span> <span class="n">FGP_LOCK</span><span class="o">|</span><span class="n">FGP_WRITE</span><span class="o">|</span><span class="n">FGP_CREAT</span><span class="p">;</span>
    <span class="n">page</span> <span class="o">=</span> <span class="n">pagecache_get_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">fgp_flags</span><span class="p">,</span>
            <span class="n">mapping_gfp_mask</span><span class="p">(</span><span class="n">mapping</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span>
        <span class="n">wait_for_stable_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">page</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>In the kernel, the cache is placed in memory in pages. Each open file has a struct file structure, and each struct file structure has a struct address_space for associating the file with memory.</p>
<p>For the second step, call iov_iter_copy_from_user_atomic. first map the allocated page to a virtual address inside the kernel by calling kmap_atomic, then copy the user state data to the virtual address of the kernel state page, and call kunmap_atomic to remove the mapping inside the kernel.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">size_t</span> <span class="nf">iov_iter_copy_from_user_atomic</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
        <span class="k">struct</span> <span class="n">iov_iter</span> <span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">kaddr</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">),</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">kaddr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
    <span class="n">iterate_all_kinds</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span>
        <span class="n">copyin</span><span class="p">((</span><span class="n">p</span> <span class="o">+=</span> <span class="n">v</span><span class="p">.</span><span class="n">iov_len</span><span class="p">)</span> <span class="o">-</span> <span class="n">v</span><span class="p">.</span><span class="n">iov_len</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">iov_base</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">iov_len</span><span class="p">),</span>
        <span class="n">memcpy_from_page</span><span class="p">((</span><span class="n">p</span> <span class="o">+=</span> <span class="n">v</span><span class="p">.</span><span class="n">bv_len</span><span class="p">)</span> <span class="o">-</span> <span class="n">v</span><span class="p">.</span><span class="n">bv_len</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">bv_page</span><span class="p">,</span>
                 <span class="n">v</span><span class="p">.</span><span class="n">bv_offset</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">bv_len</span><span class="p">),</span>
        <span class="n">memcpy</span><span class="p">((</span><span class="n">p</span> <span class="o">+=</span> <span class="n">v</span><span class="p">.</span><span class="n">iov_len</span><span class="p">)</span> <span class="o">-</span> <span class="n">v</span><span class="p">.</span><span class="n">iov_len</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">iov_base</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">iov_len</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">kaddr</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">bytes</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>In the third step, ext4_write_end is called to finish writing. This calls ext4_journal_stop to finish writing the journal, and block_write_end-&gt;__block_commit_write-&gt;mark_buffer_dirty to mark the modified cache as a dirty page. As you can see, the so-called finished write is not actually written to the hard disk, but simply written to the cache and marked as <strong>dirty pages</strong> .</p>
<p>The fourth step, calling balance_dirty_pages_ratelimited, is to write back the dirty pages.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/**
</span><span class="cm"> * balance_dirty_pages_ratelimited - balance dirty memory state
</span><span class="cm"> * @mapping: address_space which was dirtied
</span><span class="cm"> *
</span><span class="cm"> * Processes which are dirtying memory should call in here once for each page
</span><span class="cm"> * which was newly dirtied.  The function will periodically check the system&#39;s
</span><span class="cm"> * dirty state and will initiate writeback if needed.
</span><span class="cm">  */</span>
<span class="kt">void</span> <span class="nf">balance_dirty_pages_ratelimited</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span> <span class="o">=</span> <span class="n">inode_to_bdi</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
    <span class="k">struct</span> <span class="n">bdi_writeback</span> <span class="o">*</span><span class="n">wb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ratelimit</span><span class="p">;</span>
<span class="p">......</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">nr_dirtied</span> <span class="o">&gt;=</span> <span class="n">ratelimit</span><span class="p">))</span>
        <span class="n">balance_dirty_pages</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">wb</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">nr_dirtied</span><span class="p">);</span>
<span class="p">......</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Inside balance_dirty_pages_ratelimited, if the number of dirty pages is found to exceed the specified number, balance_dirty_pages-&gt;wb_start_background_writeback is called, starting a thread behind it to start writing back.</p>
<p>There are several other scenarios that trigger a writeback.</p>
<ul>
<li>user-initiated calls to sync, which flushes the cache to the hard disk and eventually calls wakeup_flusher_threads, which synchronizes dirty pages.</li>
<li>when memory is so tight that pages cannot be allocated, free_more_memory is called, and eventually wakeup_flusher_threads is called, freeing the dirty pages.</li>
<li>Dirty pages have been updated for a longer period of time than the set time and need to be written back in time to maintain data consistency in memory and on disk.</li>
</ul>
<h3 id="read-operations-with-cache">Read operations with cache</h3>
<p>Look at read with cache, which corresponds to the function generic_file_buffered_read.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="n">ssize_t</span> <span class="nf">generic_file_buffered_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span>
        <span class="k">struct</span> <span class="n">iov_iter</span> <span class="o">*</span><span class="n">iter</span><span class="p">,</span> <span class="n">ssize_t</span> <span class="n">written</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
        <span class="n">pgoff_t</span> <span class="n">end_index</span><span class="p">;</span>
        <span class="n">loff_t</span> <span class="n">isize</span><span class="p">;</span>
        <span class="n">page</span> <span class="o">=</span> <span class="n">find_get_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_flags</span> <span class="o">&amp;</span> <span class="n">IOCB_NOWAIT</span><span class="p">)</span>
                <span class="k">goto</span> <span class="n">would_block</span><span class="p">;</span>
            <span class="n">page_cache_sync_readahead</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span>
                    <span class="n">ra</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span>
                    <span class="n">index</span><span class="p">,</span> <span class="n">last_index</span> <span class="o">-</span> <span class="n">index</span><span class="p">);</span>
            <span class="n">page</span> <span class="o">=</span> <span class="n">find_get_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
                <span class="k">goto</span> <span class="n">no_cached_page</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">PageReadahead</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">page_cache_async_readahead</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span>
                    <span class="n">ra</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span>
                    <span class="n">index</span><span class="p">,</span> <span class="n">last_index</span> <span class="o">-</span> <span class="n">index</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="cm">/*
</span><span class="cm">         * Ok, we have the page, and it&#39;s up-to-date, so
</span><span class="cm">         * now we can copy it to user space...
</span><span class="cm">         */</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">copy_page_to_iter</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">iter</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>In the generic_file_buffered_read function, we need to find out if there is a cached page inside the page cache first. If not, we not only read the page, but also do a pre-read, which is done in the page_cache_sync_readahead function. After the pre-reading, try to find the cache page again.</p>
<p>If the cache page is found the first time, we still have to determine if we should continue the pre-reading; if needed, we call page_cache_async_readahead to initiate an asynchronous pre-reading.</p>
<p>Finally, copy_page_to_iter copies the contents from the kernel cache page into user memory space.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/linux/">linux</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-02/jraft-raft/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Raft protocol implementation details from JRaft</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-02/kubernetes-scheduling-framework-and-extender/">
            <span class="next-text nav-default">Kubernetes Scheduling Framework and Extender Comparison and Details</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
