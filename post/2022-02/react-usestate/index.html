<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>In-depth understanding of useState - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Why don&amp;rsquo;t function components before react 16 have state? As you know, function components did not have state before react 16, and component state could only be passed through props. Write two simple components, a class component and a function component. 1 2 3 4 5 6 7 8 9 10 11 12 13 const App = () =&amp;gt;&amp;lt;span&amp;gt;123&amp;lt;/span&amp;gt;; class App1 extends React.Component { constructor(props) { super(props); this.state = {" /><meta name="keywords" content="React, useState" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-02/react-usestate/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="In-depth understanding of useState" />
<meta property="og:description" content="Why don&rsquo;t function components before react 16 have state? As you know, function components did not have state before react 16, and component state could only be passed through props. Write two simple components, a class component and a function component. 1 2 3 4 5 6 7 8 9 10 11 12 13 const App = () =&gt;&lt;span&gt;123&lt;/span&gt;; class App1 extends React.Component { constructor(props) { super(props); this.state = {" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-02/react-usestate/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-02-25T09:54:20+08:00" />
<meta property="article:modified_time" content="2022-02-25T09:54:20+08:00" />

<meta itemprop="name" content="In-depth understanding of useState">
<meta itemprop="description" content="Why don&rsquo;t function components before react 16 have state? As you know, function components did not have state before react 16, and component state could only be passed through props. Write two simple components, a class component and a function component. 1 2 3 4 5 6 7 8 9 10 11 12 13 const App = () =&gt;&lt;span&gt;123&lt;/span&gt;; class App1 extends React.Component { constructor(props) { super(props); this.state = {"><meta itemprop="datePublished" content="2022-02-25T09:54:20+08:00" />
<meta itemprop="dateModified" content="2022-02-25T09:54:20+08:00" />
<meta itemprop="wordCount" content="3867">
<meta itemprop="keywords" content="react," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="In-depth understanding of useState"/>
<meta name="twitter:description" content="Why don&rsquo;t function components before react 16 have state? As you know, function components did not have state before react 16, and component state could only be passed through props. Write two simple components, a class component and a function component. 1 2 3 4 5 6 7 8 9 10 11 12 13 const App = () =&gt;&lt;span&gt;123&lt;/span&gt;; class App1 extends React.Component { constructor(props) { super(props); this.state = {"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">In-depth understanding of useState</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-02-25 09:54:20 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 3867 words </span>
          <span class="more-meta"> 8 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#why-dont-function-components-before-react-16-have-state">Why don&rsquo;t function components before react 16 have state?</a></li>
        <li><a href="#why-do-function-components-have-state-after-react-16">Why do function components have state after react 16?</a></li>
        <li><a href="#how-does-react-know-which-component-the-current-state-belongs-to">How does react know which component the current state belongs to?</a></li>
        <li><a href="#what-happens-when-the-seta-method-is-called">What happens when the setA method is called?</a></li>
        <li><a href="#why-do-function-components-sometimes-get-a-state-that-is-not-real-time">Why do function components sometimes get a state that is not real-time?</a></li>
        <li><a href="#why-cant-usestate-be-declared-in-a-judgment-statement">Why can&rsquo;t useState be declared in a judgment statement?</a></li>
        <li><a href="#why-does-state-need-to-be-associated-with-a-linked-table">Why does state need to be associated with a linked table?</a></li>
        <li><a href="#conclusion">Conclusion</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="why-dont-function-components-before-react-16-have-state">Why don&rsquo;t function components before react 16 have state?</h2>
<p>As you know, function components did not have state before react 16, and component state could only be passed through <code>props</code>.</p>
<p>Write two simple components, a class component and a function component.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">App</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span><span class="o">&lt;</span><span class="nx">span</span><span class="o">&gt;</span><span class="mi">123</span><span class="o">&lt;</span><span class="err">/span&gt;;</span>

<span class="kr">class</span> <span class="nx">App1</span> <span class="kr">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
  <span class="nx">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">super</span><span class="p">(</span><span class="nx">props</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="mi">312</span><span class="o">&lt;</span><span class="err">/p&gt;)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Compile <code>App1</code> with babel, and <code>App1</code> is a function component after compilation.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="c1">// 伪代码
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">App1</span> <span class="o">=</span> <span class="cm">/*#__PURE__*/</span><span class="kd">function</span> <span class="p">(</span><span class="nx">_React$Component</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">_inherits</span><span class="p">(</span><span class="nx">App1</span><span class="p">,</span> <span class="nx">_React$Component</span><span class="p">);</span>

  <span class="kd">var</span> <span class="nx">_super</span> <span class="o">=</span> <span class="nx">_createSuper</span><span class="p">(</span><span class="nx">App1</span><span class="p">);</span>

  <span class="kd">function</span> <span class="nx">App1</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">_this</span><span class="p">;</span>

    <span class="nx">_classCallCheck</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">App1</span><span class="p">);</span>

    <span class="nx">_this</span> <span class="o">=</span> <span class="nx">_super</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">props</span><span class="p">);</span>
    <span class="nx">_this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">a</span><span class="o">:</span> <span class="mi">1</span>
    <span class="p">};</span>
    <span class="k">return</span> <span class="nx">_this</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nx">_createClass</span><span class="p">(</span><span class="nx">App1</span><span class="p">,</span> <span class="p">[{</span>
    <span class="nx">key</span><span class="o">:</span> <span class="s2">&#34;render&#34;</span><span class="p">,</span>
    <span class="nx">value</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span><span class="cm">/*#__PURE__*/</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">_jsxRuntime</span><span class="p">.</span><span class="nx">jsx</span><span class="p">)(</span><span class="s2">&#34;p&#34;</span><span class="p">,</span> <span class="p">{</span>
        <span class="nx">children</span><span class="o">:</span> <span class="s2">&#34;312&#34;</span>
      <span class="p">});</span>
    <span class="p">}</span>
  <span class="p">}]);</span>

  <span class="k">return</span> <span class="nx">App1</span><span class="p">;</span>
<span class="p">}(</span><span class="nx">React</span><span class="p">.</span><span class="nx">Component</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>So why don&rsquo;t function components have state? The difference between a function component and a class component is whether or not there is a <code>render</code> method on the prototype. react calls the <code>render</code> method of the class component when it renders. The <code>render</code> of a function component is the function itself, and after it is executed, the internal variables are destroyed, so when the <code>component is re-rendered</code>, the previous state is not available. Unlike function components, class components generate an instance of a class component when they are rendered for the first time, and the render method is called render. When it is re-rendered, the instance reference of the class component is obtained and the corresponding method of the class component is called at a different life cycle.</p>
<p>There is also no difference between the class component and the function component in terms of their data structures after rendering.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/25/c0b2bb37d39244448b19061125fb2351.png" alt="react"></p>
<h2 id="why-do-function-components-have-state-after-react-16">Why do function components have state after react 16?</h2>
<p>As we all know, the biggest change made in react 16 is the fiber, and the data structure of the node (<code>fiber node</code>) has been changed significantly to fit the fiber. Modify the <code>App</code> component, render it on the page, and get the <code>fiber node</code> data structure as shown below.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">App</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="nx">setA</span><span class="p">]</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="kr">const</span> <span class="p">[</span><span class="nx">b</span><span class="p">,</span> <span class="nx">setB</span><span class="p">]</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">useState</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="k">return</span><span class="o">&lt;</span><span class="nx">span</span><span class="o">&gt;</span><span class="mi">123</span><span class="o">&lt;</span><span class="err">/span&gt;</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/25/48f2ebf2c2e845c6969721a15390fc20.png" alt="fiber node"></p>
<p>(function component on the left, class component on the right)</p>
<h2 id="how-does-react-know-which-component-the-current-state-belongs-to">How does react know which component the current state belongs to?</h2>
<p>All function component states are injected through useState, how do you identify the corresponding component?</p>
<p>A breakpoint in the <code>render</code> flow of react shows that function components have a special <code>render</code> method <code>renderWithHooks</code>. The method has 6 parameters: <code>current</code>, <code>workInProgress</code>, <code>component</code>, <code>props</code>, <code>secondArg</code>, <code>nextRenderExpirationTime</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">current: 当前正在页面渲染的node，如果是第一次渲染，则为空
workInProgress: 新的node，用于下一次页面的渲染更新
component: node对应的组件
props: 组件的props
secondArg: 不清楚...，不影响后续文章阅读
nextRenderExpirationTime: fiber渲染的过期时间
</code></pre></td></tr></table>
</div>
</div><p>When executing <code>renderWithHooks</code>, the current <code>fiber node</code> is recorded with the variable <code>currentlyRenderingFiber$1</code>. So when the function component is executed, the <code>useState</code> method gets the state of the current <code>node</code>. The state is inserted into the <code>memoizedState</code> field of the corresponding <code>node</code>. The returned method that triggered the <code>state</code> change also knows which <code>fiber node</code> it is when the change is executed because of the closure. The corresponding source code is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">mountState</span><span class="p">(</span><span class="nx">initialState</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 获取hook状态
</span><span class="c1"></span>  <span class="kd">var</span> <span class="nx">hook</span> <span class="o">=</span> <span class="nx">mountWorkInProgressHook</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">initialState</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// $FlowFixMe: Flow doesn&#39;t like mixed types
</span><span class="c1"></span>    <span class="nx">initialState</span> <span class="o">=</span> <span class="nx">initialState</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="nx">hook</span><span class="p">.</span><span class="nx">memoizedState</span> <span class="o">=</span> <span class="nx">hook</span><span class="p">.</span><span class="nx">baseState</span> <span class="o">=</span> <span class="nx">initialState</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">queue</span> <span class="o">=</span> <span class="nx">hook</span><span class="p">.</span><span class="nx">queue</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">pending</span><span class="o">:</span> <span class="kc">null</span><span class="p">,</span>
    <span class="nx">dispatch</span><span class="o">:</span> <span class="kc">null</span><span class="p">,</span>
    <span class="nx">lastRenderedReducer</span><span class="o">:</span> <span class="nx">basicStateReducer</span><span class="p">,</span>
    <span class="nx">lastRenderedState</span><span class="o">:</span> <span class="nx">initialState</span>
  <span class="p">};</span>
  <span class="c1">// 绑定当前node和更新队列
</span><span class="c1"></span>  <span class="kd">var</span> <span class="nx">dispatch</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">dispatch</span> <span class="o">=</span> <span class="nx">dispatchAction</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">currentlyRenderingFiber$1</span><span class="p">,</span> <span class="nx">queue</span><span class="p">);</span>
  <span class="k">return</span> <span class="p">[</span><span class="nx">hook</span><span class="p">.</span><span class="nx">memoizedState</span><span class="p">,</span> <span class="nx">dispatch</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p><code>renderWithHooks</code> is only used for rendering function components.</p>
</blockquote>
<p>The value of the <code>memoizeState</code> field shows that the <code>state</code> of the function component and the class component store different data structures. Class components are simple data objects, while function components are one-way chained tables.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">interface</span> <span class="nx">State</span> <span class="p">{</span>
    <span class="nx">memoizedState</span><span class="o">:</span> <span class="nx">state数据</span><span class="err">，</span><span class="nx">和baseState值相同</span><span class="p">,</span>
  <span class="nx">baseState</span><span class="o">:</span> <span class="nx">state数据</span><span class="p">,</span>
  <span class="nx">baseQueue</span><span class="o">:</span> <span class="nx">本次更新之前没执行完的queue</span><span class="p">,</span>
  <span class="nx">next</span><span class="o">:</span> <span class="nx">下一个state</span><span class="p">,</span>
  <span class="nx">queue</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">pending</span><span class="o">:</span> <span class="nx">更新state数据</span><span class="err">（</span><span class="nx">这个数据是一个对象</span><span class="err">，</span><span class="nx">里面有数据</span><span class="err">，</span><span class="nx">还有其他key用于做其他事情</span><span class="err">。）</span><span class="p">,</span>
    <span class="nx">dispatch</span><span class="o">:</span> <span class="nx">setState方法本身</span><span class="p">,</span>
    <span class="nx">lastRenderedReducer</span><span class="o">:</span> <span class="nx">useReducer用得上</span><span class="p">,</span>
    <span class="nx">lastRenderedState</span><span class="o">:</span> <span class="nx">上次渲染的State</span><span class="p">.</span><span class="nx">memoizedState数据</span><span class="p">,</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="what-happens-when-the-seta-method-is-called">What happens when the setA method is called?</h2>
<p>Before we talk about updating the component <code>state</code>, let&rsquo;s look at the flow of the component mount.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/25/1a733fc8db7644bfbf4eacf19d2d3674.png" alt="state"></p>
<p>When <code>useState</code> is called, the <code>currentlyRenderingFiber$1</code> is used to get the <code>fiber node</code> of the current component and mount the data to the <code>memoizedState</code> field on the node. This way the function component has a state.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="c1">// react
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">useState</span><span class="p">(</span><span class="nx">initialState</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">dispatcher</span> <span class="o">=</span> <span class="nx">resolveDispatcher</span><span class="p">();</span>
  <span class="k">return</span> <span class="nx">dispatcher</span><span class="p">.</span><span class="nx">useState</span><span class="p">(</span><span class="nx">initialState</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">resolveDispatcher</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ReactCurrentDispatcher 的值是react-dom注入的，后续会讲。
</span><span class="c1"></span>  <span class="kd">var</span> <span class="nx">dispatcher</span> <span class="o">=</span> <span class="nx">ReactCurrentDispatcher</span><span class="p">.</span><span class="nx">current</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="nx">dispatcher</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">))</span> <span class="p">{</span>
    <span class="p">{</span>
      <span class="nx">throwError</span><span class="p">(</span> <span class="s2">&#34;Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://fb.me/react-invalid-hook-call for tips about how to debug and fix this problem.&#34;</span> <span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">dispatcher</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// react-dom 会根据当前组件的状态注入不同的useState实现方法，这里可以先忽略。
</span><span class="c1"></span><span class="nx">useState</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">initialState</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">currentHookNameInDev</span> <span class="o">=</span> <span class="s1">&#39;useState&#39;</span><span class="p">;</span>
  <span class="nx">mountHookTypesDev</span><span class="p">();</span>
  <span class="kd">var</span> <span class="nx">prevDispatcher</span> <span class="o">=</span> <span class="nx">ReactCurrentDispatcher</span><span class="p">.</span><span class="nx">current</span><span class="p">;</span>
  <span class="nx">ReactCurrentDispatcher</span><span class="p">.</span><span class="nx">current</span> <span class="o">=</span> <span class="nx">InvalidNestedHooksDispatcherOnMountInDEV</span><span class="p">;</span>

  <span class="k">try</span> <span class="p">{</span>
  <span class="c1">// 挂载state
</span><span class="c1"></span>    <span class="k">return</span> <span class="nx">mountState</span><span class="p">(</span><span class="nx">initialState</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
    <span class="nx">ReactCurrentDispatcher</span><span class="p">.</span><span class="nx">current</span> <span class="o">=</span> <span class="nx">prevDispatcher</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">},</span>

<span class="kd">function</span> <span class="nx">mountState</span><span class="p">(</span><span class="nx">initialState</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 生成hook初始化数据，挂到fiber node节点上
</span><span class="c1"></span>  <span class="kd">var</span> <span class="nx">hook</span> <span class="o">=</span> <span class="nx">mountWorkInProgressHook</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">initialState</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// $FlowFixMe: Flow doesn&#39;t like mixed types
</span><span class="c1"></span>    <span class="nx">initialState</span> <span class="o">=</span> <span class="nx">initialState</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="nx">hook</span><span class="p">.</span><span class="nx">memoizedState</span> <span class="o">=</span> <span class="nx">hook</span><span class="p">.</span><span class="nx">baseState</span> <span class="o">=</span> <span class="nx">initialState</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">queue</span> <span class="o">=</span> <span class="nx">hook</span><span class="p">.</span><span class="nx">queue</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">pending</span><span class="o">:</span> <span class="kc">null</span><span class="p">,</span>
    <span class="nx">dispatch</span><span class="o">:</span> <span class="kc">null</span><span class="p">,</span>
    <span class="nx">lastRenderedReducer</span><span class="o">:</span> <span class="nx">basicStateReducer</span><span class="p">,</span>
    <span class="nx">lastRenderedState</span><span class="o">:</span> <span class="nx">initialState</span>
  <span class="p">};</span>
  <span class="kd">var</span> <span class="nx">dispatch</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">dispatch</span> <span class="o">=</span> <span class="nx">dispatchAction</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">currentlyRenderingFiber$1</span><span class="p">,</span> <span class="nx">queue</span><span class="p">);</span>
  <span class="k">return</span> <span class="p">[</span><span class="nx">hook</span><span class="p">.</span><span class="nx">memoizedState</span><span class="p">,</span> <span class="nx">dispatch</span><span class="p">];</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">mountWorkInProgressHook</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">hook</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">memoizedState</span><span class="o">:</span> <span class="kc">null</span><span class="p">,</span>
    <span class="nx">baseState</span><span class="o">:</span> <span class="kc">null</span><span class="p">,</span>
    <span class="nx">baseQueue</span><span class="o">:</span> <span class="kc">null</span><span class="p">,</span>
    <span class="nx">queue</span><span class="o">:</span> <span class="kc">null</span><span class="p">,</span>
    <span class="nx">next</span><span class="o">:</span> <span class="kc">null</span>
  <span class="p">};</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">workInProgressHook</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// node节点的memoizedState指向第一个hooks
</span><span class="c1"></span>    <span class="nx">currentlyRenderingFiber$1</span><span class="p">.</span><span class="nx">memoizedState</span> <span class="o">=</span> <span class="nx">workInProgressHook</span> <span class="o">=</span> <span class="nx">hook</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// 上一个hooks的next，等于当前hooks，同时把当前workInProgressHook，等于当前hooks
</span><span class="c1"></span>    <span class="nx">workInProgressHook</span> <span class="o">=</span> <span class="nx">workInProgressHook</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">hook</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">workInProgressHook</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>useState</code> also returns the corresponding <code>state</code> and a method to modify <code>state</code>. The method <code>dispatchAction</code> that modifies <code>state</code> is bound to the current <code>fiber node</code>, along with the <code>action queue</code> that updates the current state.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="c1">// 这里删除了部分无关代码
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">dispatchAction</span><span class="p">(</span><span class="nx">fiber</span><span class="p">,</span> <span class="nx">queue</span><span class="p">,</span> <span class="nx">action</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 这些都是用于Fiber Reconciler，在这里不用太在意
</span><span class="c1"></span>  <span class="kd">var</span> <span class="nx">currentTime</span> <span class="o">=</span> <span class="nx">requestCurrentTimeForUpdate</span><span class="p">();</span>
  <span class="kd">var</span> <span class="nx">suspenseConfig</span> <span class="o">=</span> <span class="nx">requestCurrentSuspenseConfig</span><span class="p">();</span>
  <span class="kd">var</span> <span class="nx">expirationTime</span> <span class="o">=</span> <span class="nx">computeExpirationForFiber</span><span class="p">(</span><span class="nx">currentTime</span><span class="p">,</span> <span class="nx">fiber</span><span class="p">,</span> <span class="nx">suspenseConfig</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">update</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">expirationTime</span><span class="o">:</span> <span class="nx">expirationTime</span><span class="p">,</span>
    <span class="nx">suspenseConfig</span><span class="o">:</span> <span class="nx">suspenseConfig</span><span class="p">,</span>
    <span class="nx">action</span><span class="o">:</span> <span class="nx">action</span><span class="p">,</span>
    <span class="nx">eagerReducer</span><span class="o">:</span> <span class="kc">null</span><span class="p">,</span>
    <span class="nx">eagerState</span><span class="o">:</span> <span class="kc">null</span><span class="p">,</span>
    <span class="nx">next</span><span class="o">:</span> <span class="kc">null</span>
  <span class="p">};</span>
  <span class="p">{</span>
    <span class="nx">update</span><span class="p">.</span><span class="nx">priority</span> <span class="o">=</span> <span class="nx">getCurrentPriorityLevel</span><span class="p">();</span>
  <span class="p">}</span>


  <span class="c1">// pending 是当前state是否有未更新的任务（比如多次调用更新state的方法）
</span><span class="c1"></span>  <span class="kd">var</span> <span class="nx">pending</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">pending</span><span class="p">;</span>

  <span class="c1">// queue是一个循环链表
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nx">pending</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">update</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">update</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">update</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">pending</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
    <span class="nx">pending</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">update</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nx">queue</span><span class="p">.</span><span class="nx">pending</span> <span class="o">=</span> <span class="nx">update</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">alternate</span> <span class="o">=</span> <span class="nx">fiber</span><span class="p">.</span><span class="nx">alternate</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">fiber</span> <span class="o">===</span> <span class="nx">currentlyRenderingFiber$1</span> <span class="o">||</span> <span class="nx">alternate</span> <span class="o">!==</span> <span class="kc">null</span> <span class="o">&amp;</span><span class="nx">amp</span><span class="p">;</span><span class="o">&amp;</span><span class="nx">amp</span><span class="p">;</span> <span class="nx">alternate</span> <span class="o">===</span> <span class="nx">currentlyRenderingFiber$1</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Reconciler 计算是否还有时间渲染，省略
</span><span class="c1"></span>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// 此处省略很多代码
</span><span class="c1"></span>    <span class="c1">// 标记当前fiber node需要重新计算。
</span><span class="c1"></span>    <span class="nx">scheduleWork</span><span class="p">(</span><span class="nx">fiber</span><span class="p">,</span> <span class="nx">expirationTime</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>As you can see from the above code, when the <code>setA</code> method is called to update the component state, the data to be updated is generated, wrapped in a data structure and pushed to the <code>queue</code> in the <code>state</code>.</p>
<p><code>scheduleWork</code> will trigger the react update, so that the component needs to be re-rendered. The overall process is basically the same as when it was first mounted, but the implementation of the <code>mountState</code> method body shows that the component is rendered using <code>initialState</code>. This is definitely problematic.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kd">function</span> <span class="nx">mountState</span><span class="p">(</span><span class="nx">initialState</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 挂载state
</span><span class="c1"></span>  <span class="kd">var</span> <span class="nx">hook</span> <span class="o">=</span> <span class="nx">mountWorkInProgressHook</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">initialState</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">initialState</span> <span class="o">=</span> <span class="nx">initialState</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// state的初始值是initialState，也就是组件传入的值
</span><span class="c1"></span>  <span class="nx">hook</span><span class="p">.</span><span class="nx">memoizedState</span> <span class="o">=</span> <span class="nx">hook</span><span class="p">.</span><span class="nx">baseState</span> <span class="o">=</span> <span class="nx">initialState</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">queue</span> <span class="o">=</span> <span class="nx">hook</span><span class="p">.</span><span class="nx">queue</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">pending</span><span class="o">:</span> <span class="kc">null</span><span class="p">,</span>
    <span class="nx">dispatch</span><span class="o">:</span> <span class="kc">null</span><span class="p">,</span>
    <span class="nx">lastRenderedReducer</span><span class="o">:</span> <span class="nx">basicStateReducer</span><span class="p">,</span>
    <span class="nx">lastRenderedState</span><span class="o">:</span> <span class="nx">initialState</span>
  <span class="p">};</span>
  <span class="kd">var</span> <span class="nx">dispatch</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">dispatch</span> <span class="o">=</span> <span class="nx">dispatchAction</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">currentlyRenderingFiber$1</span><span class="p">,</span> <span class="nx">queue</span><span class="p">);</span>
  <span class="k">return</span> <span class="p">[</span><span class="nx">hook</span><span class="p">.</span><span class="nx">memoizedState</span><span class="p">,</span> <span class="nx">dispatch</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>From this, we can infer that in the previous step, there must be an implementation method that indicates that the current component is not initially mounted and needs to be replaced with <code>useState</code>. The answer is found in <code>renderWithHooks</code>.</p>
<blockquote>
<p>To make it easier to understand, there are two key pieces of data in react: current and workInProgress, which represent the fiber node rendered by the current page, and the fiber node that calculates the difference after the update is triggered. for rendering.</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="c1">// 这里删除部分无关代码
</span><span class="c1"></span>
<span class="c1">// current 当前页面上组件对应的fiber node
</span><span class="c1">// workInProgress 当前重新渲染对应的fiber node
</span><span class="c1">// Component 函数方法体
</span><span class="c1">// ...
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">renderWithHooks</span><span class="p">(</span><span class="nx">current</span><span class="p">,</span> <span class="nx">workInProgress</span><span class="p">,</span> <span class="nx">Component</span><span class="p">,</span> <span class="nx">props</span><span class="p">,</span> <span class="nx">secondArg</span><span class="p">,</span> <span class="nx">nextRenderExpirationTime</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// currentlyRenderingFiber$1 是当前正在渲染的组件，后续渲染流程会从改变量获取state
</span><span class="c1"></span>  <span class="nx">currentlyRenderingFiber$1</span> <span class="o">=</span> <span class="nx">workInProgress</span><span class="p">;</span>


  <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">memoizedState</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
  <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">updateQueue</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
  <span class="nx">workInProgress</span><span class="p">.</span><span class="nx">expirationTime</span> <span class="o">=</span> <span class="nx">NoWork</span><span class="p">;</span> <span class="c1">// The following should have already been reset
</span><span class="c1"></span>  <span class="c1">// currentHook = null;
</span><span class="c1"></span>  <span class="c1">// workInProgressHook = null;
</span><span class="c1"></span>  <span class="c1">// didScheduleRenderPhaseUpdate = false;
</span><span class="c1"></span>  <span class="c1">// TODO Warn if no hooks are used at all during mount, then some are used during update.
</span><span class="c1"></span>  <span class="c1">// Currently we will identify the update render as a mount because memoizedState === null.
</span><span class="c1"></span>  <span class="c1">// This is tricky because it&#39;s valid for certain types of components (e.g. React.lazy)
</span><span class="c1"></span>  <span class="c1">// Using memoizedState to differentiate between mount/update only works if at least one stateful hook is used.
</span><span class="c1"></span>  <span class="c1">// Non-stateful hooks (e.g. context) don&#39;t get added to memoizedState,
</span><span class="c1"></span>  <span class="c1">// so memoizedState would be null during updates and mounts.
</span><span class="c1"></span>
  <span class="p">{</span>
    <span class="c1">// 如果当前current不为null，且有state，说明当前组件是更新，需要执行的更新state，否则就是初次挂载。
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">current</span> <span class="o">!==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="nx">current</span><span class="p">.</span><span class="nx">memoizedState</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">ReactCurrentDispatcher</span><span class="p">.</span><span class="nx">current</span> <span class="o">=</span> <span class="nx">HooksDispatcherOnUpdateInDEV</span><span class="p">;</span>
    <span class="p">}</span> <span class="nx">elseif</span> <span class="p">(</span><span class="nx">hookTypesDev</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// This dispatcher handles an edge case where a component is updating,
</span><span class="c1"></span>      <span class="c1">// but no stateful hooks have been used.
</span><span class="c1"></span>      <span class="c1">// We want to match the production code behavior (which will use HooksDispatcherOnMount),
</span><span class="c1"></span>      <span class="c1">// but with the extra DEV validation to ensure hooks ordering hasn&#39;t changed.
</span><span class="c1"></span>      <span class="c1">// This dispatcher does that.
</span><span class="c1"></span>      <span class="nx">ReactCurrentDispatcher</span><span class="p">.</span><span class="nx">current</span> <span class="o">=</span> <span class="nx">HooksDispatcherOnMountWithHookTypesInDEV</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">ReactCurrentDispatcher</span><span class="p">.</span><span class="nx">current</span> <span class="o">=</span> <span class="nx">HooksDispatcherOnMountInDEV</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// 往后省略
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>In the <code>renderWithHooks</code> method, the <code>ReactCurrentDispatcher</code> is modified, which results in a different method body corresponding to <code>useState</code>. The <code>useState</code> method call in <code>HooksDispatcherOnUpdateInDEV</code> is <code>updateState</code>. This method ignores <code>initState</code> and chooses to get the current state from the <code>state</code> of the <code>fiber node</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">useState</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">initialState</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">currentHookNameInDev</span> <span class="o">=</span> <span class="s1">&#39;useState&#39;</span><span class="p">;</span>
  <span class="nx">updateHookTypesDev</span><span class="p">();</span>
  <span class="kd">var</span> <span class="nx">prevDispatcher</span> <span class="o">=</span> <span class="nx">ReactCurrentDispatcher</span><span class="p">.</span><span class="nx">current</span><span class="p">;</span>
  <span class="nx">ReactCurrentDispatcher</span><span class="p">.</span><span class="nx">current</span> <span class="o">=</span> <span class="nx">InvalidNestedHooksDispatcherOnUpdateInDEV</span><span class="p">;</span>

  <span class="k">try</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">updateState</span><span class="p">(</span><span class="nx">initialState</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
    <span class="nx">ReactCurrentDispatcher</span><span class="p">.</span><span class="nx">current</span> <span class="o">=</span> <span class="nx">prevDispatcher</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">},</span>

<span class="kd">function</span> <span class="nx">updateState</span><span class="p">(</span><span class="nx">initialState</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">updateReducer</span><span class="p">(</span><span class="nx">basicStateReducer</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">updateReducer</span><span class="p">(</span><span class="nx">reducer</span><span class="p">,</span> <span class="nx">initialArg</span><span class="p">,</span> <span class="nx">init</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 根据之前的state初始化新的state结构，具体方法在下面
</span><span class="c1"></span>  <span class="kd">var</span> <span class="nx">hook</span> <span class="o">=</span> <span class="nx">updateWorkInProgressHook</span><span class="p">();</span>
  <span class="c1">// 当前更新state的队列
</span><span class="c1"></span>  <span class="kd">var</span> <span class="nx">queue</span> <span class="o">=</span> <span class="nx">hook</span><span class="p">.</span><span class="nx">queue</span><span class="p">;</span>

  <span class="nx">queue</span><span class="p">.</span><span class="nx">lastRenderedReducer</span> <span class="o">=</span> <span class="nx">reducer</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">current</span> <span class="o">=</span> <span class="nx">currentHook</span><span class="p">;</span> <span class="c1">// The last rebase update that is NOT part of the base state.
</span><span class="c1"></span>
  <span class="kd">var</span> <span class="nx">baseQueue</span> <span class="o">=</span> <span class="nx">current</span><span class="p">.</span><span class="nx">baseQueue</span><span class="p">;</span> <span class="c1">// The last pending update that hasn&#39;t been processed yet.
</span><span class="c1"></span>
  <span class="kd">var</span> <span class="nx">pendingQueue</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">pending</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">pendingQueue</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// We have new updates that haven&#39;t been processed yet.
</span><span class="c1"></span>    <span class="c1">// We&#39;ll add them to the base queue.
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nx">baseQueue</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Merge the pending queue and the base queue.
</span><span class="c1"></span>      <span class="kd">var</span> <span class="nx">baseFirst</span> <span class="o">=</span> <span class="nx">baseQueue</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">pendingFirst</span> <span class="o">=</span> <span class="nx">pendingQueue</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
      <span class="nx">baseQueue</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">pendingFirst</span><span class="p">;</span>
      <span class="nx">pendingQueue</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">baseFirst</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">current</span><span class="p">.</span><span class="nx">baseQueue</span> <span class="o">=</span> <span class="nx">baseQueue</span> <span class="o">=</span> <span class="nx">pendingQueue</span><span class="p">;</span>
    <span class="nx">queue</span><span class="p">.</span><span class="nx">pending</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">baseQueue</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// We have a queue to process.
</span><span class="c1"></span>    <span class="kd">var</span> <span class="nx">first</span> <span class="o">=</span> <span class="nx">baseQueue</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">newState</span> <span class="o">=</span> <span class="nx">current</span><span class="p">.</span><span class="nx">baseState</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">newBaseState</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">newBaseQueueFirst</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">newBaseQueueLast</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">update</span> <span class="o">=</span> <span class="nx">first</span><span class="p">;</span>

    <span class="k">do</span> <span class="p">{</span>
      <span class="c1">// fiber Reconciler 的内容，省略
</span><span class="c1"></span>      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// This update does have sufficient priority.
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="nx">newBaseQueueLast</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">_clone</span> <span class="o">=</span> <span class="p">{</span>
            <span class="nx">expirationTime</span><span class="o">:</span> <span class="nx">Sync</span><span class="p">,</span>
            <span class="c1">// This update is going to be committed so we never want uncommit it.
</span><span class="c1"></span>            <span class="nx">suspenseConfig</span><span class="o">:</span> <span class="nx">update</span><span class="p">.</span><span class="nx">suspenseConfig</span><span class="p">,</span>
            <span class="nx">action</span><span class="o">:</span> <span class="nx">update</span><span class="p">.</span><span class="nx">action</span><span class="p">,</span>
            <span class="nx">eagerReducer</span><span class="o">:</span> <span class="nx">update</span><span class="p">.</span><span class="nx">eagerReducer</span><span class="p">,</span>
            <span class="nx">eagerState</span><span class="o">:</span> <span class="nx">update</span><span class="p">.</span><span class="nx">eagerState</span><span class="p">,</span>
            <span class="nx">next</span><span class="o">:</span> <span class="kc">null</span>
          <span class="p">};</span>
          <span class="nx">newBaseQueueLast</span> <span class="o">=</span> <span class="nx">newBaseQueueLast</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">_clone</span><span class="p">;</span>
        <span class="p">}</span> <span class="c1">// Mark the event time of this update as relevant to this render pass.
</span><span class="c1"></span>        <span class="c1">// TODO: This should ideally use the true event time of this update rather than
</span><span class="c1"></span>        <span class="c1">// its priority which is a derived and not reverseable value.
</span><span class="c1"></span>        <span class="c1">// TODO: We should skip this update if it was already committed but currently
</span><span class="c1"></span>        <span class="c1">// we have no way of detecting the difference between a committed and suspended
</span><span class="c1"></span>        <span class="c1">// update here.
</span><span class="c1"></span>

        <span class="nx">markRenderEventTimeAndConfig</span><span class="p">(</span><span class="nx">updateExpirationTime</span><span class="p">,</span> <span class="nx">update</span><span class="p">.</span><span class="nx">suspenseConfig</span><span class="p">);</span> <span class="c1">// Process this update.
</span><span class="c1"></span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">update</span><span class="p">.</span><span class="nx">eagerReducer</span> <span class="o">===</span> <span class="nx">reducer</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// If this update was processed eagerly, and its reducer matches the
</span><span class="c1"></span>          <span class="c1">// current reducer, we can use the eagerly computed state.
</span><span class="c1"></span>          <span class="nx">newState</span> <span class="o">=</span> <span class="nx">update</span><span class="p">.</span><span class="nx">eagerState</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                  <span class="c1">// 执行状态更新，reducer是个包装函数：typeof action === &#39;function&#39; ? action(state) : action;
</span><span class="c1"></span>          <span class="kd">var</span> <span class="nx">action</span> <span class="o">=</span> <span class="nx">update</span><span class="p">.</span><span class="nx">action</span><span class="p">;</span>
          <span class="nx">newState</span> <span class="o">=</span> <span class="nx">reducer</span><span class="p">(</span><span class="nx">newState</span><span class="p">,</span> <span class="nx">action</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>

      <span class="nx">update</span> <span class="o">=</span> <span class="nx">update</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="nx">update</span> <span class="o">!==</span> <span class="kc">null</span> <span class="o">&amp;</span><span class="nx">amp</span><span class="p">;</span><span class="o">&amp;</span><span class="nx">amp</span><span class="p">;</span> <span class="nx">update</span> <span class="o">!==</span> <span class="nx">first</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">newBaseQueueLast</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">newBaseState</span> <span class="o">=</span> <span class="nx">newState</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">newBaseQueueLast</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">newBaseQueueFirst</span><span class="p">;</span>
    <span class="p">}</span> <span class="c1">// Mark that the fiber performed work, but only if the new state is
</span><span class="c1"></span>    <span class="c1">// different from the current state.
</span><span class="c1"></span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">objectIs</span><span class="p">(</span><span class="nx">newState</span><span class="p">,</span> <span class="nx">hook</span><span class="p">.</span><span class="nx">memoizedState</span><span class="p">))</span> <span class="p">{</span>
      <span class="nx">markWorkInProgressReceivedUpdate</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="nx">hook</span><span class="p">.</span><span class="nx">memoizedState</span> <span class="o">=</span> <span class="nx">newState</span><span class="p">;</span>
    <span class="nx">hook</span><span class="p">.</span><span class="nx">baseState</span> <span class="o">=</span> <span class="nx">newBaseState</span><span class="p">;</span>
    <span class="nx">hook</span><span class="p">.</span><span class="nx">baseQueue</span> <span class="o">=</span> <span class="nx">newBaseQueueLast</span><span class="p">;</span>
    <span class="nx">queue</span><span class="p">.</span><span class="nx">lastRenderedState</span> <span class="o">=</span> <span class="nx">newState</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">dispatch</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">dispatch</span><span class="p">;</span>
  <span class="k">return</span> <span class="p">[</span><span class="nx">hook</span><span class="p">.</span><span class="nx">memoizedState</span><span class="p">,</span> <span class="nx">dispatch</span><span class="p">];</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">updateWorkInProgressHook</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">nextCurrentHook</span><span class="p">;</span>

  <span class="c1">// 当前
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="nx">currentHook</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// alternate 指向的是当前页面渲染组件对应fiber node
</span><span class="c1"></span>    <span class="kd">var</span> <span class="nx">current</span> <span class="o">=</span> <span class="nx">currentlyRenderingFiber$1</span><span class="p">.</span><span class="nx">alternate</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">current</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">nextCurrentHook</span> <span class="o">=</span> <span class="nx">current</span><span class="p">.</span><span class="nx">memoizedState</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">nextCurrentHook</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">nextCurrentHook</span> <span class="o">=</span> <span class="nx">currentHook</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">nextWorkInProgressHook</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">workInProgressHook</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">nextWorkInProgressHook</span> <span class="o">=</span> <span class="nx">currentlyRenderingFiber$1</span><span class="p">.</span><span class="nx">memoizedState</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">nextWorkInProgressHook</span> <span class="o">=</span> <span class="nx">workInProgressHook</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">nextWorkInProgressHook</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// There&#39;s already a work-in-progress. Reuse it.
</span><span class="c1"></span>    <span class="nx">workInProgressHook</span> <span class="o">=</span> <span class="nx">nextWorkInProgressHook</span><span class="p">;</span>
    <span class="nx">nextWorkInProgressHook</span> <span class="o">=</span> <span class="nx">workInProgressHook</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span>
    <span class="nx">currentHook</span> <span class="o">=</span> <span class="nx">nextCurrentHook</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// Clone from the current hook.
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="nx">nextCurrentHook</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">))</span> <span class="p">{</span>
      <span class="p">{</span>
        <span class="nx">throwError</span><span class="p">(</span> <span class="s2">&#34;Rendered more hooks than during the previous render.&#34;</span> <span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">currentHook</span> <span class="o">=</span> <span class="nx">nextCurrentHook</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">newHook</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">memoizedState</span><span class="o">:</span> <span class="nx">currentHook</span><span class="p">.</span><span class="nx">memoizedState</span><span class="p">,</span>
      <span class="nx">baseState</span><span class="o">:</span> <span class="nx">currentHook</span><span class="p">.</span><span class="nx">baseState</span><span class="p">,</span>
      <span class="nx">baseQueue</span><span class="o">:</span> <span class="nx">currentHook</span><span class="p">.</span><span class="nx">baseQueue</span><span class="p">,</span>
      <span class="nx">queue</span><span class="o">:</span> <span class="nx">currentHook</span><span class="p">.</span><span class="nx">queue</span><span class="p">,</span>
      <span class="nx">next</span><span class="o">:</span> <span class="kc">null</span>
    <span class="p">};</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">workInProgressHook</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
      
     <span class="c1">// 第一个hook currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;
</span><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// 下一个hooks，关联前一个hooks
</span><span class="c1"></span>      <span class="nx">workInProgressHook</span> <span class="o">=</span> <span class="nx">workInProgressHook</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">newHook</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">workInProgressHook</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>At this point, it&rsquo;s clear what react is doing internally by calling the <code>setA</code> method. <code>setA</code> inserts an <code>update action</code> into the <code>queue</code> of the current <code>state</code> and notifies react that there is a component state that needs to be updated. When updating, the method body of <code>useState</code> is different from the initial mounted method body, so when updating, it ignores the <code>initState</code> passed by <code>useState</code>, gets the initial data from the <code>baseState</code> of the node data, and executes the <code>update action</code> in the <code>queue</code> step by step until the queue is empty, or the queue is finished.</p>
<h2 id="why-do-function-components-sometimes-get-a-state-that-is-not-real-time">Why do function components sometimes get a state that is not real-time?</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">App3</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="p">[</span><span class="nx">num</span><span class="p">,</span> <span class="nx">setNum</span><span class="p">]</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="kr">const</span> <span class="nx">add</span> <span class="o">=</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="nx">setNum</span><span class="p">(</span><span class="nx">num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">},</span> <span class="mi">1000</span><span class="p">);</span>
  <span class="p">};</span>

  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;&gt;</span>
      <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">num</span><span class="p">}</span><span class="o">&lt;</span><span class="err">/div&gt;</span>
      <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">add</span><span class="p">}</span><span class="o">&gt;</span><span class="nx">add</span><span class="o">&lt;</span><span class="err">/button&gt;</span>
    <span class="o">&lt;</span><span class="err">/&gt;</span>
  <span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>When the button is clicked within one second, no matter how many times it is clicked, the final page return will be <code>1</code>. The reason: setTimeout closes the current state <code>num</code>, and when executing <code>update state</code>, the corresponding baseState has not been updated and is still old, i.e. <code>0</code>, so multiple clicks will still be <code>0 + 1 = 1</code>. The way to modify this is to change the argument passed in to a function, so that when react executes <code>queue</code>, the <code>state</code> value from the previous step is passed to the current function.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">setNum</span><span class="p">((</span><span class="nx">state</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">state</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="why-cant-usestate-be-declared-in-a-judgment-statement">Why can&rsquo;t useState be declared in a judgment statement?</h2>
<p>The official react website has this to say.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/25/25f7bf8211704456a5e30890d3dc4d75.png" alt="react"></p>
<p>Suppose there are 3 <code>states</code>, A, B, C. If B is in the judgment statement, then the states of A and B will be updated in time, but C will not be updated. Because 2 calls to <code>useState</code> will only update state twice, in the chain of state, A.next-&gt;B, B.next-&gt;C, then only A and B will be updated, C will not be updated, leading to some unpredictable problems.</p>
<h2 id="why-does-state-need-to-be-associated-with-a-linked-table">Why does state need to be associated with a linked table?</h2>
<p>I don&rsquo;t have an answer to this question, but the only thing I can parse is: it&rsquo;s for everything (pure) functions, right?</p>
<blockquote>
<p>state is still an object, and is updated by calling a method. This way and the class component in turn remains unified and better understood.</p>
</blockquote>
<h2 id="conclusion">Conclusion</h2>
<p>By reading the source code to understand the execution of <code>useState</code>, we can deepen our understanding of the react function component state update. Feel free to point out any shortcomings or mistakes.</p>
<blockquote>
<p>The parsing above is based on react@16, reac-dom@16.</p>
</blockquote>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/react/">react</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-02/seq-command-in-linux/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">The seq command in Linux</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-02/python-bugs-move-to-github/">
            <span class="next-text nav-default">Ditching the Official Site, Python Migrates All Bugs to GitHub</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
