<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Detailed breakdown of the Kafka architecture - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Basic Concepts Kafka Architecture The Kafka architecture consists of a number of Producers, a number of Brokers, a number of Consumers, and a ZooKeeper cluster. There are two other concepts that are particularly important in Kafka - Topic and Partition. Messages in Kafka are grouped by topic, producers are responsible for sending messages to a specific topic (each message sent to a Kafka cluster is assigned a topic), and consumers" /><meta name="keywords" content="Kafka Architecture" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-02/kafka-architecture/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Detailed breakdown of the Kafka architecture" />
<meta property="og:description" content="Basic Concepts Kafka Architecture The Kafka architecture consists of a number of Producers, a number of Brokers, a number of Consumers, and a ZooKeeper cluster. There are two other concepts that are particularly important in Kafka - Topic and Partition. Messages in Kafka are grouped by topic, producers are responsible for sending messages to a specific topic (each message sent to a Kafka cluster is assigned a topic), and consumers" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-02/kafka-architecture/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-02-13T12:21:57+08:00" />
<meta property="article:modified_time" content="2022-02-13T12:21:57+08:00" />

<meta itemprop="name" content="Detailed breakdown of the Kafka architecture">
<meta itemprop="description" content="Basic Concepts Kafka Architecture The Kafka architecture consists of a number of Producers, a number of Brokers, a number of Consumers, and a ZooKeeper cluster. There are two other concepts that are particularly important in Kafka - Topic and Partition. Messages in Kafka are grouped by topic, producers are responsible for sending messages to a specific topic (each message sent to a Kafka cluster is assigned a topic), and consumers"><meta itemprop="datePublished" content="2022-02-13T12:21:57+08:00" />
<meta itemprop="dateModified" content="2022-02-13T12:21:57+08:00" />
<meta itemprop="wordCount" content="4486">
<meta itemprop="keywords" content="linux," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Detailed breakdown of the Kafka architecture"/>
<meta name="twitter:description" content="Basic Concepts Kafka Architecture The Kafka architecture consists of a number of Producers, a number of Brokers, a number of Consumers, and a ZooKeeper cluster. There are two other concepts that are particularly important in Kafka - Topic and Partition. Messages in Kafka are grouped by topic, producers are responsible for sending messages to a specific topic (each message sent to a Kafka cluster is assigned a topic), and consumers"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Detailed breakdown of the Kafka architecture</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-02-13 12:21:57 </span>
        <div class="post-category">
            <a href="/categories/kafka/"> Kafka </a>
            </div>
          <span class="more-meta"> 4486 words </span>
          <span class="more-meta"> 9 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#basic-concepts">Basic Concepts</a>
          <ul>
            <li><a href="#kafka-architecture">Kafka Architecture</a></li>
            <li><a href="#data-synchronization">Data synchronization</a></li>
          </ul>
        </li>
        <li><a href="#the-overall-structure-of-the-kafka-producer-client">The overall structure of the Kafka producer client</a>
          <ul>
            <li><a href="#interceptors">Interceptors</a></li>
            <li><a href="#serializer">Serializer</a></li>
            <li><a href="#partitioners">Partitioners</a></li>
          </ul>
        </li>
        <li><a href="#broker">Broker</a>
          <ul>
            <li><a href="#broker-processing-request-flow">Broker processing request flow</a></li>
            <li><a href="#controller">Controller</a></li>
          </ul>
        </li>
        <li><a href="#consumers">Consumers</a>
          <ul>
            <li><a href="#consumer-groups">Consumer groups</a></li>
            <li><a href="#consumer-side-partition-assignment-strategy">Consumer-side partition assignment strategy</a></li>
            <li><a href="#rebalance">Rebalance</a></li>
            <li><a href="#consumer-group-rebalancing-full-process">Consumer group rebalancing full process</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="basic-concepts">Basic Concepts</h2>
<h3 id="kafka-architecture">Kafka Architecture</h3>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/13/6a4963f82b394aa0baa819e49c346dcc.png" alt="sobyte"></p>
<p>The Kafka architecture consists of a number of Producers, a number of Brokers, a number of Consumers, and a ZooKeeper cluster.</p>
<p>There are two other concepts that are particularly important in Kafka - Topic and Partition.</p>
<p>Messages in Kafka are grouped by topic, producers are responsible for sending messages to a specific topic (each message sent to a Kafka cluster is assigned a topic), and consumers are responsible for subscribing to and consuming topics.</p>
<p>A topic is a logical concept that can also be subdivided into multiple partitions, where a partition belongs to only a single topic, and in many cases is also referred to as a Topic-Partition.</p>
<p>Kafka introduces a multi-replica (Replica) mechanism for partitions, which can improve disaster recovery by increasing the number of replicas. Different replicas of the same partition store the same message (at the same time, the replicas are not exactly the same), and the replicas have a &ldquo;master-multiple-slave&rdquo; relationship, where the leader replica is responsible for handling read and write requests, and the follower replica is only responsible for synchronizing with the leader replica&rsquo;s messages. When the leader replica fails, a new leader replica is re-elected from the follower replica to provide services to the outside world.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/13/85a82fa55b654a24971b535580b67ac8.png" alt="sobyte"></p>
<p>As shown above, there are 4 brokers in a Kafka cluster, 3 partitions in a topic, and the replica factor (i.e., number of replicas) is also 3, so each partition has 1 leader replica and 2 follower replicas.</p>
<h3 id="data-synchronization">Data synchronization</h3>
<p>All replicas in a partition are collectively known as ARs (Assigned Replicas). All replicas that are synchronized to some degree with the leader replica (including the leader replica) form ISRs (In-Sync Replicas), which are a subset of the AR set.</p>
<p>Under normal circumstances, all follower replicas should be synchronized with the leader replica to some extent, i.e., AR=ISR, OSR set is empty.</p>
<p>The leader copy is responsible for maintaining and tracking the lagging status of all follower copies in the ISR set, and will remove a follower copy from the ISR set if it falls too far behind or fails. By default, when the leader replica fails, only the replicas in the ISR set are eligible to be elected as the new leader.</p>
<p>HW stands for High Watermark, which identifies a specific message offset, and consumers can only pull messages up to this offset.
LEO stands for Log End Offset, which identifies the offset of the next message to be written in the current log file.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/13/f59f6d675f6f4f59b4c3e4a8c778482a.png" alt="sobyte"></p>
<p>As shown above, the offset (LogStartOffset) of the first message is 0, the offset of the last message is 8, and the message with offset 9 is represented by a dashed box, representing the next message to be written. The HW of the log file is 6, which means that the consumer can only pull messages with offset between 0 and 5, and messages with offset 6 are not visible to the consumer.</p>
<h2 id="the-overall-structure-of-the-kafka-producer-client">The overall structure of the Kafka producer client</h2>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/13/3520311af26f46f1b440fb3ec10516f4.png" alt="sobyte"></p>
<p>The entire producer client is coordinated by two threads, the main thread and the Sender thread (the sending thread).</p>
<p>In the main thread, messages are created by the KafkaProducer and then cached in the RecordAccumulator (also known as the message collector) after going through possible interceptors, serializers and partitioners. in Kafka.</p>
<p><strong>RecordAccumulator</strong></p>
<p>The RecordAccumulator is mainly used to cache messages so that the Sender thread can send them in bulk, thus reducing the resource consumption of network transfers to improve performance.</p>
<p>Messages sent in the main thread are appended to a double-ended queue in the RecordAccumulator, which maintains a double-ended queue for each partition inside the RecordAccumulator.</p>
<p>When a message is written to the cache, it is appended to the end of the double-ended queue; when the Sender reads a message, it is read from the head of the double-ended queue.</p>
<p>After the Sender fetches the cached messages from the RecordAccumulator, it further transforms the original <code>&lt;Partition, Deque&lt; ProducerBatch&gt;&gt;</code> save form into a <code>&lt;Node, List&lt; ProducerBatch&gt;&gt;</code>, where Node represents the broker node of the Kafka cluster.</p>
<p>Before KafkaProducer can append this message to the leader copy of a partition of the specified topic, it first needs to know the number of partitions of the topic, and then calculate (or directly specify) the target partition, and then KafkaProducer needs to know the address, port, etc. of the broker node where the leader copy of the target partition is located in order to establish the connection. KafkaProducer needs to know the address, port, etc. of the broker node where the leader copy of the target partition is located in order to establish a connection and finally send the message to Kafka.</p>
<p>So there is a conversion required here, for network connections, the producer client establishes a connection to a specific broker node, i.e. sends messages to a specific broker node and does not care which partition the message belongs to.</p>
<p><strong>InFlightRequests</strong></p>
<p>Requests are also saved in InFlightRequests before being sent from the Sender thread to Kafka. InFlightRequests save objects in the form of <code>Map&lt;NodeId, Deque&gt;</code>, whose main purpose is to cache requests that have been sent but have not yet received a response (NodeId is a String type, indicating the id number of the node).</p>
<h3 id="interceptors">Interceptors</h3>
<p>Producer interceptors can be used either to do some preparatory work before the message is sent, such as filtering non-conforming messages according to some rules, modifying the content of the message, etc., or to do some customization requirements before sending the callback logic, such as statistics-type work.</p>
<p>The producer interceptor is also easy to use and is mainly a custom implementation of the org.apache.kafka.clients.producer.</p>
<p>The ProducerInterceptor interface contains 3 methods.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="n">ProducerRecord</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="nf">onSend</span><span class="o">(</span><span class="n">ProducerRecord</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">record</span><span class="o">);</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">onAcknowledgement</span><span class="o">(</span><span class="n">RecordMetadata</span> <span class="n">metadata</span><span class="o">,</span> <span class="n">Exception</span> <span class="n">exception</span><span class="o">);</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">close</span><span class="o">();</span>
</code></pre></td></tr></table>
</div>
</div><p>The KafkaProducer calls the onSend() method of the producer interceptor to customize the message accordingly before serializing it and computing the partition. It is generally best not to modify the topic, key, and partition information of the message ProducerRecord.</p>
<p>KafkaProducer calls the onAcknowledgement() method of the Producer Interceptor before the message is answered (Acknowledgement) or if the message fails to be sent, before the user-set Callback. This method runs in the Producer&rsquo;s I/O thread, so the simpler the code logic implemented in this method, the better, otherwise it will affect the speed of message delivery.</p>
<p>The close() method is mainly used to perform some resource cleanup when the interceptor is closed.</p>
<h3 id="serializer">Serializer</h3>
<p>The producer needs to use a Serializer to convert objects into byte arrays before sending them to Kafka over the network, while on the other side, the consumer needs to use a Deserializer to convert the byte arrays received from Kafka into the corresponding objects.</p>
<p>If the producer uses a serializer, such as StringSerializer, and the consumer uses another serializer, such as IntegerSerializer, then the desired data cannot be parsed.</p>
<p>Serializers need to implement the org.apache.kafka.common.serialization.Serializer interface, which has three methods.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">configure</span><span class="o">(</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="o">?&gt;</span> <span class="n">configs</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">isKey</span><span class="o">)</span>
<span class="kd">public</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">serialize</span><span class="o">(</span><span class="n">String</span> <span class="n">topic</span><span class="o">,</span> <span class="n">T</span> <span class="n">data</span><span class="o">)</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">close</span><span class="o">()</span>
</code></pre></td></tr></table>
</div>
</div><p>The configure() method is used to configure the current class, the serialize() method is used to perform the serialization operation. And close() method is used to close the current serializer.</p>
<p>As follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">StringSerializer</span> <span class="kd">implements</span> <span class="n">Serializer</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">encoding</span> <span class="o">=</span> <span class="s">&#34;UTF8&#34;</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">configure</span><span class="o">(</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="o">?&gt;</span> <span class="n">configs</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">isKey</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">propertyName</span> <span class="o">=</span> <span class="n">isKey</span> <span class="o">?</span> <span class="s">&#34;key.serializer.encoding&#34;</span> <span class="o">:</span>
                <span class="s">&#34;value.serializer.encoding&#34;</span><span class="o">;</span>
        <span class="n">Object</span> <span class="n">encodingValue</span> <span class="o">=</span> <span class="n">configs</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">propertyName</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">encodingValue</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">encodingValue</span> <span class="o">=</span> <span class="n">configs</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">&#34;serializer.encoding&#34;</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">encodingValue</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">encodingValue</span> <span class="k">instanceof</span> <span class="n">String</span><span class="o">)</span>
            <span class="n">encoding</span> <span class="o">=</span> <span class="o">(</span><span class="n">String</span><span class="o">)</span> <span class="n">encodingValue</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">serialize</span><span class="o">(</span><span class="n">String</span> <span class="n">topic</span><span class="o">,</span> <span class="n">String</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">data</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
            <span class="k">else</span>
                <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="n">encoding</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">UnsupportedEncodingException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">SerializationException</span><span class="o">(</span><span class="s">&#34;Error when serializing &#34;</span> <span class="o">+</span>
                    <span class="s">&#34;string to byte[] due to unsupported encoding &#34;</span> <span class="o">+</span> <span class="n">encoding</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">close</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// nothing to do
</span><span class="c1"></span>    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>configure() method, which is called when creating a KafkaProducer instance and is mainly used to determine the encoding type.</p>
<p>serialize is used to encode and decode. If the several serializers provided by the Kafka client do not meet the application requirements, you can choose to use generic serialization tools such as Avro, JSON, Thrift, ProtoBuf and Protostuff to implement them, or use a custom type of serializer to implement them.</p>
<h3 id="partitioners">Partitioners</h3>
<p>If a partition field is specified in the message ProducerRecord, there is no need for a partitioner because the partition represents the partition number to which the message is sent.</p>
<p>If the partition field is not specified in the message ProducerRecord, then you need to rely on the partitioner to calculate the value of the partition based on the key field. The role of the partitioner is to assign partitions to messages.</p>
<p>The default partitioner provided in Kafka is org.apache.kafka.clients.producer.internationals. There are 2 methods defined in this interface, which are shown below.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">int</span> <span class="nf">partition</span><span class="o">(</span><span class="n">String</span> <span class="n">topic</span><span class="o">,</span> <span class="n">Object</span> <span class="n">key</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">keyBytes</span><span class="o">,</span> 
                     <span class="n">Object</span> <span class="n">value</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">valueBytes</span><span class="o">,</span> <span class="n">Cluster</span> <span class="n">cluster</span><span class="o">);</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">close</span><span class="o">();</span>
</code></pre></td></tr></table>
</div>
</div><p>The partition() method is used to calculate the partition number and returns a value of type int. The parameters in the partition() method represent the subject, key, serialized key, value, serialized value, and metadata information of the cluster, through which a feature-rich partitioner can be implemented. close() method is used to reclaim some resources when closing the partitioner.</p>
<p>In the default partitioner implementation of DefaultPartitioner, close() is the null method and the main partition allocation logic is defined in the partition() method. If the key is not null, then the default partitioner will hash the key and eventually calculate the partition number based on the resulting hash, and messages with the same key will be written to the same partition. If the key is null, then the message will be sent to each available partition in the topic in a polled manner.</p>
<p>Custom partitioners simply implement the Partitioner interface like DefaultPartitioner. Since the processing of messages under each partition is sequential, we can use the custom partitioner to achieve orderly consumption by sending all the keys in a series to a partition.</p>
<h2 id="broker">Broker</h2>
<h3 id="broker-processing-request-flow">Broker processing request flow</h3>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/13/76d8ce5ae41844fa98430366f1f3ea05.png" alt="sobyte"></p>
<p>In the Kafka architecture, there are many clients sending requests to the Broker side, and the Broker side of Kafka has a SocketServer component that establishes connections with the clients and then distributes the requests through the Acceptor thread. Throughput.</p>
<p>The default size of the network thread pool is 3, which means that each Broker will create 3 network threads when it starts, specifically to handle requests sent by the client, which can be modified by the Broker side parameter num.network.threads.</p>
<p>Then the next processing network threads processing process is as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/13/51500120923e4942847e1d88cd418bbd.png" alt="sobyte"></p>
<p>When the network thread gets the request, it puts the request into a shared request queue. there is also a pool of IO threads on the Broker side that takes the request out of this queue and performs the actual processing. If it is a PRODUCE production request, the message is written to the underlying disk log; if it is a FETCH request, the message is read from the disk or page cache.</p>
<p>The threads at the IO thread pool are the threads that execute the request logic. The default is 8, which means that each Broker automatically creates 8 IO threads to process the request when it starts, which can be adjusted with the Broker-side parameter num.io.threads.</p>
<p>The Purgatory component is used to cache delayed requests (Delayed Requests). For example, if a PRODUCE request with acks=all is set, once acks=all is set, the request must wait until all copies in the ISR have received the message before returning, and then the IO thread handling the request must wait for the results of other Broker writes.</p>
<h3 id="controller">Controller</h3>
<p>There will be one or more brokers in a Kafka cluster, and one of them will be elected as the controller (Kafka Controller), which is responsible for managing the state of all partitions and replicas in the entire cluster.</p>
<h4 id="how-are-controllers-elected">How are controllers elected?</h4>
<p>When a Broker starts, it tries to create a /controller node in ZooKeeper. Kafka&rsquo;s current rule for electing controllers is that the first Broker to successfully create a /controller node is designated as the controller.</p>
<p>The /controller_epoch node in ZooKeeper stores an integer controller_epoch value. controller_epoch is used to record the number of times a controller has changed, i.e., how many generations of controllers the current controller is, which we can also call &quot; controller_epoch&quot;.</p>
<p>The initial value of controller_epoch is 1, which means that the first controller in the cluster has an epoch of 1. Kafka uses controller_epoch to ensure the uniqueness of controllers and thus the consistency of related operations.</p>
<p>Each request interacting with a controller carries the controller_epoch field. If the controller_epoch value of a request is less than the controller_epoch value in memory, the request is considered to be a request to an expired controller, and the request is considered invalid.</p>
<p>If the controller_epoch value of the request is greater than the controller_epoch value in memory, then a new controller has been elected.</p>
<h4 id="what-does-the-controller-do">What does the controller do?</h4>
<ul>
<li>Topic management (create, delete, add partitions)</li>
<li>Partition reallocation</li>
<li>Preferred leader election
Preferred leader election is mainly a solution provided by Kafka to change the Leader in order to avoid overloading some Brokers.</li>
<li>Cluster membership management (new Broker, Broker active shutdown, Broker down)
The controller component uses the Watch mechanism to check for changes in the number of children under the /brokers/ids node of ZooKeeper. Currently, when a new Broker is started, it creates a dedicated znode node under /brokers. Once created, ZooKeeper pushes a message notification to the controller via the Watch mechanism, so that the controller can automatically sense the change and start subsequent new Broker jobs.</li>
<li>Data Services
The most complete cluster metadata information is stored on the controller.</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/13/0dc5508df5334a4b822a59cd1c165528.png" alt="sobyte"></p>
<h4 id="what-happens-when-a-controller-goes-down">What happens when a controller goes down?</h4>
<p>When a running controller suddenly goes down or terminates unexpectedly, Kafka can quickly sense it and immediately enable a standby controller to replace the previously failed one. This process is known as Failover, and it is done automatically without your manual intervention.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/13/e9bc92d548c04219bb6c00221312876b.png" alt="sobyte"></p>
<h2 id="consumers">Consumers</h2>
<h3 id="consumer-groups">Consumer groups</h3>
<p>In Kafka, each consumer has a corresponding consumer group. When a message is published to a topic, it is only cast to one consumer in each consumer group that subscribes to it. Each consumer can only consume the messages in the partition to which it is assigned. And each partition can only be consumed by one consumer in a consumer group.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/13/6a6c40b9dd3943debbdac2788cd4f45b.png" alt="sobyte"></p>
<p>As shown in the figure above, we can set up two consumer groups to broadcast messages, and both consumer group A and group B can receive messages from the producer.</p>
<p>This model of consumers and consumer groups allows the overall consumption capacity to have horizontal scalability, and we can increase (or decrease) the number of consumers to increase (or decrease) the overall consumption capacity. For a fixed number of partitions, increasing the number of consumers will not always increase the spending power, and if there are too many consumers and the number of <strong>consumers is greater than the number of partitions</strong>, there will be no consumers assigned to any partition.</p>
<p>As follows: there are 8 consumers and 7 partitions, then the last consumer C7 cannot consume any message because it cannot be assigned any partition.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/13/61d807f2d4f44979848bba70ae3ce5a6.png" alt="sobyte"></p>
<h3 id="consumer-side-partition-assignment-strategy">Consumer-side partition assignment strategy</h3>
<p>Kafka provides the consumer client parameter partition.assignment.strategy to set the partition assignment strategy between the consumer and the subscription topic.</p>
<p><strong>RangeAssignor assignment strategy</strong></p>
<p>By default, the RangeAssignor allocation strategy is used.</p>
<p>The RangeAssignor allocation strategy works by dividing the total number of consumers and the total number of partitions to obtain a span, and then dividing the partitions evenly by the span to ensure that the partitions are distributed as evenly as possible to all consumers. For each topic, the RangeAssignor policy sorts all consumers subscribed to the topic in the consumer group by the dictionary order of their names, and then divides each consumer into a fixed range of partitions, and if there is not enough equal distribution, then the consumer with the highest dictionary order will be assigned one more partition.</p>
<p>Suppose there are 2 consumers C0 and C1 in the consumer group, both subscribed to topics t0 and t1, and each topic has 4 partitions, then all partitions subscribed can be identified as: t0p0, t0p1, t0p2, t0p3, t1p0, t1p1, t1p2, t1p3. The final allocation result is</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">消费者C0：t0p0、t0p1、t1p0、t1p1
消费者C1：t0p2、t0p3、t1p2、t1p3
</code></pre></td></tr></table>
</div>
</div><p>Assuming that the 2 topics in the above example have only 3 partitions, then all partitions of the subscription can be identified as: t0p0, t0p1, t0p2, t1p0, t1p1, t1p2. The final allocation is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">消费者C0：t0p0、t0p1、t1p0、t1p1
消费者C1：t0p2、t1p2
</code></pre></td></tr></table>
</div>
</div><p>It can be clearly seen that such an allocation is not uniform.</p>
<p><strong>RoundRobinAssignor allocation strategy</strong></p>
<p>The RoundRobinAssignor allocation policy works by sorting all consumers in a consumer group and all partitions of topics to which the consumers subscribe in dictionary order, and then assigning the partitions to each consumer in turn by polling.</p>
<p>If all the consumers in the same consumer group have the same subscription information, then the partition distribution of the RoundRobinAssignor allocation policy is uniform.</p>
<p>If the consumers in the same consumer group have different subscription information, then the partition assignment is not a complete polling assignment and may result in uneven partition assignment.</p>
<p>Suppose there are three consumers (C0, C1, and C2) in a consumer group, and t0, t0, t1, and t2 topics have 1, 2, and 3 partitions, respectively, i.e., the entire consumer group subscribes to the six partitions t0p0, t1p0, t1p1, t2p0, t2p1, and t2p2.</p>
<p>Specifically, consumer C0 subscribes to topic t0, consumer C1 subscribes to topics t0 and t1, and consumer C2 subscribes to topics t0, t1, and t2, then the final distribution is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">消费者C0：t0p0
消费者C1：t1p0
消费者C2：t1p1、t2p0、t2p1、t2p2
</code></pre></td></tr></table>
</div>
</div><p>As we can see, the RoundRobinAssignor policy is not perfect, and this allocation is not optimal, because it is possible to allocate partition t1p1 to consumer C1.</p>
<p><strong>StickyAssignor allocation strategy</strong></p>
<p>This allocation strategy, which has two main purposes.</p>
<ol>
<li>the allocation of partitions should be as uniform as possible.</li>
<li>the allocation of partitions should remain the same as the last allocation as much as possible.</li>
</ol>
<p>Suppose there are 3 consumers (C0, C1 and C2) in the consumption group, and they all subscribe to 4 topics (t0, t1, t2, t3) and each topic has 2 partitions. That is, the whole consumer group subscribes to the 8 partitions t0p0, t0p1, t1p0, t1p1, t2p0, t2p1, t3p0, t3p1. The final allocation results are as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">消费者C0：t0p0、t1p1、t3p0
消费者C1：t0p1、t2p0、t3p1
消费者C2：t1p0、t2p1
</code></pre></td></tr></table>
</div>
</div><p>Assume again that consumer C1 is out of the consumption group at this point, then the distribution results are as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">消费者C0：t0p0、t1p1、t3p0、t2p0
消费者C2：t1p0、t2p1、t0p1、t3p1
</code></pre></td></tr></table>
</div>
</div><p>The StickyAssignor allocation policy, like the &ldquo;sticky&rdquo; in its name, gives the allocation policy a certain &ldquo;stickiness&rdquo; to make the first two assignments as identical as possible, thus reducing the loss of system resources and other The assignment policy is as &ldquo;sticky&rdquo; as its name implies.</p>
<h3 id="rebalance">Rebalance</h3>
<p>Rebalance is the act of transferring the ownership of a partition from one consumer to another. It provides guarantees for high availability and scalability of consumer groups, allowing us to easily and safely delete consumers within a consumer group or add consumers to a consumer group.</p>
<p>Disadvantages.</p>
<ol>
<li>the consumers in the consumer group cannot read messages during rebalancing.</li>
<li>Rebalance is very slow. If there are hundreds of Consumer instances in a Consumer group, Rebalance can take several hours at a time.</li>
<li>The current state of the consumer is also lost when rebalancing is performed. For example, when a consumer finishes consuming a part of a message in a partition, the rebalance occurs before the consumer has time to submit the consumption shift, and then the partition is assigned to another consumer in the consumer group, and the part of the message that was consumed is consumed again, i.e., repeated consumption occurs.</li>
</ol>
<p>Rebalance occurs at three times.</p>
<ol>
<li>the number of group members changes</li>
<li>the number of topics subscribed to changes</li>
<li>when the number of partitions in the subscribed topic changes</li>
</ol>
<p>The latter two types are usually caused by business changes, which we cannot control, so we will focus on how to avoid rebalance caused by changes in the number of group members.</p>
<p>After the Consumer Group completes Rebalance, each Consumer instance periodically sends heartbeat requests to the Coordinator to indicate that it is still alive. If a Consumer instance fails to send these heartbeat requests in time, the Coordinator considers the Consumer &ldquo;dead&rdquo; and removes it from the Group and starts a new round of Rebalance.</p>
<p>The Consumer side can set <strong>session.timeout.ms</strong>, which defaults to 10s, to indicate that if the Coordinator does not receive a heartbeat from a Consumer instance in the Group within 10 seconds, it will assume that the Consumer instance is dead.</p>
<p>The Consumer side can also set <strong>heartbeat.interval.ms</strong>, which indicates the frequency of sending heartbeat requests.</p>
<p>and the <strong>max.poll.interval.ms</strong> parameter, which limits the maximum time between two calls to the poll method by the Consumer-side application. The default value is 5 minutes, which means that if your Consumer application cannot consume all the messages returned by the poll method within 5 minutes, the Consumer will initiate a request to &ldquo;leave the group&rdquo; and the Coordinator will start a new round of Rebalance.</p>
<p>So knowing the above parameters, we can avoid the following two problems: 1.</p>
<ol>
<li>
<p>non-essential Rebalance is caused by Consumer being &ldquo;kicked out&rdquo; of the Group due to failure to send heartbeat in time.
So we can set it like this in the production environment.</p>
<ul>
<li>Set session.timeout.ms = 6s.</li>
<li>Set heartbeat.interval.ms = 2s.</li>
</ul>
</li>
<li>
<p>Necessary Rebalance is caused by Consumer consuming too much time. How to consume tasks up to 8 minutes, and max.poll.interval.ms is set to 5 minutes, then Rebalance will also occur, so if there are heavier tasks, you can adjust this parameter appropriately.</p>
</li>
<li>
<p>the frequent Full GC on the Consumer side causes a long stall, which triggers Rebalance.</p>
</li>
</ol>
<h3 id="consumer-group-rebalancing-full-process">Consumer group rebalancing full process</h3>
<p>The rebalancing process is notified to other consumer instances by the Heartbeat Thread on the consumer side.</p>
<p>When the coordinator decides to start a new round of rebalancing, it wraps &ldquo;REBALANCE_IN_PROGRESS&rdquo; in the heartbeat request response and sends it back to the consumer instance. When the consumer instance finds out that the heartbeat response contains &ldquo;REBALANCE_IN_PROGRESS&rdquo;, it will immediately know that rebalancing has started again.</p>
<p>So, in fact, heartbeat.interval.ms not only sets the heartbeat interval, but also controls the frequency of rebalancing notifications.</p>
<h4 id="consumer-group-state-machine">Consumer Group State Machine</h4>
<p>Once rebalancing is turned on, the coordinator component on the Broker side has to complete the entire rebalancing process, and Kafka has designed a Consumer Group State Machine to achieve this.</p>
<p>Kafka defines five states for consumer groups, which are Empty, Dead, PreparingRebalance, CompletingRebalance, and Stable.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/13/4cce4ab90e8a447a973564ad1cd4b073.png" alt="sobyte"></p>
<p>Flow of individual states of the state machine.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/13/116003a856324812be781009ad4ee1ad.png" alt="sobyte"></p>
<p>When a new member joins or an existing member drops out, the consumer group status jumps directly from Stable to PreparingRebalance, at which point all existing members must reapply to the group. When all members have dropped out of the group, the consumer group status changes to Empty, which is the condition for Kafka to automatically delete expired shifts periodically. So if your consumer group has been down for a long time (more than 7 days), then Kafka has probably deleted the displacement data for that group.</p>
<h4 id="groupcoordinator">GroupCoordinator</h4>
<p>The GroupCoordinator is the component of the Kafka server that is used to manage consumer groups. The most important responsibility of the coordinator is to perform consumer rebalancing operations.</p>
<h4 id="consumer-side-rebalancing-process">Consumer-side rebalancing process</h4>
<p>On the consumer side, rebalancing is divided into two steps: joining the group and waiting for the Leader Consumer (LC) to assign the solution, respectively. That is, JoinGroup request and SyncGroup request.</p>
<ol>
<li>
<p>Join Group
When a member of a group joins the group, it sends a JoinGroup request to the coordinator. In this request, each member reports the topics to which he/she is subscribed, so that the coordinator can collect the subscription information of all members.</p>
</li>
<li>
<p>Selecting a consumer group leader
Once the JoinGroup requests are collected from all members, the coordinator selects one of these members to be the leader of the consumer group.
The leader here is a specific consumer instance, which is neither a replica nor a coordinator. The task of the leader consumer is to collect the subscription information of all members and then, based on this information, develop a specific partitioned consumer allocation scheme.</p>
</li>
<li>
<p>Election of partition allocation policy
The election of this partition allocation is based on the votes of the individual consumers within the consumer group.
The coordinator collects all the allocation policies supported by each consumer to form a candidate set, and each consumer finds the first policy supported by itself from the candidate set and votes for this policy. The strategy with the highest number of votes is the allocation strategy for the current consumer group.
If a consumer does not support the selected allocation protocol, then an exception is thrown: Member does not support protocol.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/13/b3b1d88817394a3ca761665cd7bfeed2.png" alt="sobyte"></p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/13/19f2177360a24a759607e81ef4f20391.png" alt="sobyte"></p>
</li>
<li>
<p>Sending a SyncGroup request
The coordinator encapsulates the consumer group subscription information in the response body of the JoinGroup request and sends it to the leader, who then sends a SyncGroup request to the coordinator.</p>
</li>
<li>
<p>Responding to a SyncGroup
All consumers in the group send a SyncGroup request, except that not the leader&rsquo;s request content is empty, and then a SyncGroup response is received, accepting the subscription information.</p>
</li>
</ol>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/linux/">linux</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-02/google-vulnerability-reward-program-2021/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Google bug bounty sets new record, Chrome fixes industry-leading speed</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-02/jraft-raft/">
            <span class="next-text nav-default">Raft protocol implementation details from JRaft</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
