<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Getting to Know the Power of Ast - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="The abstract syntax tree is an intermediate product of the compilation process, and is generally just a simple thing to understand. But we can take the whole parser and ast package from Go and use it directly, which can be very powerful in some scenarios. What is ast? I took an excerpt from Wikipedia. In computer science, an Abstract Syntax Tree (AST), or Syntax tree for short, is an abstract" /><meta name="keywords" content="golang, ast" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-02/getting-to-know-the-power-of-ast/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Getting to Know the Power of Ast" />
<meta property="og:description" content="The abstract syntax tree is an intermediate product of the compilation process, and is generally just a simple thing to understand. But we can take the whole parser and ast package from Go and use it directly, which can be very powerful in some scenarios. What is ast? I took an excerpt from Wikipedia. In computer science, an Abstract Syntax Tree (AST), or Syntax tree for short, is an abstract" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-02/getting-to-know-the-power-of-ast/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-02-08T10:24:16+08:00" />
<meta property="article:modified_time" content="2022-02-08T10:24:16+08:00" />

<meta itemprop="name" content="Getting to Know the Power of Ast">
<meta itemprop="description" content="The abstract syntax tree is an intermediate product of the compilation process, and is generally just a simple thing to understand. But we can take the whole parser and ast package from Go and use it directly, which can be very powerful in some scenarios. What is ast? I took an excerpt from Wikipedia. In computer science, an Abstract Syntax Tree (AST), or Syntax tree for short, is an abstract"><meta itemprop="datePublished" content="2022-02-08T10:24:16+08:00" />
<meta itemprop="dateModified" content="2022-02-08T10:24:16+08:00" />
<meta itemprop="wordCount" content="1567">
<meta itemprop="keywords" content="golang,ast," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Getting to Know the Power of Ast"/>
<meta name="twitter:description" content="The abstract syntax tree is an intermediate product of the compilation process, and is generally just a simple thing to understand. But we can take the whole parser and ast package from Go and use it directly, which can be very powerful in some scenarios. What is ast? I took an excerpt from Wikipedia. In computer science, an Abstract Syntax Tree (AST), or Syntax tree for short, is an abstract"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Getting to Know the Power of Ast</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-02-08 10:24:16 </span>
        <div class="post-category">
            <a href="/categories/news/"> news </a>
            </div>
          <span class="more-meta"> 1567 words </span>
          <span class="more-meta"> 4 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#assume-a-scenario">Assume a scenario</a></li>
        <li><a href="#intuitively-understand-how-to-parse-rules-with-ast">Intuitively understand how to parse rules with ast</a></li>
        <li><a href="#principle-analysis">Principle analysis</a></li>
        <li><a href="#summary">Summary</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>The abstract syntax tree is an intermediate product of the compilation process, and is generally just a simple thing to understand. But we can take the whole parser and ast package from Go and use it directly, which can be very powerful in some scenarios.</p>
<p>What is ast? I took an excerpt from Wikipedia.</p>
<blockquote>
<p>In computer science, an Abstract Syntax Tree (AST), or Syntax tree for short, is an abstract representation of the syntactic structure of source code. It represents the syntactic structure of a programming language in a tree-like form, with each node in the tree representing a structure in the source code.</p>
</blockquote>
<p>At its core, it means that ast can represent the code structure in the form of a tree. With a tree structure, you can do traversals of it and can do a lot of things.</p>
<h2 id="assume-a-scenario">Assume a scenario</h2>
<p>Assume a scenario: we can get various characteristics of the driver from an interface of the driver platform, such as: age, number of orders, income, daily driving hours, driving age, average speed, the number of complaints &hellip;&hellip; data is generally delivered using json.</p>
<p>Driver platform operations often need to engage in some activities, such as the election of.</p>
<ul>
<li>the number of orders more than 10000, and the driving age of more than 5 years of old drivers</li>
<li>Efficient drivers with less than 3 hours of driving time per day and more than 500 income</li>
<li>&ldquo;Wild&rdquo; drivers with age over 40 and average speed over 70</li>
<li>&hellip;&hellip;</li>
</ul>
<p>These rules are not fixed and change often, but they are always a combination of driver characteristics.</p>
<p>For simplicity, we pick 2 characteristics and represent them in a <code>Driver</code> structure.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Driver</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Orders</span>         <span class="kt">int</span>
	<span class="nx">DrivingYears</span>   <span class="kt">int</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>In order to cooperate with the operation of activities, we need to determine whether a driver meets the requirements according to the rules given by the operation.</p>
<p>If the company has a lot of people, you can arrange a rd dedicated to serve the operations lady, every time you do activities to manually modify the code, it is not impossible. And actually quite simple, let&rsquo;s write a sample code.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 从第三方获取司机特征，json 表示
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">getDriverRemote</span><span class="p">()</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="k">return</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">`{&#34;orders&#34;:100000,&#34;driving_years&#34;:18}`</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 判断是否为老司机
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">isOldDriver</span><span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">Driver</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">d</span><span class="p">.</span><span class="nx">Orders</span> <span class="p">&gt;</span> <span class="mi">10000</span> <span class="o">&amp;&amp;</span> <span class="nx">d</span><span class="p">.</span><span class="nx">DrivingYears</span> <span class="p">&gt;</span> <span class="mi">5</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">bs</span> <span class="o">:=</span> <span class="nf">getDriverRemote</span><span class="p">()</span>
	<span class="kd">var</span> <span class="nx">d</span> <span class="nx">Driver</span>
	<span class="nx">json</span><span class="p">.</span><span class="nf">Unmarshal</span><span class="p">(</span><span class="nx">bs</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">d</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">isOldDriver</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">d</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Looking directly at the <code>main</code> function: <code>getDriverRemote</code> simulates getting a driver&rsquo;s feature data from a third-party RPC, represented as a json. Then <code>json.Unmarshal</code> to deserialize the <code>Driver</code> structure. Finally, the <code>isOldDriver</code> function is called to determine if the driver matches the rules of the operation.</p>
<p><code>isOldDriver</code> uses an if statement to determine if the driver is an old driver based on the 2 fields of the <code>Driver</code> structure.</p>
<p>It&rsquo;s really quite simple.</p>
<p>But each time I update the rules, I have to go through a complete online process, which is also quite troublesome. Is there a simpler way? So that we can directly parse a string rule given to us by the operations team, and directly return a bool value to indicate whether the condition is met.</p>
<p>There is!</p>
<p>Next is the heart of this article, how to use ast to do the same.</p>
<h2 id="intuitively-understand-how-to-parse-rules-with-ast">Intuitively understand how to parse rules with ast</h2>
<p>Using some of the functions provided by the ast package, we can very easily string a rule as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">orders</span> <span class="p">&gt;</span> <span class="mi">10000</span> <span class="o">&amp;&amp;</span> <span class="nx">driving_years</span> <span class="p">&gt;</span> <span class="mi">5</span>
</code></pre></td></tr></table>
</div>
</div><p>resolves into a binary tree like this.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/08/e26823e927ed4727b2e30707e464e65d.png" alt="sobyte"></p>
<p>BinaryExpr<code>represents a binary expression, which consists of three parts, X and Y, and the symbol OP. The top one,</code>BinaryExpr`, represents the left and right halves of the rule together.</p>
<p>Obviously, the left half is: <code>orders &gt; 10000</code> and the right half is: <code>driving_years &gt; 5</code>. Miraculously, both the left and right halves happen to be binary expressions again.</p>
<p>The left half of <code>orders &gt; 10000</code> is actually also the smallest leaf node, which can be calculated as a bool value. After splitting it up, it can be divided into X, Y, and OP; X is <code>orders</code>, OP is &ldquo;&gt;&rdquo;, and Y is &ldquo;10000&rdquo;. Where X denotes an identifier and is of type ast.Ident, Y denotes a literal of a basic type, e.g. int, string type &hellip;&hellip; is of type ast.BasicLit.</p>
<p>The right half of <code>driving_years &gt; 18</code> can also be split up as such.</p>
<p>Then, take the value of <code>orders</code> field of this driver from the json to be 100000, which is larger than 10000, so the left half is counted as true. similarly, the right half is counted as true. finally, the outermost <code>&amp;&amp;</code> is counted again, and the result is still true.</p>
<p>At this point, directly based on the rule string, we can calculate the result.</p>
<p>If written as a program, it is a traversal process of dfs. If it is not a leaf node, then it is a binary expression node, which must have X, Y, and OP parts. Recursively traverse X. If X is a leaf node, then end the recursion and compute the value of X. &hellip;&hellip;</p>
<p>Here is another abstract syntax tree printed out with the ast package.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/08/537eda7c01ef4f88a0f4cccf0fdd3010.png" alt="sobyte"></p>
<p>In the above diagram, 1, 2, 3 represent the outermost binary expression; 4, 5, 6 represent the left binary expression.</p>
<p>Combining this diagram with the code of the relevant structure of the ast package, it is very clear. For example, the code of <code>ast.BinaryExpr</code> is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// A BinaryExpr node represents a binary expression.
</span><span class="c1"></span><span class="nx">BinaryExpr</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">X</span>     <span class="nx">Expr</span>        <span class="c1">// left operand
</span><span class="c1"></span>	<span class="nx">OpPos</span> <span class="nx">token</span><span class="p">.</span><span class="nx">Pos</span>   <span class="c1">// position of Op
</span><span class="c1"></span>	<span class="nx">Op</span>    <span class="nx">token</span><span class="p">.</span><span class="nx">Token</span> <span class="c1">// operator
</span><span class="c1"></span>	<span class="nx">Y</span>     <span class="nx">Expr</span>        <span class="c1">// right operand
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>It has X, Y, OP, and even resolves the position of the Op, which is represented by OpPos.</p>
<p>If you are still interested in the implementation, then continue to the schematic analysis section below, otherwise you can skip directly to the concluding summary section.</p>
<h2 id="principle-analysis">Principle analysis</h2>
<p>Using the same example as above, let&rsquo;s write a direct expression.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">orders &gt; <span class="m">10000</span> <span class="o">&amp;&amp;</span> driving_years &gt; <span class="m">5</span>
</code></pre></td></tr></table>
</div>
</div><p>Next, ast is used to parse the rules and determine whether they are true or false.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int64</span><span class="p">{</span><span class="s">&#34;orders&#34;</span><span class="p">:</span> <span class="mi">100000</span><span class="p">,</span> <span class="s">&#34;driving_years&#34;</span><span class="p">:</span> <span class="mi">18</span><span class="p">}</span>
	<span class="nx">rule</span> <span class="o">:=</span> <span class="s">`orders &gt; 10000 &amp;&amp; driving_years &gt; 5`</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">Eval</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span> <span class="nx">rule</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>For simplicity, we use map directly instead of json, for the same reason, just for convenience.</p>
<p>The <code>Eval</code> function determines whether <code>rule</code> is true or false.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Eval : 计算 expr 的值
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Eval</span><span class="p">(</span><span class="nx">m</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int64</span><span class="p">,</span> <span class="nx">expr</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">exprAst</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">parser</span><span class="p">.</span><span class="nf">ParseExpr</span><span class="p">(</span><span class="nx">expr</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="c1">// 打印 ast
</span><span class="c1"></span>	<span class="nx">fset</span> <span class="o">:=</span> <span class="nx">token</span><span class="p">.</span><span class="nf">NewFileSet</span><span class="p">()</span>
	<span class="nx">ast</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="nx">fset</span><span class="p">,</span> <span class="nx">exprAst</span><span class="p">)</span>

	<span class="k">return</span> <span class="nf">judge</span><span class="p">(</span><span class="nx">exprAst</span><span class="p">,</span> <span class="nx">m</span><span class="p">),</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The expression is first parsed into <code>Expr</code>, and then the judge function is called to compute the result.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// dfs
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">judge</span><span class="p">(</span><span class="nx">bop</span> <span class="nx">ast</span><span class="p">.</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">m</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int64</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="c1">// 叶子结点
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">isLeaf</span><span class="p">(</span><span class="nx">bop</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// 断言成二元表达式
</span><span class="c1"></span>		<span class="nx">expr</span> <span class="o">:=</span> <span class="nx">bop</span><span class="p">.(</span><span class="o">*</span><span class="nx">ast</span><span class="p">.</span><span class="nx">BinaryExpr</span><span class="p">)</span>
		<span class="nx">x</span> <span class="o">:=</span> <span class="nx">expr</span><span class="p">.</span><span class="nx">X</span><span class="p">.(</span><span class="o">*</span><span class="nx">ast</span><span class="p">.</span><span class="nx">Ident</span><span class="p">)</span> <span class="c1">// 左边
</span><span class="c1"></span>		<span class="nx">y</span> <span class="o">:=</span> <span class="nx">expr</span><span class="p">.</span><span class="nx">Y</span><span class="p">.(</span><span class="o">*</span><span class="nx">ast</span><span class="p">.</span><span class="nx">BasicLit</span><span class="p">)</span> <span class="c1">// 右边
</span><span class="c1"></span>
		<span class="c1">// 如果是 &#34;&gt;&#34; 符号
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">expr</span><span class="p">.</span><span class="nx">Op</span> <span class="o">==</span> <span class="nx">token</span><span class="p">.</span><span class="nx">GTR</span> <span class="p">{</span>
			<span class="nx">left</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">[</span><span class="nx">x</span><span class="p">.</span><span class="nx">Name</span><span class="p">]</span>
			<span class="nx">right</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">ParseInt</span><span class="p">(</span><span class="nx">y</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
			<span class="k">return</span> <span class="nx">left</span> <span class="p">&gt;</span> <span class="nx">right</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="c1">// 不是叶子节点那么一定是 binary expression（我们目前只处理二元表达式）
</span><span class="c1"></span>	<span class="nx">expr</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">bop</span><span class="p">.(</span><span class="o">*</span><span class="nx">ast</span><span class="p">.</span><span class="nx">BinaryExpr</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="nb">println</span><span class="p">(</span><span class="s">&#34;this cannot be true&#34;</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="c1">// 递归地计算左节点和右节点的值
</span><span class="c1"></span>	<span class="k">switch</span> <span class="nx">expr</span><span class="p">.</span><span class="nx">Op</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">token</span><span class="p">.</span><span class="nx">LAND</span><span class="p">:</span>
		<span class="k">return</span> <span class="nf">judge</span><span class="p">(</span><span class="nx">expr</span><span class="p">.</span><span class="nx">X</span><span class="p">,</span> <span class="nx">m</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nf">judge</span><span class="p">(</span><span class="nx">expr</span><span class="p">.</span><span class="nx">Y</span><span class="p">,</span> <span class="nx">m</span><span class="p">)</span>
	<span class="k">case</span> <span class="nx">token</span><span class="p">.</span><span class="nx">LOR</span><span class="p">:</span>
		<span class="k">return</span> <span class="nf">judge</span><span class="p">(</span><span class="nx">expr</span><span class="p">.</span><span class="nx">X</span><span class="p">,</span> <span class="nx">m</span><span class="p">)</span> <span class="o">||</span> <span class="nf">judge</span><span class="p">(</span><span class="nx">expr</span><span class="p">.</span><span class="nx">Y</span><span class="p">,</span> <span class="nx">m</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nb">println</span><span class="p">(</span><span class="s">&#34;unsupported operator&#34;</span><span class="p">)</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>judge</code> computes the value of an expression recursively using dfs.</p>
<p>The recursive termination condition is that the leaf node.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 判断是否是叶子节点
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">isLeaf</span><span class="p">(</span><span class="nx">bop</span> <span class="nx">ast</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">expr</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">bop</span><span class="p">.(</span><span class="o">*</span><span class="nx">ast</span><span class="p">.</span><span class="nx">BinaryExpr</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="c1">// 二元表达式的最小单位，左节点是标识符，右节点是值
</span><span class="c1"></span>	<span class="nx">_</span><span class="p">,</span> <span class="nx">okL</span> <span class="o">:=</span> <span class="nx">expr</span><span class="p">.</span><span class="nx">X</span><span class="p">.(</span><span class="o">*</span><span class="nx">ast</span><span class="p">.</span><span class="nx">Ident</span><span class="p">)</span>
	<span class="nx">_</span><span class="p">,</span> <span class="nx">okR</span> <span class="o">:=</span> <span class="nx">expr</span><span class="p">.</span><span class="nx">Y</span><span class="p">.(</span><span class="o">*</span><span class="nx">ast</span><span class="p">.</span><span class="nx">BasicLit</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">okL</span> <span class="o">&amp;&amp;</span> <span class="nx">okR</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="summary">Summary</h2>
<p>Today&rsquo;s article focuses on how to parse a binary expression with the ast package and the parser package, and see how powerful it is to use it to make a very simple rule engine.</p>
<p>In fact, there are more interesting things you can do with the ast package. For example, convert thrift files to proto files in bulk, parse sql statements and do some auditing &hellip;&hellip;</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/golang/">golang</a>
          <a href="/tags/ast/">ast</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-02/bash-history-tricks/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Tips for using Bash History</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-02/where-is-goexit-from/">
            <span class="next-text nav-default">Where did goexit come from?</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
