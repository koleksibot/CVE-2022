<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Memcached Meta Commands - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Memcached is the oldest in-memory caching server. Because it doesn&amp;rsquo;t support as rich a data structure as Redis, Memcached is used less and less. But I think Memcached is a great example of the Unix philosophy of doing one thing at a time and doing it well. And Memcached is focused on the one thing that is memory caching. This is best demonstrated by the introduction of Meta Commands in Memcached in version 1." /><meta name="keywords" content="memcached, Meta, Commands" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-02/memcached-meta-commands/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Memcached Meta Commands" />
<meta property="og:description" content="Memcached is the oldest in-memory caching server. Because it doesn&rsquo;t support as rich a data structure as Redis, Memcached is used less and less. But I think Memcached is a great example of the Unix philosophy of doing one thing at a time and doing it well. And Memcached is focused on the one thing that is memory caching. This is best demonstrated by the introduction of Meta Commands in Memcached in version 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-02/memcached-meta-commands/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-02-28T09:28:18+08:00" />
<meta property="article:modified_time" content="2022-02-28T09:28:18+08:00" />

<meta itemprop="name" content="Memcached Meta Commands">
<meta itemprop="description" content="Memcached is the oldest in-memory caching server. Because it doesn&rsquo;t support as rich a data structure as Redis, Memcached is used less and less. But I think Memcached is a great example of the Unix philosophy of doing one thing at a time and doing it well. And Memcached is focused on the one thing that is memory caching. This is best demonstrated by the introduction of Meta Commands in Memcached in version 1."><meta itemprop="datePublished" content="2022-02-28T09:28:18+08:00" />
<meta itemprop="dateModified" content="2022-02-28T09:28:18+08:00" />
<meta itemprop="wordCount" content="2138">
<meta itemprop="keywords" content="memcached," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Memcached Meta Commands"/>
<meta name="twitter:description" content="Memcached is the oldest in-memory caching server. Because it doesn&rsquo;t support as rich a data structure as Redis, Memcached is used less and less. But I think Memcached is a great example of the Unix philosophy of doing one thing at a time and doing it well. And Memcached is focused on the one thing that is memory caching. This is best demonstrated by the introduction of Meta Commands in Memcached in version 1."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Memcached Meta Commands</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-02-28 09:28:18 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 2138 words </span>
          <span class="more-meta"> 11 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#cache-penetration-problem">Cache Penetration Problem</a></li>
        <li><a href="#the-hot-key-problem">The Hot Key Problem</a></li>
        <li><a href="#data-transfer-and-memory-usage-issues">Data transfer and memory usage issues</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>Memcached is the oldest in-memory caching server. Because it doesn&rsquo;t support as rich a data structure as Redis, Memcached is used less and less. But I think Memcached is a great example of the Unix philosophy of doing one thing at a time and doing it well. And Memcached is focused on the one thing that is memory caching. This is best demonstrated by the introduction of Meta Commands in Memcached in version 1.6. Today, we&rsquo;ll introduce you to Meta Commands.</p>
<p>The structure of a Meta Commands is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">&lt;cm&gt; &lt;key&gt; &lt;datalen*&gt; &lt;flag1&gt; &lt;flag2&gt; &lt;...&gt;<span class="se">\r\n</span>
</code></pre></td></tr></table>
</div>
</div><p>Here <code>&lt;cm&gt;</code> denotes <code>command</code>, which uses two letters to denote different commands. <code>&lt;key&gt;</code> indicates the key value to be operated on. <code>&lt;datalen*&gt;</code> indicates the length of the data part of this request. Some meta-commands do not need to transfer additional data, so this field is not needed. Then comes the essence of the Meta command: flag (tag). Each meta command can have multiple flags attached to it to influence the behavior of Memcached and the content of the return value.</p>
<p>The structure of the return value of a meta command is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">&lt;RC&gt; &lt;datalen*&gt; &lt;flag1&gt; &lt;flag2&gt; &lt;...&gt;<span class="se">\r\n</span>
</code></pre></td></tr></table>
</div>
</div><p>Here <code>&lt;RC&gt;</code> means <code>return code</code>, which is the return code. Like <code>&lt;cm&gt;</code>, <code>&lt;RC&gt;</code> uses two letters. There is also the optional <code>&lt;datalen*&gt;</code>, which is followed by multiple tokens.</p>
<p>Here are a few examples of meta commands.</p>
<p>Set cache.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">ms foo <span class="m">2</span> T90 F1<span class="se">\r\n</span>
hi<span class="se">\r\n</span>

HD<span class="se">\r\n</span>
</code></pre></td></tr></table>
</div>
</div><p>The meta directive starts with <code>m</code>. <code>ms</code> denotes <code>set</code>, which is used to set the cache. In this example, <code>foo</code> is the key name, and <code>2</code> indicates the length of the data. This is followed by two tag parameters: <code>T90</code> for setting the TTL to 90 seconds, and <code>F1</code> for setting the cache to <code>1</code> for the corresponding business data. Start another line to transfer the data with the length of two.</p>
<p>Query cache.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">mg foo t f v<span class="se">\r\n</span>
VA <span class="m">2</span> s2 t78 f1<span class="se">\r\n</span>

hi<span class="se">\r\n</span>
</code></pre></td></tr></table>
</div>
</div><p><code>mg</code> denotes <code>get</code>, which is used to query the cache information. Three token parameters are used in this example: <code>t</code> indicates that the cached TTL is returned, <code>f</code> indicates that the cached business token data is returned, and <code>v</code> indicates that the cached data is returned. Yes, <code>mg</code> does not return cached data by default. Because in many scenarios, the cached content will be large and we only need to see the TTL/CAS or something like that, so <code>mg</code> does not return the cached data by default and needs to add the <code>v</code> flag to return it.</p>
<p>To delete a cache.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">md foo I\r\n

HD\r\n
</code></pre></td></tr></table>
</div>
</div><p><code>md</code> stands for <code>delete</code>, which is used to delete the cache. However, it is also possible to adjust the server&rsquo;s behavior when deleting by marking it. For example, <code>I</code> here tells the server to mark the cache as expired (stale) and not to actually delete it. We&rsquo;ll talk more about the specific usage below.</p>
<p>With the above as a foundation, we will then describe how the meta directive specifically addresses various types of caching issues. In total, there are three types of problems, as follows.</p>
<ul>
<li>Cache-pass-through problems</li>
<li>Hot Key problems</li>
<li>Data transfer and memory usage problems</li>
</ul>
<h2 id="cache-penetration-problem">Cache Penetration Problem</h2>
<p>Cache penetration is a system performance problem caused by a large number of requests going back to the source after a cache has been invalidated or deleted. There are two ways to deal with this problem: one is to use a source lock, so that only requests with concurrent locks can go back to the source; the other is to avoid cache invalidation. These two methods can be easily implemented by using meta directives.</p>
<p>Let&rsquo;s start with the back-source concurrency lock.</p>
<p>We can use the <code>N</code> token when querying the cache.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">mg foo c v N30
VA <span class="m">0</span> c2 W
</code></pre></td></tr></table>
</div>
</div><p>This means that the cache corresponding to <code>foo</code> is queried, and if it does not exist, a new empty cache is created. If more than one request executes this statement at the same time, only one request has a <code>W</code> token in the return value, indicating that it got a back source lock and the request needs to update the cache via back source. The other requests receive the <code>Z</code> token. Since this query also returns the <code>CAS</code> version via the <code>c</code> flag, the cache should be updated with the <code>c</code> flag. As follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">ms foo <span class="m">2</span> c2
hi
</code></pre></td></tr></table>
</div>
</div><p>If another process updates the cache during the back-source process, the <code>CAS</code> version of the cache will also be updated and the back-source update will fail to avoid writing dirty data.</p>
<p>The above is for scenarios where the cache has been invalidated. There are only two cases of cache invalidation, one is when the expiration time has passed, and the other is when the source data has changed and the cache is actively deleted. The meta directive provides a back-to-source control mechanism for each of these two cases.</p>
<p>The first one is called Early Recache. So the so-called Early Recache is to obtain concurrent locks when the cache is about to expire, and try to update the cache before it expires, so as to avoid penetration. The specific method is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">mg foo v t R30
VA 2 t29 W
hi
</code></pre></td></tr></table>
</div>
</div><p>The <code>mg</code> here adds the <code>R30</code> flag to indicate that concurrent locks are acquired if the TTL of the cache is less than 30 seconds. When multiple requests are executed simultaneously, only one request will return the <code>W</code> flag. This request can comfortably do the source return and update the cache. When updating the cache, you need to pass <code>T</code> to set the new TTL, thus avoiding the cache expiration problem.</p>
<p>Another type of cache is called a Stale Cache. That is, when we delete a cache, we don&rsquo;t really delete it, but we mark it as dirty.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">md foo I T30
HD
</code></pre></td></tr></table>
</div>
</div><p>The <code>I</code> flag here means mark only, not delete. <code>T30</code> means the dirty cache is kept for a maximum of 30 seconds. Once the query encounters a dirty cache, it will return an additional <code>X</code> tag.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">mg foo t c v
VA 4 t29 c777 W X
data
</code></pre></td></tr></table>
</div>
</div><p>An <code>X</code> flag indicates that the current cache is out of date, but the business code can still decide whether to continue using it. More importantly, only one request out of all concurrent requests will receive the <code>W</code> flag, begging for help to update the cache back to its source. Dirty caching allows for more precise back-source control.</p>
<h2 id="the-hot-key-problem">The Hot Key Problem</h2>
<p>Another prominent problem with caching is the hot Key problem. If a Key is particularly heavily accessed, it can put a lot of pressure on a single node. Usually people will spread the pressure to different instances by sharding. But this requires a prerequisite that you need to know in advance which Keys are hot Keys. so this can only be described as an after-the-fact remedy. The meta directive provides us with the ability to discover hot Keys automatically.</p>
<p>In fact, it is just the introduction of two tokens.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">mg foo v h l c
VA <span class="m">4</span> h1 l5 c4
data
</code></pre></td></tr></table>
</div>
</div><p>The tags here are <code>h</code> and <code>l</code> respectively. Where <code>h1</code> indicates that the current key has been accessed since it was created, and <code>l5</code> indicates that the last access was made 5 seconds ago. With these two tokens, the business code can decide whether a local cache needs to be set or not. For example, we can do something like this.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">if (h == 1 &amp;&amp; l &lt; 5 &amp;&amp; random(1000) == 0) {
  add_to_local_cache(it)
}
</code></pre></td></tr></table>
</div>
</div><p>The <code>random(1000)</code> here can be other data indicators. If a key has been accessed recently, it may be a hot key and can be considered to be cached locally for a short period of time.</p>
<p>Once the data is cached locally, it becomes a problem to update it. Because it is a hot key, the cache time cannot be set too small. One option is to use a message queue to broadcast data updates, but this is too heavy. We can use <code>mg</code> to start a local timing process that periodically queries the <code>CAS</code> version of the hotkey.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">mg foo c
HD c500
</code></pre></td></tr></table>
</div>
</div><p>Here <code>mg</code> only returns the version number. If the version has changed, the local cache is updated again. This solves the hotkey discovery and update problem in a relatively simple way.</p>
<h2 id="data-transfer-and-memory-usage-issues">Data transfer and memory usage issues</h2>
<p>There are also two optimizations for reducing data transfer, one is to pass only the necessary data, and the other is to support returning multiple data in one request.</p>
<p>As we said earlier, the <code>mg</code> directive, by default, does not return cached data and keys. this way, if one only wants to see the TTL of a certain key, one only needs to execute it.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">mg foo t
HD t94
</code></pre></td></tr></table>
</div>
</div><p>Here <code>HD</code> means <code>header</code>, followed by <code>t94</code> which means the current TTL is 94 seconds. We can also use a single command to query multiple messages.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">mg foo t c
HD t94 c8
</code></pre></td></tr></table>
</div>
</div><p>The <code>c</code> here represents the <code>CAS</code> version, which changes when the cache data is updated.</p>
<p>If you need to check multiple caches, the traditional directive needs to be written like this.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">get bar foooooooooooooooooooooooooooooooo baz
VALUE foooooooooooooooooooooooooooooooo 0 2
hi
END
</code></pre></td></tr></table>
</div>
</div><p>Only <code>foooooooooooooooooooooooooooooooo</code> has a value here, and <code>END</code> means end. But <code>mg</code> does not support querying more than one key. the same effect needs to be written like this.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">mg bar v<span class="se">\r\n</span>mg foooooooooooooooooooooooooooooooo v<span class="se">\r\n</span>gm baz v<span class="se">\r\n</span>
VA <span class="m">2</span>
hi
</code></pre></td></tr></table>
</div>
</div><p>Since mg does not return the key by default, it is not clear which key <code>hi</code> corresponds to, and we can certainly ask the server to return the corresponding key by adding the <code>k</code> tag.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">mg bar k v\r\nmg foooooooooooooooooooooooooooooooo k v\r\ngm baz k v\r\n
VA 2 kfoooooooooooooooooooooooooooooooo
hi
</code></pre></td></tr></table>
</div>
</div><p>But here <code>foo+</code> is a bit too wasteful compared to the data <code>hi</code>. To reduce data transfer, <code>mg</code> supports <code>O</code> tags to pass in business data.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">mg bar O1 v\r\nmg foooooooooooooooooooooooooooooooo O2 v\r\ngm baz O3 v\r\n
VA 2 O1
hi
</code></pre></td></tr></table>
</div>
</div><p>This allows the business code to complete the mapping with the <code>O</code> flag in the return value. And because <code>mg</code> does not return <code>END</code> like <code>get</code>, to explicitly mark the completion of the data transfer, we need to pass an additional <code>mn</code> command, and the server will return the <code>MN</code> response directly. The complete command is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">mg bar O1 v\r\nmg foooooooooooooooooooooooooooooooo O2 v\r\ngm baz O3 v\r\nmn\r\n
VA 2 O1
hi
MN
</code></pre></td></tr></table>
</div>
</div><p>This achieves the effect of querying multiple keys with minimal data transfer.</p>
<p>Because the meta instruction can have multiple token information attached to it, we can complete multiple operations in a single handoff. As an example. If we want to use the cache to control spike inventory with a maximum inventory quantity of 100, we can perform the following operation.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">ma foo M- N120 J99 v
VA 2
99
</code></pre></td></tr></table>
</div>
</div><p>Here <code>ma</code> means <code>arithmetic</code>, which means arithmetic operation. <code>M-</code> means that the number is subtracted by one; <code>N120</code> means that if there is no cache, a new one is created with a TTL of 120 seconds; <code>J99</code> means that the newly added cache value is <code>99</code>; and <code>v</code> means that the result is returned. Since Memcached does not perform a minus one operation when creating a cache, the initial value of <code>100</code> is set to ensure that it will be minus one every time. But after it gets to 0, it doesn&rsquo;t keep decreasing, which means that the result after decreasing by one is <code>0</code>, regardless of whether the current value is <code>1</code> or <code>0</code>. So we need to treat the return value <code>1</code> as a sign that we are out of stock. If there is no <code>ma</code> command, we need to use <code>decr</code> and <code>add</code> commands to achieve the above effect.</p>
<p>The above is the main functionality and design of Memcached Meta Commands. There are many more meta-commands that can completely replace the original ones. If you are interested, you can continue to read the <a href="https://github.com/memcached/memcached/blob/master/doc/protocol.txt">official protocol</a> and also the official <a href="https://github.com/memcached/memcached/wiki/MetaCommands">introduction to meta-commands</a>. If you think of Memcached as an in-memory database, there is no way to compete with Redis. But if you think of Memcached only as an in-memory cache, then it&rsquo;s basically the best you can do. Although Memcached is used less than before, AWS&rsquo;s Elasticache actually supports Memcached version 1.6, which means that services on AWS can now use meta directives. This shows that Memcached should not be so easily replaced by Redis.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/memcached/">memcached</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-02/the-most-often-errors-in-flutter/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">The most common mistakes that beginners make when practicing Flutter</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-02/csharp-11-news-features/">
            <span class="next-text nav-default">What are the new features in C# 11?</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
