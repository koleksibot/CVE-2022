<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Modern processor architecture - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="A short, straightforward introduction to modern processor microarchitecture design.
 Today&amp;rsquo;s robots are very primitive, capable of understanding only a few simple instructions such as &amp;lsquo;go left&amp;rsquo;, &amp;lsquo;go right&amp;rsquo; and &amp;lsquo;build car&amp;rsquo;.
John Thomas Sladek
 Warning 1: This article is intended to be about serious science in informal and witty terms.
Warning 2: Long article! Estimated reading time is 36 minutes.
This article introduces some concepts about processor microarchitecture to junior computer science students and readers interested in modern processor architecture." /><meta name="keywords" content="cpu, Modern Processor architecture" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-02/modern-processor/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Modern processor architecture" />
<meta property="og:description" content="A short, straightforward introduction to modern processor microarchitecture design.
 Today&rsquo;s robots are very primitive, capable of understanding only a few simple instructions such as &lsquo;go left&rsquo;, &lsquo;go right&rsquo; and &lsquo;build car&rsquo;.
John Thomas Sladek
 Warning 1: This article is intended to be about serious science in informal and witty terms.
Warning 2: Long article! Estimated reading time is 36 minutes.
This article introduces some concepts about processor microarchitecture to junior computer science students and readers interested in modern processor architecture." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-02/modern-processor/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-02-22T09:49:16+08:00" />
<meta property="article:modified_time" content="2022-02-22T09:49:16+08:00" />

<meta itemprop="name" content="Modern processor architecture">
<meta itemprop="description" content="A short, straightforward introduction to modern processor microarchitecture design.
 Today&rsquo;s robots are very primitive, capable of understanding only a few simple instructions such as &lsquo;go left&rsquo;, &lsquo;go right&rsquo; and &lsquo;build car&rsquo;.
John Thomas Sladek
 Warning 1: This article is intended to be about serious science in informal and witty terms.
Warning 2: Long article! Estimated reading time is 36 minutes.
This article introduces some concepts about processor microarchitecture to junior computer science students and readers interested in modern processor architecture."><meta itemprop="datePublished" content="2022-02-22T09:49:16+08:00" />
<meta itemprop="dateModified" content="2022-02-22T09:49:16+08:00" />
<meta itemprop="wordCount" content="4982">
<meta itemprop="keywords" content="cpu," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Modern processor architecture"/>
<meta name="twitter:description" content="A short, straightforward introduction to modern processor microarchitecture design.
 Today&rsquo;s robots are very primitive, capable of understanding only a few simple instructions such as &lsquo;go left&rsquo;, &lsquo;go right&rsquo; and &lsquo;build car&rsquo;.
John Thomas Sladek
 Warning 1: This article is intended to be about serious science in informal and witty terms.
Warning 2: Long article! Estimated reading time is 36 minutes.
This article introduces some concepts about processor microarchitecture to junior computer science students and readers interested in modern processor architecture."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Modern processor architecture</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-02-22 09:49:16 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 4982 words </span>
          <span class="more-meta"> 24 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#super-10g">Super 10G</a></li>
        <li><a href="#streamline-and-instruction-level-parallelism">Streamline and instruction-level parallelism</a></li>
        <li><a href="#a-deeper-pipeline---a-super-pipeline">A deeper pipeline - a super pipeline</a></li>
        <li><a href="#multi-emission---superscalar-processors">Multi-emission - superscalar processors</a></li>
        <li><a href="#explicit-parallelism---extra-long-instruction-set">Explicit parallelism - extra-long instruction set</a></li>
        <li><a href="#data-dependency-and-latency">Data dependency and latency</a></li>
        <li><a href="#branching-and-branch-prediction">Branching and branch prediction</a></li>
        <li><a href="#removing-branching-statements">Removing Branching Statements</a></li>
        <li><a href="#instruction-scheduling-register-renaming-and-chaotic-execution">Instruction Scheduling, Register Renaming, and Chaotic Execution</a></li>
        <li><a href="#multicore-and-hyper-threading">Multicore and Hyper-Threading</a></li>
        <li><a href="#data-parallelism---simd-instruction-set">Data parallelism - SIMD instruction set</a></li>
        <li><a href="#memory-and-memory-walls">Memory and memory walls</a></li>
        <li><a href="#cache">Cache</a></li>
        <li><a href="#cache-conflicts-and-relevance">Cache Conflicts and Relevance</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/22/1895c720c00c4af4ae023bff907a8c56.png" alt="Modern Processor architecture"></p>
<p>A short, straightforward introduction to modern processor microarchitecture design.</p>
<blockquote>
<p><em>Today&rsquo;s robots are very primitive, capable of understanding only a</em> <em>few simple instructions such as &lsquo;go left&rsquo;, &lsquo;go right&rsquo; and &lsquo;build car&rsquo;.</em></p>
<p><a href="https://www.azquotes.com/quote/1403947">John Thomas Sladek</a></p>
</blockquote>
<p><strong>Warning 1:</strong> This article is intended to be about serious science in informal and witty terms.</p>
<p><strong>Warning 2:</strong> Long article! Estimated reading time is 36 minutes.</p>
<p>This article introduces some concepts about processor microarchitecture to junior computer science students and readers interested in modern processor architecture. Specifically, there are the following aspects.</p>
<ul>
<li>Streamlining (superscalar execution, chaotic execution, very long word instructions, branch prediction)</li>
<li>Multicore and Hyper-Threading (Synchronous Hyper-Threading SMT)</li>
<li>SIMD instruction set (SSE, AVS, NEON, SVE)</li>
<li>Cache and cache mechanism</li>
</ul>
<p>Sounds like a lot of deep content, <strong>but don&rsquo;t be afraid!</strong> This article will take you on a quick tour of what seems like something only a processor design practitioner or architecture expert could understand. Maybe you&rsquo;ll be able to brag to your classmates/friends soon.</p>
<h2 id="super-10g">Super 10G</h2>
<p>The higher the main frequency, the better the CPU performance, which seems to be a misconception of many people (excluding the up owner quoted above), but, since the ancient times, CPU performance and main frequency are not directly related. So where did this stereotype come from?</p>
<p>Let&rsquo;s take a look at some upper ancient (late 1990&rsquo;s) processor data&hellip;</p>
<table>
<thead>
<tr>
<th>Main Frequency</th>
<th>Model</th>
<th>SPECint95</th>
<th>SPECfp95</th>
</tr>
</thead>
<tbody>
<tr>
<td>195 MHz</td>
<td>MIPS R10000</td>
<td>11.0</td>
<td>17.0</td>
</tr>
<tr>
<td>400 MHz</td>
<td>Alpha 21164</td>
<td>12.3</td>
<td>17.2</td>
</tr>
<tr>
<td>300 MHz</td>
<td>UltraSPARC</td>
<td>12.1</td>
<td>15.5</td>
</tr>
<tr>
<td>300 MHz</td>
<td>Pentium II</td>
<td>11.6</td>
<td>8.8</td>
</tr>
<tr>
<td>300 MHz</td>
<td>PowerPC G3</td>
<td>14.8</td>
<td>11.4</td>
</tr>
<tr>
<td>135 MHz</td>
<td>POWER2</td>
<td>6.2</td>
<td>17.6</td>
</tr>
</tbody>
</table>
<p>SPEC was a commonly used performance test tool back in the day, and Steve Jobs demonstrated the performance improvement of SPEC at the launch when he announced the switch of Apple&rsquo;s Macbook from IBM PowerPC platform to Intel&rsquo;s Core platform.</p>
<p>From the table, you can see why there is such a different performance difference for 300MHz processors. Why do the lower main frequency CPUs crush the higher main frequency ones instead?</p>
<p>What? You say this is all the data from the past? Then let&rsquo;s have a recent one.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/22/e70dad6a96684ad6a223a487ad54eb6a.png" alt="sobyte"></p>
<p>The Intel i9-9900K that is super to half human thank you (5GHz) is actually being hung by the M1?</p>
<p>Yes, you read that right, which means there&rsquo;s obviously something besides the main frequency, and that is -</p>
<h2 id="streamline-and-instruction-level-parallelism">Streamline and instruction-level parallelism</h2>
<p>Instructions are executed one after the other in the processor, right? Not exactly right. Such a statement may be intuitive, but it is not true. In fact, since the 1980s, CPUs no longer execute each instruction exactly sequentially. Modern processors can execute different stages of different instructions at the same time, and some can even execute multiple instructions completely simultaneously.</p>
<p>Let&rsquo;s take a look at how a simple four-stage pipeline is constructed. Instructions are divided into four parts: <strong>fetch, decode, execute, and write back</strong> .</p>
<p>If the CPU executes fully sequentially, then each instruction takes 4 cycles to execute, IPC = 0.25 (Instruction per cycle). Of course, CPI was preferred in older times, when processors were generally unable to execute one instruction per cycle. But times have changed, and any desktop processor you can get your hands on can execute one, two, or even three instructions in one cycle.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/22/203ada2a85a647fea158c1d093461759.png" alt="sobyte"></p>
<p>As you can see, the components within the CPU that are responsible for computing (ALU) are actually very laid back, even working only 25% of the time. What? I see you have a talent for capitalism&hellip;</p>
<p>Well, modern processors do have the means to squeeze these ALUs (yes, modern processors have more than one ALU too). A very intuitive idea is that since most of the stages are not fully occupied by the CPU, it would be nice to overlap them. Indeed, that&rsquo;s what modern processors do.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/22/ecced06da65b422388f4d3245f7773dd.png" alt="sobyte"></p>
<p>Now we have a processor that can execute one instruction a cycle most of the time, which looks good! That&rsquo;s already a quadruple speedup without increasing the main frequency.</p>
<p>From a hardware point of view, each stage of the pipeline is made up of logic modules for that stage, and the CPU clock acts like a pump, pumping signals (or one could say data) from one stage to the next one at a time, like this.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/22/69cc23c304344eee9167eda9503b4802.png" alt="sobyte"></p>
<p>In fact, in addition to such a simple structure, modern processors have, first, many additional ALUs, such as integer multiplication, addition, bitwise operations, various operations on floating-point numbers, etc., with at least one ALU for almost every common operation. second, if the result of the previous instruction is the operand of the next instruction, then why write the data back to the register? Thus comes the Bypass (forward pass) path, used in this case to redirect data to the input port of the operator. Putting it all together, a more detailed pipelined microarchitecture would look like this.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/22/3aa899c20fe54ab6877ae0f44bed19ab.png" alt="sobyte"></p>
<h2 id="a-deeper-pipeline---a-super-pipeline">A deeper pipeline - a super pipeline</h2>
<p>Since CPU main clock for some reason (some mysterious force?) Since there has been no major improvement for many years (yes, the top of the overclocking list is still AMD&rsquo;s bulldozer architecture CPU), pipeline design has become almost the race home for CPU manufacturers. Deeper pipelines firstly continue to increase the actual IPC (the theoretical upper limit is still 1), and secondly avoid the impact of pipelines on timing. This has to do with the characteristics of transistors, and interested readers can search the web to find out why multi-stage pipeline structure affects timing and the final synthesis out of the main frequency.</p>
<p>This race reached its peak between 2000-2010, when processors could even have pipelines of up to 31 stages. But the ultra-deep pipeline brought structural complexity and significantly more difficulty in designing dynamic scheduling modules, so there have not been any CPUs with that many pipeline stages since then. For comparison, most current (2021) processors use pipelines ranging from 10-20 levels depending on the application scenario.</p>
<p>x86 and other CISC processors typically have deeper pipelines because they have several times as many tasks to do in the fetch and decode phase, so they typically use deeper pipelines to avoid performance loss in this phase.</p>
<h2 id="multi-emission---superscalar-processors">Multi-emission - superscalar processors</h2>
<p>Since integer operators and floating point operators and some other ALUs are not dependent on each other and do their own thing, why not squeeze them further and make them as busy as possible together? This gives rise to multi-launch and superscalar processors. Multi-emission means that the processor can &ldquo;fire&rdquo; more than one instruction per cycle, for example, floating-point and integer instructions can be executed simultaneously without interfering with each other. To accomplish this, the logic of the fetch and decode phases must be enhanced, which gives rise to a structure called a <strong>scheduler</strong> or <strong>distributor</strong>, which looks like this.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/22/aabfbe317cbd4ec0afbc714028920008.png" alt="sobyte"></p>
<p>Or let&rsquo;s look at an actual Intel Skylake architecture scheduler. The red circle in the diagram is the scheduler responsible for &ldquo;firing&rdquo; instructions per cycle.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/22/868189efc5d844edb684723364166cee.png" alt="sobyte"></p>
<p>Of course, different operations now have different &ldquo;data paths&rdquo; and go through different operators. Because different operators may also have different execution stages within them, different instructions have different pipeline depths: simple instructions are executed faster and complex instructions are executed slower, which reduces the <strong>latency</strong> of simple instructions (which we&rsquo;ll get to shortly). Some instructions (such as division) can be quite time-consuming and may take tens of cycles to return, so these factors become especially important in compiler design. The interested reader may wish to consider the usefulness of <strong>Mason primes</strong> here.</p>
<p>The instruction flow in a superscalar processor might look like this.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/22/3949d6186bc040ca8c9e7436d76655e3.png" alt="sobyte"></p>
<p>Modern processors generally have a considerable number of launch ports, for example, the Intel Skylake mentioned above is an eight-launch architecture, Apple&rsquo;s M1 is also eight-launch, and ARM&rsquo;s latest release, the N1, is a 16-launch processor.</p>
<h2 id="explicit-parallelism---extra-long-instruction-set">Explicit parallelism - extra-long instruction set</h2>
<p>When compatibility is not an issue (which, unfortunately, is rarely the case), we can design an instruction set that explicitly states that certain instructions can be executed in parallel, thus avoiding tedious dependency checks at decode time. This would theoretically make the hardware design of the processor simpler, smaller, and easier to achieve higher main frequencies.</p>
<p>In this type of instruction set, an &ldquo;instruction&rdquo; is actually a &ldquo;set of sub-instructions&rdquo;, which allows them to have a very large number of instructions, and thus each instruction is very long, e.g. 128bits, which is where the name <strong>Very Long Instruction Set (VLIW)</strong> comes from.</p>
<p>The instruction flow of a Very Long Instruction Set processor is very similar to that of a superscalar processor, except that it eliminates the cumbersome fetch and decode stages, like this.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/22/807d416e6d9741ab8d18b9aad1d280d6.png" alt="sobyte"></p>
<p>Except for the hardware architecture, very long instruction set processors are very similar to superscalar processors, especially from the compiler&rsquo;s point of view (which we will also talk about soon).</p>
<p>However, very long instruction set processors are usually designed to <strong>not check dependencies</strong>, which makes them dependent on compiler magic to guarantee correct results, and if a cache miss occurs, they have to stop the whole processor, not just the instruction that encountered the cache miss problem. The compiler inserts &ldquo;nops&rdquo; (no operations) - that is, empty instructions - between instructions to ensure that data-dependent instructions are executed correctly. This undoubtedly makes the compiler more difficult to design and takes longer to compile, but it also saves valuable on-chip processor resources and often results in slightly better performance.</p>
<p>Intel&rsquo;s IA-64 architecture was a very long instruction set (VLIW) architecture, and the resulting &ldquo;Itanium&rdquo; family of processors was considered the successor to x86 at the time. The &ldquo;Itanium&rdquo; series of processors was considered the successor to the x86 at the time, but the market did not like the new architecture, so the series did not develop. The hottest direction of modern hardware acceleration is the GPU, which can also be considered a VLIW architecture processor, but it takes the VLIW architecture a step further by using &ldquo;core functions&rdquo; instead of instructions, which greatly increases the scalability of this architecture, and is also available to interested readers.</p>
<h2 id="data-dependency-and-latency">Data dependency and latency</h2>
<p>How far can we go down the road of pipelining and multi-launching? If multi-launch and multi-stage pipelining are so good, why not make a 50-stage pipelined, 30-launch processor? Let&rsquo;s discuss the following two instructions.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">a = b * c;
d = a + 1;
</code></pre></td></tr></table>
</div>
</div><p>Second instruction <strong>Dependent</strong> First instruction - the processor cannot execute the next instruction until it has completed the previous one. This is a serious problem, which makes multiple firing useless, because no matter how many firing processors you make, the two instructions can still only be executed sequentially (excluding parts such as fetching fingers). We will discuss about dependencies and elimination later.</p>
<p>If the first instruction is a simple addition instruction, then the adder can pass the data back to the input port of the ALU via the Bypass path (forward pass) after execution and continue the computation so that the pipeline can work properly. But unfortunately, the first instruction is a multiplication that requires multiple cycles to complete (most current CPUs do not use single-cycle multiplication because the complex logic usually hurts the main frequency), so the processor has to add a number of &ldquo;bubbles&rdquo; to the pipeline in order to wait for the first instruction to complete, which is similar to &ldquo;nops&rdquo; to ensure the correctness of the operation.</p>
<p>The number of CPU cycles it takes between the time an instruction reaches the input port of the operator and the time the result is available for execution is called <strong>instruction latency</strong>. The deeper the pipeline, the higher the instruction latency, so a deeper pipeline that cannot be filled efficiently will only result in high instruction latency without any benefit to the processor performance.</p>
<p>From the compiler&rsquo;s point of view (taking into account Bypass, the latency in the hardware engineer&rsquo;s mouth usually does not include Bypass), the instruction latency of modern processors is typically: 1 cycle for integer multiplication and bit operations, 2-6 cycles for floating point multiplication and addition, 10+ cycles for complex instructions like sincos, and finally division which can be up to 30-50 cycles.</p>
<p>The latency of access operations is also a very problematic issue, because they are usually the very first step of each instruction, which makes the latency they cause difficult to compensate in other ways. In addition to this, their latency is also hard to predict, because the latency depends heavily on whether the cache hits or not, and the cache is dynamically scheduled (which we will also talk about soon).</p>
<h2 id="branching-and-branch-prediction">Branching and branch prediction</h2>
<p>Another important issue in the pipeline is branching, so let&rsquo;s look at the next section of the program.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">7</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The compiled assembly program will look like this.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">    cmp a, 7    ; a &gt; 7 ?
    ble L1
    mov c, b    ; b = c
    br L2
L1: mov d, b    ; b = d
L2: ...
</code></pre></td></tr></table>
</div>
</div><p>Now imagine a pipelined processor executing this program. By the time the processor reaches the second line, that is, the second line of the jump command, the processor&rsquo;s executor must have removed all subsequent instructions from memory in advance and completed the decoding process. But which instruction is being jumped? Is it line 3, line 4 or line 5? We don&rsquo;t know where to jump until the jump command reaches the executor. In a deeply pipelined processor, it seems to have to stop and wait for the jump command, then refill the pipeline with new instructions. This is of course unacceptable. Programs, especially loops, have a large percentage of branch-jump commands, and if we waited for this command to complete every time, then our pipeline would have to pause frequently, and the performance gains we achieved with the pipeline would be lost.</p>
<p><strong>So modern processors make guesses</strong> . What? I thought the advanced processor design industry could come up with a better solution! Don&rsquo;t worry yet, there is actually a pattern to the branch jumps in the program, and modern processors branch predictions are typically 99% accurate or better (although branch predictions are also the source of Intel&rsquo;s spectre and meltdown vulnerabilities).</p>
<p>The <strong>processor will execute along the predicted branch</strong> , so that our processor can keep the pipeline and operators occupied and execute at high speed. Of course, the result of the execution is not yet final; only after the result of the branch-hopping command is available will the correct prediction be written back (commit or retire). What about wrong guesses? Then the processor has no choice but to start the pipeline again from another branch, and in highly streamlined modern processors, the cost of a branch prediction error (<strong>branch prediction error penalty</strong>) is quite high, often amounting to tens of CPU cycles.</p>
<p>The key here is how <strong>processors make predictions</strong>. In general, there are two types of branch prediction: static and dynamic.</p>
<p><strong>Static branch prediction means that the processor makes a guess independent of the runtime state</strong> and the optimization of the jumps is done by the compiler. Static predictions usually have a blanket jump or a backward jump that predicts no jump, and a forward jump that predicts a jump. The latter usually works better because loops generally have a large number of forward jump instructions in them.</p>
<p><strong>Dynamic branch prediction, on the other hand, decides whether to jump or not based on the history of jump instructions</strong> . One of the simplest dynamic branch predictors is the <strong>2-bit saturation counter</strong> , which is a four-state state machine characterized by the fact that only two consecutive prediction errors will change the prediction direction. It has been able to achieve more than 90% correct prediction rates in most settings.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/22/894a50c382d64daeaf45ae03c802a15c.png" alt="sobyte"></p>
<p>This predictor performed poorly when alternating jump and non-jump branch instructions, so the n-level adaptive branch predictor was invented, which is similar in principle to a 2-bit saturation counter, although it can remember the past n histories and perform well in repeated jump patterns.</p>
<p>Unfortunately, branch prediction is one of the core competencies of each CPU vendor, and most good branch prediction techniques are also important trade secrets, so there is not much to dive into in this area. cloudflare recently published a <a href="https://blog.cloudflare.com/branch-predictor/">blog post</a> that tested in depth the characteristics of branch predictors on M1 for x86 and ARM, and interested readers can take a look.</p>
<h2 id="removing-branching-statements">Removing Branching Statements</h2>
<p>Since branching is something that processors don&rsquo;t like, people want to minimize the use of branch statements. The following is common, and is often used when finding the maximum and minimum values or when making conditional assignments (lines 1, 2).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">cmp a, 7       ; a &gt; 7 ?
mov c, b       ; b = c
cmovle d, b    ; if le, then b = d
</code></pre></td></tr></table>
</div>
</div><p>So people devised instructions like line 3. Such an instruction assigns the value of d to b under a specific condition without introducing a branch, and simply does not write back (commit/retire) when the condition is not satisfied. This instruction is called a <strong>conditional transfer instruction</strong> and is often used in compilers to avoid jumping.</p>
<p>Our ancient x86 architecture did not support conditional transfer instructions to begin with, nor did MIPS or SPARC, while the Alpha architecture was designed from the beginning with such instructions in mind (newer instruction sets like RISC-V certainly do.) ARM, on the other hand, was the first instruction set to use fully predictable instructions, which is interesting because early ARM processors typically used a very shallow pipeline with The branch prediction penalty was very small.</p>
<h2 id="instruction-scheduling-register-renaming-and-chaotic-execution">Instruction Scheduling, Register Renaming, and Chaotic Execution</h2>
<p>If branches and long-latency instructions introduce pipeline bubbles, can the processor time taken up by these bubbles be used for useful things? To achieve this, it is necessary to introduce <strong>random execution</strong> . Chaotic execution allows the processor to disorder some of the instructions and execute something else at the same time as the long latency instructions.</p>
<p>Historically, there have been two ways to achieve chaotic execution: software and hardware.</p>
<p>The software approach is well understood and involves strong compiler-architecture coupling to generate instructions at the compile stage that are free of interdependencies and easy to schedule by the processor. The advantage of instruction rescheduling at the compile stage, also known as <strong>static instruction scheduling</strong>, is that the software implementation can be more flexible (as we all know, software can do anything), and often the software can also have enough storage space to analyze the entire program and therefore obtain a better instruction layout. The disadvantages are of course obvious, as the compiler requires in-depth knowledge of architecture-related information, such as instruction latency and branch prediction penalties, making portability very difficult. Therefore the hardware approach is more commonly used in modern processors.</p>
<p>The hardware approach focuses on <strong>register renaming</strong> to eliminate read-read and write-write pseudo-dependencies. Register renaming means using different physical hardware storage for the same registers called by different instructions, and then sorting these instructions and registers in the write-back phase so that these false dependencies are no longer the cause of pipeline bubbles. Note that write-read dependencies are true data dependencies, and while techniques like forward delivery can reduce latency, there is no solution to such dependencies. Modern processors also do not have just 16 general-purpose registers and 32 floating-point registers, for example, but usually hundreds of physical registers on the CPU&rsquo;s chip. The most famous algorithm for register renaming is the Tomasulo algorithm, which the interested reader can search for.</p>
<p>The advantage of the hardware approach is that it reduces the architecture coupling of the compiler, improves the convenience of software writing, and usually the hardware messy execution is not as bad as the software. The disadvantage is that both dependency analysis and register renaming consume valuable on-chip space and power, but the performance improvement is not correspondingly large. Therefore, sequential execution is used in some CPUs that are more concerned with low power consumption and cost, such as ARM&rsquo;s low-power product line, Intel Atom, etc.</p>
<h2 id="multicore-and-hyper-threading">Multicore and Hyper-Threading</h2>
<p>We have previously discussed various approaches to instruction set parallelism, and many times they do not work very well because a significant portion of programs do not provide fine-grained parallelism. Therefore, the effect of making wider and deeper processors is quite limited.</p>
<p>But then the CPU designers thought, if there is no sufficient parallelism in this program without interdependent instructions, then there must be no data dependency between different programs (instruction-level data dependency), so wouldn&rsquo;t it be nice to run two threads on the same physical core at the same time to fill in the gaps in the pipeline with each other? This is called <strong>synchronous multithreading (SMT)</strong> , and it provides thread-level parallelization. This technique is transparent to the world outside the CPU, as if there were really twice as many CPUs, hence the virtual cores that are now also often spoken of.</p>
<p>From a hardware perspective, a synchronous multithreading implementation requires doubling the number of all structures related to running state, such as registers, PC counters, MMUs and TLBs, etc. Fortunately, these structures are not a major part of the CPU, and the most complex decoders and distributors, operators and caches are shared between the two threads.</p>
<p>Of course, the real performance cannot be doubled, the theoretical upper limit depends on the number of operators, and synchronous multithreading just makes better use of the operators. Therefore, in tasks such as game screen generation, where parallelism is already very high, SMT has almost no effect, but instead brings some performance loss due to occasional thread switching.</p>
<p>The instruction flow of the SMT processor looks something like this.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/22/fbc53d019c1a4a0fb92db65f93d8b1f7.png" alt="sobyte"></p>
<p>Great! Now we have a way to fill which pipeline bubbles, without any risk. So, <strong>30-launch processor here we come</strong>! Is that right? Unfortunately, no.</p>
<p>Although IBM has used 8-threaded cores in its products, but we will soon see that the bottleneck of modern processors has long been not only the CPU itself, access memory latency and bandwidth have become more urgent issues to solve. And using 8 MMUs, 8 PCs, and 8 TLBs at the same time is not a cache-friendly approach. As a result, it is rare to hear of processors with more than one core and two threads anymore.</p>
<h2 id="data-parallelism---simd-instruction-set">Data parallelism - SIMD instruction set</h2>
<p>In addition to instruction-level parallelism and hyperthreading, there is another type of parallelized design in modern processors - data parallelization. The idea of data parallelization is to parallelize different data of the same instruction, not to parallelize different instructions. That is why instruction sets that use data parallelization are often called <strong>SIMD instruction sets</strong> (single instruction multiple data) or <strong>vector instruction sets</strong>.</p>
<p>In supercomputers and high performance computing, SIMD instruction sets are used extensively because scientific computations usually deal with extremely large amounts of data without complex operations on each piece of data and with essentially no interdependencies. The SIMD instruction set is also present in a large number of modern personal computers, even in the most inexpensive cell phones.</p>
<p>The SIMD instruction set works as shown in the following diagram.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/22/5651d8b55cbe4635b80d909d21b63a85.png" alt="sobyte"></p>
<p>Intel has been increasing the length of vectors that can be parallelized over the past 20 years, from 128bits for SSE to 512bits for AVX512, while ARM has leaped from 128bits for NEON to 2048bits for SVE since ARMv8a. ARM has leaped from NEON&rsquo;s 128bits to SVE&rsquo;s 2048bits since ARMv8a, and even supports variable length.</p>
<p>Modern x86-64 processors support the SSE instruction set, so compilers now automatically add the SSE instruction set for optimization if they compile target files for 64-bit platforms. Because the SIMD instruction set is evolving rapidly, many instructions have latencies comparable to traditional scalar commands, and because the SSE instruction set also has instructions that operate on individual operands, modern compilers use the SSE instruction set by default for individual floating-point operations instead of using traditional x87 floating-point instructions. In addition, almost all architectures have their own SIMD instruction set.</p>
<p>Simple and repetitive tasks like rendering screens or scientific calculations are well suited to the SIMD instruction set, and in fact, GPUs work similarly to SIMD. Unfortunately, the SIMD instruction set does not work well in most ordinary (unthought-out) code. Modern compilers all have varying degrees of automatic loop vectorization (using the SIMD instruction set), but when the program writer does not give good consideration to data dependencies and memory layout (as will be discussed shortly), the compiler often fails to optimize the code much. Fortunately, it is often possible for the compiler to understand that certain loops can be optimized with simple changes, which in turn can dramatically improve the speed of the program.</p>
<h2 id="memory-and-memory-walls">Memory and memory walls</h2>
<blockquote>
<p>Modern processors are so fast that they spend most of their time waiting for memory to respond instead of doing their job.</p>
<p>&ndash; Anonymous (forgot the source)</p>
</blockquote>
<p>Since the invention of computers, processors have evolved much faster than storage, as shown in the following comparative chart.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/22/710a0ef028914219bd767ab5c6efba0c.png" alt="sobyte"></p>
<p>Memory access is very expensive for modern processors.</p>
<ul>
<li>In 1980, a CPU access to memory typically took only one cycle.</li>
<li>In 2021, it will take about 300-500 cycles for a CPU to access memory.</li>
</ul>
<p>When we consider that we use so many means on the CPU to squeeze the operators so that the IPC can break 1, this makes memory even slower to look at. Here is a table showing how long it takes to access the rest of the memory if the processor cycle is considered as 1 second.</p>
<table>
<thead>
<tr>
<th>Event</th>
<th>Delay</th>
<th>Equivalent Delay</th>
</tr>
</thead>
<tbody>
<tr>
<td>CPU cycles</td>
<td>0.2ns</td>
<td>1s</td>
</tr>
<tr>
<td>L1 cache access</td>
<td>0.9ns</td>
<td>4s</td>
</tr>
<tr>
<td>L2 cache access</td>
<td>3ns</td>
<td>15s</td>
</tr>
<tr>
<td>L3 cache accesses</td>
<td>10ns</td>
<td>50s</td>
</tr>
<tr>
<td>Memory access</td>
<td>100ns</td>
<td>8min</td>
</tr>
<tr>
<td>Solid-state drive access</td>
<td>10-100us</td>
<td>15-150h</td>
</tr>
<tr>
<td>mechanical hard drive access</td>
<td>1-10ms</td>
<td>2-18 months</td>
</tr>
</tbody>
</table>
<p>As you can see, modern CPUs are simply too fast and programmers now have to spend more effort than in the past to make their programs take full advantage of the CPU&rsquo;s performance instead of getting stuck on memory operations.</p>
<p>To solve this serious problem, processor designers have come up with a solution, the cache that has appeared in the table above. 80s CPUs were basically not designed with a cache because there was no memory wall problem. Modern CPUs generally have up to three levels of cache (some low-power and mobile CPUs have only two), and understanding how these caches work is good for programmers to write faster programs.</p>
<h2 id="cache">Cache</h2>
<p>Modern processors use multiple levels of cache to avoid the effects of memory latency in order to address memory walls. A typical cache structure looks like this.</p>
<table>
<thead>
<tr>
<th>level</th>
<th>size</th>
<th>delay</th>
<th>physical location</th>
</tr>
</thead>
<tbody>
<tr>
<td>L1 cache</td>
<td>32 KB</td>
<td>4 cycles</td>
<td>internal per core</td>
</tr>
<tr>
<td>L2 cache</td>
<td>256 KB</td>
<td>12 cycles</td>
<td>per die or per core</td>
</tr>
<tr>
<td>L3 cache</td>
<td>6 MB</td>
<td>~21 cycles</td>
<td>shared across the processor or per die</td>
</tr>
<tr>
<td>RAM</td>
<td>4+ GB</td>
<td>~117 cycles</td>
<td>on a memory stick on the motherboard</td>
</tr>
</tbody>
</table>
<p>Happily, the caching mechanisms of modern processors are surprisingly effective, with L1 cache hit rates as high as 90% most of the time, indicating that the cost of a memory access is only a few cycles in most cases.</p>
<p>The cache is able to achieve such good results mainly because the program is well <strong>localized</strong>. There are spatial locality and temporal locality. <strong>Time-locality</strong> means that when a program accesses a piece of memory, it is likely to access that piece of memory consecutively next. <strong>Spatial locality</strong> means that when a program accesses a piece of memory, it is likely to access a nearby piece of memory perhaps. To take advantage of such locality, the data in memory is copied from the memory sticks to the cache piece by piece, and these fast are called <strong>cache lines</strong>.</p>
<p>From a hardware perspective, the cache works much like a key-value pair table; the Key is the address of the memory, and the Value is the corresponding data. In fact the Key is not necessarily the full address, but is usually a part of the high bit of the address, while the low bit is used to index the cache itself. It is possible to use both physical and virtual addresses as Key, and there are advantages and disadvantages to each (as with all things). The disadvantage of using virtual addresses is that process context switches require cache refreshes, which are very expensive. The disadvantage of using physical addresses is that every time you check the cache, you need to check the page table first. Therefore, modern processors usually use virtual addresses as cache indexes and physical addresses as cache line markers. Such an approach is also known as &quot; <strong>virtual index - physical tag</strong>&quot; caching.</p>
<h2 id="cache-conflicts-and-relevance">Cache Conflicts and Relevance</h2>
<p>Ideally, caches should hold the most recently used data, but for hardware caches on CPUs, algorithms to efficiently maintain usage state cannot meet strict latency requirements and are difficult to implement in hardware, so usually processors use a simple approach: <strong>each cache line corresponds directly to several locations in memory</strong> . Since the corresponding locations are unlikely to be accessed simultaneously, the cache is valid.</p>
<p>This is very fast (which is what caches were originally designed for), but when the program does keep accessing different locations corresponding to the same cache line back and forth, the cache control unit has to repeatedly load data from memory, which is very time consuming and is called a <strong>cache conflict</strong>. The solution is not to limit each memory region to one cache line, but to several, which are called <strong>cache associativity</strong>.</p>
<p>Of course, the fastest way is to have one cache line per memory region, which is called a <strong>direct mapped cache</strong>, and a cache using four associativity levels is called a <strong>4-channel associative cache</strong>. A cache where memory can be loaded to any cache line is called a <strong>full associative cache</strong>. The benefit of using associative caching is that it greatly reduces cache conflicts while keeping query latency within a reasonable range. This is also the approach typically used by modern processors.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/cpu/">cpu</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-02/sigstore/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">What is the Sigstore project?</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-02/c-va-list-pitfall/">
            <span class="next-text nav-default">A va_list error case</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
