<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Communicating with C&#43;&#43; code in NodeJS - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="I recently encountered a problem in my project where I needed to call C&#43;&#43; code in NodeJS, so here&amp;rsquo;s a quick summary.
The main options In NodeJS, there are two main options for communicating with code written in other languages.
 Using the AddOn technique, write an extension to NodeJS using C&#43;&#43; and then call the source code or dynamic libraries written in other languages in the code using the FFI (Foreign Function Interface) technique, which brings in dynamic libraries written in other languages directly in Node  A comparison of these two approaches shows that each has its own advantages and disadvantages." /><meta name="keywords" content="c&#43;&#43;, Communicate Node" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-02/communicate-with-cpp-code-in-node/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Communicating with C&#43;&#43; code in NodeJS" />
<meta property="og:description" content="I recently encountered a problem in my project where I needed to call C&#43;&#43; code in NodeJS, so here&rsquo;s a quick summary.
The main options In NodeJS, there are two main options for communicating with code written in other languages.
 Using the AddOn technique, write an extension to NodeJS using C&#43;&#43; and then call the source code or dynamic libraries written in other languages in the code using the FFI (Foreign Function Interface) technique, which brings in dynamic libraries written in other languages directly in Node  A comparison of these two approaches shows that each has its own advantages and disadvantages." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-02/communicate-with-cpp-code-in-node/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-02-09T13:17:53+08:00" />
<meta property="article:modified_time" content="2022-02-09T13:17:53+08:00" />

<meta itemprop="name" content="Communicating with C&#43;&#43; code in NodeJS">
<meta itemprop="description" content="I recently encountered a problem in my project where I needed to call C&#43;&#43; code in NodeJS, so here&rsquo;s a quick summary.
The main options In NodeJS, there are two main options for communicating with code written in other languages.
 Using the AddOn technique, write an extension to NodeJS using C&#43;&#43; and then call the source code or dynamic libraries written in other languages in the code using the FFI (Foreign Function Interface) technique, which brings in dynamic libraries written in other languages directly in Node  A comparison of these two approaches shows that each has its own advantages and disadvantages."><meta itemprop="datePublished" content="2022-02-09T13:17:53+08:00" />
<meta itemprop="dateModified" content="2022-02-09T13:17:53+08:00" />
<meta itemprop="wordCount" content="3391">
<meta itemprop="keywords" content="c&#43;&#43;,node," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Communicating with C&#43;&#43; code in NodeJS"/>
<meta name="twitter:description" content="I recently encountered a problem in my project where I needed to call C&#43;&#43; code in NodeJS, so here&rsquo;s a quick summary.
The main options In NodeJS, there are two main options for communicating with code written in other languages.
 Using the AddOn technique, write an extension to NodeJS using C&#43;&#43; and then call the source code or dynamic libraries written in other languages in the code using the FFI (Foreign Function Interface) technique, which brings in dynamic libraries written in other languages directly in Node  A comparison of these two approaches shows that each has its own advantages and disadvantages."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Communicating with C&#43;&#43; code in NodeJS</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-02-09 13:17:53 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 3391 words </span>
          <span class="more-meta"> 16 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#the-main-options">The main options</a>
          <ul>
            <li><a href="#ffi-preparation-for-use">FFI preparation for use</a></li>
            <li><a href="#installing-nodejs">Installing NodeJS</a></li>
            <li><a href="#installing-the-c-toolchain-for-windows">Installing the C++ toolchain for Windows</a></li>
            <li><a href="#install-node-gyp">Install node-gyp</a></li>
            <li><a href="#installing-ffi-and-ref">Installing FFI and REF</a></li>
            <li><a href="#installing-the-electron-rebuild-package">Installing the electron-rebuild package</a></li>
          </ul>
        </li>
        <li><a href="#how-to-use">How to use</a>
          <ul>
            <li><a href="#simple-overview">Simple overview</a></li>
            <li><a href="#types">Types</a></li>
            <li><a href="#calling-external-symbols">Calling external symbols</a></li>
            <li><a href="#callback-functions">Callback functions</a></li>
          </ul>
        </li>
        <li><a href="#some-tips">Some Tips</a>
          <ul>
            <li><a href="#how-to-debug--dll">How to debug  DLL</a></li>
            <li><a href="#how-to-load-a-dll-that-is-in-another-folder">How to load a DLL that is in another folder</a></li>
            <li><a href="#some-linking-errors">Some linking errors</a></li>
            <li><a href="#using-ffi-in-electron">Using FFI in Electron</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>I recently encountered a problem in my project where I needed to call C++ code in NodeJS, so here&rsquo;s a quick summary.</p>
<h2 id="the-main-options">The main options</h2>
<p>In NodeJS, there are two main options for communicating with code written in other languages.</p>
<ul>
<li>Using the AddOn technique, write an extension to NodeJS using C++ and then call the source code or dynamic libraries written in other languages in the code</li>
<li>using the FFI (Foreign Function Interface) technique, which brings in dynamic libraries written in other languages directly in Node</li>
</ul>
<p>A comparison of these two approaches shows that each has its own advantages and disadvantages.</p>
<p>First, the AddOn technique is more general, it can use C++ code to extend the behavior of Node, and many libraries use this approach to do some of the more low-level operations (such as communication with the operating system). However, it is a bit tricky to write a C++ project, export the corresponding functions according to the NodeJS specification, and compile it every time you install it (to fit the local Node version). If you just call a DLL, you also need to repackage the DLL&rsquo;s interface in your project.</p>
<p>If you use FFI technology, it is more limited. First, it can only call other dynamic libraries, and if you want to do more with C/C++, you need to wrap another layer of DLL, and it only supports the <code>_cdecl</code> calling convention (that is, the DLL must be marked with the <code>_cdecl</code> compile command when exported), not <code>_stdcall</code> or <code>_fastcall</code> calls are not supported. However, it is easy to call the DLL by declaring the interface directly in the JS code.</p>
<p>In comparison, if you only call third-party DLLs (and they happen to be <code>_cdecl</code> exports), you can&rsquo;t go wrong with FFI (although there may be some performance loss and debugging difficulties).</p>
<p>In fact, in theory, FFI is also based on AddOn technology, except that it can help you convert interfaces defined in JS directly into C interfaces and share them with the loaded DLLs using NodeJS&rsquo;s Buffer memory. Of course, this generality of FFI also results in some performance loss.</p>
<p>Let&rsquo;s talk about using FFI on Windows as an example of how to use NodeJS to communicate with a DLL compiled from C++.</p>
<h3 id="ffi-preparation-for-use">FFI preparation for use</h3>
<h3 id="installing-nodejs">Installing NodeJS</h3>
<p>You may already have NodeJS in your environment, but if it&rsquo;s the latest version, there will be various compatibility issues when installing FFI (for example, the compilation won&rsquo;t pass, and although someone has provided a patch, it hasn&rsquo;t been merged into the master branch yet, so to avoid bugs, it&rsquo;s better not to use it yet). So you can install the LTS version instead.</p>
<p>Also, you need to pay attention to whether the DLL to be called is 32-bit or 64-bit, and the version of the Node needs to match the version of the DLL. If a 64-bit Node calls a 32-bit DLL, it will not be loaded successfully, and vice versa.</p>
<h3 id="installing-the-c-toolchain-for-windows">Installing the C++ toolchain for Windows</h3>
<p>There are two options here.</p>
<ul>
<li>Install Visual Studio and install the corresponding toolchain. If you are using VS 2019, you need to install C++ desktop development and Windows SDK related tools (Node v10 now only supports MSVC for v141), this way it is easier to debug later (although it is also tough)</li>
<li>After installing Node, run Powershell with administrator privileges and install windows-build-tools globally, refer to the command <code>npm install --global --production windows-build-tools</code></li>
</ul>
<h3 id="install-node-gyp">Install node-gyp</h3>
<p>node-gyp is a gyp-based cross-platform build tool in Node for building other libraries.</p>
<p>When installing it, you need to use the VC toolchain, so if you don&rsquo;t have the toolchain in a global variable, you need to open VS&rsquo;s <code>Developer Powershell</code> installation, which is usually found in the Visual Studio folder in the start menu.</p>
<p>Reference command: <code>npm install -g node-gyp</code></p>
<h3 id="installing-ffi-and-ref">Installing FFI and REF</h3>
<p>The following steps still require the VC toolchain, so they may still need to be executed in <code>Developer Powershell</code> (it is recommended to always have this window available for any commands that involve compiling and installing later).</p>
<p>If you install the FFI and related tools without the VC toolchain, you will install the binary code directly, which may result in the ABI version of the package not matching the ABI version of NodeJS (mentioned in the Tips below).</p>
<p>Now, switch to the project&rsquo;s folder and install the following packages. The ffi package supports FFI functionality, the ref package supports pointer functionality (the principle is to convert JS structures to C structures via Node&rsquo;s Buffer memory), and the ref-* package supports advanced structures (such as arrays and structs).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">npm install ffi -s
npm install ref -s
npm install ref-array -s
npm install ref-struct -s
</code></pre></td></tr></table>
</div>
</div><p>In addition, you can also install the ref-wchar package if you want to support the common wchar type in VC.</p>
<h3 id="installing-the-electron-rebuild-package">Installing the electron-rebuild package</h3>
<p>For electron projects, it is also recommended to install the electron-rebuild package, which iterates through all packages in the node_modules directory and recompiles them.</p>
<p>Then, the recommended command to configure electron-rebuild in package.json is.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="s2">&#34;scripts&#34;</span><span class="err">:</span> <span class="p">{</span>
  <span class="nt">&#34;rebuild&#34;</span><span class="p">:</span> <span class="s2">&#34;./node_modules/.bin/electron-rebuild&#34;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>After that, you can just run <code>npm run rebuild</code> when you need to recompile.</p>
<h2 id="how-to-use">How to use</h2>
<h3 id="simple-overview">Simple overview</h3>
<p>The following official example can be viewed.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">ffi</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;ffi&#39;</span><span class="p">)</span>

<span class="kd">var</span> <span class="nx">libm</span> <span class="o">=</span> <span class="nx">ffi</span><span class="p">.</span><span class="nx">Library</span><span class="p">(</span><span class="s1">&#39;libm&#39;</span><span class="p">,</span> <span class="p">{</span>
  <span class="nx">ceil</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;double&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;double&#39;</span><span class="p">]]</span>
<span class="p">})</span>
<span class="nx">libm</span><span class="p">.</span><span class="nx">ceil</span><span class="p">(</span><span class="mf">1.5</span><span class="p">)</span> <span class="c1">// 2
</span></code></pre></td></tr></table>
</div>
</div><p>After the introduction of FFI, the libm library is called using FFI (perhaps this example can only be used on Unix-like systems) with the general extension libm.so. The system searches for this dynamic library in the system directory and loads it into the node process using the dynamic linker.</p>
<p>Next, the program declares a method ceil (round up) in the libm library, where the return value of the function is of type double (doule in the first array), and the input to the function is also a value of type double (double in the second array).</p>
<p>Finally, the function in the dynamic library can be called directly using the <code>libm.ceil</code> method and return the correct value.</p>
<p>This is just a simple use case for FFI, more complex usage (mainly asynchronous calls and callback functions) can be found on the FFI examples page at <a href="https://github.com/node-ffi/node-ffi/wiki/Node-FFI-Tutorial">https://github.com/node-ffi/node-ffi/wiki/Node-FFI-Tutorial</a>.</p>
<h3 id="types">Types</h3>
<p>The type system of FFI actually remembers the types of the ref library. The type system of the ref library is based on the Buffer memory of NodeJS, which allows you to access and modify the data in Buffer memory based on the type of data in Buffe.</p>
<p>The data types that come with ref are all basic types, such as int, bool, or string. All types can be found in the ref <a href="https://github.com/TooTallNate/ref/wiki/Known-%22types%22">wiki</a>.</p>
<p>Most types in ref are abbreviated, for example <code>ref.types.int</code> can be abbreviated to <code>int</code>.</p>
<p>Note that <code>char*</code> can be written as <code>string</code>, and the corresponding ref type is <code>ref.types.CString</code>. It is important to note that string is a basic type in JS, but a reference type in C.</p>
<p>For pointer types, ref provides a method <code>ref.refType()</code> to get them, e.g. <code>int*</code> type can be obtained using <code>ref.refType('int')</code>. Of course, to save time, you can also use <code>int*</code> directly.</p>
<p>For pointer dereferencing, the ref library also provides a <code>deref()</code> method. Just use this method on a variable of the corresponding type to get the variable whose contents the pointer points to. For example, if a JS variable a_pointer of type <code>int*</code> is pointed to, then we can use the <code>a_pointer.deref()</code> method if we want to get the specific integer value.</p>
<p>Conversely, if you want to get the address of a variable, you need to use the <code>ref()</code> method on a variable.</p>
<p>You need to be careful to master the difference between types and variable values, using <code>ref.types</code>, <code>ref.refType</code> or <code>ref_struct({...})</code> as will be mentioned below `, and if you want to get a variable of a certain type, there are two ways to get it, one is to get it from the return value of the FFI function, and the other is to open a space in the Buffer to hold the variable of the type obtained, as will be described below.</p>
<p>If you need to open up a space in the NodJS Buffer of a certain type, you can use the <code>ref.alloc()</code> function and just pass in the type name. For example, if you want to open up a memory of type int, you can use <code>ref.alloc('int')</code> to get it.</p>
<p>In addition, the following points need to be noted.</p>
<ul>
<li>If opening memory of type string, it is recommended to use the method ref.allocCString, whose argument is a JS string. Because C strings have a <code>\0</code> identifier at the end, it is safer to use this method to get C strings.</li>
<li>If the value is NULL in C, the corresponding value in JS is ref.NULL.</li>
<li>If you encounter a pointer type, you can uniformly use <code>'void'</code> or <code>ref.types.void</code> to represent it.</li>
<li>If you want to represent a pointer to a function, you can use <code>'pointer'</code> to represent it.</li>
</ul>
<p>For composite types, such as arrays or structures, the ref library itself does not provide support for them, and you need to use the ref-array and ref-struct libraries to implement them.</p>
<p>In addition, there is also a ref-based library ref-wchar that supports the more common wide character wchar type in the Windows API.</p>
<p>Finally, the documentation for ref is attached at <a href="http://tootallnate.github.io/ref/">http://tootallnate.github.io/ref/</a>, where the specific APIs can be consulted.</p>
<h3 id="calling-external-symbols">Calling external symbols</h3>
<p>Suppose we have the following C code (and make it more complex).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* main.c */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">t_s_t</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span> <span class="n">t_s</span><span class="p">;</span>

<span class="kr">__declspec</span><span class="p">(</span><span class="n">dllexport</span><span class="p">)</span> <span class="kt">int</span> <span class="n">add_one</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">__declspec</span><span class="p">(</span><span class="n">dllexport</span><span class="p">)</span> <span class="kt">void</span> <span class="n">struct_test</span><span class="p">(</span><span class="n">t_s</span><span class="o">**</span> <span class="n">t_s_p</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">t_s_p</span> <span class="o">=</span> <span class="p">(</span><span class="n">t_s</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">t_s</span><span class="p">));</span>
    <span class="p">(</span><span class="o">*</span><span class="n">t_s_p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">(</span><span class="o">*</span><span class="n">t_s_p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b</span> <span class="o">=</span> <span class="sc">&#39;d&#39;</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>The above code declares a structure <code>t_s</code> and two functions <code>add_one</code> and <code>struct_test</code>. The <code>__declspec</code> tag in front of the function indicates that it is declared as an exported function. VC exports C functions by default using the <code>_cdecl</code> calling convention.</p>
<p>The <code>add_one</code> method does the obvious thing, it returns the incoming arguments plus one more. The <code>struct_test</code> function, on the other hand, creates a memory space on the heap of the size of the raw declaration structure, then assigns a pointer to that memory space to the incoming argument and assigns a value to the structure. (The code here is actually not rigorous enough to perform memory reclamation, but that is not the focus of this article, so let&rsquo;s not discuss it first)</p>
<p>Note that in the case of C++ code, you need to use the <code>extern &quot;C&quot;</code> tag to export it, otherwise you won&rsquo;t be able to find the function through the symbols in the source code due to symbolic modifications and calling conventions.</p>
<p>We can use VS&rsquo;s <code>Developer Powershell</code> to compile the above source code.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">cl</span> <span class="o">/</span><span class="n">c</span> <span class="n">main</span><span class="p">.</span><span class="n">c</span>
<span class="n">Link</span> <span class="o">/</span><span class="n">dll</span> <span class="n">main</span><span class="p">.</span><span class="n">obj</span>
</code></pre></td></tr></table>
</div>
</div><p>The compilation will generate main.dll, a dynamic library that we will use later.</p>
<p>For the above C function, we have the following JS code, assuming it is in the same folder as the C code.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="cm">/* index.js */</span>
<span class="kr">const</span> <span class="nx">ffi</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;ffi&#39;</span><span class="p">)</span>
<span class="kr">const</span> <span class="nx">ref</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;ref&#39;</span><span class="p">)</span>
<span class="kr">const</span> <span class="nx">ref_struct</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;ref-struct&#39;</span><span class="p">)</span>

<span class="kr">const</span> <span class="nx">t_s</span> <span class="o">=</span> <span class="nx">ref_struct</span><span class="p">({</span>
  <span class="nx">a</span><span class="o">:</span> <span class="nx">ref</span><span class="p">.</span><span class="nx">types</span><span class="p">.</span><span class="kr">int</span><span class="p">,</span>
  <span class="nx">b</span><span class="o">:</span> <span class="nx">ref</span><span class="p">.</span><span class="nx">types</span><span class="p">.</span><span class="kr">char</span>
<span class="p">})</span>

<span class="kr">const</span> <span class="nx">t_s_ref</span> <span class="o">=</span> <span class="nx">ref</span><span class="p">.</span><span class="nx">refType</span><span class="p">(</span><span class="nx">t_s</span><span class="p">)</span>

<span class="kr">const</span> <span class="nx">test_ffi</span> <span class="o">=</span> <span class="nx">ffi</span><span class="p">.</span><span class="nx">Library</span><span class="p">(</span><span class="nx">__dirname</span> <span class="o">+</span> <span class="s1">&#39;\\main&#39;</span><span class="p">,</span> <span class="p">{</span>
  <span class="nx">add_one</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;int&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;int&#39;</span><span class="p">]],</span>
  <span class="c1">// aka &#39;add_one&#39;: [ref.types.int, [&#39;int&#39;]],
</span><span class="c1"></span>  <span class="nx">struct_test</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;void&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;pointer&#39;</span><span class="p">]]</span>
  <span class="c1">// aka &#39;struct_test&#39;: [&#39;void&#39;, [t_s_ref]],
</span><span class="c1"></span><span class="p">})</span>
<span class="kr">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">test_ffi</span><span class="p">.</span><span class="nx">add_one</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="c1">//21
</span><span class="c1"></span>
<span class="nx">t_s_p</span> <span class="o">=</span> <span class="nx">ref</span><span class="p">.</span><span class="nx">alloc</span><span class="p">(</span><span class="nx">t_s_ref</span><span class="p">)</span>
<span class="nx">test_ffi</span><span class="p">.</span><span class="nx">struct_test</span><span class="p">(</span><span class="nx">t_s_p</span><span class="p">)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">t_s_p</span><span class="p">)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">t_s_p</span><span class="p">.</span><span class="nx">deref</span><span class="p">())</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">t_s_p</span><span class="p">.</span><span class="nx">deref</span><span class="p">().</span><span class="nx">deref</span><span class="p">())</span> <span class="c1">//a-&gt;1, b-&gt;&#39;d&#39;
</span></code></pre></td></tr></table>
</div>
</div><p>First, a structure <code>t_s</code> , corresponding to the type <code>t_s*</code> in C, is declared in the code. Then, we also get a reference <code>t_s_ref</code> to the structure <code>t_s</code> , which corresponds to the type <code>t_s*</code> in C. Why is there an extra layer of pointers in C? The reason is the same as for the previous string.</p>
<p>Then, the test_ffi variable is declared, which calls the ffi.Library method, which returns the handle to the DLL in JS and the function declaration through which the DLL call can be made. The method takes two arguments, the name of the dynamic library (you can omit the expansion name dll) and an object describing the symbols of the C function and its arguments.</p>
<p>The list has been briefly described above. The key of the object is the name of the function, the value is an array, the first element of which is the type of the function&rsquo;s return value, and the second element is another array that contains the types of the function&rsquo;s input parameters. These types use the ref package based type system introduced in the previous section. The types can be represented as strings or as code, see aka&rsquo;s comments in the code.</p>
<p>Next, the code calls the <code>add_one</code> function in the C dynamic library via <code>test_ffi.add_one</code>, which is called in the same way as the function in JS. However, you need to be careful not to pass the wrong type of arguments, especially since the string type in C is different from the string type in JS and should be converted as mentioned above.</p>
<p>The code then uses ref.alloc to create a memory space for the t_s_ref variable (note that this is a pointer-sized space, not a structure size), assigns the address to the t_s_p variable, and then passes the variable to the struct_test function. Since t_s_p is a duplex pointer, it needs to be dereferenced twice to get the real value of the structure.</p>
<h3 id="callback-functions">Callback functions</h3>
<p>A callback function can be declared using the <code>ffi.Callback()</code> function, where the first argument to the function is the return value, the second argument is a list of incoming parameters, and the third argument is the closure of the real callback function.</p>
<p>For example, a callback function is defined as follows, which gets the username and id and returns whether the action was executed successfully.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="nf">int</span><span class="p">(</span><span class="o">*</span><span class="n">callback</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>Then, in ffi, the callback function can be declared using the following.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">callback_function</span> <span class="o">=</span> <span class="nx">ffi</span><span class="p">.</span><span class="nx">Callback</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;int&#39;</span><span class="p">,</span> <span class="s1">&#39;string&#39;</span><span class="p">],</span> <span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">username</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="c1">// do something
</span><span class="c1"></span>  <span class="k">return</span> <span class="mi">1</span>
<span class="p">})</span>
</code></pre></td></tr></table>
</div>
</div><p>After the declaration, the callback function needs to be passed into some function as a parameter.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">test_ffi</span><span class="p">.</span><span class="nx">set_a_callback</span><span class="p">(</span><span class="nx">callback_function</span><span class="p">)</span>

<span class="c1">// Make an extra reference to the callback pointer to avoid GC
</span><span class="c1"></span><span class="nx">process</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;exit&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">callback_function</span>
<span class="p">})</span>
</code></pre></td></tr></table>
</div>
</div><p>In particular, it is important to make sure that the function has a reference in JS after setting up the callback function (for example, a reference to the function is placed in the NodeJS exit event, which is a classic practice). Otherwise, the function will be destructured by the NodeJS GC. This happens when the program starts executing normally, but when the callback function is called after a while, the program exits abnormally. If you use VS to debug the program, you will see that the program may have accessed an illegal pointer because the DLL code also stores the pointer to the callback function, but in JS the address pointed to by the pointer is not referenced by the code in JS, so it is freed by the CG, so when the code in the DLL calls the function at that address, it accesses illegal memory.</p>
<h2 id="some-tips">Some Tips</h2>
<h3 id="how-to-debug--dll">How to debug  DLL</h3>
<p>One of the biggest problems you may find in using ffi is that it is difficult to debug your program. Especially when dealing with a DLL, it&rsquo;s like working with a black box operation. Although you have translated its API into JS code using FFI against the header file, it&rsquo;s still difficult to determine whether the passed or returned values are correct, whether the parameters are correctly passed in the C++ code, whether they are correctly executed after being passed, etc. This requires a way to be able to debug.</p>
<p>A good way to do this is to use the Attach-to-process method of Visual Studio, the number one IDE in the universe for debugging. However, this debugging method requires that you have the source code of the DLL or the PDB (symbolic) file (if you don&rsquo;t have it, you can only see the disassembled code near the exceptions, which are usually caused by memory errors, and the data near it may not make much sense).</p>
<p>If you have the source files on hand, then first open the project, then after loading the DLL in NodeJS, you can select &ldquo;Attach to process&rdquo; when starting the project, and select the NodeJS process in the dialog to enter the debugging interface. In the debug interface, you can insert breakpoints and also see the memory near the breakpoints.</p>
<p>If you don&rsquo;t have source files on hand but have PDB files (or a small amount of source code), you can use VS to open an empty project and then add the location of symbol files in the debugging settings so that you can also debug with breakpoints. During debugging, you can check whether the code has hit breakpoints or not, and when you hit breakpoints, you will be guided to load the project file, and if you have, you can select it, otherwise you can check the disassembly code near the breakpoints.</p>
<p>You can refer to the MSDN documentation for the specific debugging method: <a href="https://docs.microsoft.com/en-us/visualstudio/debugger/attach-to-running-processes-with-the-visual-studio-debugger?view=vs-2019">https://docs.microsoft.com/en-us/visualstudio/debugger/attach-to-running-processes-with-the-visual-studio-debugger?view=vs-2019</a>, I won&rsquo;t go into too much detail here.</p>
<h3 id="how-to-load-a-dll-that-is-in-another-folder">How to load a DLL that is in another folder</h3>
<p>If the JS file and the DLL file are not in the same folder, the loading may fail with an error like &ldquo;Dynamic Linking Error: Win32 error 126&rdquo;.</p>
<p>In this case, you need to put the path of the DLL folder in the PATH where the system is looking for dynamic linking libraries, but FFI does not provide such an interface. However, the Windows API provides the SetDllDirectoryA interface to switch the PATH of the process looking for DLLs, which can be done with the following code.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">kernel32_ffi</span> <span class="o">=</span> <span class="nx">ffi</span><span class="p">.</span><span class="nx">Library</span><span class="p">(</span><span class="s1">&#39;kernel32&#39;</span><span class="p">,</span> <span class="p">{</span>
  <span class="nx">SetDllDirectoryA</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;bool&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;string&#39;</span><span class="p">]]</span>
<span class="p">})</span>
<span class="nx">kernel32_ffi</span><span class="p">.</span><span class="nx">SetDllDirectoryA</span><span class="p">(</span><span class="nx">your_custom_dll_directory</span><span class="p">)</span>

</code></pre></td></tr></table>
</div>
</div><h3 id="some-linking-errors">Some linking errors</h3>
<p>As mentioned above, if the dynamic library is not in the PATH, the dynamic library will not be found and the error &ldquo;Dynamic Linking Error: Win32 error 126&rdquo; will be reported, and in some other cases, the error will be reported whenever the dynamic library is not found. If this error occurs, you need to check if the name of the dynamic library is correct, check if the version of the dynamic library is correct (e.g. 32-bit Node is using a 64-bit DLL), etc.</p>
<p>Another common error is &ldquo;Dynamic Linking Error: Win32 error 127&rdquo;, which means that the corresponding symbol is not found in the DLL, so you may need to check if the function name declared in the ffi is correct and if the DLL version is not correct.</p>
<h3 id="using-ffi-in-electron">Using FFI in Electron</h3>
<p>Since each version of Electron is built based on the corresponding Node and Chrome versions, you need to install the local NodeJS version according to the version of Electron you are using before using FFI, otherwise the FFI may not match the Node version, resulting in an ABI version discrepancy: <code>xx was compiled This version of Node.js requires NODE_MODULE_VERSION xx</code> (NodeJS uses NODE_MODULE_VERSION VERSION to identify the ABI version).</p>
<p>In this case, you can use the <code>electron-rebuild</code> mentioned above to recompile all the plugins in the project (note that the local NodeJS ABI version must be the same as the NodeJS ABI version in Electron).</p>
<p>Also, note that versions of Electron above 5 use the NodeJS 12 ABI, but the current Ref library does not support that ABI, which will cause the build to fail. However, a pull request has been submitted to fix this, and I believe there will be a version available.</p>
<p>There are also NAPI versions of FFI and Ref, named <code>ffi-napi</code> and <code>ref-napi</code> respectively, and NAPI versions of ref-related packages, such as array and struct extensions, with the same naming convention as above. The Node C++ extension interface using NAPI is relatively stable and is the future trend.</p>
<p>Finally, the Electron version can be viewed at <a href="https://electronjs.org/releases/stable">https://electronjs.org/releases/stable</a>, while the versions of NodeJS and its ABI can be viewed at <a href="https://nodejs.org/en/download/releases/">https://nodejs.org/en/download/releases/</a>.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/c&#43;&#43;/">c&#43;&#43;</a>
          <a href="/tags/node/">node</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-02/raspberrypi-32bit-64bit/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Up to 1400% Performance Improvement, Raspberry Pi 32-bit/64-bit System Comparison Test</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-02/cpp-pointers-references/">
            <span class="next-text nav-default">The underlying implementation of pointers and references in C&#43;&#43;</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
