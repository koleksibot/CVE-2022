<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>My opinion about Lisp - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Lisp is a computer programming language invented by John McCarthy in 1958. The name &amp;ldquo;Lisp&amp;rdquo; is an abbreviation for &amp;ldquo;List Processing&amp;rdquo;, which means table processing&amp;hellip; The above is probably the accepted authoritative introduction, and a lot of information on the Internet probably says so. From this information, we can see that Lisp is a computer programming language similar to C and Java, and it is a different language from the" /><meta name="keywords" content="lisp" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-02/my-opinion-about-lisp/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="My opinion about Lisp" />
<meta property="og:description" content="Lisp is a computer programming language invented by John McCarthy in 1958. The name &ldquo;Lisp&rdquo; is an abbreviation for &ldquo;List Processing&rdquo;, which means table processing&hellip; The above is probably the accepted authoritative introduction, and a lot of information on the Internet probably says so. From this information, we can see that Lisp is a computer programming language similar to C and Java, and it is a different language from the" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-02/my-opinion-about-lisp/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-02-16T09:11:47+08:00" />
<meta property="article:modified_time" content="2022-02-16T09:11:47+08:00" />

<meta itemprop="name" content="My opinion about Lisp">
<meta itemprop="description" content="Lisp is a computer programming language invented by John McCarthy in 1958. The name &ldquo;Lisp&rdquo; is an abbreviation for &ldquo;List Processing&rdquo;, which means table processing&hellip; The above is probably the accepted authoritative introduction, and a lot of information on the Internet probably says so. From this information, we can see that Lisp is a computer programming language similar to C and Java, and it is a different language from the"><meta itemprop="datePublished" content="2022-02-16T09:11:47+08:00" />
<meta itemprop="dateModified" content="2022-02-16T09:11:47+08:00" />
<meta itemprop="wordCount" content="4611">
<meta itemprop="keywords" content="lisp," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="My opinion about Lisp"/>
<meta name="twitter:description" content="Lisp is a computer programming language invented by John McCarthy in 1958. The name &ldquo;Lisp&rdquo; is an abbreviation for &ldquo;List Processing&rdquo;, which means table processing&hellip; The above is probably the accepted authoritative introduction, and a lot of information on the Internet probably says so. From this information, we can see that Lisp is a computer programming language similar to C and Java, and it is a different language from the"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">My opinion about Lisp</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-02-16 09:11:47 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 4611 words </span>
          <span class="more-meta"> 10 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#1-lisp-language-and-dialects">1. Lisp language and dialects</a></li>
        <li><a href="#2-lisps-programs">2. Lisp&rsquo;s programs</a></li>
        <li><a href="#3-characteristics-of-lisp">3. Characteristics of Lisp</a>
          <ul>
            <li><a href="#31-simple-syntax">3.1 Simple syntax</a></li>
            <li><a href="#32-diversity-of-implementations-and-operating-principles">3.2 Diversity of implementations and operating principles</a></li>
            <li><a href="#33-automatic-memory-management-gc">3.3 Automatic memory management (GC)</a></li>
            <li><a href="#34-first-class-function-and-functional-programming">3.4 First-class Function and Functional Programming</a></li>
            <li><a href="#35-code-is-data">3.5 Code is data</a></li>
            <li><a href="#36-free-extensions">3.6 Free extensions</a></li>
          </ul>
        </li>
        <li><a href="#4-some-lisp-related-suggestions">4. Some Lisp related suggestions</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>Lisp is a computer programming language invented by John McCarthy in 1958. The name &ldquo;Lisp&rdquo; is an abbreviation for &ldquo;List Processing&rdquo;, which means table processing&hellip; The above is probably the accepted authoritative introduction, and a lot of information on the Internet probably says so. From this information, we can see that Lisp is a computer programming language similar to C and Java, and it is a different language from the so-called natural languages such as Chinese and English, which is probably the impression most people have of it. However, in the process of learning Lisp, I have felt a lot of places contrary to the common sense of programming languages, and I have some thoughts about it.</p>
<h2 id="1-lisp-language-and-dialects">1. Lisp language and dialects</h2>
<p>If we are talking about one language in particular, &ldquo;Lisp language&rdquo; refers to the version invented by John McCarthy in 1958. However, that version of Lisp should have remained in the books. Over the next few decades, Lisp developed and evolved rapidly, and modern Lisp is no longer the same language as the original version, but looks a bit similar, using S-expressions with parentheses, but the language features and implementations are very different. So, the term &ldquo;Lisp language&rdquo; is more appropriate to refer to a class of languages that includes the original Lisp and its derivative dialects (e.g. Common Lisp, Scheme, Emacs Lisp).</p>
<p>You may never have heard of computer dialects, after all, there is no such thing as a &ldquo;C++ dialect&rdquo; or a &ldquo;Java dialect&rdquo;, because a version of Java explicitly defines all the syntax for that version of the language, and developers cannot directly modify syntax or add syntax directly. However, Lisp provides the ability to extend the lexicon and syntax (e.g., Common Lisp macros and read macros), allowing Lisp users to add as many language features as they want to their Lisp implementation, resulting in a large number of dialects, some of which may not even have names.</p>
<p>Common Lisp and Scheme are the two main Lisp dialects that are relatively mainstream nowadays, each with many implementations and derived dialects. Emacs Lisp and AutoLisp are still active, but only for specific environments and scenarios, Emacs Lisp is only used in the Emacs editor and AutoLisp is embedded in AutoCAD. There are also dialects used in specific scientific fields, so I won&rsquo;t go into them here.</p>
<p>Although Common Lisp and Scheme are the two major Lisp dialects, they are not specific Lisp implementations, but only a specification, and the corresponding specific implementations are not only the language features and APIs specified in the specification, but usually contain their own extensions. Some common implementations and their corresponding official homepages (or project addresses) are listed below. I personally recommend SBCL and ChezScheme.</p>
<p><strong>Common Lisp implementations</strong>.</p>
<table>
<thead>
<tr>
<th>name</th>
<th>site</th>
</tr>
</thead>
<tbody>
<tr>
<td>Steel Bank Common Lisp (SBCL)</td>
<td><a href="http://www.sbcl.org/">http://www.sbcl.org/</a></td>
</tr>
<tr>
<td>GNU CLISP</td>
<td><a href="https://clisp.sourceforge.io/">https://clisp.sourceforge.io/</a></td>
</tr>
<tr>
<td>Embeddable Common-Lisp (ECL)</td>
<td><a href="https://ecl.common-lisp.dev/">https://ecl.common-lisp.dev/</a></td>
</tr>
<tr>
<td>Armed Bear Common Lisp (ABCL)</td>
<td><a href="https://www.abcl.org/">https://www.abcl.org/</a></td>
</tr>
</tbody>
</table>
<p><strong>Scheme implementation</strong>.</p>
<table>
<thead>
<tr>
<th>name</th>
<th>site</th>
</tr>
</thead>
<tbody>
<tr>
<td>Chez Scheme</td>
<td><a href="https://scheme.com/">https://scheme.com/</a> or <a href="https://cisco.github.io/ChezScheme/">https://cisco.github.io/ChezScheme/</a></td>
</tr>
<tr>
<td>Racket</td>
<td><a href="https://www.racket-lang.org/">https://www.racket-lang.org/</a></td>
</tr>
<tr>
<td>GNU Guile</td>
<td><a href="http://www.gnu.org/software/guile/">http://www.gnu.org/software/guile/</a></td>
</tr>
</tbody>
</table>
<h2 id="2-lisps-programs">2. Lisp&rsquo;s programs</h2>
<p>Talking about a programming language can be hollow and abstract without program examples. This section shows what a Lisp program might look like.</p>
<p>First, let&rsquo;s look at a few hello world examples.</p>
<ul>
<li>
<p>Example 1. print 5 lines of hello world</p>
<blockquote>
<p>English: <code>Print 5 lines of &quot;hello world&quot;</code>.</p>
</blockquote>
<blockquote>
<p>Lisp: <code>(print 5 lines of &quot;hello world&quot;)</code> or <code>(print 5 lines of &quot;hello world&quot;)</code>.</p>
</blockquote>
</li>
<li>
<p>Example 2. the string &ldquo;hello world&rdquo;</p>
<blockquote>
<p>English: <code>String &quot;hello world&quot;</code>.</p>
</blockquote>
<blockquote>
<p>Lisp: <code>(string &quot;hello world&quot;)</code> or <code>#T(character string &quot;hello world&quot;)</code>.</p>
</blockquote>
</li>
<li>
<p>Example 3. John says, &ldquo;hello world&rdquo;</p>
<blockquote>
<p>English: <code>&quot;hello world,&quot; says John</code></p>
</blockquote>
<blockquote>
<p>Lisp: <code>(John says &quot;hello world&quot;)</code> or <code>#P (John says &quot;hello world&quot;)</code> or <code>(John says &quot;hello world&quot;)</code></p>
</blockquote>
</li>
</ul>
<p>Some of you may have tried the above example in a Lisp implementation and encountered a bunch of errors. It&rsquo;s not that I&rsquo;m fooling anyone, but the above can indeed be used as a Lisp program, but it lacks the corresponding macro or operator implementation. Well, back to business, here are a few simple examples (Common Lisp implementations) that work.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nf">print</span> <span class="s">&#34;hello world&#34;</span><span class="p">)</span> <span class="c1">;打印&#34;hello world&#34;</span>

<span class="p">(</span><span class="nc">list</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>        <span class="c1">;创建一个列表，包含元素1、2、3、4</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">test-fun</span> <span class="p">(</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="c1">;定义函数test-fun执行加法</span>
  <span class="p">(</span><span class="nf">+</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">))</span>

<span class="p">(</span><span class="nv">test-fun</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>        <span class="c1">;用1和2来调用函数test-fun</span>

<span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">i</span> <span class="p">(</span><span class="nc">list</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span> <span class="c1">;对列表进行遍历并打印</span>
  <span class="p">(</span><span class="nf">print</span> <span class="nv">i</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>We can see that the above Lisp programs have a common feature: they all have <code>(xxx ......)</code> is a form of bracketed symbols. For example, the program <code>(list 1 2 3 4)</code> returns <code>(1 2 3 4)</code> as a table containing elements 1, 2, 3, and 4, and the empty table is <code>()</code>. (Some may notice that <code>#P(...)</code> and <code>#Y[...]</code> such expressions, which are the mechanism for the reader macros provided by Common Lisp, which are converted by the reader into Lisp programs consisting of tables that can be used to implement some convenient syntactic sugar, or even embedded JSON-like syntax: <code>#J{ &quot;id&quot; : &quot;XX123&quot; , &quot;type&quot; : 2 }</code>.)</p>
<p>Lisp programs themselves are composed of such tables, and content organized with such tables can basically be Lisp programs. If you know something about parsers and interpreters, you can add other forms of code organization to Lisp with the help of extension mechanisms provided by the Lisp implementation. So, to sum up, the code form of Lisp is versatile, and it is sometimes the developer&rsquo;s imagination and habits that limit the program form.</p>
<p>The next two Lisp programs are close to the application.</p>
<p>The first is a Common Lisp program, which is an example of a database query implemented with SxQL, and a macro-based DSL implementation (anyone who knows SQL will understand what this program does).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">select</span> <span class="p">(</span><span class="ss">:title</span> <span class="ss">:author</span> <span class="ss">:year</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">from</span> <span class="ss">:books</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">where</span> <span class="p">(</span><span class="ss">:and</span> <span class="p">(</span><span class="ss">:&gt;=</span> <span class="ss">:year</span> <span class="mi">1995</span><span class="p">)</span>
               <span class="p">(</span><span class="ss">:&lt;</span> <span class="ss">:year</span> <span class="mi">2010</span><span class="p">)))</span>
  <span class="p">(</span><span class="nv">order-by</span> <span class="p">(</span><span class="ss">:desc</span> <span class="ss">:year</span><span class="p">)))</span>
</code></pre></td></tr></table>
</div>
</div><p>The following paragraph is a reference answer to an exercise given by the author in the book Essentials of Programming Languages (the Chinese is an additional comment I added), implemented in Scheme, to build a parser for the LET language.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">define</span> <span class="nv">the-lexical-spec</span>                            <span class="c1">;定义词法规范</span>
  <span class="o">&#39;</span><span class="p">((</span><span class="nv">whitespace</span> <span class="p">(</span><span class="nv">whitespace</span><span class="p">)</span> <span class="nv">skip</span><span class="p">)</span>                  <span class="c1">;空白字符的词法（引用Scheme的空白字符）和对应操作，skip表示跳过，什么都不做</span>
    <span class="p">(</span><span class="nv">comment</span> <span class="p">(</span><span class="s">&#34;%&#34;</span> <span class="p">(</span><span class="nv">arbno</span> <span class="p">(</span><span class="nf">not</span> <span class="sc">#\newline</span><span class="p">)))</span> <span class="nv">skip</span><span class="p">)</span>    <span class="c1">;注释的词法（%开头直到行末）和对应操作，arbno类似正则里的&#34;*&#34;，表示&#34;任意个&#34;</span>
    <span class="p">(</span><span class="nv">identifier</span>                                     <span class="c1">;标识符的词法（字母开头加上任意个字母数字符号组合）和对应操作，symbol表示保留为符号</span>
      <span class="p">(</span><span class="nv">letter</span> <span class="p">(</span><span class="nv">arbno</span> <span class="p">(</span><span class="nb">or</span> <span class="nv">letter</span> <span class="nv">digit</span> <span class="s">&#34;_&#34;</span> <span class="s">&#34;-&#34;</span> <span class="s">&#34;?&#34;</span><span class="p">)))</span>
      <span class="nc">symbol</span><span class="p">)</span>
    <span class="p">(</span><span class="nc">number</span> <span class="p">(</span><span class="nv">digit</span> <span class="p">(</span><span class="nv">arbno</span> <span class="nv">digit</span><span class="p">))</span> <span class="nc">number</span><span class="p">)</span>           <span class="c1">;数字的词法（1个以上的数字）和对应操作，number表示保留为数字</span>
    <span class="p">(</span><span class="nc">number</span> <span class="p">(</span><span class="s">&#34;-&#34;</span> <span class="nv">digit</span> <span class="p">(</span><span class="nv">arbno</span> <span class="nv">digit</span><span class="p">))</span> <span class="nc">number</span><span class="p">)))</span>     <span class="c1">;数字的词法（-开头加1个以上的数字）和对应操作，number表示保留为数字</span>

<span class="p">(</span><span class="nv">define</span> <span class="nv">the-grammar</span>                                 <span class="c1">;定义语法规范</span>
  <span class="o">&#39;</span><span class="p">((</span><span class="nv">program</span> <span class="p">(</span><span class="nv">expression</span><span class="p">)</span> <span class="nv">a-program</span><span class="p">)</span>                <span class="c1">;程序由表达式组成</span>
    <span class="p">(</span><span class="nv">expression</span> <span class="p">(</span><span class="nc">number</span><span class="p">)</span> <span class="nv">const-exp</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">expression</span>                                     <span class="c1">;表达式可以是&#34;-(1,2)&#34;这样的表达式</span>
      <span class="p">(</span><span class="s">&#34;-&#34;</span> <span class="s">&#34;(&#34;</span> <span class="nv">expression</span> <span class="s">&#34;,&#34;</span> <span class="nv">expression</span> <span class="s">&#34;)&#34;</span><span class="p">)</span>
      <span class="nv">diff-exp</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">expression</span>                                     <span class="c1">;表达式可以是&#34;zero?(a)&#34;这样的表达式</span>
      <span class="p">(</span><span class="s">&#34;zero?&#34;</span> <span class="s">&#34;(&#34;</span> <span class="nv">expression</span> <span class="s">&#34;)&#34;</span><span class="p">)</span>
      <span class="nv">zero?-exp</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">expression</span>                                     <span class="c1">;表达式可以是&#34;if ... then ... else&#34;这样的表达式</span>
      <span class="p">(</span><span class="s">&#34;if&#34;</span> <span class="nv">expression</span> <span class="s">&#34;then&#34;</span> <span class="nv">expression</span> <span class="s">&#34;else&#34;</span> <span class="nv">expression</span><span class="p">)</span>
      <span class="nv">if-exp</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">expression</span> <span class="p">(</span><span class="nv">identifier</span><span class="p">)</span> <span class="nv">var-exp</span><span class="p">)</span>               <span class="c1">;表达式可以是一个标识符</span>
    <span class="p">(</span><span class="nv">expression</span>                                     <span class="c1">;表达式可以是&#34;let a  = 1 in ...&#34;这样的表达式</span>
      <span class="p">(</span><span class="s">&#34;let&#34;</span> <span class="nv">identifier</span> <span class="s">&#34;=&#34;</span> <span class="nv">expression</span> <span class="s">&#34;in&#34;</span> <span class="nv">expression</span><span class="p">)</span>
      <span class="nv">let-exp</span><span class="p">)))</span>

<span class="c1">;;;;;;;;;;;;;;;; sllgen boilerplate ;;;;;;;;;;;;;;;;</span>
<span class="p">(</span><span class="nv">sllgen:make-define-datatypes</span> <span class="nv">the-lexical-spec</span> <span class="nv">the-grammar</span><span class="p">)</span> <span class="c1">;根据词法和语法规范生成对应数据结构</span>

<span class="p">(</span><span class="nv">define</span> <span class="nv">scan&amp;parse</span>
  <span class="p">(</span><span class="nv">sllgen:make-string-parser</span> <span class="nv">the-lexical-spec</span> <span class="nv">the-grammar</span><span class="p">))</span> <span class="c1">;根据词法和语法规范生成对应解析器</span>
</code></pre></td></tr></table>
</div>
</div><p>Lisp&rsquo;s syntax is extensible and has a highly dynamic macro mechanism, so the Lisp language can extend itself and even extend the syntax at runtime to give birth to new languages. In addition, the code written in Lisp consists of a list (e.g., <code>(+ 1 2 3 4)</code>, which sums 1, 2, 3, and 4), and a table is one of the basic structures in Lisp (e.g., <code>'(+ 1 2 3 4)</code> or <code>(list '+ '1 '2 '3 '4)</code>, which represents a table containing +, 1, 2, 3, and 4 elements), so using The Lisp language makes it very easy to modify Lisp code and generate Lisp code (e.g., <code>(setf (first '(+ 1 2 3 4)) '-)</code>, replaces the first element in the table with &lsquo;-&rsquo; and the program changes from cumulative addition to cumulative subtraction). Because of the high consistency of data and code in the Lisp language, many people who write Lisp are able to implement their own Lisp interpreters and compilers.</p>
<h2 id="3-characteristics-of-lisp">3. Characteristics of Lisp</h2>
<p>When analyzing a language, it is inevitable to analyze the advantages and disadvantages of the language compared to other languages, but the advantages and disadvantages are easily influenced by the application scenario and the developer&rsquo;s ability, and may be the case of &ldquo;A&rsquo;s honey, B&rsquo;s arsenic&rdquo;. Therefore, it is better to list some of the features of Lisp and discuss them in relation to the possible advantages and disadvantages of using it in development scenarios.</p>
<p>When it comes to features, it may be understood as &ldquo;unique points&rdquo;. Lisp is an old language that has existed for more than half a century, and during this time, many of the original Lisp-specific features have been accepted and absorbed by other languages, and even become industry standards (e.g., recursive function calls), and many modern language features have been absorbed from other languages (e.g., object-oriented programming). It would be a bit one-sided to talk only about the unique points, so it is better to explain all the features of Lisp as a language. （There are many points worth mentioning in both Common Lisp and Scheme, but it is better to write a long article about them)</p>
<h3 id="31-simple-syntax">3.1 Simple syntax</h3>
<p>Few languages have a simpler syntax than Lisp, as mentioned at the beginning of the SICP book &ldquo;all the formal properties can be covered in an hour and then you don&rsquo;t have to pay attention to the syntax details (because there are none)&rdquo;, especially Scheme (Common Lisp is a bit more complex). When I did the SICP exercises, it took about 300 lines of code or less to implement the explanation of Scheme&rsquo;s basic syntax. The SICP is 400 pages long, and the simple Scheme compiler interpreter is finished.</p>
<p>For developers, this simplicity greatly reduces learning time and puts more effort into advanced features and programming. For language processors (compilers and interpreters), it simplifies the parsing process and makes it easy to write language processors.</p>
<p>The main problem is the difficulty of parsing the code with the naked eye. As an example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-lisp" data-lang="lisp"><span class="nv">fun1</span><span class="p">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="p">)</span><span class="c1">;    //1</span>

<span class="k">if</span> <span class="p">(</span><span class="k">type</span> <span class="nv">==</span> <span class="mi">0</span><span class="p">)</span><span class="nv">{</span> <span class="nv">//2</span>
    <span class="nv">Console.log</span><span class="p">(</span><span class="s">&#34;...&#34;</span><span class="p">)</span><span class="c1">;//... 3</span>
    <span class="nb">return</span> <span class="mi">0</span><span class="c1">;          //... 3</span>
<span class="nv">}</span>
</code></pre></td></tr></table>
</div>
</div><p>You don&rsquo;t need to look closely at each character in the above JavaScript code to know that 1 is a function call, 2 is an if branch, and 3 is a block of code with a glance of the eye. Replace the above code with the Common Lisp code as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">fun1</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>

<span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">=</span> <span class="k">type</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">(</span><span class="k">progn</span>
    <span class="p">(</span><span class="nf">print</span> <span class="s">&#34;...&#34;</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">return</span> <span class="mi">0</span><span class="p">)))</span>
</code></pre></td></tr></table>
</div>
</div><p>It is not clear whether <code>fun1</code> is a function, a macro or a special operator; it is not clear that <code>if</code> is a special operator, not conditional and branching; nor is it clear that <code>(progn ...) </code> introduces a block-like form of code. It is even more impossible to see the general structure of the program by a simple glance; one must observe it down to the character level. Because Lisp&rsquo;s code is all S-expressions, it is sometimes impossible to tell at the lexical and syntactic level whether a symbol is a function or a macro, so the editor cannot do the same perfect syntax highlighting that Java does, making project management somewhat difficult.</p>
<h3 id="32-diversity-of-implementations-and-operating-principles">3.2 Diversity of implementations and operating principles</h3>
<p>Introducing a programming language necessarily involves the underlying implementation/running principles of the language, for example, C can be compiled into machine code for the corresponding platform using the GCC compiler, python can be interpreted by the python interpreter, and Java can be compiled into Java bytecode by the Java compiler and then interpreted by the Java virtual machine. Each language also has its own official implementation and more specific specification.</p>
<p>Lisp does not have an official implementation, as Common Lisp and Scheme do, and the language specification is only a specification of the language, without specifying specific interpreting and compiling behavior (but still specifying some relevant APIs). In fact, the Lisp language seems to run in all the ways that programming languages do: clisp, guile, and most other implementations can be used interactively at the command line in a REPL format; while SBCL and ChezScheme can compile Lisp into native machine code for execution; ECL can be embedded into C/C++ programs, and clisp can compile the code into ECL can be embedded in C/C++ programs, clisp can compile code into corresponding bytecode and interpret and execute bytecode; ABCL is embedded in Java programs running on top of the Java virtual machine, and so on. Unlike most languages implemented in software, in the 1980s there was a hardware device used to execute Lisp directly - the Lisp machine. That was a machine that implemented an interpreter for Lisp programs in hardware, which was all the rage in those days and may only be seen in museums now.</p>
<p>Moreover, Lisp had no strict restrictions on compilation and runtime, and did not necessarily have to be compiled into a standalone file for execution, nor did it have to be interpreted for execution. In a Common Lisp program, you can even do the following things.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nb">setf</span> <span class="nv">a</span> <span class="mi">1</span> 
      <span class="nv">fun-name</span> <span class="ss">&#39;add1</span><span class="p">)</span>                          <span class="c1">;设置符号a为1，函数名fun-name为add1</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">exp1</span> <span class="p">(</span><span class="nc">list</span> <span class="ss">&#39;+</span> <span class="ss">&#39;a</span> <span class="mi">1</span><span class="p">))</span>                     <span class="c1">;生成表达式(+ a 1)，并设置给符号exp1</span>
<span class="p">(</span><span class="nf">eval</span> <span class="nv">exp1</span><span class="p">)</span>                                    <span class="c1">;对符号exp1的值进行解释求值</span>
<span class="p">(</span><span class="nb">setf</span> <span class="nv">fun-def-exp</span> <span class="o">`</span><span class="p">(</span><span class="nb">defun</span> <span class="o">,</span><span class="nv">fun-name</span> <span class="p">(</span><span class="nv">a</span><span class="p">)</span> <span class="o">,</span><span class="nv">exp1</span><span class="p">))</span><span class="c1">;生成函数定义表达式(defun add1 (a) (+ a 1))</span>
<span class="p">(</span><span class="nf">eval</span> <span class="nv">fun-def-exp</span><span class="p">)</span>                             <span class="c1">;解释并求值上面函数的定义</span>
<span class="p">(</span><span class="nf">compile</span> <span class="nv">fun-name</span><span class="p">)</span>                             <span class="c1">;编译该函数</span>
<span class="p">(</span><span class="nf">funcall</span> <span class="nv">fun-name</span> <span class="mi">2</span><span class="p">)</span>                           <span class="c1">;调用该函数</span>
</code></pre></td></tr></table>
</div>
</div><p>Such a variety of implementations allows users to find and choose the right one for their scenarios: SBCL and ChezScheme, which program local machine code, are suitable for situations where performance is a concern; clisp, which has a good interactive experience, can be used as a command-line REPL; the streamlined ABCL and ECL can be embedded into Java and C/C++ programs, respectively, as built-in scripting engines, and so on. The abundance of runtime options also makes it possible to generate, compile, and load code at runtime, so that developers are no longer constrained by how programs are executed.</p>
<p>However, &ldquo;diversity&rdquo; is often linked to &ldquo;fragmentation&rdquo;, with implementations containing their own extensions and even extended syntax (e.g., Racket is on the verge of being extended into another language). Programs written according to the language specification have good portability and backward compatibility across implementations, but the portability of the program suffers if it uses features that are extended by some implementations. For example, the Japanese Common Lisp developer Eitaro Fukamachi developed an http server called <a href="https://github.com/fukamachi/woo">woo</a> that has excellent performance, but uses SBCL-specific features that cannot be used on other Common Lisp implementations.</p>
<h3 id="33-automatic-memory-management-gc">3.3 Automatic memory management (GC)</h3>
<p>Even in this era of GC, this is a feature that I don&rsquo;t want to talk about, but I have to&hellip;</p>
<p>Lisp was the first language in history to adopt garbage collection, which was groundbreaking in those days (&ldquo;the father of Lisp&rdquo; was also the &ldquo;father of GC&rdquo;). This approach to memory management enhances memory security, reduces the mental strain on developers to manage memory, and makes the language simpler, with specific algorithms to improve memory continuity. Lisp&rsquo;s powerful expressiveness, free style, and automatic memory management allow developers to devote their efforts to programming without paying too much attention to memory issues. This is a feature that can directly improve the developer&rsquo;s happiness.</p>
<p>However, the disadvantages of the garbage collection mechanism also became the disadvantages of Lisp. The problem of maximum pause time makes it impossible to apply to scenarios with high real-time requirements, and the reduced efficiency of heap usage makes it impossible to run on low-end embedded devices where resources are tight. In addition, it has been more than half a century since the first garbage collection algorithm was proposed, but choosing the right garbage collection algorithm for the application scenario, adjusting GC parameters, and writing programs that fit with the garbage collection algorithm is still a highly skilled and rare craft.</p>
<h3 id="34-first-class-function-and-functional-programming">3.4 First-class Function and Functional Programming</h3>
<p>Lisp is a language that provides a First-class Function, and therefore a language that supports functional programming. The first-class functions here have the following properties.</p>
<ol>
<li>they can be named with variables</li>
<li>can be provided as parameters to procedures</li>
<li>can be returned by the procedure as a result</li>
<li>can be included in a data structure</li>
</ol>
<p>Expressed in a JavaScript program, this means that</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">a</span> <span class="o">+</span> <span class="mi">1</span>                <span class="c1">//1
</span><span class="c1"></span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">a</span><span class="p">()</span>
<span class="p">})(()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;hello&#34;</span><span class="p">))</span>      <span class="c1">//2
</span><span class="c1"></span><span class="kd">function</span> <span class="nx">test</span> <span class="p">(</span><span class="nx">x</span><span class="p">){</span>
  <span class="k">return</span> <span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">x</span>               <span class="c1">//3
</span><span class="c1"></span><span class="p">}</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;hello&#34;</span><span class="p">)]</span>  <span class="c1">//4
</span></code></pre></td></tr></table>
</div>
</div><p>An approximate Scheme program is.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">define</span> <span class="nv">f</span> <span class="p">(</span><span class="nb">lambda</span> <span class="p">(</span><span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nf">+</span> <span class="nv">a</span> <span class="mi">1</span><span class="p">)))</span>      <span class="c1">;1</span>
<span class="p">((</span><span class="nb">lambda</span> <span class="p">(</span><span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nv">a</span><span class="p">))</span> 
  <span class="p">(</span><span class="nb">lambda</span> <span class="p">()</span> <span class="p">(</span><span class="nv">printf</span> <span class="s">&#34;hello&#34;</span><span class="p">)))</span>      <span class="c1">;2</span>
<span class="p">(</span><span class="nv">define</span> <span class="nv">test</span> <span class="p">(</span><span class="nb">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">lambda</span> <span class="p">(</span><span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nf">+</span> <span class="nv">a</span> <span class="nv">x</span><span class="p">))))</span>             <span class="c1">;3</span>
<span class="p">(</span><span class="nc">list</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">lambda</span> <span class="p">()</span> <span class="p">(</span><span class="nv">printf</span> <span class="s">&#34;hello&#34;</span><span class="p">)))</span><span class="c1">;4</span>
</code></pre></td></tr></table>
</div>
</div><p>As mentioned above, functions in Lisp work just like numbers and strings, which provides the basis for functional programming. This makes it a much better experience than Java and Python, which &ldquo;add&rdquo; functional features to the language.</p>
<p>However, Lisp recommends/supports functional programming, not mandates it, and does not put much emphasis on pure functions. It is not a &ldquo;functional language&rdquo;, but rather a &ldquo;multi-paradigm language&rdquo;, where object-oriented programming, language-oriented programming, logic-based programming, etc. are all possible in addition to functional programming (if not, then extend the syntax to do so). ). Therefore, some advanced/radical functional features and functional modules (e.g., immutable data structures and inert evaluation) are missing from the base features provided by the language, and can only be implemented by extensions or open source implementations.</p>
<h3 id="35-code-is-data">3.5 Code is data</h3>
<p>In most popular programming languages, programs can be written to build all kinds of complex data structures and computational procedures, but the code that builds them is itself in a special position, even read-only and protected, such as the restricted access method and code areas in Java and C. And most languages have a complex syntax that makes the parsed code structure very complex as well. These reasons also make it difficult to develop code generation programs and code processing tools for these languages. However, this problem is solved in Lisp, where the Lisp program itself is organized by the Lisp base list structure, which is very close to the abstract syntax tree itself, and the Lisp support for symbolic data makes it possible to represent identifiers and keywords in the code in a simple way. These two points greatly simplify the process of manipulating Lisp code.</p>
<p>As an example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nc">list</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>        <span class="c1">;1. 得到列表(1 2 3 4)</span>
<span class="p">(</span><span class="k">quote</span> <span class="p">(</span><span class="nc">list</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span><span class="c1">;2. 得到列表(LIST 1 2 3 4)</span>
<span class="o">&#39;</span><span class="p">(</span><span class="nc">list</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>       <span class="c1">;3. 得到列表(LIST 1 2 3 4)</span>
</code></pre></td></tr></table>
</div>
</div><p>In the Lisp code above, 1 is a function call that builds a list of corresponding data; 2 is a <code>quote</code> operation that gets the table structure data from the above code (the <code>LIST</code> in the list is a symbol); and 3 is a shortened version of 2. This way we can easily do the following things.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nf">exp</span> <span class="o">&#39;</span><span class="p">(</span><span class="nc">list</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)))</span>    <span class="c1">;将一个表达式作为列表数据绑定给符号exp</span>
  <span class="p">(</span><span class="nf">print</span> <span class="p">(</span><span class="nf">length</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nf">exp</span><span class="p">)))</span>    <span class="c1">;获取表达式的参数数量</span>
  <span class="p">(</span><span class="nb">setf</span> <span class="nf">exp</span> <span class="p">(</span><span class="nc">cons</span> <span class="ss">&#39;+</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nf">exp</span><span class="p">)))</span><span class="c1">;将表达式的操作替换为&#34;+&#34;</span>
  <span class="p">(</span><span class="nf">eval</span> <span class="nf">exp</span><span class="p">))</span>                   <span class="c1">;对新的表达式进行求值</span>
</code></pre></td></tr></table>
</div>
</div><p>As John McCarthy says, &ldquo;LISP programs act as representations of LISP data that can be manipulated by object programs. This prevents a separation between the system programmer and the application programmer.&rdquo; In other programming languages, there is a world of difference between the data faced and the privileges held by those who develop the language and those who use it; in Lisp, there is not so much difference between the two, and all that is faced is Lisp&rsquo;s table structure.</p>
<h3 id="36-free-extensions">3.6 Free extensions</h3>
<p>To add new functionality to a program, C adds new structures and functions, Java adds new classes, each language has its own set of schemes, and even some multi-paradigm languages offer multiple schemes (e.g., C++ and Scala). However, in the quest for concise, highly abstract expressions, the syntax of the language can be a barrier, limiting developers to a circle or forcing them to beat around the bush to achieve the desired functionality, and the complex reality of &ldquo;the right language for the right domain&rdquo;.</p>
<p>In contrast, Lisp has its own solution, but instead of limiting developers to &ldquo;their own solution&rdquo;, Lisp provides developers with various mechanisms to extend themselves (e.g., macros and meta-object protocols in Common Lisp). For example, the following code uses Common Lisp&rsquo;s reader macros to add a slice-like syntax to Common Lisp.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nf">set-macro-character</span> <span class="sc">#\]</span> <span class="p">(</span><span class="nf">get-macro-character</span> <span class="sc">#\)</span><span class="p">))</span>
<span class="p">(</span><span class="nf">set-dispatch-macro-character</span> <span class="sc">#\#</span> <span class="sc">#\[</span>
  <span class="nf">#&#39;</span><span class="p">(</span><span class="nb">lambda</span> <span class="p">(</span><span class="nc">stream</span> <span class="nv">char1</span> <span class="nv">char2</span><span class="p">)</span>
      <span class="p">(</span><span class="k">declare</span> <span class="p">(</span><span class="k">ignore</span> <span class="nv">char1</span> <span class="nv">char2</span><span class="p">))</span>
      <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">accum</span> <span class="no">nil</span><span class="p">)</span>
            <span class="p">(</span><span class="nv">pair</span> <span class="p">(</span><span class="nf">read-delimited-list</span> <span class="sc">#\]</span> <span class="nc">stream</span> <span class="no">t</span><span class="p">)))</span>
        <span class="p">(</span><span class="nb">do</span> <span class="p">((</span><span class="nv">i</span> <span class="p">(</span><span class="nf">ceiling</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">pair</span><span class="p">))</span> <span class="p">(</span><span class="nf">1+</span> <span class="nv">i</span><span class="p">)))</span>
            <span class="p">((</span><span class="nf">&gt;</span> <span class="nv">i</span> <span class="p">(</span><span class="nf">floor</span> <span class="p">(</span><span class="nf">cadr</span> <span class="nv">pair</span><span class="p">)))</span>
             <span class="p">(</span><span class="nc">list</span> <span class="ss">&#39;quote</span> <span class="p">(</span><span class="nf">nreverse</span> <span class="nv">accum</span><span class="p">)))</span>
          <span class="p">(</span><span class="nb">push</span> <span class="nv">i</span> <span class="nv">accum</span><span class="p">)))))</span>

<span class="err">#</span><span class="nv">[2</span> <span class="nv">7]</span> <span class="c1">;产生 (2 3 4 5 6 7)</span>
</code></pre></td></tr></table>
</div>
</div><p>If the expressions of other languages are not applicable to the scenario, then you should &ldquo;find another one&rdquo;; if the expressions of Lisp are not applicable to the scenario, then you should let Lisp fit the scenario. This has made Lisp popular with many hackers who value freedom. As John McCarthy says: &ldquo;Everyone can &ldquo;improve&rdquo; their LISP, and many of these &ldquo;improvements&rdquo; have evolved into improvements to the language. &quot; Someone who is &ldquo;proficient&rdquo; in Java may not necessarily be able to implement Java, but someone who is &ldquo;familiar&rdquo; with Lisp will generally be able to implement a working Lisp.</p>
<p>Freedom fosters diversity and fragmentation. Various dialects and programming methods were implemented in a variety of ways, and the desire to add object-oriented programming and logic-based programming to Lisp was like an after-school exercise in school, solved by developing a few hundred lines of code a day. While this makes developers more &ldquo;independent&rdquo;, it also makes the community less lively and connected than in other languages.</p>
<p>In addition, this freedom also creates the potential for projects to get out of control. There is a joke that &ldquo;a Lisp language runs and becomes another language, and a Lisp program runs and becomes another program&rdquo;, which is a great advantage if the dynamics are under control, but can be fatal if it gets out of control. If Lisp developers do not discipline themselves and let themselves go, it is easy to write highly abstract and unstructured programs, which are far more painful to troubleshoot than in other languages.</p>
<h2 id="4-some-lisp-related-suggestions">4. Some Lisp related suggestions</h2>
<p>Finally, some advice for those who have developed an interest in Lisp (truly my own opinion).</p>
<p>Lisp is suitable for people who have the following characteristics to learn (suitable people).</p>
<ol>
<li>want to open their eyes (it is recommended to read SICP or PAIP, you may feel like going from the bottom of the well into outer space)</li>
<li>interested in computer science (especially in the field of PL) (you can find many textbooks and papers, Lisp has fewer books in the field of engineering).</li>
<li>don&rsquo;t want to write code, want to generate code (learning Lisp can deepen the understanding of processing code with programs and generating code).</li>
<li>want to implement the programming language (Lisp is a shortcut, although a large number of language interpreters are now implemented in C, but with the help of C to learn the interpreter is a long and bumpy road).</li>
</ol>
<p>However, it is not recommended to spend time learning Lisp if the following characteristics are included (not for the right people).</p>
<ol>
<li>expect to get direct project solutions or direct application to their work (Lisp has a lack of three-party libraries and little Chinese material).</li>
<li>religious worship of the programming language (it is dangerous not to pay attention to the shortcomings of the Lisp language design due to worship).</li>
<li>people whose time and energy are too valuable (many good books on Lisp require a lot of time to study, do exercises or even chew raw meat, the road to practice is longer and the ceiling is higher).</li>
</ol>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/lisp/">lisp</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-02/go-deprecate-strings-title/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Go1.18 new feature: deprecate strings.Title method</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-02/opera-emoji-web-addresses/">
            <span class="next-text nav-default">Opera becomes the first browser to support pure emoji URLs</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
