<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Raft protocol implementation details from JRaft - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Distributed Systems and the Consistency Problem The consistency problem is a core problem that needs to be solved in distributed systems. Distributed systems are generally composed of multiple nodes of equal status, and the interaction between the nodes is like several people getting together to discuss a problem. Let&amp;rsquo;s imagine a more specific scenario, such as three people discussing where to eat at noon, the first person said that a hot pot restaurant has just opened nearby, and I heard that the taste is very good; but the second person said, no, it takes too long to eat hot pot, or just drink some porridge; and the third person said, I just went to that porridge restaurant yesterday, it&amp;rsquo;s too bad, it&amp;rsquo;s better to go to McDonalds." /><meta name="keywords" content="Jraft Raft" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-02/jraft-raft/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Raft protocol implementation details from JRaft" />
<meta property="og:description" content="Distributed Systems and the Consistency Problem The consistency problem is a core problem that needs to be solved in distributed systems. Distributed systems are generally composed of multiple nodes of equal status, and the interaction between the nodes is like several people getting together to discuss a problem. Let&rsquo;s imagine a more specific scenario, such as three people discussing where to eat at noon, the first person said that a hot pot restaurant has just opened nearby, and I heard that the taste is very good; but the second person said, no, it takes too long to eat hot pot, or just drink some porridge; and the third person said, I just went to that porridge restaurant yesterday, it&rsquo;s too bad, it&rsquo;s better to go to McDonalds." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-02/jraft-raft/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-02-13T11:55:42+08:00" />
<meta property="article:modified_time" content="2022-02-13T11:55:42+08:00" />

<meta itemprop="name" content="Raft protocol implementation details from JRaft">
<meta itemprop="description" content="Distributed Systems and the Consistency Problem The consistency problem is a core problem that needs to be solved in distributed systems. Distributed systems are generally composed of multiple nodes of equal status, and the interaction between the nodes is like several people getting together to discuss a problem. Let&rsquo;s imagine a more specific scenario, such as three people discussing where to eat at noon, the first person said that a hot pot restaurant has just opened nearby, and I heard that the taste is very good; but the second person said, no, it takes too long to eat hot pot, or just drink some porridge; and the third person said, I just went to that porridge restaurant yesterday, it&rsquo;s too bad, it&rsquo;s better to go to McDonalds."><meta itemprop="datePublished" content="2022-02-13T11:55:42+08:00" />
<meta itemprop="dateModified" content="2022-02-13T11:55:42+08:00" />
<meta itemprop="wordCount" content="5419">
<meta itemprop="keywords" content="Raft,jraft," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Raft protocol implementation details from JRaft"/>
<meta name="twitter:description" content="Distributed Systems and the Consistency Problem The consistency problem is a core problem that needs to be solved in distributed systems. Distributed systems are generally composed of multiple nodes of equal status, and the interaction between the nodes is like several people getting together to discuss a problem. Let&rsquo;s imagine a more specific scenario, such as three people discussing where to eat at noon, the first person said that a hot pot restaurant has just opened nearby, and I heard that the taste is very good; but the second person said, no, it takes too long to eat hot pot, or just drink some porridge; and the third person said, I just went to that porridge restaurant yesterday, it&rsquo;s too bad, it&rsquo;s better to go to McDonalds."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Raft protocol implementation details from JRaft</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-02-13 11:55:42 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 5419 words </span>
          <span class="more-meta"> 26 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#distributed-systems-and-the-consistency-problem">Distributed Systems and the Consistency Problem</a></li>
        <li><a href="#the-byzantine-generals-problem">The Byzantine Generals Problem</a>
          <ul>
            <li><a href="#the-three-generals-dilemma">The Three Generals' Dilemma</a></li>
          </ul>
        </li>
        <li><a href="#starting-with-a-counter-example">Starting with a Counter example</a>
          <ul>
            <li><a href="#requirements">Requirements</a></li>
            <li><a href="#system-architecture-10">System architecture 1.0</a></li>
            <li><a href="#system-architecture-15">System Architecture 1.5</a></li>
            <li><a href="#system-architecture-20">System Architecture 2.0</a></li>
            <li><a href="#system-architecture-30">System Architecture 3.0</a></li>
          </ul>
        </li>
        <li><a href="#raft-consensus-algorithm">Raft Consensus Algorithm</a></li>
        <li><a href="#basic-concepts-in-raft">Basic concepts in Raft</a>
          <ul>
            <li><a href="#3-rolesstates-of-raft-node">3 Roles/states of Raft-node</a></li>
            <li><a href="#3-types-of-message">3 types of Message</a></li>
            <li><a href="#term-logical-clock">Term Logical Clock</a></li>
          </ul>
        </li>
        <li><a href="#leader-election">Leader election</a>
          <ul>
            <li><a href="#election-steps">Election steps</a></li>
            <li><a href="#vote-split">vote split</a></li>
            <li><a href="#what-the-election-is-trying-to-solve">What the election is trying to solve</a></li>
            <li><a href="#when-an-election-can-be-initiated">When an election can be initiated</a></li>
            <li><a href="#when-to-actually-initiate-an-election">When to actually initiate an election</a></li>
            <li><a href="#which-candidates-deserve-votes">Which candidates deserve votes</a></li>
            <li><a href="#when-does-step-down-happen">When does step down happen</a></li>
            <li><a href="#how-to-avoid-spoilers-from-underqualified-candidates">How to avoid &ldquo;spoilers&rdquo; from underqualified candidates</a></li>
          </ul>
        </li>
        <li><a href="#log-replication">Log replication</a>
          <ul>
            <li><a href="#logentry">LogEntry</a></li>
            <li><a href="#follower-log-inconsistency">Follower log inconsistency</a></li>
            <li><a href="#the-replicated-logs-are-ordered-and-continuous">The replicated logs are ordered and continuous</a></li>
            <li><a href="#replicated-logs-are-concurrent">Replicated logs are concurrent</a></li>
            <li><a href="#copy-logs-are-batch">Copy logs are batch</a></li>
            <li><a href="#snapshot-in-log-replication">Snapshot in Log Replication</a></li>
            <li><a href="#pipeline-mechanism-for-replicating-logs">Pipeline mechanism for replicating logs</a></li>
            <li><a href="#replication-log-details">Replication log details</a></li>
          </ul>
        </li>
        <li><a href="#linear-consistent-reads">Linear Consistent Reads</a>
          <ul>
            <li><a href="#raft-log-read">Raft Log read</a></li>
            <li><a href="#readindex-read">ReadIndex Read</a></li>
            <li><a href="#lease-read">Lease Read</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="distributed-systems-and-the-consistency-problem">Distributed Systems and the Consistency Problem</h2>
<p>The consistency problem is a core problem that needs to be solved in distributed systems. Distributed systems are generally composed of multiple nodes of equal status, and the interaction between the nodes is like several people getting together to discuss a problem. Let&rsquo;s imagine a more specific scenario, such as three people discussing where to eat at noon, the first person said that a hot pot restaurant has just opened nearby, and I heard that the taste is very good; but the second person said, no, it takes too long to eat hot pot, or just drink some porridge; and the third person said, I just went to that porridge restaurant yesterday, it&rsquo;s too bad, it&rsquo;s better to go to McDonalds. As a result, the three people deadlocked, never reached agreement.</p>
<p>Someone said, this is not a bad solution, voting. So the three people voted for a round, the results of each person still adhere to their own proposals, the problem is still not resolved. Someone thought of an idea, why don&rsquo;t we elect a leader, the leader said anything, we will listen to him, so that we don&rsquo;t have to fight. The three people finally realized that the issue of &ldquo;choosing a leader&rdquo; was still essentially the same as the original issue of &ldquo;where to eat&rdquo; and was equally difficult to solve.</p>
<p>At this point, I&rsquo;m afraid some readers are thinking, &ldquo;What&rsquo;s wrong with these three people? &hellip;&hellip; It&rsquo;s such a trivial matter as eating a meal, why do they have to fight like this? In fact, without some strictly defined rules and protocols between each node in a distributed system, there is a real possibility that the interaction between them will be like the above scenario. If the whole system does not agree, it will not work at all.</p>
<p>So, there are clever people who have designed consistency protocols (consensus protocol), such as our common ones like Paxos, Raft, Zab and so on. The final goal of the protocol is for each node to reach the same proposal according to certain rules, but whose proposal prevails? One rule that comes to mind is that whichever node makes a proposal first will prevail, and any proposal made later will be invalid.</p>
<p>However, the situation in a distributed system is much more complicated than a few people getting together to discuss the problem, and there is the problem of network latency here. This makes it difficult for X and Y to agree on who is first and who is second, respectively.</p>
<p>The situation is further complicated if we consider the possibility of node downtime and message loss. Node downtime can be seen as a special case of message loss, which is equivalent to the loss of all messages sent to this node. In the theoretical framework of CAP, this is equivalent to network partitioning, which corresponds to the P in CAP. e.g., several nodes are unreachable, i.e., they do not receive any response to the messages sent to them by other nodes. The real reason could be that the middle of the network is down, or that the destination nodes are down, or that the messages are delayed indefinitely. In short, it means that some nodes in the system are out of contact and they can no longer participate in the decision making, but it does not mean that they cannot be reconnected after some time.</p>
<p>To make it more intuitive, let&rsquo;s assume that some nodes are down. At that time, can the remaining nodes still agree on the proposal without some nodes participating in the decision? Even if they do, after the downed nodes recover (noting that they may not know about the agreed proposals among the other nodes), will they disagree with the agreed proposals again, thus causing confusion? All these are questions that need to be addressed by the distributed consistency protocol.</p>
<p>In fact, it is more important to understand the question itself than the answer to the question.</p>
<h2 id="the-byzantine-generals-problem">The Byzantine Generals Problem</h2>
<p>In the theory of distributed systems, this problem is abstracted into a well-known problem, the Byzantine Generals Problem (BGP).</p>
<p>The Byzantine Empire sends multiple armies to besiege an enemy army, each with a general, but because of the distance between them, they can only pass messages to each other by messenger. The enemy was so strong that more than half of the Byzantine army had to join the attack in order to defeat the enemy. In the meantime, the generals had to send messages to each other by messenger and then attack at the same point in time after consensus.</p>
<p>Related papers.</p>
<ul>
<li><a href="http://lamport.azurewebsites.net/pubs/byz.pdf">《The Byzantine Generals Problem》</a></li>
<li><a href="http://lamport.azurewebsites.net/pubs/reaching.pdf">《Reaching Agreement in the Presence of Faults》</a></li>
</ul>
<h3 id="the-three-generals-dilemma">The Three Generals' Dilemma</h3>
<p>Suppose there are only three Byzantine generals, A, B and C, and they have to discuss only one thing: whether to attack or retreat tomorrow. To do this, the generals need to vote on the principle of &ldquo;majority rule&rdquo;, as long as two of them are in agreement.</p>
<p>For example, if A and B vote to attack and C votes to retreat.</p>
<ol>
<li>then the message from A&rsquo;s messenger to both B and C is to attack.</li>
<li>the message from B&rsquo;s messenger to both A and C is attack.</li>
<li>and the message from C&rsquo;s messenger to both A and B is retreat.</li>
</ol>
<p>What if a slight change is made: what if a traitor comes out of the three generals? The traitor&rsquo;s purpose is to break the agreement between the loyal generals and to make the Byzantine army suffer.</p>
<p>As the traitor C, you will not play the usual cards, so you have a messenger tell A that you &ldquo;want to attack&rdquo;, and another messenger tell B that you &ldquo;want to retreat&rdquo;.</p>
<p>At this point, General A sees the vote as: Attacker : Retreater = 2 : 1, while General B sees 1 : 2. The next day, the loyal A rushed to the battlefield, but found that only one of their own army launched the attack, while the same loyal B, but has long retreated. Eventually, A&rsquo;s army loses to the enemy.</p>
<p>Raft&rsquo;s algorithm is based on the premise that <strong>no malicious nodes exist in order to reach agreement</strong> . Otherwise, these famous algorithms would then fail.</p>
<h2 id="starting-with-a-counter-example">Starting with a Counter example</h2>
<h3 id="requirements">Requirements</h3>
<p>Provide a Counter where the Client can specify the step size each time it counts, and can also initiate a query at any time.</p>
<p>This seemingly simple requirement has three main functional points.</p>
<ul>
<li>Implementation: Counter server, with counting function, with the specific formula: Cn = Cn-1 + delta.</li>
<li>Provide write service, write delta to trigger the counter operation.</li>
<li>Provide a read service, which reads the current Cn value.</li>
</ul>
<p>In addition, we have an optional requirement of availability, we need to have backup machines, and the read and write services cannot be unavailable.</p>
<h3 id="system-architecture-10">System architecture 1.0</h3>
<p>Based on the functional requirements just analyzed, we design the architecture of 1.0, which is very simple. A node Counter Server provides the counting function and receives counting requests and query requests from clients.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/13/882cabd4e149440492b88f7d57d7e4ce.png" alt="sobyte"></p>
<p>However, there are two problems with such an architecture: first, the Server is a single point, and once the Server node fails, the service is unavailable; second, the results are stored in memory, and node failure will lead to data loss.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/13/fb9459fe0e72401b95b5482377fea783.png" alt="sobyte"></p>
<h3 id="system-architecture-15">System Architecture 1.5</h3>
<p>For problem 1, we have to start a new standby machine when the node fails. For problem 2, we optimize it by adding a local file store. This will store the data to disk after each counter completes its operation.</p>
<p>But it also leads to another problem: disk IO is very frequent, and this cold standby mode still leads to a period of service unavailability.</p>
<h3 id="system-architecture-20">System Architecture 2.0</h3>
<p>Since the above problems can no longer be solved by just adding machines, we propose Architecture 2.0, which uses a cluster model to provide services. We use three nodes to form a cluster, and one node provides the service to the outside world. When the Server receives a write request from the Client, the Server computes the result and then copies the result to the other two machines, and after receiving successful responses from all the other nodes, the Server returns the computation result to the Client.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/13/a455ecc65739422f941dca18c2180379.png" alt="sobyte"></p>
<p>But there is a problem with this architecture: * We choose which Server plays the role of the Leader.</p>
<ul>
<li>Which Server we choose to play the role of Leader to provide services to the public;</li>
<li>Which Server we choose to take over the role of Leader when it becomes unavailable;</li>
<li>When the Leader is not available, which one will take over?</li>
<li>The Leader needs to wait until all nodes respond before responding to the Client when processing write requests.</li>
<li>It is also important that we cannot guarantee that the data replication from Leader to Follower is in order, so the data of the three nodes may be different at any moment.</li>
</ul>
<p>So to ensure the order and content of the replicated data, this is where the consensus algorithm comes in handy, and we use SOFAJRaft to build our 3.0 architecture.</p>
<h3 id="system-architecture-30">System Architecture 3.0</h3>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/13/ad518d8519574e55b18866d1febe2216.png" alt="sobyte"></p>
<p>In the 3.0 architecture, Counter Server uses SOFAJRaft to form a cluster, and the election of Leaders and replication of data are left to SOFAJRaft.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/13/2919ba4d353149e79dafcfe42b78829b.png" alt="sobyte"></p>
<p>In the timing diagram, we can see that the business logic of Counter has become as simple as in architecture 1.0, and the work of maintaining consistent data is left to SOFAJRaft, so the gray part of the diagram is not business-aware.</p>
<p>In the 3.0 architecture using SOFAJRaft, SOFAJRaft helps us to finish the work of Leader election and data synchronization between nodes, in addition, SOFAJRaft only needs more than half of the nodes to respond, and no longer needs all nodes of the cluster to answer, which can further improve the processing efficiency of write requests.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/13/ee2af48e34514b939eb37d66583fd01f.png" alt="sobyte"></p>
<h2 id="raft-consensus-algorithm">Raft Consensus Algorithm</h2>
<p>Small paper: &ldquo;In Search of an Understandable consensus Algorithm&rdquo;</p>
<p>Large paper: &ldquo;Consensus: Bridging theory and practice&rdquo;</p>
<p>Raft is a consensus algorithm characterized by allowing multiple participants to reach complete agreement on a single thing: one thing, one conclusion. At the same time, the agreed conclusions are irreversible. To explain the consensus algorithm, let&rsquo;s take an example of a bank account: if a cluster of servers maintains a bank account system, and a Client issues a command to the cluster to &ldquo;deposit $100&rdquo;, then when the cluster returns a successful answer, the Client will be able to query the cluster again and will be able to Even if a machine is unavailable, the <code>$100</code> account cannot be tampered with. This is what the consensus algorithm aims to achieve.</p>
<h2 id="basic-concepts-in-raft">Basic concepts in Raft</h2>
<h3 id="3-rolesstates-of-raft-node">3 Roles/states of Raft-node</h3>
<p>There are three types of roles in a cluster organized by the Raft protocol.</p>
<ol>
<li>Leader</li>
<li>Follower</li>
<li>Candidate</li>
</ol>
<p>Just like a democratic society, the leader is elected by popular vote. At the beginning there is no leader, all the participants in the cluster are the masses, then first a general election is opened, during the election all the masses can participate in the election, then the role of all the masses becomes the candidates, after the democratic vote to elect the leader begins the term of the leader, then the election is over, all the candidates except the leader return to the role of the masses to obey the leader. Here is a concept called &ldquo;term of office&rdquo;, which is expressed in the term Term.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/13/cc28de30b7aa4c199819bcd7c9a6343c.png" alt="sobyte"></p>
<h3 id="3-types-of-message">3 types of Message</h3>
<ol>
<li>RequestVote RPC: sent by Candidate, used to send poll requests.</li>
<li>AppendEntries (Heartbeat) RPC: sent by the Leader, used to copy log entries from the Leader to the Followers, also used as Heartbeat (an empty log entry is a Heartbeat).</li>
<li>InstallSnapshot RPC: issued by the Leader, used for snapshot transfer, although in most cases each server creates snapshots independently, the Leader sometimes has to send snapshots to some Follower that is too far behind, which usually happens when the Leader has discarded the next log entry to be sent to that Follower ( This usually happens when the Leader has already discarded the next log entry to be sent to that Follower (cleared out during Log Compaction).</li>
</ol>
<h3 id="term-logical-clock">Term Logical Clock</h3>
<ol>
<li>time is divided into terms, with term ids increasing monotonically on the timeline.</li>
<li>each term starts with a Leader election, after which the Leader manages the entire cluster for the duration of the term, i.e. <strong>&ldquo;election + routine operations &ldquo;</strong>;</li>
<li>at most one Leader per term, there may be no Leader (due to spilt-vote).</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/13/4037b7e8f8e841289b9f2cc3976c21a1.png" alt="sonbyte"></p>
<h2 id="leader-election">Leader election</h2>
<h3 id="election-steps">Election steps</h3>
<p>The following steps are extracted from the paper for illustration.</p>
<ol>
<li>When servers start up, they begin as followers</li>
<li>If a follower receives no communication over a period of time called the <strong>election timeout</strong> , then it assumes there is no viable leader and begins an election to choose a new leader</li>
<li>To begin an election, a follower increments its current term and transitions to candidate state</li>
<li>then votes for itself and issues RequestVote RPCs in parallel to each of
the other servers in the cluster.</li>
<li>A candidate wins an election if it receives votes from a majority of the servers in the full cluster for the same term</li>
<li>Once a candidate wins an election, it becomes leader</li>
<li>a candidate may receive an AppendEntries RPC</li>
<li>If the leader&rsquo;s term is at least as large as the candidate&rsquo;s current term, then the candidate recognizes the leader as legitimate and returns to follower state</li>
<li>If the term in the RPC is smaller than the candidate&rsquo;s current term, then the candidate rejects the RPC and continues in candidate state</li>
</ol>
<h3 id="vote-split">vote split</h3>
<p>if many followers become candidates at the same time, votes could be split so that no candidate obtains a majority. When this happens, each candidate will time out and start a new election by incrementing its term and initiating another round of RequestVote RPCs.</p>
<p>Raft uses randomized election timeouts to ensure that split votes are rare and that they are resolved quickly.</p>
<p>Here&rsquo;s an example to illustrate the election process</p>
<h3 id="what-the-election-is-trying-to-solve">What the election is trying to solve</h3>
<p>A distributed cluster can be thought of as a fleet of ships that communicate with each other by means of semaphore. In such a fleet, the ships are neither completely isolated from each other, but neither can they maintain very close contact as they do on land; weather, sea conditions, ship spacing, and ship battle damage cause contact between ships to exist but be unreliable.</p>
<p>The fleet as a unified combat cluster needs to have a unified consensus and consistent orders, all of which depend on the flagship command. Each ship has to obey the orders issued by the flagship, and when the flagship can no longer work, another warship needs to take over the role of the flagship.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/13/7111dbfd84cd44f2905bceff1fbc0c43.png" alt="sobyte"></p>
<p>How to choose a flagship that is recognized by everyone in the fleet is the problem that the election in SOFAJRaft will solve.</p>
<h3 id="when-an-election-can-be-initiated">When an election can be initiated</h3>
<p>In SOFAJRaft, the trigger criterion is the communication timeout. When the flagship does not communicate with the Follower ship for a specified period of time, the Follower can assume that the flagship is no longer able to perform the flagship duties properly, and the Follower can try to take over the role of the flagship. This communication timeout is called Election Timeout (ET), and the Follower&rsquo;s attempt to take over the flagship is also known as initiating an election request.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/13/c499fa8cd0b949f9aac38310eaa44efd.png" alt="sobyte"></p>
<h3 id="when-to-actually-initiate-an-election">When to actually initiate an election</h3>
<p>In an election, the ship that initiated the election can only become the flagship if more than half the ships in the fleet agree, otherwise a new round of elections has to be started. So if Follower takes the strategy of starting the election as soon as possible, trying to choose the available flagship for the fleet as soon as possible, there is a potential risk that multiple ships may start the election almost at the same time, and as a result, none of them will get more than half of the votes, resulting in a fruitless round of election, which is called vote split above.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/13/532688fd0c1644d0b9de4fb3c6f94bc3.png" alt="sobyte"></p>
<p>To avoid this, we use a random election trigger time. When Follower finds that the flagship is lost, it will choose to wait for a random period of time Random(0, ET), and if no flagship is elected during the waiting period, then Follower will initiate the election again.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/13/33ffef9420014b6b81f76be1926b8fcd.png" alt="sobyte"></p>
<h3 id="which-candidates-deserve-votes">Which candidates deserve votes</h3>
<p>SOFAJRaft&rsquo;s election contains judgments on two attributes: LogIndex and Term, which is the core part of the whole election algorithm.</p>
<ol>
<li>Term: we will number the history of flagships in the fleet, such as the 1st flagship and 2nd flagship of the fleet, and this number we will use Term to represent. Since there can only be at most one ship in the fleet as flagship at the same time, each Term belongs to only one ship, and obviously Term is monotonically increasing.</li>
<li>LogIndex: Each flagship will issue some orders (called &ldquo;flagship orders&rdquo;, analogous to &ldquo;presidential orders&rdquo;) during its term of office, and these flagship orders should be numbered and filed. This number is identified by two dimensions, Term and LogIndex, and means &ldquo;LogIndex of the flagship issued by the Term flagship&rdquo;. Unlike real presidential decrees, the LogIndex of our flagship decrees is always incremental and does not start from the beginning when the flagship changes.</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/13/4742929a63ab49caadf83ed1ae413e49.png" alt="sobyte"></p>
<p>Specifically, a voting ship V will not vote for either candidate C: one where lastTermC &lt; lastTermV; or (lastTermV == lastTermC) &amp;&amp; (lastLogIndexV &gt; lastLogIndexC).</p>
<p>The first case means that the last flagship that candidate C communicated with is no longer the latest flagship; the second case means that although both C and V have communicated with the same flagship, the flagship order that candidate C received from the flagship is not as complete as V (lastLogIndexV &gt; lastLogIndexC), so V will not vote for it.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/13/0b71487d16cd4096b7c333c65c8b0bfa.png" alt="sobyte"></p>
<h3 id="when-does-step-down-happen">When does step down happen</h3>
<p>A step down can occur in a Candidate that has fallen back to Follower, or in a Leader that has fallen back to Follower. If the Candidate is a Leader, then the Candidate abandons the race for the current Leader, and if the Leader is a Follower, then the Candidate reverts to the Follower state and reopens the election.</p>
<p>The Candidate will step down to Follower in the following two cases:</p>
<ol>
<li>if the Candidate receives a poll request from another Server with a higher Term while the Candidate is waiting for the Servers' poll results.</li>
<li>if a heartbeat from another Server with a higher Term is received while Candidate is waiting for the voting result of Servers.</li>
</ol>
<p>And for Leader, it will also fall back to Follower state when a Leader with higher Term is found.</p>
<h3 id="how-to-avoid-spoilers-from-underqualified-candidates">How to avoid &ldquo;spoilers&rdquo; from underqualified candidates</h3>
<p>SOFAJRaft uses LogIndex and Term as selection criteria for elections, so before a ship initiates an election, it increments its own Term and sends it to the other ships in an election request (possibly with a complex semaphore), indicating that it is running for the &ldquo;Term + 1&rdquo; flagship.</p>
<p>There is a mechanism that is used to keep the Term increments of each ship synchronized: when the voting Follower ships receive the poll request, they will update their Term to match the candidate if they find their Term is smaller than the one in the poll request, which makes it easy to synchronize the Term increments to the whole fleet.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/13/53d4f3d1e06f4db09c7ab5af25f4f1e0.png" alt="sobyte"></p>
<p>But this mechanism also poses a problem. If a ship does not see the flagship&rsquo;s semaphore for its own reasons, it will presumptuously try to run to become the new flagship, and although it keeps initiating elections and never gets elected (because the flagship and other ships are communicating normally), it actually raises the global Term by its own vote request, which in the SOFAJRaft algorithm will force the flagship to stepdown (step back from the flagship position).</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/13/c8023d5b2be243ec947578e6b389f68e.png" alt="sobyte"></p>
<p>So we need a mechanism to stop this &ldquo;disruption&rdquo;, which is the pre-vote loop. If a candidate does not receive feedback from more than half of the nodes, the candidate will have the sense to drop out of the race and will not raise the global Term.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/13/024951b3fc604cd295827941156475e8.png" alt="sobyte"></p>
<p>In the above analogy, we can see that the main tasks of the whole election operation are:</p>
<ol>
<li>Candidate is triggered by ET</li>
<li>Candidate starts to try to initiate a pre-vote pre-vote</li>
<li>Follower decides whether to approve the pre-vote request</li>
<li>Candidate decides whether to send RequestVoteRequest based on the pre-vote response</li>
<li>Follower determines whether to approve the RequestVoteRequest</li>
<li>Candidate decides if he is elected based on the response</li>
</ol>
<h2 id="log-replication">Log replication</h2>
<ol>
<li>
<p>Leaders provide services to the public</p>
<p>Once a leader has been elected, it begins servicing client requests. Each client request contains a command to be executed by the replicated state machines.</p>
</li>
<li>
<p>leader execution log replication</p>
<p>The leader appends the command to its log as a new entry, then issues AppendEntries RPCs in parallel to each of the other servers to replicate the entry.</p>
</li>
<li>
<p>Log replication success</p>
<p>When the entry has been safely replicated (as described below), the leader applies the entry to its state machine and returns the result of that execution to the client.</p>
</li>
<li>
<p>Log replication failure</p>
</li>
</ol>
<p>Another situation in which Follower fails is the following.</p>
<p>If followers crash or run slowly, or if network packets are lost, the leader retries AppendEntries RPCs indefinitely (even after it has responded to the client) until all followers eventually store all log entries.</p>
<h3 id="logentry">LogEntry</h3>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/13/56d68d0a84da4c5db0893a3873c8175d.png" alt="sobyte"></p>
<p>As shown in the figure above, each square represents a LogEntry, you can see that Log is composed of one LogEntry, ideally the array is consistent on all instances. log elements are further divided into uncommitted and committed depending on their status. Only the committed LogEntry will return a successful client write.</p>
<p>The top row is the log index, which is the subscript value, monotonically increasing and continuous. The number in the square represents the term term.</p>
<p>committed entry：A log entry is committed once the leader that created the entry has replicated it on a majority of the servers</p>
<p>This means that a log is only considered a committed log if it is replicated to most of the nodes.</p>
<p>Once a follower learns that a log entry is committed, it applies the entry to its local state machine (in log order).</p>
<p>Once Follower learns that this LogEntry has been committed, then it will put this LogEntry into the state machine for execution.</p>
<h3 id="follower-log-inconsistency">Follower log inconsistency</h3>
<p>In general, the logs of the Leader and Follower are consistent, but in reality the Leader is not guaranteed not to crash, so the logs may be inconsistent as shown below.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/13/130fa61df22644d1bd0ed4bdd77a121d.png" alt="sobyte"></p>
<p>As shown above, Follower may have less logs than Leader, may have redundant logs, and may both lose logs and have redundant logs.</p>
<p>So Raft needs to do these things with the consistency of the logs.</p>
<ol>
<li>
<p>consistency check</p>
<p>Since the leader will bring index and term when sending LogEntry, Follower has to check whether this LogEntry is continuous with the previous log after receiving it, so Follower will reject the replication request that cannot be continuous with the existing local log. In this case, we need to go through the Log recovery process.</p>
</li>
<li>
<p>find the latest log entry</p>
<p>If it is not consistent, then you need to find the log that is recognized by both Leader and Follower, which must be continuous in Follower and exist in Leader, as follows.</p>
<ol>
<li>The leader maintains a nextIndex for each follower,
which is the index of the next log entry the leader will send to that follower.</li>
<li>When a leader first comes to power, it initializes all nextIndex values to the index just after the last one in its log.</li>
<li>After the Leader node establishes a connection with Follower via Replicator, it sends a Probe request of type Probe to know the location of the logs already owned by Follower.</li>
<li>If a follower&rsquo;s log is inconsistent with the leader&rsquo;s, the AppendEntries consistency check will fail in the next AppendEntries RPC. After a rejection, the leader decrements nextIndex and retries the AppendEntries RPC. Eventually nextIndex will reach a point where the leader and follower logs match.</li>
<li>Eventually nextIndex will reach a point where the leader and follower logs match. When this happens, AppendEntries will succeed, which removes any conflicting entries in the follower&rsquo;s log and appends entries from the leader&rsquo;s log</li>
</ol>
</li>
</ol>
<p>Here are the details of log replication in JRaft</p>
<h3 id="the-replicated-logs-are-ordered-and-continuous">The replicated logs are ordered and continuous</h3>
<p>When SOFAJRaft replicates logs, the order of log transfers must be strictly sequential, and all logs must not be out of order or have gaps (i.e. they cannot be missed).</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/13/aa733493303947bea8189f0db2e90e6a.png" alt="sobyte"></p>
<h3 id="replicated-logs-are-concurrent">Replicated logs are concurrent</h3>
<p>The Leader node in SOFAJRaft replicates logs to multiple Follower nodes simultaneously, and a Replicator is assigned to each Follower in the Leader to handle the replication log task exclusively.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/13/b3141a0bd37646b396747ea20fdfd1ad.png" alt="sobyte"></p>
<h3 id="copy-logs-are-batch">Copy logs are batch</h3>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/13/89db03295b7b48a0965b82c64b84c035.png" alt="sobyte"></p>
<h3 id="snapshot-in-log-replication">Snapshot in Log Replication</h3>
<p>Snapshot allows Follower to quickly keep up with the Leader&rsquo;s log progress and not replay log messages from long ago, which eases network throughput and improves log synchronization efficiency.</p>
<h3 id="pipeline-mechanism-for-replicating-logs">Pipeline mechanism for replicating logs</h3>
<p>Pipeline enables Leader and Follower to no longer strictly follow the &ldquo;Request -Response - Request&rdquo; interaction pattern, and Leader can continuously Append the replicated logs without receiving a Response. The Leader can continuously send the AppendEntriesRequest of the replicated log to the Follower without receiving a Response.</p>
<p>The Leader only needs to maintain a queue for each Follower to record the copied logs and resend the subsequent logs to the Follower in case of log copy failure.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/13/5cf6f6c8e4404ff8ac49c689f052b0b3.png" alt="sobyte"></p>
<h3 id="replication-log-details">Replication log details</h3>
<ol>
<li>
<p>detect Follower log statusLeader node, after establishing a connection with Follower via Replicator, sends a probe request of type Probe in order to know the location of the logs already owned by Follower so that it can send subsequent logs to Follower.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/13/75b7b43afea74be988eebaeeac72763d.png" alt="sobyte"></p>
</li>
<li>
<p>Use Inflight to help implement the pipeline</p>
<p>Inflight is an abstraction of the logEntry sent out in bulk, which indicates which logEntry has been encapsulated as a log replication request and sent out.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/13/cc906b9e37ac4764bd31f1b2c16b30dc.png" alt="sobyte"></p>
<p>The Leader maintains a queue, and adds an Inflight to the queue for each batch of logEntry, so that when it knows that a batch of logEntry has failed to replicate, it can rely on the Inflight in the queue to replicate that batch of logEntry and all subsequent logs to the follower. This ensures that the log replication is completed and that the order of the replicated logs remains unchanged.</p>
</li>
</ol>
<h2 id="linear-consistent-reads">Linear Consistent Reads</h2>
<p>A simple example of a linearly consistent read is that if we write a value at t1, we must be able to read that value after t1, and cannot read the old value before t1.</p>
<p>When a Client initiates a write request to the cluster and receives a successful response, the result of the write operation is visible to all subsequent read requests.</p>
<h3 id="raft-log-read">Raft Log read</h3>
<p>The most conventional way to achieve a linear consistent read is to use the Raft protocol, where the read request is also processed according to the Log, and the read result is obtained through Log replication and state machine execution, and then the read result is returned to the Client. It is very convenient to implement linear read through Raft, which means that any read request will go through the Raft Log once, and then read the value from the state machine when applying after the log is committed, which will ensure that the read value is linear.</p>
<p>Of course, because every Read needs to go through the Raft process, Raft Log storage and replication bring about the overhead of disk swiping, storage overhead, and network overhead, and going through Raft Log not only has the overhead of log drop, but also the network overhead of log replication, in addition to a bunch of Raft &ldquo;read log&rdquo; caused by the disk occupation The performance of Read operations is very inefficient, so it has a great impact on performance in scenarios with many read operations, and is unacceptable in systems with a large proportion of reads, and is usually not used.</p>
<p>In Raft, nodes have three states: Leader, Candidate and Follower. Any Raft write operation must go through Leader, and only Leader will copy the corresponding Raft log to Majority&rsquo;s node to consider the write as successful. So if the current Leader can be sure that it is the Leader, then it can directly read the data on this Leader, because for the Leader, if it confirms that a Log has been submitted to most nodes and applies to the state machine at t1, then the Read after t1 must be able to read the newly written data.</p>
<p>In other words, compared to Raft Log read, there is less process of Log copy, instead, as long as you confirm your leader identity, you can read data directly from the leader, so that the data must be accurate.</p>
<p>Then how to confirm that the Leader must be the Leader when processing this Read? In the Raft paper, two methods are mentioned:</p>
<ul>
<li>ReadIndex Read</li>
<li>Lease Read</li>
</ul>
<h3 id="readindex-read">ReadIndex Read</h3>
<p>The first type is ReadIndex Read, when the Leader needs to process a Read request, the Leader can provide a linear consistent read after exchanging heartbeat information with more than half of the machines to make sure he is still the Leader:</p>
<ol>
<li>the Leader records the commitIndex of its current Log into a Local variable ReadIndex.</li>
<li>then launch a round of Heartbeat to Followers nodes, if more than half of the nodes return the corresponding Heartbeat Response, then the Leader can determine that it is still the Leader;</li>
<li>the Leader waits for its StateMachine state machine to execute, and applies at least to the Log recorded in ReadIndex, until applyIndex exceeds ReadIndex, so that it can safely provide Linearizable Read, and does not care if the Leader has drifted away at the time of reading.</li>
<li>The Leader executes the Read request and returns the result to the Client.</li>
</ol>
<p>Using ReadIndex Read to provide Follower Read function, it is easy to provide Linearizable Read on top of Followers node, after Follower receives Read request.</p>
<ol>
<li>the Follower node requests the latest ReadIndex from the Leader.</li>
<li>the Leader still goes through the same process as before, executing the first 3 steps (to make sure it is really the Leader), and returns the ReadIndex to the Follower.</li>
<li>Follower waits for the applyIndex of the current state machine to exceed the ReadIndex.</li>
<li>Follower executes the Read request and returns the result to Client.</li>
</ol>
<p>ReadIndex Read uses the Heartbeat method instead of log replication, eliminating the Raft Log process. Compared to the Raft Log method, ReadIndex Read eliminates the disk overhead and can significantly increase throughput. There is still network overhead, but Heartbeat is already small, so performance is still very good.</p>
<h3 id="lease-read">Lease Read</h3>
<p>Although ReadIndex Read is much faster than the original Raft Log Read, there is still a Heartbeat network overhead, so we consider to do further optimization.</p>
<p>The Raft paper mentions a Lease Read optimization method through Clock + Heartbeat, which means that the Leader first records a time point Start when sending a Heartbeat, and when most nodes in the system reply to the Heartbeat Response, due to Raft&rsquo;s election mechanism, the Follower will be at the Election Timeout. Follower will re-elect after the Election Timeout time, and the next Leader election time is guaranteed to be greater than Start+Election Timeout/Clock Drift Bound, so we can assume that the Leader&rsquo;s Lease validity period can be up to Start+Election Timeout/Clock Drift. Lease Read is similar to ReadIndex but further optimized, not only saving Log, but also eliminating network interaction, significantly improving read throughput and significantly reducing latency.</p>
<p>The basic idea of Lease Read is that the Leader takes a smaller lease period than the Election Timeout (preferably one order of magnitude smaller), and no election occurs during the lease period to ensure that the Leader does not change, so the ReadIndex step of sending Heartbeat is skipped, which also reduces the latency.</p>
<p>It can be seen that the correctness of Lease Read is linked to the time and depends on the accuracy of the local clock, so although the Lease Read approach is very efficient, it still faces the problem of risk, that is, there is a preset premise that the time of each server&rsquo;s CPU Clock is accurate, even if there is an error, it will be in a very small Bound range, the time of If the clock drift is serious, and the frequency of the clock goes differently among servers, this Lease mechanism may go wrong.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/raft/">Raft</a>
          <a href="/tags/jraft/">jraft</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-02/kafka-architecture/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Detailed breakdown of the Kafka architecture</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-02/linux-file-system-and-file-caching/">
            <span class="next-text nav-default">Linux file system and file caching knowledge collation</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
