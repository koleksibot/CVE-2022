<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Linux System Programming -(pthread) Thread Creation and Usage - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="This article describes the basic use of threads on Linux. 1. Preface Difference between threads and processes (1) Process: It is the smallest unit of OS scheduling. ps, top, etc. commands can be used to view the details of processes under Linux. (2) Thread: It is the smallest unit of process scheduling, each process has a main thread. The main thing to do in the process is the thread. (3)" /><meta name="keywords" content="Linux, Pthread" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-02/linux-pthread/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Linux System Programming -(pthread) Thread Creation and Usage" />
<meta property="og:description" content="This article describes the basic use of threads on Linux. 1. Preface Difference between threads and processes (1) Process: It is the smallest unit of OS scheduling. ps, top, etc. commands can be used to view the details of processes under Linux. (2) Thread: It is the smallest unit of process scheduling, each process has a main thread. The main thing to do in the process is the thread. (3)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-02/linux-pthread/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-02-24T09:34:02+08:00" />
<meta property="article:modified_time" content="2022-02-24T09:34:02+08:00" />

<meta itemprop="name" content="Linux System Programming -(pthread) Thread Creation and Usage">
<meta itemprop="description" content="This article describes the basic use of threads on Linux. 1. Preface Difference between threads and processes (1) Process: It is the smallest unit of OS scheduling. ps, top, etc. commands can be used to view the details of processes under Linux. (2) Thread: It is the smallest unit of process scheduling, each process has a main thread. The main thing to do in the process is the thread. (3)"><meta itemprop="datePublished" content="2022-02-24T09:34:02+08:00" />
<meta itemprop="dateModified" content="2022-02-24T09:34:02+08:00" />
<meta itemprop="wordCount" content="1889">
<meta itemprop="keywords" content="linux," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Linux System Programming -(pthread) Thread Creation and Usage"/>
<meta name="twitter:description" content="This article describes the basic use of threads on Linux. 1. Preface Difference between threads and processes (1) Process: It is the smallest unit of OS scheduling. ps, top, etc. commands can be used to view the details of processes under Linux. (2) Thread: It is the smallest unit of process scheduling, each process has a main thread. The main thing to do in the process is the thread. (3)"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Linux System Programming -(pthread) Thread Creation and Usage</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-02-24 09:34:02 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 1889 words </span>
          <span class="more-meta"> 4 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#1-preface">1. Preface</a></li>
        <li><a href="#2-introduction-to-thread-related-functions">2. Introduction to thread-related functions</a>
          <ul>
            <li><a href="#21-creating-threads">2.1 Creating threads</a></li>
            <li><a href="#22-exiting-a-thread">2.2 Exiting a thread</a></li>
            <li><a href="#23-waiting-for-a-thread-to-finish">2.3 Waiting for a thread to finish</a></li>
            <li><a href="#24-thread-separation-property">2.4 Thread separation property</a></li>
            <li><a href="#25-getting-the-identifier-of-the-current-thread">2.5 Getting the identifier of the current thread</a></li>
            <li><a href="#26-automatic-thread-resource-cleanup">2.6 Automatic thread resource cleanup</a></li>
            <li><a href="#27-auto-cleanup-thread-sample-code">2.7 Auto-cleanup thread sample code</a></li>
            <li><a href="#28-thread-cancellation-functions">2.8 Thread cancellation functions</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>This article describes the basic use of threads on Linux.</p>
<h2 id="1-preface">1. Preface</h2>
<p><strong>Difference between threads and processes</strong> (1) Process: It is the smallest unit of OS scheduling. ps, top, etc. commands can be used to view the details of processes under Linux. (2) Thread: It is the smallest unit of process scheduling, each process has a main thread. The main thing to do in the process is the thread.</p>
<p>(3) In the whole system, the process ID is the unique identifier, and the management of processes is done by PID. When a process is created, a structure is created in the kernel to store all the information about the process, and each node that stores the process information also stores its own PID, which is used to manage the process when it is needed (e.g., sending signals). When a child process ends and needs to be recycled (when it calls exit() to exit or when code execution is finished), it needs to be done with the wait() system call, and the unrecovered extinct process becomes a zombie process that no longer exists as a process entity, but takes up PID resources, so recycling is necessary.</p>
<p>For threads, to actively terminate you need to call pthread_exit() and the main thread needs to call pthread_join() to recycle (provided the thread does not have the &ldquo;detach property&rdquo; set). Signaling a thread like a thread sends a thread signal is also implemented via the thread ID.</p>
<p>Communication methods between processes: A. Shared memory B. Message queues C. Semaphore D. Named pipes E. Nameless pipes F. Signals G. Files H. Sockets Communication methods between threads: A. Mutual exclusion B. Spin locks C. Conditional variables D. Read/write locks E. Thread signals F. Global variables</p>
<p>The communication method used between processes either requires switching the kernel context or accessing with peripherals (famous pipes, files). So it will be slower. If threads use their own specific communication method, it is basically done in their own process space, there is no switching, so the communication speed will be faster. In other words, there is a difference in speed between the communication methods used by processes and threads, in addition to the difference in type.</p>
<p>Note: When a process running multiple threads catches a signal, it will only block the main thread, while other sub-threads will not be affected and will continue to execute.</p>
<h2 id="2-introduction-to-thread-related-functions">2. Introduction to thread-related functions</h2>
<h3 id="21-creating-threads">2.1 Creating threads</h3>
<p>pthread_create is a function for creating threads for Unix operating systems (Unix, Linux, etc.). <strong>Compile time requires specifying the link library:</strong> -lpthread <strong>function prototype</strong>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">pthread_create</span>
<span class="p">(</span>
    <span class="n">pthread_t</span> <span class="o">*</span><span class="kr">thread</span><span class="p">,</span> 
    <span class="k">const</span> <span class="n">pthread_attr_t</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
    <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">start_routine</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> 
    <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span>
<span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>Parameter introduction</strong></p>
<p>The first parameter is a pointer to the thread identifier. The second parameter is used to set the thread property. The third parameter is the starting address of the thread running function. The last parameter is the argument of the run function. The last argument is the argument to run the function. NULL is not required. see function help under Linux: <code># man pthread_create</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/24/75b632a780934b03a7694c17300b4e8a.png" alt="man pthread_create"></p>
<p><strong>Return Value:</strong> Returns 0 if the thread creation was successful, or the error number if the thread creation failed. After a successful thread creation, the attr parameter is used to specify various different thread properties. The newly created thread starts at the address of the start_rtn function, which has only one universal pointer argument arg. If more than one argument needs to be passed to the thread work function, then these arguments need to be put into a structure, and the address of this structure is passed in as an argument to arg.</p>
<p><strong>Example:</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="c1">//线程函数1
</span><span class="c1"></span><span class="kt">void</span> <span class="o">*</span><span class="nf">pthread_func1</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;线程函数1正在运行.....</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">//线程函数2
</span><span class="c1"></span><span class="kt">void</span> <span class="o">*</span><span class="nf">pthread_func2</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;线程函数2正在运行.....</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span><span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
  
  <span class="n">pthread_t</span> <span class="n">thread_id1</span><span class="p">;</span>
  <span class="n">pthread_t</span> <span class="n">thread_id2</span><span class="p">;</span>
   <span class="cm">/*1. 创建线程1*/</span>
    <span class="k">if</span><span class="p">(</span><span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">thread_id1</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="n">pthread_func1</span><span class="p">,</span><span class="nb">NULL</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;线程1创建失败!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="cm">/*2. 创建线程2*/</span>
    <span class="k">if</span><span class="p">(</span><span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">thread_id2</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="n">pthread_func2</span><span class="p">,</span><span class="nb">NULL</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;线程2创建失败!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="cm">/*3. 等待线程结束,释放线程的资源*/</span>
  <span class="n">pthread_join</span><span class="p">(</span><span class="n">thread_id1</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>
  <span class="n">pthread_join</span><span class="p">(</span><span class="n">thread_id2</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//gcc pthread_demo_code.c -lpthread
</span><span class="c1"></span>
</code></pre></td></tr></table>
</div>
</div><h3 id="22-exiting-a-thread">2.2 Exiting a thread</h3>
<p>A thread terminates execution by calling the pthread_exit function in the same way that a process calls the exit function at the end. This function terminates the thread that called it and returns a pointer to an object.</p>
<p>This function terminates the thread that called it and returns a pointer to an object, the return value of which can be obtained from the second argument of the pthread_join function.</p>
<p><strong>Prototype function</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">void</span> <span class="nf">pthread_exit</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">retval</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>Parameter resolution</strong> The address of the thread to return to. Note: The thread stack must be freed at the end of the thread, that is, the thread function must call pthread_exit() to end it, otherwise it is not freed until the main process function exits.</p>
<h3 id="23-waiting-for-a-thread-to-finish">2.3 Waiting for a thread to finish</h3>
<p>The pthread_join() function waits in a blocking fashion for the thread specified by thread to finish. When the function returns, the resources of the thread being waited for are retrieved. If the thread has already finished, then the function returns immediately. The thread specified by thread must have the joinable property. <strong>Prototype function</strong>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">pthread_join</span><span class="p">(</span><span class="n">pthread_t</span> <span class="kr">thread</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">retval</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>Parameters</strong> First parameter: thread identifier, i.e. thread ID, which identifies a unique thread. Last parameter: user-defined pointer to store the address of the thread being waited for. <strong>Return value</strong> 0 means success. For failure, an error number is returned. Example of receiving a thread return value:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="c1">//退出线程
</span><span class="c1"></span><span class="n">pthread_exit</span> <span class="p">(</span><span class="s">&#34;线程已正常退出&#34;</span><span class="p">);</span>
<span class="c1">//接收线程的返回值
</span><span class="c1"></span><span class="kt">void</span> <span class="o">*</span><span class="n">pth_join_ret1</span><span class="p">;</span>
<span class="n">pthread_join</span><span class="p">(</span> <span class="n">thread1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pth_join_ret1</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="24-thread-separation-property">2.4 Thread separation property</h3>
<p>The default state for creating a thread is joinable (join property). If a thread finishes running without calling pthread_join, its state is similar to that of a Zombie Process in a process, i.e. there are still some resources that have not been recovered (exit status code), so the person creating the thread should pthread_join to wait for the thread to finish running and get the exit code of the thread to recover its resources (similar to wait,waitpid of a process). But after calling the pthread_join(pthread_id) function, if the thread does not finish running, the caller will be blocked, which in some cases we don&rsquo;t want.</p>
<p>The pthread_detach function sets the state of the thread to detached, which automatically releases all resources when the thread finishes running. <strong>Prototype function</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">pthread_detach</span><span class="p">(</span><span class="n">pthread_t</span> <span class="kr">thread</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>Parameters</strong> Thread identifier <strong>Return value</strong> 0 means success. Error returns an error code. EINVAL thread is not a joinable thread. esrch has no thread ID to be found.</p>
<h3 id="25-getting-the-identifier-of-the-current-thread">2.5 Getting the identifier of the current thread</h3>
<p>The pthread_self function gets the ID of the thread itself. <strong>Prototype function</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="n">pthread_t</span> <span class="nf">pthread_self</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>return value</strong> The identifier of the current thread. pthread_t is of type unsigned long int, so use the %lu method when printing, otherwise there will be problems displaying the results.</p>
<h3 id="26-automatic-thread-resource-cleanup">2.6 Automatic thread resource cleanup</h3>
<p>A thread can schedule functions to be called when it exits. Such functions are called thread cleanup handlers. This is used to do some post-exit resource cleanup when the program exits abnormally. A <code>pthread_cleanup_push()/pthread_cleanup_pop()</code> function is provided in the POSIX thread API to automatically release resources. Termination actions (including calls to <code>pthread_exit()</code> and exception termination) in the segment between the point of call of <code>pthread_cleanup_push()</code> and <code>pthread_cleanup_pop()</code> will execute the cleanup function specified by <code>pthread_cleanup_push()</code>.</p>
<p>Note: The <code>pthread_cleanup_push</code> function needs to be called in pairs with the <code>pthread_cleanup_pop</code> function. <strong>function prototype</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">pthread_cleanup_push</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">routine</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span> <span class="c1">//注册清理函数
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">pthread_cleanup_pop</span><span class="p">(</span><span class="kt">int</span> <span class="n">execute</span><span class="p">);</span> <span class="c1">//释放清理函数
</span></code></pre></td></tr></table>
</div>
</div><p><strong>parameters</strong> <code>void (*routine)(void *)</code> : The function entry for the handler. <code>void *arg</code> : The formal parameter passed to the handler. int execute : The status value of execute. 0 indicates that the cleanup function is not called. 1 indicates that the cleanup function is called.</p>
<p><strong>Conditions that cause the cleanup function to be called:</strong></p>
<ol>
<li>pthread_exit() function is called</li>
<li>pthread_cleanup_pop has a formal reference of 1. Note: return does not result in a cleanup function call.</li>
</ol>
<h3 id="27-auto-cleanup-thread-sample-code">2.7 Auto-cleanup thread sample code</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="c1">//线程清理函数
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">routine_func</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">printf</span><span class="p">(</span><span class="s">&#34;线程资源清理成功</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="p">}</span>
  
<span class="c1">//线程工作函数
</span><span class="c1"></span><span class="kt">void</span> <span class="o">*</span><span class="nf">start_routine</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">pthread_cleanup_push</span><span class="p">(</span><span class="n">routine_func</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>

  <span class="c1">//终止线程
</span><span class="c1"></span>  <span class="c1">// pthread_exit(NULL);
</span><span class="c1"></span>   
   <span class="n">pthread_cleanup_pop</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">//1会导致清理函数被调用。0不会调用。
</span><span class="c1"></span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span><span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
   <span class="n">pthread_t</span> <span class="n">thread_id</span><span class="p">;</span>  <span class="c1">//存放线程的标识符
</span><span class="c1"></span>  
  <span class="cm">/*1. 创建线程*/</span>
  <span class="k">if</span><span class="p">(</span><span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">thread_id</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="n">start_routine</span><span class="p">,</span><span class="nb">NULL</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span>
     <span class="n">printf</span><span class="p">(</span><span class="s">&#34;线程创建失败!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>    
  <span class="p">}</span> 
  <span class="cm">/*2.设置线程的分离属性*/</span>
  <span class="k">if</span><span class="p">(</span><span class="n">pthread_detach</span><span class="p">(</span><span class="n">thread_id</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span>
     <span class="n">printf</span><span class="p">(</span><span class="s">&#34;分离属性设置失败!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">){}</span>  
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="28-thread-cancellation-functions">2.8 Thread cancellation functions</h3>
<p>The pthread_cancel function is a thread cancellation function, which is used to cancel other threads in the same process.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="err">头文件</span><span class="o">:</span> <span class="err">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">pthread</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span>
<span class="err">函数原型：</span><span class="n">pthread_cancel</span><span class="p">(</span><span class="n">pthread_t</span> <span class="n">tid</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div>
    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/linux/">linux</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-02/ipv4-and-ipv6/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Difference between IPv4 and IPv6</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-02/the-state-of-javascript-2021/">
            <span class="next-text nav-default">2021 JavaScript Survey: The Year of Vite, Esbuild, TypeScript Adoption Grows Significantly</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
