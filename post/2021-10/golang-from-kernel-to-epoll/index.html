<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>golang from kernel to epoll - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Basic implementation of linux networking In the TCP/IP network hierarchy model, the entire protocol stack is divided into physical layer, link layer, network layer, transport layer, and application layer. The physical layer corresponds to the grid card and the grid line, and the application layer corresponds to various applications such as Nginx, FTP, etc. Linux implements the link layer, the grid layer, and the transport layer. In the Linux kernel" /><meta name="keywords" content="golang, Kernel, Epoll" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2021-10/golang-from-kernel-to-epoll/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="golang from kernel to epoll" />
<meta property="og:description" content="Basic implementation of linux networking In the TCP/IP network hierarchy model, the entire protocol stack is divided into physical layer, link layer, network layer, transport layer, and application layer. The physical layer corresponds to the grid card and the grid line, and the application layer corresponds to various applications such as Nginx, FTP, etc. Linux implements the link layer, the grid layer, and the transport layer. In the Linux kernel" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2021-10/golang-from-kernel-to-epoll/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-10-17T14:41:33+08:00" />
<meta property="article:modified_time" content="2021-10-17T14:41:33+08:00" />

<meta itemprop="name" content="golang from kernel to epoll">
<meta itemprop="description" content="Basic implementation of linux networking In the TCP/IP network hierarchy model, the entire protocol stack is divided into physical layer, link layer, network layer, transport layer, and application layer. The physical layer corresponds to the grid card and the grid line, and the application layer corresponds to various applications such as Nginx, FTP, etc. Linux implements the link layer, the grid layer, and the transport layer. In the Linux kernel"><meta itemprop="datePublished" content="2021-10-17T14:41:33+08:00" />
<meta itemprop="dateModified" content="2021-10-17T14:41:33+08:00" />
<meta itemprop="wordCount" content="6308">
<meta itemprop="keywords" content="golang," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="golang from kernel to epoll"/>
<meta name="twitter:description" content="Basic implementation of linux networking In the TCP/IP network hierarchy model, the entire protocol stack is divided into physical layer, link layer, network layer, transport layer, and application layer. The physical layer corresponds to the grid card and the grid line, and the application layer corresponds to various applications such as Nginx, FTP, etc. Linux implements the link layer, the grid layer, and the transport layer. In the Linux kernel"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">golang from kernel to epoll</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-10-17 14:41:33 </span>
        <div class="post-category">
            <a href="/categories/skills/"> skills </a>
            <a href="/categories/implementation-details/"> implementation-details </a>
            </div>
          <span class="more-meta"> 6308 words </span>
          <span class="more-meta"> 13 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#basic-implementation-of-linux-networking">Basic implementation of linux networking</a></li>
        <li><a href="#how-to-network-events">How to network events</a></li>
        <li><a href="#epoll">epoll</a></li>
        <li><a href="#poll-function">poll function</a></li>
        <li><a href="#part-of-the-code">Part of the code</a></li>
        <li><a href="#epoll-source-code">epoll source code</a></li>
        <li><a href="#basic-data-structure">Basic data structure</a></li>
        <li><a href="#ep_insert-is-implemented-as-follows">ep_insert is implemented as follows.</a></li>
        <li><a href="#ep_ptable_queue_proc">ep_ptable_queue_proc</a></li>
        <li><a href="#the-epoll_wait-implementation-is-as-follows">The epoll_wait implementation is as follows.</a></li>
        <li><a href="#epoll_wait-calls-ep_poll-ep_poll-is-implemented-as-follows">epoll_wait calls ep_poll. ep_poll is implemented as follows.</a></li>
        <li><a href="#trivia">Trivia</a>
          <ul>
            <li><a href="#hybrid-mode">Hybrid mode</a></li>
            <li><a href="#dma">DMA</a></li>
            <li><a href="#non-blocking-socket-programming-to-handle-eagain-errors">Non-blocking socket programming to handle EAGAIN errors</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="basic-implementation-of-linux-networking">Basic implementation of linux networking</h2>
<p>In the TCP/IP network hierarchy model, the entire protocol stack is divided into physical layer, link layer, network layer, transport layer, and application layer. The physical layer corresponds to the grid card and the grid line, and the application layer corresponds to various applications such as Nginx, FTP, etc. Linux implements the link layer, the grid layer, and the transport layer.</p>
<p>In the Linux kernel implementation, the link layer protocol is implemented by the grid card driver, and the kernel protocol stack implements the network and transport layers. The kernel provides socket access to the higher application layers for user processes. The layered model of the TCP/IP network as we see it using the Linux perspective should look like the following.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/17/4741bd3766684ef78fc9e5edc71cfc7f.png" alt=""></p>
<h2 id="how-to-network-events">How to network events</h2>
<p>When data arrives on the device, a voltage change is triggered on the relevant pin of the CPU to notify the CPU to process the data.</p>
<p>You can also call this a <strong>hard interrupt</strong></p>
<p>But as we know, the CPU runs very fast, but the network reads the data very slowly, which will occupy the CPU for a long time, making the CPU unable to handle other events, such as mouse movement.</p>
<p>So how to solve this problem in linux?</p>
<p>The linux kernel splits the interrupt processing into 2 parts, one is the <strong>hard interrupt</strong> mentioned above, and the other is the <strong>soft interrupt</strong>.</p>
<p>The first part receives the cpu voltage change, generates a hard interrupt, then does only the simplest processing, and then asynchronously hands over to the hardware to receive the information into the buffer. At this time, the cpu can already receive other interrupt information over.</p>
<p>The second part is the soft interrupt part, how does the soft interrupt do it? In fact, it is to change the binary bits of memory, similar to the status field that we usually write business to, such as in network Io, when the buffer has finished receiving data, it will change the current status to complete. For example, when epoll reads a certain io time to finish reading data, it does not directly enter the ready state, but waits for the next loop to traverse to determine the status before stuffing this fd into the ready list (of course, this time is very short, but compared to the cpu, this time is very long).</p>
<p>The second half of the implementation used in kernel versions from 2.4 onwards is soft interrupts, which are handled solely by the ksoftirqd kernel thread. Unlike hard interrupts, which apply a voltage change to the physical CPU pins, soft interrupts notify the soft interrupt handler by giving a binary value to a variable in memory.</p>
<p>This is why epoll (formally introduced) was only known to be used in 2.6; the kernel did not support this approach until 2.4.</p>
<p>The overall data flow diagram is as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/17/1c715d5268fc4eb6a9e3b11303d5abc5.png" alt=""></p>
<p>A data from arrives at the NIC and goes through the following steps before a data reception is completed.</p>
<ul>
<li>The packet enters the physical NIC from an outside network. If the destination address is not that NIC and the NIC does not have promiscuous mode enabled, the packet is discarded by the NIC.</li>
<li>The NIC writes the packet by DMA to the specified memory address, which is allocated and initialized by the NIC driver. Note: Older NICs may not support DMA, though newer NICs generally do.</li>
<li>The NIC notifies the CPU via a hardware interrupt (IRQ) that data is coming</li>
<li>The CPU calls the registered interrupt function according to the interrupt table, and this interrupt function will call the corresponding function in the driver (NIC Driver)</li>
<li>The driver disables the interrupt of the NIC first, indicating that the driver already knows that there is data in the memory, and tells the NIC to write the memory directly next time it receives a packet, and not to notify the CPU again, which can improve efficiency and avoid the CPU being interrupted constantly.</li>
<li>Start soft interrupt. After this step, the hardware interrupt handler function ends and returns. Since the hard interrupt handler cannot be interrupted during its execution, if it takes too long to execute, it will make the CPU unable to respond to other hardware interrupts, so the kernel introduces soft interrupts so that the time-consuming part of the hard interrupt handler function can be moved to the soft interrupt handler function to be handled slowly.</li>
<li>When it receives a soft interrupt, it will call the corresponding soft interrupt processing function. For the soft interrupt thrown by the network card driver module in step 6 above, ksoftirqd will call the net_rx_action function of the network module</li>
<li>net_rx_action calls the poll function in the NIC driver to process the packets one by one</li>
<li>In the pool function, the driver reads the packets written to memory one by one, the format of the packets in memory is only known to the driver</li>
<li>The driver converts the packets in memory to the skb format recognized by the kernel network module and then calls the napi_gro_receive function</li>
<li>napi_gro_receive will process the GRO related content, that is, it will merge the packets that can be merged, so that only one protocol stack call is needed. Then determine if RPS is enabled, if so, enqueue_to_backlog will be called</li>
<li>In the enqueue_to_backlog function, the packet will be put into the input_pkt_queue of the CPU&rsquo;s softnet_data structure, and then return, if the input_pkt_queue is full, the packet will be discarded, the size of the queue can be determined by net.core. The size of the queue can be configured via net.core. netdev_max_backlog</li>
<li>The CPU will then process the network data in its own input_pkt_queue in its own soft interrupt context (call __netif_receive_skb_core)</li>
<li>If RPS is not enabled, napi_gro_receive will call __netif_receive_skb_core directly</li>
<li>See if there is a socket of type AF_PACKET (which is often called raw socket), if so, copy a copy of the data to it. tcpdump captures the packets here.</li>
<li>Call the corresponding function of the protocol stack and give the packet to the stack for processing.</li>
<li>After all the packets in memory have been processed (i.e. the poll function is finished), enable the hard interrupt of the NIC, so that the next time the NIC receives data again it will notify the CPU</li>
</ul>
<h2 id="epoll">epoll</h2>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/17/5c4b8af38ca84f64a5be16ee296269de.png" alt=""></p>
<h2 id="poll-function">poll function</h2>
<p>The poll function here is a callback function that is registered and handled in a soft interrupt. For example, the epoll program will register an &ldquo;ep_poll_callback&rdquo;</p>
<p>Take go epoll as an example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">go: accept –&gt; pollDesc.Init -&gt; poll_runtime_pollOpen –&gt; runtime.netpollopen(epoll_create) -&gt; epollctl(EPOLL_CTL_ADD)
</code></pre></td></tr></table>
</div>
</div><p>go: netpollblock(gopark),let out cpu-&gt;scheduled back, netpoll(0) writes concurrently to ready state -&gt; other operations &hellip;&hellip;</p>
<p>epoll thread: epoll_create(ep_ptable_queue_proc, register soft interrupt to ksoftirqd, register method ep_poll_callback to)-&gt;epoll_add-&gt;epoll_wait(ep_poll let out cpu)</p>
<p>core: NIC receives data -&gt; dma+hard interrupt -&gt; soft interrupt -&gt; system dispatch to ksoftirqd, handle ep_poll_callback (note here that new connections come into the program, not by callback,but by accept) -&gt; get the previously registered fd handle -&gt; copy NIC data to the handle -&gt; Operate on the fd according to the event type (ready list)</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/17/f195e2b6970c46c5a0a8bed10341e910.png" alt=""></p>
<h2 id="part-of-the-code">Part of the code</h2>
<p>go: accept</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// accept阻塞，等待系统事件（等待有客户端进来）
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">fd</span> <span class="o">*</span><span class="nx">FD</span><span class="p">)</span> <span class="nf">Accept</span><span class="p">()</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">Sockaddr</span><span class="p">,</span> <span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">fd</span><span class="p">.</span><span class="nf">readLock</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">defer</span> <span class="nx">fd</span><span class="p">.</span><span class="nf">readUnlock</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">fd</span><span class="p">.</span><span class="nx">pd</span><span class="p">.</span><span class="nf">prepareRead</span><span class="p">(</span><span class="nx">fd</span><span class="p">.</span><span class="nx">isFile</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">s</span><span class="p">,</span> <span class="nx">rsa</span><span class="p">,</span> <span class="nx">errcall</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">accept</span><span class="p">(</span><span class="nx">fd</span><span class="p">.</span><span class="nx">Sysfd</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">rsa</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">err</span>
		<span class="p">}</span>
		<span class="k">switch</span> <span class="nx">err</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">EAGAIN</span><span class="p">:</span>
			<span class="k">if</span> <span class="nx">fd</span><span class="p">.</span><span class="nx">pd</span><span class="p">.</span><span class="nf">pollable</span><span class="p">()</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">fd</span><span class="p">.</span><span class="nx">pd</span><span class="p">.</span><span class="nf">waitRead</span><span class="p">(</span><span class="nx">fd</span><span class="p">.</span><span class="nx">isFile</span><span class="p">);</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="k">continue</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="k">case</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">ECONNABORTED</span><span class="p">:</span>
			<span class="c1">// This means that a socket on the listen
</span><span class="c1"></span>			<span class="c1">// queue was closed before we Accept()ed it;
</span><span class="c1"></span>			<span class="c1">// it&#39;s a silly error, so try again.
</span><span class="c1"></span>			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errcall</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="c1">//accept创建netpoll
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">fd</span> <span class="o">*</span><span class="nx">netFD</span><span class="p">)</span> <span class="nf">accept</span><span class="p">()</span> <span class="p">(</span><span class="nx">netfd</span> <span class="o">*</span><span class="nx">netFD</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">d</span><span class="p">,</span> <span class="nx">rsa</span><span class="p">,</span> <span class="nx">errcall</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">fd</span><span class="p">.</span><span class="nx">pfd</span><span class="p">.</span><span class="nf">Accept</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">errcall</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
			<span class="nx">err</span> <span class="p">=</span> <span class="nf">wrapSyscallError</span><span class="p">(</span><span class="nx">errcall</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">netfd</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">newFD</span><span class="p">(</span><span class="nx">d</span><span class="p">,</span> <span class="nx">fd</span><span class="p">.</span><span class="nx">family</span><span class="p">,</span> <span class="nx">fd</span><span class="p">.</span><span class="nx">sotype</span><span class="p">,</span> <span class="nx">fd</span><span class="p">.</span><span class="nx">net</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">poll</span><span class="p">.</span><span class="nf">CloseFunc</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">netfd</span><span class="p">.</span><span class="nf">init</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>  <span class="c1">//open 创建 ctl_add
</span><span class="c1"></span>		<span class="nx">fd</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="nx">lsa</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">syscall</span><span class="p">.</span><span class="nf">Getsockname</span><span class="p">(</span><span class="nx">netfd</span><span class="p">.</span><span class="nx">pfd</span><span class="p">.</span><span class="nx">Sysfd</span><span class="p">)</span>
	<span class="nx">netfd</span><span class="p">.</span><span class="nf">setAddr</span><span class="p">(</span><span class="nx">netfd</span><span class="p">.</span><span class="nf">addrFunc</span><span class="p">()(</span><span class="nx">lsa</span><span class="p">),</span> <span class="nx">netfd</span><span class="p">.</span><span class="nf">addrFunc</span><span class="p">()(</span><span class="nx">rsa</span><span class="p">))</span>
	<span class="k">return</span> <span class="nx">netfd</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="err">###</span> <span class="c1">//syscall包。 最终调用的是linux的accept
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">accept</span><span class="p">(</span><span class="nx">s</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">rsa</span> <span class="o">*</span><span class="nx">RawSockaddrAny</span><span class="p">,</span> <span class="nx">addrlen</span> <span class="o">*</span><span class="nx">_Socklen</span><span class="p">)</span> <span class="p">(</span><span class="nx">fd</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">r0</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">e1</span> <span class="o">:=</span> <span class="nf">syscall</span><span class="p">(</span><span class="nf">funcPC</span><span class="p">(</span><span class="nx">libc_accept_trampoline</span><span class="p">),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">rsa</span><span class="p">)),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">addrlen</span><span class="p">)))</span>
	<span class="nx">fd</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">r0</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">e1</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">err</span> <span class="p">=</span> <span class="nf">errnoErr</span><span class="p">(</span><span class="nx">e1</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><h2 id="epoll-source-code">epoll source code</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"> <span class="nx">static</span> <span class="kt">int</span> <span class="nx">__init</span> <span class="nf">eventpoll_init</span><span class="p">(</span><span class="nx">void</span><span class="p">)</span>
<span class="p">{</span>
   <span class="nf">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pmutex</span><span class="p">);</span>
   <span class="nf">ep_poll_safewake_init</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">psw</span><span class="p">);</span>
   <span class="nx">epi_cache</span> <span class="p">=</span> <span class="nf">kmem_cache_create</span><span class="p">(</span><span class="s">&#34;eventpoll_epi&#34;</span><span class="p">,</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kd">struct</span> <span class="nx">epitem</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">SLAB_HWCACHE_ALIGN</span><span class="p">|</span><span class="nx">EPI_SLAB_DEBUG</span><span class="p">|</span><span class="nx">SLAB_PANIC</span><span class="p">,</span> <span class="nx">NULL</span><span class="p">);</span>
   <span class="nx">pwq_cache</span> <span class="p">=</span> <span class="nf">kmem_cache_create</span><span class="p">(</span><span class="s">&#34;eventpoll_pwq&#34;</span><span class="p">,</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kd">struct</span> <span class="nx">eppoll_entry</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">EPI_SLAB_DEBUG</span><span class="p">|</span><span class="nx">SLAB_PANIC</span><span class="p">,</span> <span class="nx">NULL</span><span class="p">);</span>
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="basic-data-structure">Basic data structure</h2>
<p>epoll uses kmem_cache_create (slab allocator) to allocate memory to hold struct epitem and struct eppoll_entry. When an fd is added to the system, an epitem structure is created, which is the basic data structure for the kernel to manage epoll.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">struct</span> <span class="nx">epitem</span> <span class="p">{</span>
	<span class="kd">struct</span> <span class="nx">rb_node</span>  <span class="nx">rbn</span><span class="p">;</span>        <span class="c1">//用于主结构管理的红黑树
</span><span class="c1"></span>	<span class="kd">struct</span> <span class="nx">list_head</span>  <span class="nx">rdllink</span><span class="p">;</span>  <span class="c1">//事件就绪队列
</span><span class="c1"></span>	<span class="kd">struct</span> <span class="nx">epitem</span>  <span class="o">*</span><span class="nx">next</span><span class="p">;</span>       <span class="c1">//用于主结构体中的链表
</span><span class="c1"></span>	<span class="kd">struct</span> <span class="nx">epoll_filefd</span>  <span class="nx">ffd</span><span class="p">;</span>   <span class="c1">//这个结构体对应的被监听的文件描述符信息
</span><span class="c1"></span>	<span class="kt">int</span>  <span class="nx">nwait</span><span class="p">;</span>                 <span class="c1">//poll操作中事件的个数
</span><span class="c1"></span>	<span class="kd">struct</span> <span class="nx">list_head</span>  <span class="nx">pwqlist</span><span class="p">;</span>  <span class="c1">//双向链表，保存着被监视文件的等待队列，功能类似于select/poll中的poll_table
</span><span class="c1"></span>	<span class="kd">struct</span> <span class="nx">eventpoll</span>  <span class="o">*</span><span class="nx">ep</span><span class="p">;</span>      <span class="c1">//该项属于哪个主结构体（多个epitm从属于一个eventpoll）
</span><span class="c1"></span>	<span class="kd">struct</span> <span class="nx">list_head</span>  <span class="nx">fllink</span><span class="p">;</span>   <span class="c1">//双向链表，用来链接被监视的文件描述符对应的struct file。因为file里有f_ep_link,用来保存所有监视这个文件的epoll节点
</span><span class="c1"></span>	<span class="kd">struct</span> <span class="nx">epoll_event</span>  <span class="nx">event</span><span class="p">;</span>  <span class="c1">//注册的感兴趣的事件,也就是用户空间的epoll_event
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>And the main data structure corresponding to each epoll fd (epfd) is</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">struct</span> <span class="nx">eventpoll</span> <span class="p">{</span>
	<span class="nx">spin_lock_t</span>       <span class="nx">lock</span><span class="p">;</span>        <span class="c1">//对本数据结构的访问
</span><span class="c1"></span>	<span class="kd">struct</span> <span class="nx">mutex</span>      <span class="nx">mtx</span><span class="p">;</span>         <span class="c1">//防止使用时被删除
</span><span class="c1"></span>	<span class="nx">wait_queue_head_t</span>     <span class="nx">wq</span><span class="p">;</span>      <span class="c1">//sys_epoll_wait() 使用的等待队列
</span><span class="c1"></span>	<span class="nx">wait_queue_head_t</span>   <span class="nx">poll_wait</span><span class="p">;</span>       <span class="c1">//file-&gt;poll()使用的等待队列
</span><span class="c1"></span>	<span class="kd">struct</span> <span class="nx">list_head</span>    <span class="nx">rdllist</span><span class="p">;</span>        <span class="c1">//事件满足条件的链表
</span><span class="c1"></span>	<span class="kd">struct</span> <span class="nx">rb_root</span>      <span class="nx">rbr</span><span class="p">;</span>            <span class="c1">//用于管理所有fd的红黑树（树根）
</span><span class="c1"></span>	<span class="kd">struct</span> <span class="nx">epitem</span>      <span class="o">*</span><span class="nx">ovflist</span><span class="p">;</span>       <span class="c1">//将事件到达的fd进行链接起来发送至用户空间
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>struct eventpoll is created at epoll_create.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">long</span> <span class="nf">sys_epoll_create</span><span class="p">(</span><span class="kt">int</span> <span class="nx">size</span><span class="p">)</span> <span class="p">{</span>

    <span class="kd">struct</span> <span class="nx">eventpoll</span> <span class="o">*</span><span class="nx">ep</span><span class="p">;</span>

   <span class="c1">// ...
</span><span class="c1"></span>
    <span class="nf">ep_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ep</span><span class="p">);</span> <span class="c1">//为ep分配内存并进行初始化
</span><span class="c1"></span>
<span class="cm">/* 调用anon_inode_getfd 新建一个file instance，
</span><span class="cm">
</span><span class="cm">也就是epoll可以看成一个文件（匿名文件）。
</span><span class="cm">
</span><span class="cm">因此我们可以看到epoll_create会返回一个fd。
</span><span class="cm">
</span><span class="cm">           epoll所管理的所有的fd都是放在一个大的结构eventpoll(红黑树)中，
</span><span class="cm">
</span><span class="cm">将主结构体struct eventpoll *ep放入file-&gt;private项中进行保存（sys_epoll_ctl会取用）*/</span>

 <span class="nx">fd</span> <span class="p">=</span> <span class="nf">anon_inode_getfd</span><span class="p">(</span><span class="s">&#34;[eventpoll]&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">eventpoll_fops</span><span class="p">,</span> <span class="nx">ep</span><span class="p">,</span> <span class="nx">O_RDWR</span> <span class="p">|</span> <span class="p">(</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">O_CLOEXEC</span><span class="p">));</span>
     <span class="k">return</span> <span class="nx">fd</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>where ep_alloc(struct eventpoll **pep) allocates memory for pep and initializes it. Where the above registered operation eventpoll_fops is defined as follows: <code>static const struct file_operations eventpoll_fops = { .release= ep_eventpoll_release, .poll = ep_eventpoll_ poll, };</code> In this way, a red-black tree is maintained in the kernel with the following approximate structure: clip_image002 Then comes the epoll_ctl function (omitting code such as error checking).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">asmlinkage</span> <span class="nx">long</span> <span class="nf">sys_epoll_ctl</span><span class="p">(</span><span class="kt">int</span> <span class="nx">epfd</span><span class="p">,</span><span class="kt">int</span> <span class="nx">op</span><span class="p">,</span><span class="kt">int</span> <span class="nx">fd</span><span class="p">,</span><span class="kd">struct</span> <span class="nx">epoll_event</span> <span class="nx">__user</span> <span class="o">*</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="kt">error</span><span class="p">;</span>
    <span class="kd">struct</span> <span class="nx">file</span> <span class="o">*</span><span class="nx">file</span><span class="p">,</span><span class="o">*</span><span class="nx">tfile</span><span class="p">;</span>
    <span class="kd">struct</span> <span class="nx">eventpoll</span> <span class="o">*</span><span class="nx">ep</span><span class="p">;</span>
    <span class="kd">struct</span> <span class="nx">epoll_event</span> <span class="nx">epds</span><span class="p">;</span>
    <span class="kt">error</span> <span class="p">=</span> <span class="o">-</span><span class="nx">FAULT</span><span class="p">;</span>
    <span class="c1">//判断参数的合法性，将 __user *event 复制给 epds。
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="nf">ep_op_has_event</span><span class="p">(</span><span class="nx">op</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nf">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">epds</span><span class="p">,</span><span class="nx">event</span><span class="p">,</span><span class="nf">sizeof</span><span class="p">(</span><span class="kd">struct</span> <span class="nx">epoll_event</span><span class="p">)))</span>
            <span class="k">goto</span> <span class="nx">error_return</span><span class="p">;</span> <span class="c1">//省略跳转到的代码
</span><span class="c1"></span>    <span class="nx">file</span>  <span class="p">=</span> <span class="nf">fget</span> <span class="p">(</span><span class="nx">epfd</span><span class="p">);</span> <span class="c1">// epoll fd 对应的文件对象
</span><span class="c1"></span>    <span class="nx">tfile</span> <span class="p">=</span> <span class="nf">fget</span><span class="p">(</span><span class="nx">fd</span><span class="p">);</span>    <span class="c1">// fd 对应的文件对象
</span><span class="c1"></span>    <span class="c1">//在create时存入进去的（anon_inode_getfd），现在取用。
</span><span class="c1"></span>    <span class="nx">ep</span> <span class="p">=</span> <span class="nx">file</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">private</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">data</span><span class="p">;</span>
    <span class="nf">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ep</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">mtx</span><span class="p">);</span>
    <span class="c1">//防止重复添加（在ep的红黑树中查找是否已经存在这个fd）
</span><span class="c1"></span>    <span class="nx">epi</span> <span class="p">=</span> <span class="nf">epi_find</span><span class="p">(</span><span class="nx">ep</span><span class="p">,</span><span class="nx">tfile</span><span class="p">,</span><span class="nx">fd</span><span class="p">);</span>
    <span class="k">switch</span><span class="p">(</span><span class="nx">op</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">case</span> <span class="nx">EPOLL_CTL_ADD</span><span class="p">:</span>  <span class="c1">//增加监听一个fd
</span><span class="c1"></span>            <span class="k">if</span><span class="p">(!</span><span class="nx">epi</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="nx">epds</span><span class="p">.</span><span class="nx">events</span> <span class="o">|=</span> <span class="nx">EPOLLERR</span> <span class="p">|</span> <span class="nx">POLLHUP</span><span class="p">;</span>     <span class="c1">//默认包含POLLERR和POLLHUP事件
</span><span class="c1"></span>                <span class="kt">error</span> <span class="p">=</span> <span class="nf">ep_insert</span><span class="p">(</span><span class="nx">ep</span><span class="p">,</span><span class="o">&amp;</span><span class="nx">epds</span><span class="p">,</span><span class="nx">tfile</span><span class="p">,</span><span class="nx">fd</span><span class="p">);</span>  <span class="c1">//在ep的红黑树中插入这个fd对应的epitm结构体。
</span><span class="c1"></span>            <span class="p">}</span> <span class="k">else</span>  <span class="c1">//重复添加（在ep的红黑树中查找已经存在这个fd）。
</span><span class="c1"></span>                <span class="kt">error</span> <span class="p">=</span> <span class="o">-</span><span class="nx">EEXIST</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="o">...</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kt">error</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="ep_insert-is-implemented-as-follows">ep_insert is implemented as follows.</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">static</span> <span class="kt">int</span> <span class="nf">ep_insert</span><span class="p">(</span><span class="k">struct</span> <span class="nc">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">epoll_event</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">file</span> <span class="o">*</span><span class="n">tfile</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">)</span>
<span class="p">{</span>
   <span class="kt">int</span> <span class="n">error</span> <span class="p">,</span><span class="n">revents</span><span class="p">,</span><span class="n">pwake</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="p">;</span>
   <span class="k">struct</span> <span class="nc">epitem</span> <span class="o">*</span><span class="n">epi</span><span class="p">;</span>
   <span class="cm">/*
</span><span class="cm">      struct ep_queue{
</span><span class="cm">         poll_table pt;
</span><span class="cm">         struct epitem *epi;
</span><span class="cm">      }   */</span>
   <span class="k">struct</span> <span class="nc">ep_pqueue</span> <span class="n">epq</span><span class="p">;</span>
   <span class="c1">//分配一个epitem结构体来保存每个加入的fd
</span><span class="c1"></span>   <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">epi</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">epi_cache</span><span class="p">,</span><span class="n">GFP_KERNEL</span><span class="p">)))</span>
      <span class="k">goto</span> <span class="n">error_return</span><span class="p">;</span>
   <span class="c1">//初始化该结构体
</span><span class="c1"></span>   <span class="n">ep_rb_initnode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rbn</span><span class="p">);</span>
   <span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">);</span>
   <span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">fllink</span><span class="p">);</span>
   <span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">pwqlist</span><span class="p">);</span>
   <span class="n">epi</span><span class="o">-&gt;</span><span class="n">ep</span> <span class="o">=</span> <span class="n">ep</span><span class="p">;</span>
   <span class="n">ep_set_ffd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">ffd</span><span class="p">,</span><span class="n">tfile</span><span class="p">,</span><span class="n">fd</span><span class="p">);</span>
   <span class="n">epi</span><span class="o">-&gt;</span><span class="n">event</span> <span class="o">=</span> <span class="o">*</span><span class="n">event</span><span class="p">;</span>
   <span class="n">epi</span><span class="o">-&gt;</span><span class="n">nwait</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="n">epi</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">EP_UNACTIVE_PTR</span><span class="p">;</span>
   <span class="n">epq</span><span class="p">.</span><span class="n">epi</span> <span class="o">=</span> <span class="n">epi</span><span class="p">;</span>
   <span class="c1">//安装poll回调函数
</span><span class="c1"></span>   <span class="n">init_poll_funcptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epq</span><span class="p">.</span><span class="n">pt</span><span class="p">,</span> <span class="n">ep_ptable_queue_proc</span> <span class="p">);</span>
   <span class="cm">/* 调用poll函数来获取当前事件位，其实是利用它来调用注册函数ep_ptable_queue_proc（poll_wait中调用）。
</span><span class="cm">       如果fd是套接字，f_op为socket_file_ops，poll函数是
</span><span class="cm">       sock_poll()。如果是TCP套接字的话，进而会调用
</span><span class="cm">       到tcp_poll()函数。此处调用poll函数查看当前
</span><span class="cm">       文件描述符的状态，存储在revents中。
</span><span class="cm">       在poll的处理函数(tcp_poll())中，会调用sock_poll_wait()，
</span><span class="cm">       在sock_poll_wait()中会调用到epq.pt.qproc指向的函数，
</span><span class="cm">       也就是ep_ptable_queue_proc()。  */</span>
   <span class="n">revents</span> <span class="o">=</span> <span class="n">tfile</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">(</span><span class="n">tfile</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">epq</span><span class="p">.</span><span class="n">pt</span><span class="p">);</span>
   <span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tfile</span><span class="o">-&gt;</span><span class="n">f_ep_lock</span><span class="p">);</span>
   <span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">fllink</span><span class="p">,</span><span class="o">&amp;</span><span class="n">tfile</span><span class="o">-&gt;</span><span class="n">f_ep_lilnks</span><span class="p">);</span>
   <span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tfile</span><span class="o">-&gt;</span><span class="n">f_ep_lock</span><span class="p">);</span>
   <span class="n">ep_rbtree_insert</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span><span class="n">epi</span><span class="p">);</span> <span class="c1">//将该epi插入到ep的红黑树中
</span><span class="c1"></span>   <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
<span class="c1">//  revents &amp; event-&gt;events：刚才fop-&gt;poll的返回值中标识的事件有用户event关心的事件发生。
</span><span class="c1">// !ep_is_linked(&amp;epi-&gt;rdllink)：epi的ready队列中有数据。ep_is_linked用于判断队列是否为空。
</span><span class="c1"></span><span class="cm">/*  如果要监视的文件状态已经就绪并且还没有加入到就绪队列中,则将当前的
</span><span class="cm">    epitem加入到就绪队列中.如果有进程正在等待该文件的状态就绪,则
</span><span class="cm">    唤醒一个等待的进程。  */</span>
<span class="k">if</span><span class="p">((</span><span class="n">revents</span> <span class="o">&amp;</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ep_is_linked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epi</span><span class="o">-&gt;</span><span class="n">rdllink</span><span class="p">,</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">rdllist</span><span class="p">);</span> <span class="c1">//将当前epi插入到ep-&gt;ready队列中。
</span><span class="c1"></span><span class="cm">/* 如果有进程正在等待文件的状态就绪，
</span><span class="cm">也就是调用epoll_wait睡眠的进程正在等待，
</span><span class="cm">则唤醒一个等待进程。
</span><span class="cm">waitqueue_active(q) 等待队列q中有等待的进程返回1，否则返回0。
</span><span class="cm">*/</span>
      <span class="k">if</span><span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">))</span>
         <span class="n">__wake_up_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span><span class="n">TAKS_UNINTERRUPTIBLE</span> <span class="o">|</span> <span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
<span class="cm">/*  如果有进程等待eventpoll文件本身（???）的事件就绪，
</span><span class="cm">           则增加临时变量pwake的值，pwake的值不为0时，
</span><span class="cm">           在释放lock后，会唤醒等待进程。 */</span> 
      <span class="k">if</span><span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">poll_wait</span><span class="p">))</span>
         <span class="n">pwake</span><span class="o">++</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span><span class="n">flags</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">pwake</span><span class="p">)</span>
      <span class="n">ep_poll_safewake</span><span class="p">(</span><span class="o">&amp;</span><span class="n">psw</span><span class="p">,</span><span class="o">&amp;</span><span class="n">ep</span><span class="o">-&gt;</span><span class="n">poll_wait</span><span class="p">);</span><span class="c1">//唤醒等待eventpoll文件状态就绪的进程
</span><span class="c1"></span>   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">init_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc);
revents = tfile-&gt;f_op-&gt;poll(tfile, &amp;epq.pt);
</code></pre></td></tr></table>
</div>
</div><p>These two functions register ep_ptable_queue_proc to qproc in epq.pt. typedef struct poll_table_struct { poll_queue_proc qproc; unsigned long key; }poll_table; Execute f_op- &gt;poll(tfile, &amp;epq.pt), the XXX_poll(tfile, &amp;epq.pt) function executes poll_wait(), and poll_wait() calls the epq.pt.qproc function, i.e., ep_ptable_queue_proc. ep_ptable_queue_ proc function is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="cm">/*  在文件操作中的poll函数中调用，将epoll的回调函数加入到目标文件的唤醒队列中。
</span><span class="cm">    如果监视的文件是套接字，参数whead则是sock结构的sk_sleep成员的地址。  */</span>
<span class="nx">static</span> <span class="nx">void</span> <span class="nf">ep_ptable_queue_proc</span><span class="p">(</span><span class="kd">struct</span> <span class="nx">file</span> <span class="o">*</span><span class="nx">file</span><span class="p">,</span> <span class="nx">wait_queue_head_t</span> <span class="o">*</span><span class="nx">whead</span><span class="p">,</span> <span class="nx">poll_table</span> <span class="o">*</span><span class="nx">pt</span><span class="p">)</span> <span class="p">{</span>
<span class="cm">/* struct ep_queue{
</span><span class="cm">         poll_table pt;
</span><span class="cm">         struct epitem *epi;
</span><span class="cm">      } */</span>
    <span class="kd">struct</span> <span class="nx">epitem</span> <span class="o">*</span><span class="nx">epi</span> <span class="p">=</span> <span class="nf">ep_item_from_epqueue</span><span class="p">(</span><span class="nx">pt</span><span class="p">);</span> <span class="c1">//pt获取struct ep_queue的epi字段。
</span><span class="c1"></span>    <span class="kd">struct</span> <span class="nx">eppoll_entry</span> <span class="o">*</span><span class="nx">pwq</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">epi</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">nwait</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">pwq</span> <span class="p">=</span> <span class="nf">kmem_cache_alloc</span><span class="p">(</span><span class="nx">pwq_cache</span><span class="p">,</span> <span class="nx">GFP_KERNEL</span><span class="p">)))</span> <span class="p">{</span>
        <span class="nf">init_waitqueue_func_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pwq</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">wait</span><span class="p">,</span> <span class="nx">ep_poll_callback</span><span class="p">);</span>
        <span class="nx">pwq</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">whead</span> <span class="p">=</span> <span class="nx">whead</span><span class="p">;</span>
        <span class="nx">pwq</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">base</span> <span class="p">=</span> <span class="nx">epi</span><span class="p">;</span>
        <span class="nf">add_wait_queue</span><span class="p">(</span><span class="nx">whead</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">pwq</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">wait</span><span class="p">);</span>
        <span class="nf">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">pwq</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">llink</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">epi</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">pwqlist</span><span class="p">);</span>
        <span class="nx">epi</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">nwait</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="cm">/* We have to signal that an error occurred */</span>
        <span class="cm">/*
</span><span class="cm">         * 如果分配内存失败，则将nwait置为-1，表示
</span><span class="cm">         * 发生错误，即内存分配失败，或者已发生错误
</span><span class="cm">         */</span>
        <span class="nx">epi</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">nwait</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="ep_ptable_queue_proc">ep_ptable_queue_proc</h2>
<p>where struct eppoll_entry is defined as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">struct</span> <span class="nx">eppoll_entry</span> <span class="p">{</span>
   <span class="kd">struct</span> <span class="nx">list_head</span> <span class="nx">llink</span><span class="p">;</span>
   <span class="kd">struct</span> <span class="nx">epitem</span> <span class="o">*</span><span class="nx">base</span><span class="p">;</span>
   <span class="nx">wait_queue_t</span> <span class="nx">wait</span><span class="p">;</span>
   <span class="nx">wait_queue_head_t</span> <span class="o">*</span><span class="nx">whead</span><span class="p">;</span>
<span class="p">};</span>
<span class="nx">ep_ptable_queue_proc</span> <span class="nx">函数完成</span> <span class="nx">epitem</span> <span class="nx">加入到特定文件的wait队列任务</span><span class="err">。</span>
<span class="nx">ep_ptable_queue_proc有三个参数</span><span class="err">：</span>
<span class="kd">struct</span> <span class="nx">file</span> <span class="o">*</span><span class="nx">file</span><span class="p">;</span>              <span class="nx">该fd对应的文件对象</span>
<span class="nx">wait_queue_head_t</span> <span class="o">*</span><span class="nx">whead</span><span class="p">;</span>      <span class="nx">该fd对应的设备等待队列</span><span class="err">（</span><span class="nx">同select中的mydev</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">wait_address</span><span class="err">）</span>
<span class="nx">poll_table</span> <span class="o">*</span><span class="nx">pt</span><span class="p">;</span>                 <span class="nx">f_op</span><span class="o">-</span><span class="p">&gt;</span><span class="nf">poll</span><span class="p">(</span><span class="nx">tfile</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">epq</span><span class="p">.</span><span class="nx">pt</span><span class="p">)</span><span class="nx">中的epq</span><span class="p">.</span><span class="nx">pt</span>
</code></pre></td></tr></table>
</div>
</div><p>In the ep_ptable_queue_proc function, another very important data structure, eppoll_entry, is introduced. eppoll_entry mainly completes the association between the epitem and the callback (ep_poll_callback) function when the epitem event occurs. First, the whead of eppoll_entry is pointed to the device wait queue of fd (same as wait_address in select), then the base variable of eppoll_entry is initialized to point to epitem, and finally the epoll_entry is mounted to the device wait queue of fd by add_wait_queue. queue. After this action, the epoll_entry has been mounted to the device wait queue of fd.</p>
<p>Since the ep_ptable_queue_proc function sets the ep_poll_callback callback function for the wait queue. So when the device hardware data arrives, the wakeup function ep_poll_callback will be called when the hardware interrupt handling function will wake up the process waiting on that wait queue</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">static</span> <span class="kt">int</span> <span class="nf">ep_poll_callback</span><span class="p">(</span><span class="nx">wait_queue_t</span> <span class="o">*</span><span class="nx">wait</span><span class="p">,</span> <span class="nx">unsigned</span> <span class="nx">mode</span><span class="p">,</span> <span class="kt">int</span> <span class="nx">sync</span><span class="p">,</span> <span class="nx">void</span> <span class="o">*</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
   <span class="kt">int</span> <span class="nx">pwake</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="nx">unsigned</span> <span class="nx">long</span> <span class="nx">flags</span><span class="p">;</span>
   <span class="kd">struct</span> <span class="nx">epitem</span> <span class="o">*</span><span class="nx">epi</span> <span class="p">=</span> <span class="nf">ep_item_from_wait</span><span class="p">(</span><span class="nx">wait</span><span class="p">);</span>
   <span class="kd">struct</span> <span class="nx">eventpoll</span> <span class="o">*</span><span class="nx">ep</span> <span class="p">=</span> <span class="nx">epi</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">ep</span><span class="p">;</span>
   <span class="nf">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ep</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">lock</span><span class="p">,</span> <span class="nx">flags</span><span class="p">);</span>
   <span class="c1">//判断注册的感兴趣事件
</span><span class="c1">//#define EP_PRIVATE_BITS  (EPOLLONESHOT | EPOLLET)
</span><span class="c1">//有非EPOLLONESHONT或EPOLLET事件
</span><span class="c1"></span>   <span class="k">if</span> <span class="p">(!(</span><span class="nx">epi</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">event</span><span class="p">.</span><span class="nx">events</span> <span class="o">&amp;</span> <span class="err">~</span><span class="nx">EP_PRIVATE_BITS</span><span class="p">))</span>
      <span class="k">goto</span> <span class="nx">out_unlock</span><span class="p">;</span>
   <span class="k">if</span> <span class="p">(</span><span class="nf">unlikely</span><span class="p">(</span><span class="nx">ep</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">ovflist</span> <span class="o">!=</span> <span class="nx">EP_UNACTIVE_PTR</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">epi</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">next</span> <span class="o">==</span> <span class="nx">EP_UNACTIVE_PTR</span><span class="p">)</span> <span class="p">{</span>
         <span class="nx">epi</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">next</span> <span class="p">=</span> <span class="nx">ep</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">ovflist</span><span class="p">;</span>
         <span class="nx">ep</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">ovflist</span> <span class="p">=</span> <span class="nx">epi</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">goto</span> <span class="nx">out_unlock</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="k">if</span> <span class="p">(</span><span class="nf">ep_is_linked</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">epi</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">rdllink</span><span class="p">))</span>
      <span class="k">goto</span> <span class="nx">is_linked</span><span class="p">;</span>
    <span class="c1">//***关键***，将该fd加入到epoll监听的就绪链表中
</span><span class="c1"></span>   <span class="nf">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">epi</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">rdllink</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">ep</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">rdllist</span><span class="p">);</span>
   <span class="c1">//唤醒调用epoll_wait()函数时睡眠的进程。用户层epoll_wait(...) 超时前返回。
</span><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="nf">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ep</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">wq</span><span class="p">))</span>
      <span class="nf">__wake_up_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ep</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">wq</span><span class="p">,</span> <span class="nx">TASK_UNINTERRUPTIBLE</span> <span class="p">|</span> <span class="nx">TASK_INTERRUPTIBLE</span><span class="p">);</span>
   <span class="k">if</span> <span class="p">(</span><span class="nf">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ep</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">poll_wait</span><span class="p">))</span>
      <span class="nx">pwake</span><span class="o">++</span><span class="p">;</span>
   <span class="nx">out_unlock</span><span class="p">:</span> <span class="nf">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ep</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">lock</span><span class="p">,</span> <span class="nx">flags</span><span class="p">);</span>
   <span class="k">if</span> <span class="p">(</span><span class="nx">pwake</span><span class="p">)</span>
      <span class="nf">ep_poll_safewake</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">psw</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">ep</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">poll_wait</span><span class="p">);</span>
   <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>So the main function of ep_poll_callback function is to add the epitem instance corresponding to the file to the ready queue when the wait event of the monitored file is ready, and when the user calls epoll_wait(), the kernel will report the event in the ready queue to the user.</p>
<h2 id="the-epoll_wait-implementation-is-as-follows">The epoll_wait implementation is as follows.</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nf">SYSCALL_DEFINE4</span><span class="p">(</span><span class="nx">epoll_wait</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">epfd</span><span class="p">,</span> <span class="kd">struct</span> <span class="nx">epoll_event</span> <span class="nx">__user</span> <span class="o">*</span><span class="p">,</span> <span class="nx">events</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">maxevents</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">timeout</span><span class="p">)</span>  <span class="p">{</span>
   <span class="kt">int</span> <span class="kt">error</span><span class="p">;</span>
   <span class="kd">struct</span> <span class="nx">file</span> <span class="o">*</span><span class="nx">file</span><span class="p">;</span>
   <span class="kd">struct</span> <span class="nx">eventpoll</span> <span class="o">*</span><span class="nx">ep</span><span class="p">;</span>
    <span class="cm">/* 检查maxevents参数。 */</span>
   <span class="k">if</span> <span class="p">(</span><span class="nx">maxevents</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">maxevents</span> <span class="p">&gt;</span> <span class="nx">EP_MAX_EVENTS</span><span class="p">)</span>
      <span class="k">return</span> <span class="o">-</span><span class="nx">EINVAL</span><span class="p">;</span>
    <span class="cm">/* 检查用户空间传入的events指向的内存是否可写。参见__range_not_ok()。 */</span>
   <span class="k">if</span> <span class="p">(!</span><span class="nf">access_ok</span><span class="p">(</span><span class="nx">VERIFY_WRITE</span><span class="p">,</span> <span class="nx">events</span><span class="p">,</span> <span class="nx">maxevents</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kd">struct</span> <span class="nx">epoll_event</span><span class="p">)))</span> <span class="p">{</span>
      <span class="kt">error</span> <span class="p">=</span> <span class="o">-</span><span class="nx">EFAULT</span><span class="p">;</span>
      <span class="k">goto</span> <span class="nx">error_return</span><span class="p">;</span>
   <span class="p">}</span>
    <span class="cm">/* 获取epfd对应的eventpoll文件的file实例，file结构是在epoll_create中创建。 */</span>
   <span class="kt">error</span> <span class="p">=</span> <span class="o">-</span><span class="nx">EBADF</span><span class="p">;</span>
   <span class="nx">file</span> <span class="p">=</span> <span class="nf">fget</span><span class="p">(</span><span class="nx">epfd</span><span class="p">);</span>
   <span class="k">if</span> <span class="p">(!</span><span class="nx">file</span><span class="p">)</span>
      <span class="k">goto</span> <span class="nx">error_return</span><span class="p">;</span>
    <span class="cm">/* 通过检查epfd对应的文件操作是不是eventpoll_fops 来判断epfd是否是一个eventpoll文件。如果不是则返回EINVAL错误。 */</span>
   <span class="kt">error</span> <span class="p">=</span> <span class="o">-</span><span class="nx">EINVAL</span><span class="p">;</span>
   <span class="k">if</span> <span class="p">(!</span><span class="nf">is_file_epoll</span><span class="p">(</span><span class="nx">file</span><span class="p">))</span>
      <span class="k">goto</span> <span class="nx">error_fput</span><span class="p">;</span>
    <span class="cm">/* At this point it is safe to assume that the &#34;private_data&#34; contains  */</span>
   <span class="nx">ep</span> <span class="p">=</span> <span class="nx">file</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">private_data</span><span class="p">;</span>
    <span class="cm">/* Time to fish for events ... */</span>
   <span class="kt">error</span> <span class="p">=</span> <span class="nf">ep_poll</span><span class="p">(</span><span class="nx">ep</span><span class="p">,</span> <span class="nx">events</span><span class="p">,</span> <span class="nx">maxevents</span><span class="p">,</span> <span class="nx">timeout</span><span class="p">);</span>
    <span class="nx">error_fput</span><span class="p">:</span>
   <span class="nf">fput</span><span class="p">(</span><span class="nx">file</span><span class="p">);</span>
<span class="nx">error_return</span><span class="p">:</span>
   <span class="k">return</span> <span class="kt">error</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="epoll_wait-calls-ep_poll-ep_poll-is-implemented-as-follows">epoll_wait calls ep_poll. ep_poll is implemented as follows.</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"> <span class="nx">static</span> <span class="kt">int</span> <span class="nf">ep_poll</span><span class="p">(</span><span class="kd">struct</span> <span class="nx">eventpoll</span> <span class="o">*</span><span class="nx">ep</span><span class="p">,</span> <span class="kd">struct</span> <span class="nx">epoll_event</span> <span class="nx">__user</span> <span class="o">*</span><span class="nx">events</span><span class="p">,</span> <span class="kt">int</span> <span class="nx">maxevents</span><span class="p">,</span> <span class="nx">long</span> <span class="nx">timeout</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="nx">res</span><span class="p">,</span> <span class="nx">eavail</span><span class="p">;</span>
   <span class="nx">unsigned</span> <span class="nx">long</span> <span class="nx">flags</span><span class="p">;</span>
   <span class="nx">long</span> <span class="nx">jtimeout</span><span class="p">;</span>
   <span class="nx">wait_queue_t</span> <span class="nx">wait</span><span class="p">;</span>
    <span class="cm">/* timeout是以毫秒为单位，这里是要转换为jiffies时间。这里加上999(即1000-1)，是为了向上取整。 */</span>
   <span class="nx">jtimeout</span> <span class="p">=</span> <span class="p">(</span><span class="nx">timeout</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">timeout</span> <span class="o">&gt;=</span> <span class="nx">EP_MAX_MSTIMEO</span><span class="p">)</span> <span class="err">?</span><span class="nx">MAX_SCHEDULE_TIMEOUT</span> <span class="p">:</span> <span class="p">(</span><span class="nx">timeout</span> <span class="o">*</span> <span class="nx">HZ</span> <span class="o">+</span> <span class="mi">999</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>
 <span class="nx">retry</span><span class="p">:</span>
   <span class="nf">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ep</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">lock</span><span class="p">,</span> <span class="nx">flags</span><span class="p">);</span>
    <span class="nx">res</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="k">if</span> <span class="p">(</span><span class="nf">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ep</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">rdllist</span><span class="p">))</span> <span class="p">{</span>
      <span class="cm">/* 没有事件，所以需要睡眠。当有事件到来时，睡眠会被ep_poll_callback函数唤醒。*/</span>
      <span class="nf">init_waitqueue_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">wait</span><span class="p">,</span> <span class="nx">current</span><span class="p">);</span> <span class="c1">//将current进程放在wait这个等待队列中。
</span><span class="c1"></span>      <span class="nx">wait</span><span class="p">.</span><span class="nx">flags</span> <span class="o">|=</span> <span class="nx">WQ_FLAG_EXCLUSIVE</span><span class="p">;</span>
      <span class="cm">/* 将当前进程加入到eventpoll的等待队列中，等待文件状态就绪或直到超时，或被信号中断。 */</span>
      <span class="nf">__add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ep</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">wait</span><span class="p">);</span>
       <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
         <span class="cm">/* 执行ep_poll_callback()唤醒时应当需要将当前进程唤醒，所以当前进程状态应该为“可唤醒”TASK_INTERRUPTIBLE  */</span>
         <span class="nf">set_current_state</span><span class="p">(</span><span class="nx">TASK_INTERRUPTIBLE</span><span class="p">);</span>
         <span class="cm">/* 如果就绪队列不为空，也就是说已经有文件的状态就绪或者超时，则退出循环。*/</span>
         <span class="k">if</span> <span class="p">(!</span><span class="nf">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ep</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">rdllist</span><span class="p">)</span> <span class="o">||</span> <span class="p">!</span><span class="nx">jtimeout</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>
         <span class="cm">/* 如果当前进程接收到信号，则退出循环，返回EINTR错误 */</span>
         <span class="k">if</span> <span class="p">(</span><span class="nf">signal_pending</span><span class="p">(</span><span class="nx">current</span><span class="p">))</span> <span class="p">{</span>
            <span class="nx">res</span> <span class="p">=</span> <span class="o">-</span><span class="nx">EINTR</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
         <span class="p">}</span>
          <span class="nf">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ep</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">lock</span><span class="p">,</span> <span class="nx">flags</span><span class="p">);</span>
         <span class="cm">/* 主动让出处理器，等待ep_poll_callback()将当前进程唤醒或者超时,返回值是剩余的时间。
</span><span class="cm">从这里开始当前进程会进入睡眠状态，直到某些文件的状态就绪或者超时。
</span><span class="cm">当文件状态就绪时，eventpoll的回调函数ep_poll_callback()会唤醒在ep-&gt;wq指向的等待队列中的进程。*/</span>
         <span class="nx">jtimeout</span> <span class="p">=</span> <span class="nf">schedule_timeout</span><span class="p">(</span><span class="nx">jtimeout</span><span class="p">);</span>
         <span class="nf">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ep</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">lock</span><span class="p">,</span> <span class="nx">flags</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="nf">__remove_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ep</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">wait</span><span class="p">);</span>
       <span class="nf">set_current_state</span><span class="p">(</span><span class="nx">TASK_RUNNING</span><span class="p">);</span>
   <span class="p">}</span>
    <span class="cm">/* ep-&gt;ovflist链表存储的向用户传递事件时暂存就绪的文件。
</span><span class="cm">    * 所以不管是就绪队列ep-&gt;rdllist不为空，或者ep-&gt;ovflist不等于
</span><span class="cm">    * EP_UNACTIVE_PTR，都有可能现在已经有文件的状态就绪。
</span><span class="cm">    * ep-&gt;ovflist不等于EP_UNACTIVE_PTR有两种情况，一种是NULL，此时
</span><span class="cm">    * 可能正在向用户传递事件，不一定就有文件状态就绪，
</span><span class="cm">    * 一种情况时不为NULL，此时可以肯定有文件状态就绪，
</span><span class="cm">    * 参见ep_send_events()。
</span><span class="cm">    */</span>
   <span class="nx">eavail</span> <span class="p">=</span> <span class="p">!</span><span class="nf">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ep</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">rdllist</span><span class="p">)</span> <span class="o">||</span> <span class="nx">ep</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">ovflist</span> <span class="o">!=</span> <span class="nx">EP_UNACTIVE_PTR</span><span class="p">;</span>
    <span class="nf">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ep</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">lock</span><span class="p">,</span> <span class="nx">flags</span><span class="p">);</span>
    <span class="cm">/* Try to transfer events to user space. In case we get 0 events and there&#39;s still timeout left over, we go trying again in search of more luck. */</span>
   <span class="cm">/* 如果没有被信号中断，并且有事件就绪，但是没有获取到事件(有可能被其他进程获取到了)，并且没有超时，则跳转到retry标签处，重新等待文件状态就绪。 */</span>
   <span class="k">if</span> <span class="p">(!</span><span class="nx">res</span> <span class="o">&amp;&amp;</span> <span class="nx">eavail</span> <span class="o">&amp;&amp;</span> <span class="p">!(</span><span class="nx">res</span> <span class="p">=</span> <span class="nf">ep_send_events</span><span class="p">(</span><span class="nx">ep</span><span class="p">,</span> <span class="nx">events</span><span class="p">,</span> <span class="nx">maxevents</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="nx">jtimeout</span><span class="p">)</span>
      <span class="k">goto</span> <span class="nx">retry</span><span class="p">;</span>
    <span class="cm">/* 返回获取到的事件的个数或者错误码 */</span>
   <span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="trivia">Trivia</h2>
<h3 id="hybrid-mode">Hybrid mode</h3>
<p>Promiscuous mode (English: promiscuous mode) is a term used in computer networks. It refers to the ability of a machine&rsquo;s network card to receive all data streams passing through it, regardless of their destination address.</p>
<p>Promiscuous mode is commonly used in network analysis</p>
<h3 id="dma">DMA</h3>
<p>DMA, full name Direct Memory Access, means direct memory access.</p>
<p>DMA transfers copy data from one address space to another, providing high-speed data transfers between peripherals and memory or between memory and memory. When the CPU initializes this transfer action, the transfer action itself is implemented and completed by the DMA controller. the DMA transfer method does not require the CPU to directly control the transfer, and there is no interrupt processing method like retaining the field and restoring the field process, through the hardware to open a direct data transfer channel for RAM and IO devices, making the CPU much more efficient.</p>
<p>Main features of DMA:</p>
<ul>
<li>Each channel is directly connected to a dedicated hardware DMA request, and each channel equally supports software triggers, which are configured via software.</li>
<li>Priority between multiple requests on the same DMA module can be programmed by software (there are four levels: very high, high, medium and low), and priority settings are determined by hardware when they are equal (request 0 has priority over request 1, and so on).</li>
<li>Transfer width (byte, half-word, full-word) of the independent data source and destination data areas, simulating the packetization and unpacketization process. Source and destination addresses must be aligned by data transfer width.</li>
<li>Supports circular buffer management.</li>
<li>Each channel has 3 event flags (DMA half-transfer, DMA transfer complete, and DMA transfer error), which logically or become a single interrupt request.</li>
<li>Transfers between memory and memory, peripheral and memory, and memory and peripheral.</li>
<li>Flash, SRAM, SRAM of peripherals, APB1, APB2 and AHB peripherals can be used as sources and targets for accesses.</li>
<li>Programmable number of data transfers: up to 65535 (0xFFFF).</li>
</ul>
<h3 id="non-blocking-socket-programming-to-handle-eagain-errors">Non-blocking socket programming to handle EAGAIN errors</h3>
<p>　In linux, when receiving data from a non-blocking socket, there is often a Resource temporarily unavailable, and the errno code is 11(EAGAIN), what does this mean? 　　This indicates that you have called a blocking operation in non-blocking mode, and this error is returned when the operation is not completed. For non-blocking sockets, EAGAIN is not an error. On VxWorks and Windows, EAGAIN is called EWOULDBLOCK.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/golang/">golang</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2021-10/go-pointer/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Golang - About Pointers and Performance</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2021-10/shopee-clickhouse-hot-and-cold-data/">
            <span class="next-text nav-default">Shopee ClickHouse Cold and hot data separation storage architecture and practice</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
