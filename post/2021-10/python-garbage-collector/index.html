<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Python garbage collection mechanism and implementation - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Python, as an interpreted language, is known for its clean and easy to understand code. We can assign values to names directly, without having to declare types. The Python interpreter determines name types and allocates and frees memory space at runtime, and this automatic memory management greatly reduces the burden on the programmer. For a high-level language like Python, developers can complete their work without concern for its internal garbage" /><meta name="keywords" content="python, gc" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2021-10/python-garbage-collector/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Python garbage collection mechanism and implementation" />
<meta property="og:description" content="Python, as an interpreted language, is known for its clean and easy to understand code. We can assign values to names directly, without having to declare types. The Python interpreter determines name types and allocates and frees memory space at runtime, and this automatic memory management greatly reduces the burden on the programmer. For a high-level language like Python, developers can complete their work without concern for its internal garbage" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2021-10/python-garbage-collector/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-10-23T14:44:43+08:00" />
<meta property="article:modified_time" content="2021-10-23T14:44:43+08:00" />

<meta itemprop="name" content="Python garbage collection mechanism and implementation">
<meta itemprop="description" content="Python, as an interpreted language, is known for its clean and easy to understand code. We can assign values to names directly, without having to declare types. The Python interpreter determines name types and allocates and frees memory space at runtime, and this automatic memory management greatly reduces the burden on the programmer. For a high-level language like Python, developers can complete their work without concern for its internal garbage"><meta itemprop="datePublished" content="2021-10-23T14:44:43+08:00" />
<meta itemprop="dateModified" content="2021-10-23T14:44:43+08:00" />
<meta itemprop="wordCount" content="3775">
<meta itemprop="keywords" content="python," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Python garbage collection mechanism and implementation"/>
<meta name="twitter:description" content="Python, as an interpreted language, is known for its clean and easy to understand code. We can assign values to names directly, without having to declare types. The Python interpreter determines name types and allocates and frees memory space at runtime, and this automatic memory management greatly reduces the burden on the programmer. For a high-level language like Python, developers can complete their work without concern for its internal garbage"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Python garbage collection mechanism and implementation</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-10-23 14:44:43 </span>
        <div class="post-category">
            <a href="/categories/skills/"> skills </a>
            </div>
          <span class="more-meta"> 3775 words </span>
          <span class="more-meta"> 8 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#python-memory-management-mechanisms">Python memory management mechanisms</a>
          <ul>
            <li><a href="#block">Block</a></li>
            <li><a href="#pool">Pool</a></li>
            <li><a href="#arena">Arena</a></li>
          </ul>
        </li>
        <li><a href="#pythons-garbage-collection-mechanism">Python&rsquo;s garbage collection mechanism</a>
          <ul>
            <li><a href="#reference-counting">reference counting</a></li>
            <li><a href="#mark-and-sweep">Mark and Sweep</a></li>
            <li><a href="#generational-garbage-collector">Generational garbage collector</a></li>
          </ul>
        </li>
        <li><a href="#the-gc-module-in-python">The gc module in Python</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>Python, as an interpreted language, is known for its clean and easy to understand code. We can assign values to names directly, without having to declare types. The Python interpreter determines name types and allocates and frees memory space at runtime, and this automatic memory management greatly reduces the burden on the programmer. For a high-level language like Python, developers can complete their work without concern for its internal garbage collection mechanism. Complementary to this, learning Python&rsquo;s internal garbage collection mechanism and understanding its principles will enable developers to write better code and be more Pythonista.</p>
<h2 id="python-memory-management-mechanisms">Python memory management mechanisms</h2>
<p>In Python, memory management involves a private heap (heap) that contains all Python objects and data structures. Management of this private heap is ensured by the internal Python memory manager, which has different components to handle various dynamic storage management aspects such as sharing, partitioning, preallocation, or caching.</p>
<p>At the lowest level, a raw memory allocator ensures that there is enough space in the private heap to store all Python-related data by interacting with the operating system&rsquo;s memory manager. On top of the raw memory allocator, several object-specific allocators run on the same heap and implement different memory management policies based on the characteristics of each object type. For example, integer objects are managed differently within the heap than strings, tuples, or dictionaries because integers require different storage requirements and speed-versus-space tradeoffs. Thus, the Python memory manager assigns some work to object-specific allocators, but ensures that the latter operate within the confines of the private heap.</p>
<p>Python heap memory management is performed by the interpreter, and users have no control over it, even though they often manipulate object pointers to blocks of memory within the heap, and it is important to understand this.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/23/f42be86960fc4c09938c7b81059667cc.png" alt=""></p>
<p>Python uses suballocation (memory pools) for small objects to avoid the performance drain of too many GCs for small objects (&lt;=512bytes). For large objects, use the standard C allocator to allocate memory.</p>
<p>Python&rsquo;s allocator for small objects is divided into three tiers from large to small: arena, pool, and block.</p>
<h3 id="block">Block</h3>
<p>Block is the smallest level, each block can only contain a fixed size Python Object. size from 8-512bytes, in steps of 8bytes, divided into 64 different types of blocks.</p>
<table>
<thead>
<tr>
<th>Request in bytes</th>
<th>Size of allocated block</th>
<th>size class idx</th>
</tr>
</thead>
<tbody>
<tr>
<td>1-8</td>
<td>8</td>
<td>0</td>
</tr>
<tr>
<td>9-16</td>
<td>16</td>
<td>1</td>
</tr>
<tr>
<td>17-24</td>
<td>24</td>
<td>2</td>
</tr>
<tr>
<td>25-32</td>
<td>32</td>
<td>3</td>
</tr>
<tr>
<td>33-40</td>
<td>40</td>
<td>4</td>
</tr>
<tr>
<td>41-48</td>
<td>48</td>
<td>5</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>505-512</td>
<td>512</td>
<td>63</td>
</tr>
</tbody>
</table>
<h3 id="pool">Pool</h3>
<p>A Pool is a collection of blocks of the same size called a Pool, which is usually 4kb in size, consistent with the size of a virtual memory page. Restricting the size of blocks in a Pool to a fixed size has the following advantages: When an object is destroyed in a block in the current Pool, Pool memory management can put the newly generated object into that block.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* Pool for small blocks. */</span>
<span class="k">struct</span> <span class="n">pool_header</span> <span class="p">{</span>
    <span class="k">union</span> <span class="p">{</span> <span class="n">block</span> <span class="o">*</span><span class="n">_padding</span><span class="p">;</span>
            <span class="n">uint</span> <span class="n">count</span><span class="p">;</span> <span class="p">}</span> <span class="n">ref</span><span class="p">;</span>          <span class="cm">/* number of allocated blocks    */</span>
    <span class="n">block</span> <span class="o">*</span><span class="n">freeblock</span><span class="p">;</span>                   <span class="cm">/* pool&#39;s free list head         */</span>
    <span class="k">struct</span> <span class="n">pool_header</span> <span class="o">*</span><span class="n">nextpool</span><span class="p">;</span>       <span class="cm">/* next pool of this size class  */</span>
    <span class="k">struct</span> <span class="n">pool_header</span> <span class="o">*</span><span class="n">prevpool</span><span class="p">;</span>       <span class="cm">/* previous pool       &#34;&#34;        */</span>
    <span class="n">uint</span> <span class="n">arenaindex</span><span class="p">;</span>                    <span class="cm">/* index into arenas of base adr */</span>
    <span class="n">uint</span> <span class="n">szidx</span><span class="p">;</span>                         <span class="cm">/* block size class index        */</span>
    <span class="n">uint</span> <span class="n">nextoffset</span><span class="p">;</span>                    <span class="cm">/* bytes to virgin block         */</span>
    <span class="n">uint</span> <span class="n">maxnextoffset</span><span class="p">;</span>                 <span class="cm">/* largest valid nextoffset      */</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>Pools of the same size are linked by a bidirectional chain. sidx identifies the type of Block. arenaindex identifies the Arena to which the current Pool belongs. ref.conut identifies how many Blocks are used by the current Pool. freeblock: identifies a pointer to the blocks available in the current Pools. freeblock is actually a single-linked table implementation. When a block is empty, the block is inserted into the head of the freeblock chain.</p>
<p>Each Pool has three states.</p>
<ul>
<li>used: partially used, i.e. the Pool is not full and not empty</li>
<li>full: full, i.e. all the blocks in the Pool have been allocated</li>
<li>empty: empty, i.e. all blocks in the Pool are unallocated</li>
</ul>
<p>usedpool In order to manage Pools very efficiently, Python uses an additional array, usedpool, to manage them. That is, as shown below, usedpool stores the header pointer to each Pool of a particular size in order, and Pools of the same size are linked in a bidirectional chain. When allocating new memory space to create a Pool of a particular size, simply use usedpools to find the header pointer and iterate through it. When no memory space is available, simply insert a new Pool at the head of the Pool&rsquo;s bidirectional chain.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/23/710a7d7242d04fd79ca4f10c34140466.png" alt=""></p>
<h3 id="arena">Arena</h3>
<p>Pools and Blocks do not directly allocate memory (allocate), Pools and Blocks use the memory space already allocated from the arena side. arena: is a 256kb block of memory allocated on the heap, providing 64 Pools.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/23/c1fc165990df41ab8af8eff4e4b9fb32.png" alt=""></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">arena_object</span> <span class="p">{</span>
    <span class="n">uintptr_t</span> <span class="n">address</span><span class="p">;</span>
    <span class="n">block</span><span class="o">*</span> <span class="n">pool_address</span><span class="p">;</span>
    <span class="n">uint</span> <span class="n">nfreepools</span><span class="p">;</span>
    <span class="n">uint</span> <span class="n">ntotalpools</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">pool_header</span><span class="o">*</span> <span class="n">freepools</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">arena_object</span><span class="o">*</span> <span class="n">nextarena</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">arena_object</span><span class="o">*</span> <span class="n">prevarena</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>All arenas are also linked using a double-linked table (prevarena, nextarena fields). The nfreepools and ntotalpools store information about the currently available pools. freepools pointers point to the currently available pools. arena structure is simple, the responsibility is to allocate memory to pools on demand, and when an arena is empty, the memory of that arena is returned to the operating system.</p>
<h2 id="pythons-garbage-collection-mechanism">Python&rsquo;s garbage collection mechanism</h2>
<p>Python uses a reference-counting mechanism as the primary strategy, supplemented by two mechanisms: mark-clear and generational collection.</p>
<h3 id="reference-counting">reference counting</h3>
<p>The default garbage collection mechanism used by the Python language is &ldquo;Reference Counting&rdquo;, an algorithm first proposed by George E. Collins in 1960 and still used by many programming languages today, 50 years later. The principle of reference counting is: each object maintains an ob_ref field, which is used to record the number of times the object is currently referenced, whenever a new reference points to the object, its reference count ob_ref plus 1, whenever the object&rsquo;s reference fails count ob_ref minus 1, once the object&rsquo;s reference count is 0, the object is immediately recycled, and the memory space occupied by the object will be released. Its disadvantage is that it requires extra space to maintain the reference count, which is a secondary problem, but the main problem is that it does not solve the object&rsquo;s &ldquo;circular reference&rdquo;, so there are many languages such as Java that do not use this algorithm as a garbage collection mechanism.</p>
<p>Everything in Python is an object, which means that all the variables you use in Python are essentially class objects. In fact, the core of every object is a PyObject structure, which has an internal reference counter, ob_refcnt, that updates the value of ob_refcnt in real time as the program runs, to reflect the number of names that reference the current object. When the reference counter value of an object is 0, it means that the object has become garbage, then it will be recycled and the memory it uses will be freed immediately.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_object</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">ob_refcnt</span><span class="p">;</span><span class="c1">//引用计数
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">_typeobject</span> <span class="o">*</span><span class="n">ob_type</span><span class="p">;</span>
<span class="p">}</span> <span class="n">PyObject</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>Cases that result in +1 reference count.</p>
<ul>
<li>object is created, e.g. a=23</li>
<li>An object is referenced, e.g. b=a</li>
<li>The object is passed as an argument to a function, e.g. func(a)</li>
<li>The object is stored as an element in a container, e.g. list1=[a,a]</li>
</ul>
<p>which results in a reference count of -1</p>
<ul>
<li>The object&rsquo;s alias is destroyed explicitly, e.g. del a</li>
<li>An object&rsquo;s alias is given to a new object, e.g. a=24</li>
<li>An object leaves its scope, e.g. a local variable in the func function when the f function finishes executing (global variables do not)</li>
<li>The container in which the object is located is destroyed, or the object is removed from the container</li>
</ul>
<p>We can get the current reference count of an object referenced by a name by using getrefcount() in the sys package. sys.getrefcount() itself will cause the reference count to be added by one.</p>
<h4 id="circular-references">Circular references</h4>
<p>Another phenomenon of reference counting is circular references, equivalent to two objects a and b, where a references b, b references a, so that the reference count of a and b are 1 and will never be 0, which means that the two objects will never be recycled, which is a circular reference , a and b form a reference loop, the example is as follows :</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>  <span class="c1"># 计数为 1</span>
<span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>  <span class="c1"># 计数为 1</span>
<span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>  <span class="c1"># 计数为 2</span>
<span class="n">b</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  <span class="c1"># 计数为 2</span>
<span class="k">del</span> <span class="n">a</span>  <span class="c1"># 计数为 1</span>
<span class="k">del</span> <span class="n">b</span>  <span class="c1"># 计数为 1</span>
</code></pre></td></tr></table>
</div>
</div><p>In addition to the above two objects refer to each other, they can also refer to themselves:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="n">list3</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="n">list3</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">list3</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Circular references cause variables to never count to 0, causing reference counting to fail to remove them.</p>
<p>The reference counting method has its obvious advantages, such as efficiency, simple implementation logic, real-time, once an object&rsquo;s reference count goes to zero, the memory is released directly. There is no need to wait for a specific moment like other mechanisms. By randomly assigning garbage collection to the running phase, the time to deal with reclaiming memory is spread over the usual time, and the normal program runs more smoothly. Reference counting also has some disadvantages.</p>
<ul>
<li>Simple logic, but somewhat cumbersome to implement. Each object needs to be allocated a separate space to count the reference count, which in effect increases the space burden and requires maintenance of the reference count, which is prone to errors during maintenance.</li>
<li>In some scenarios, it may be slower. Normally garbage collection runs smoothly, but when a large object needs to be freed, such as a dictionary, it needs to be called in a nested loop for all objects referenced, which may take longer.</li>
<li>Circular references. This is the Achilles heel of reference counting, which is insurmountable and must be supplemented with other garbage collection algorithms.</li>
</ul>
<p>That is, Python&rsquo;s garbage collection mechanism is designed in large part to deal with the possibility of circular references, and is complementary to reference counting.</p>
<h3 id="mark-and-sweep">Mark and Sweep</h3>
<p>Python uses the Mark and Sweep algorithm to solve the problem of circular references that can be generated by container objects. (Note that only container objects generate circular references, such as lists, dictionaries, objects of user-defined classes, tuples, and so on. Simple types like numbers, strings, and so on do not have circular references. (As an optimization strategy, tuples containing only simple types are also not considered for the token removal algorithm.)</p>
<p>As its name suggests, the algorithm is divided into two steps when performing garbage collection, which are</p>
<ul>
<li>Marking phase, which iterates through all objects and marks the object as reachable if it is reachable, i.e., if there are still objects that refer to it.</li>
<li>Clear phase, which iterates through the objects again, and if an object is not marked as reachable, then it is recycled.</li>
</ul>
<p>Objects are linked together by references (pointers) to form a directed graph, with objects forming the nodes and reference relationships forming the edges of the directed graph. From the root object, the objects are traversed along the directed edges, and the reachable objects are marked as active objects, while the unreachable objects are the inactive objects to be removed. The so-called root object is some global variables, call stacks, and registers, which cannot be deleted.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/23/1ac772716175422391f9b276bc8d3c6a.png" alt=""></p>
<p>We consider the small black circle as the root object, from the small black circle, object 1 is reachable, then it will be marked, objects 2 and 3 are indirectly reachable will also be marked, while 4 and 5 are not reachable, then 1, 2 and 3 are active objects, 4 and 5 are inactive objects will be recycled by GC.</p>
<p>As shown in the figure below, in order to keep track of the container objects, each container object needs to maintain two additional pointers, which are used to form a double-ended chain table of container objects, with the pointers pointing to the front and back container objects for insertion and deletion operations. objects to be scanned, and another chain table that holds temporarily unreachable objects. In the diagram, these two tables are named &ldquo;Object to Scan&rdquo; and &ldquo;Unreachable&rdquo; respectively. The example in the figure is such a situation: link1,link2,link3 form a reference ring, while link1 is also referenced by a variable A (in fact, here is better called the name A). link4 self-reference, also forms a reference ring. We can also see from the figure, each node in addition to a record of the current reference count variable ref_count and a gc_ref variable, the gc_ref is a copy of ref_count, so the initial value of the size of ref_count.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/23/71f865bd1ee14822a3d3355152392a00.png" alt=""></p>
<p>When gc starts, it will iterate through the &ldquo;Object to Scan&rdquo; chain of container objects one by one, and the gc_ref of all objects referenced by the current object will be subtracted by one. (When scanning to link1, as link1 references link2, so the gc_ref of link2 will be reduced by one, and then scanning link2, as link2 references link3, so the gc_ref of link3 will be reduced by one &hellip;..) After examining all the objects in the &ldquo;Objects to Scan&rdquo; chain like this, the ref_count and gc_ref of the objects in the two chains are shown below. This step is equivalent to remove the influence of circular references on the reference count.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/23/3b17c232e5494f4fa3952ea0b6feb10d.png" alt=""></p>
<p>Then, gc will scan all the container objects again, if the object&rsquo;s gc_ref value is 0, then the object is marked as GC_TENTATIVELY_UNREACHABLE and moved to the &ldquo;Unreachable&rdquo; chain. This is the case for link3 and link4 in the figure below.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/23/2c32e166a6024ab8b5957c4eef1b7e91.png" alt=""></p>
<p>If the object&rsquo;s gc_ref is not 0, then the object will be marked as GC_REACHABLE, and when gc finds a node that is reachable, then it will recursively mark all nodes reachable from that node as GC_REACHABLE, which is the case for link2 and link3 in the figure below.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/23/890b9a84a35941f28d20b3d665541878.png" alt=""></p>
<p>In addition to marking all reachable nodes as GC_REACHABLE, if the node is currently in the &ldquo;Unreachable&rdquo; chain, you need to move it back to the &ldquo;Object to Scan&rdquo; chain, the figure below shows the situation after link3 is moved back.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/23/653e91824d4f4932bd614931fc098653.png" alt=""></p>
<p>After all the objects in the second traversal are traversed, the objects in the &ldquo;Unreachable&rdquo; chain are the objects that really need to be released. As shown above, link4 is now in the Unreachable chain, and gc releases it immediately.</p>
<p>The garbage collection phase described above suspends the entire application and waits for marker removal to finish before resuming operation.</p>
<p>The advantage of marker removal is that it solves the circular reference problem and has no additional overhead during the execution of the algorithm. The disadvantage is that the normal program will be blocked when executing marker clearing. Another disadvantage is that the marker clearing algorithm generates some small memory fragments in the program&rsquo;s heap space after many executions.</p>
<h3 id="generational-garbage-collector">Generational garbage collector</h3>
<p>The generational recycling technique is a garbage collection mechanism developed in the early 1980s and is the core algorithm of Java garbage collection. Generational recycling is based on the statistical fact that for programs, there exists a certain percentage of memory blocks that have a relatively short lifetime; while the remaining memory blocks will have a longer lifetime, even from the beginning of the program until the end of the program. The percentage of objects with a shorter lifetime is usually between 80% and 90%. Therefore, it is simply assumed that: the longer an object exists, the more likely it is not garbage and the less it should be collected. This effectively reduces the number of objects traversed when performing the mark-and-clean algorithm, thus increasing the speed of garbage collection, a space-for-time approach strategy.</p>
<ul>
<li>Python divides all objects into three generations of 0, 1, and 2.</li>
<li>All new objects are generation 0 objects.</li>
<li>When a generation of objects has undergone garbage collection and is still alive, it is classified as a next-generation object.</li>
</ul>
<p>So, by what criteria are objects classified? Is it enough to randomly divide an object into a certain generation? The answer is no. In fact, there is a lot to learn about object generation, and a good classification standard can significantly improve the efficiency of garbage collection.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/23/51861d4e68f248578699b7f48e1f5784.png" alt=""></p>
<p>Python internally divides objects into 3 generations, each maintained by a gc_generation structure (defined in Include/internal/mem.h), based on how long the object has been alive.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">gc_generation</span> <span class="p">{</span> 
    <span class="n">PyGC_Head</span> <span class="n">head</span><span class="p">;</span> 
    <span class="kt">int</span> <span class="n">threshold</span><span class="p">;</span> <span class="cm">/* collection threshold */</span> 
    <span class="kt">int</span> <span class="n">count</span><span class="p">;</span> <span class="cm">/* count of allocations or collections of younger generations */</span> 
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>where.</p>
<ul>
<li>head , the head of the collectible object chain table through which the objects in the generation are maintained</li>
<li>threshold, the Python garbage collection operation will scan the generation only if count exceeds this threshold</li>
<li>count, a counter that varies from generation to generation</li>
</ul>
<p>The Python virtual machine runtime state is represented by the pyruntimestate structure in Include/internal/pystate.h, which has an internal _gc_runtime_state ( Include/internal/mem.h ) structure that holds GC state information, including three object generations These 3 generations are used in the GC module. These 3 generations are initialized in the _PyGC_Initialize function of the GC module ( Modules/gcmodule.c ).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">gc_generation</span> <span class="n">generations</span><span class="p">[</span><span class="n">NUM_GENERATIONS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="cm">/* PyGC_Head, threshold, count */</span>
    <span class="p">{{{</span><span class="n">_GEN_HEAD</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">_GEN_HEAD</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">}},</span> <span class="mi">700</span> <span class="mi">0</span><span class="p">},</span>
    <span class="p">{{{</span><span class="n">_GEN_HEAD</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">_GEN_HEAD</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">}},</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
    <span class="p">{{{</span><span class="n">_GEN_HEAD</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">_GEN_HEAD</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">}},</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>For the sake of discussion, we will call these 3 generations: the first generation, the middle generation and the old generation. When these 3 generations are initialized, the corresponding gc_generation arrays will look like this</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/23/f992206e6f3e4681b973f94fc96037d4.png" alt=""></p>
<p>Each gc_generation structure points to itself at the head node of the chain, in other words each collectible object chain starts out empty, the counter field count is initialized to 0, and the threshold field has its own policy. How are these policies understood?</p>
<ul>
<li>When Python calls <em>PyObject_GC_Alloc to allocate memory for an object to be tracked, the function adds 1 to the primitive count counter, and the object is then added to the primitive object chain, and when Python calls PyObject_GC_Del to free memory for garbage objects, the function adds 1 to the primitive count counter,</em> PyObject_GC_Alloc will call collect_generations to perform a garbage collection (GC) if the threshold (700) is exceeded after self-incrementing the count.</li>
<li>The collect_generations function starts from the oldest generation and iterates through each generation one by one to find the oldest generation that needs to perform a recycling operation (,count&gt;threshold ). The collect_with_callback function is then called to start recycling that generation, and that function eventually calls the collect function.</li>
<li>When the collect function processes a generation, it first resets the count of the generations younger than it to 0, then removes their object chains, stitches them together with its own, performs a GC algorithm, and finally adds 1 to the counter of the next generation.</li>
</ul>
<p>Thus.</p>
<ul>
<li>Python performs a GC operation for every 701 new objects that need to be GC&rsquo;d in the system</li>
<li>The number of generations to be processed for each GC operation may be different, determined by both count and threshold</li>
<li>If a generation needs to be GC&rsquo;d (count&gt;hreshold), all the young generations before it are GC&rsquo;d at the same time</li>
<li>For multiple generations, Python stitches their object chains together and processes them all at once</li>
<li>After the GC is executed, count is cleared to zero, and the count of the next generation is added by 1</li>
</ul>
<p>Here&rsquo;s a simple example: the first generation triggers a GC operation, and Python executes the collect_generations function. It finds out that the oldest generation to reach the threshold is the middle generation, so it calls collection_with_callback(1), where 1 is the subscript of the middle generation in the array.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/23/6559bd8ffe2b4f41bc036c10ed44bb55.png" alt=""></p>
<p>collection_with_callback(1) ends up calling collect(1), which first adds one to the counter of the next generation; then resets the counters of this generation and all previous young generations to zero; and finally calls gc_list_merge to merge the chain of recyclable objects together.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/23/61e7db57585c4d64a4a4eb033860f729.png" alt=""></p>
<p>Finally, the collect function performs a marker removal algorithm to garbage collect the merged chain table.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/23/ad81abe7bace44d1adbf3a1bb2353fe4.png" alt=""></p>
<p>This is the whole secret of the generational recovery mechanism, which seems complicated, but with a little summary you can get a few straightforward strategies.</p>
<ul>
<li>Every 701 new objects that need GC, trigger a new generation GC</li>
<li>Every 11 new-generation GCs, trigger a mid-generation GC</li>
<li>Trigger an old-generation GC for every 11 mid-generation GCs (old-generation GCs are also affected by other policies and are less frequent)</li>
<li>Before executing a generation GC, the young generation object chain is also moved to that generation and GC&rsquo;d together</li>
<li>After an object is created, it will be gradually moved to the old generation over time, and the recovery frequency is gradually reduced</li>
</ul>
<h2 id="the-gc-module-in-python">The gc module in Python</h2>
<p>The gc module is our interface for memory management in Python. Generally Python programmers don&rsquo;t have to care about their program&rsquo;s memory management, but there are times, such as when they find a memory leak in their program, that they may need to use the gc module&rsquo;s interface to troubleshoot the problem.</p>
<p>Some Python systems will turn off automatic garbage collection, and the program will judge the timing of the collection itself. It is said that instagram&rsquo;s system does this, and the overall running efficiency is increased by 10%.</p>
<p>Commonly used functions.</p>
<ul>
<li>set_debug(flags) : set gc&rsquo;s debug log, usually set to gc.DEBUG_LEAK to see the memory leak objects.</li>
<li>collect([generation]) : Perform garbage collection. It will collect those objects that have circular references. This function can pass parameters, 0 means only the garbage object of generation 0, 1 means collect the object of generation 0 and generation 1, 2 means collect the object of generation 0, 1 and 2. If no parameters are passed, then 2 is used as the default parameter.</li>
<li>get_threshold() : Get the threshold value for the gc module to perform garbage collection. The return is a tuple, the 0th is the threshold for generation zero, the 1st is the threshold for generation 1, and the 2nd is the threshold for generation 2.</li>
<li>set_threshold(threshold0[, threshold1[, threshold2]) : Set the threshold for performing garbage collection.</li>
<li>get_count() : Get the current counter for automatically executing garbage collection. Returns a tuple. The 0th one is the number of garbage objects of generation zero, the 1st one is the number of times the chain table of generation zero is traversed, and the 2nd one is the number of times the chain table of generation 1 is traversed.</li>
</ul>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/python/">python</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2021-10/rate-limit/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Service High Availability Flow Limiting</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2021-10/pandas/">
            <span class="next-text nav-default">Pandas Data Processing Concise Tutorial</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
