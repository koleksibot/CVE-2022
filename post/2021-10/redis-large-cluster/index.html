<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Redis Large Cluster Scaling Performance Optimization Practices - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Background In the existing network environment, some businesses using Redis clusters often need to perform node expansion operations as their business volume rises. I have previously learned that after some operations and maintenance students expanded Redis clusters with a large number of nodes, the business side reported a decrease in cluster performance, as evidenced by a significant increase in access latency. Some businesses are sensitive to Redis cluster access latency," /><meta name="keywords" content="redis, Large Cluster, Performance, Practices" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2021-10/redis-large-cluster/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Redis Large Cluster Scaling Performance Optimization Practices" />
<meta property="og:description" content="Background In the existing network environment, some businesses using Redis clusters often need to perform node expansion operations as their business volume rises. I have previously learned that after some operations and maintenance students expanded Redis clusters with a large number of nodes, the business side reported a decrease in cluster performance, as evidenced by a significant increase in access latency. Some businesses are sensitive to Redis cluster access latency," />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2021-10/redis-large-cluster/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-10-19T22:15:39+08:00" />
<meta property="article:modified_time" content="2021-10-19T22:15:39+08:00" />

<meta itemprop="name" content="Redis Large Cluster Scaling Performance Optimization Practices">
<meta itemprop="description" content="Background In the existing network environment, some businesses using Redis clusters often need to perform node expansion operations as their business volume rises. I have previously learned that after some operations and maintenance students expanded Redis clusters with a large number of nodes, the business side reported a decrease in cluster performance, as evidenced by a significant increase in access latency. Some businesses are sensitive to Redis cluster access latency,"><meta itemprop="datePublished" content="2021-10-19T22:15:39+08:00" />
<meta itemprop="dateModified" content="2021-10-19T22:15:39+08:00" />
<meta itemprop="wordCount" content="4108">
<meta itemprop="keywords" content="redis," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Redis Large Cluster Scaling Performance Optimization Practices"/>
<meta name="twitter:description" content="Background In the existing network environment, some businesses using Redis clusters often need to perform node expansion operations as their business volume rises. I have previously learned that after some operations and maintenance students expanded Redis clusters with a large number of nodes, the business side reported a decrease in cluster performance, as evidenced by a significant increase in access latency. Some businesses are sensitive to Redis cluster access latency,"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Redis Large Cluster Scaling Performance Optimization Practices</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-10-19 22:15:39 </span>
        <div class="post-category">
            <a href="/categories/skills/"> skills </a>
            </div>
          <span class="more-meta"> 4108 words </span>
          <span class="more-meta"> 9 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#background">Background</a>
          <ul>
            <li><a href="#problem-description">Problem Description</a></li>
            <li><a href="#description-of-the-current-network-environment">Description of the current network environment</a></li>
            <li><a href="#observe-the-phenomenon">Observe the phenomenon</a></li>
          </ul>
        </li>
        <li><a href="#troubleshooting">Troubleshooting</a>
          <ul>
            <li><a href="#redis-hotspot-exclusion">Redis Hotspot Exclusion</a></li>
            <li><a href="#client-troubleshooting">Client troubleshooting</a></li>
            <li><a href="#summary-of-the-survey">Summary of the survey</a></li>
          </ul>
        </li>
        <li><a href="#optimization">Optimization</a>
          <ul>
            <li><a href="#analysis-of-the-current-situation">Analysis of the current situation</a></li>
            <li><a href="#optimization-solutions">Optimization Solutions</a></li>
            <li><a href="#realization">Realization</a></li>
          </ul>
        </li>
        <li><a href="#comparison-of-optimization-results">Comparison of optimization results</a>
          <ul>
            <li><a href="#test-environment--pressure-test-scenarios">Test environment &amp; pressure test scenarios</a></li>
            <li><a href="#cpu-resource-usage-comparison">CPU resource usage comparison</a></li>
            <li><a href="#time-consumption-comparison">Time consumption comparison</a></li>
          </ul>
        </li>
        <li><a href="#summary">Summary</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="background">Background</h2>
<p>In the existing network environment, some businesses using Redis clusters often need to perform node expansion operations as their business volume rises.</p>
<p>I have previously learned that after some operations and maintenance students expanded Redis clusters with a large number of nodes, the business side reported a decrease in cluster performance, as evidenced by a significant increase in access latency.</p>
<p>Some businesses are sensitive to Redis cluster access latency, such as the existing network environment for real-time reading of models, or some businesses rely on synchronization processes for reading Redis clusters, which can affect the real-time process latency of the business. This may not be acceptable on the business side.</p>
<p>To find the root cause of this problem, we troubleshoot the cluster performance degradation after a particular Redis cluster migration operation.</p>
<h3 id="problem-description">Problem Description</h3>
<p>The scenario for this specific Redis cluster problem is that a particular Redis cluster has undergone a scaling operation. The business side uses Hiredis-vip for Redis cluster access and performs MGET operations.</p>
<p>The business side perceives that the latency of accessing the Redis cluster becomes high.</p>
<h3 id="description-of-the-current-network-environment">Description of the current network environment</h3>
<ul>
<li>Most of the Redis versions deployed in the current network environment are 3.x or 4.x;</li>
<li>The business is using the client Hiredis-vip to access the Redis cluster;</li>
<li>The number of nodes in the Redis cluster is relatively large, with a size of 100+;</li>
<li>The cluster had a previous expansion operation.</li>
</ul>
<h3 id="observe-the-phenomenon">Observe the phenomenon</h3>
<p>Because latency becomes high, we troubleshoot in several ways.</p>
<ul>
<li>whether the bandwidth is hitting full capacity.</li>
<li>whether the CPU is over-occupied.</li>
<li>whether the OPS is high.</li>
</ul>
<p>By simple monitoring and troubleshooting, the bandwidth load is not high. However, the CPU performance was found to be abnormal.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/19/896b0aada2da418f973226a08c5ca7fd.png" alt=""></p>
<h4 id="comparing-ops-and-cpu-load">Comparing OPS and CPU load</h4>
<p>Observing the MGET and CPU load used by the business feedback, we found the corresponding monitoring curve.</p>
<p>There is no direct correlation between MGET and high CPU load in terms of temporal analysis. The feedback from the business side is a general increase in MGET latency. Here we see that the OPS and CPU load of MGET are staggered.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/19/e239a935cecf4da2995a778a5263a328.png" alt=""></p>
<p>Here we can temporarily determine that there is no direct relationship between business requests and CPU load for the time being, but it can be seen from the curve: there are staggered business requests and cpu load on the same timeline, and there should be an indirect relationship between the two.</p>
<h4 id="compare-cluster-instruction-ops-and-cpu-load">Compare Cluster instruction OPS and CPU load</h4>
<p>Since some of my colleagues on the operations side had previously given feedback that the cluster had undergone expansion operations, there was bound to be a migration of slots.</p>
<p>Considering that business clients generally use caches to store slot topology information of Redis clusters, it was suspected that the Cluster directive would have some connection with CPU load.</p>
<p>We found that there was indeed some connection.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/19/3e56af3c9b0a46c6a13ccba10bb02877.png" alt=""></p>
<p>Here it is obvious: CPU usage rises significantly when a certain instance is executing Cluster instructions.</p>
<p>Based on the above phenomena, a simple focus can be roughly made on.</p>
<ul>
<li>MGET is executed on the business side, and Cluster instruction is executed for some reason.</li>
<li>Cluster instruction is causing high CPU usage affecting other operations for some reasons.</li>
<li>Cluster instructions are suspected to be a performance bottleneck.</li>
</ul>
<p>Also, to elicit a few issues of concern.</p>
<p><strong>Why are there more Cluster instructions being executed?</strong></p>
<p><strong>Why are CPU resources higher when Cluster instructions are executed?</strong></p>
<p><strong>Why are clusters with large node sizes prone to slot migration operations?</strong> <strong>Why is it easy to get &ldquo;caught&rdquo; in cluster migration slots with large node sizes?</strong></p>
<h2 id="troubleshooting">Troubleshooting</h2>
<h3 id="redis-hotspot-exclusion">Redis Hotspot Exclusion</h3>
<p>We performed a simple analysis using perf top on a Redis instance that appeared to have a high CPU load in the field.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/19/4e46a09f8275454fa44257cf81fb1fc5.png" alt=""></p>
<p>As you can see from the above graph, the function (ClusterReplyMultiBulkSlots) takes up 51.84% of the CPU resources, which is abnormal.</p>
<h4 id="clusterreplymultibulkslots-implementation-principle">ClusterReplyMultiBulkSlots implementation principle</h4>
<p>We analyze the clusterReplyMultiBulkSlots function.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span><span class="lnt">94
</span><span class="lnt">95
</span><span class="lnt">96
</span><span class="lnt">97
</span><span class="lnt">98
</span><span class="lnt">99
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">clusterReplyMultiBulkSlots</span><span class="p">(</span><span class="n">client</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* Format: 1) 1) start slot
</span><span class="cm">     *            2) end slot
</span><span class="cm">     *            3) 1) master IP
</span><span class="cm">     *               2) master port
</span><span class="cm">     *               3) node ID
</span><span class="cm">     *            4) 1) replica IP
</span><span class="cm">     *               2) replica port
</span><span class="cm">     *               3) node ID
</span><span class="cm">     *           ... continued until done
</span><span class="cm">     */</span>
 
    <span class="kt">int</span> <span class="n">num_masters</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">slot_replylen</span> <span class="o">=</span> <span class="n">addDeferredMultiBulkLength</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
 
    <span class="n">dictEntry</span> <span class="o">*</span><span class="n">de</span><span class="p">;</span>
    <span class="n">dictIterator</span> <span class="o">*</span><span class="n">di</span> <span class="o">=</span> <span class="n">dictGetSafeIterator</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">);</span>
    <span class="k">while</span><span class="p">((</span><span class="n">de</span> <span class="o">=</span> <span class="n">dictNext</span><span class="p">(</span><span class="n">di</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/*注意：此处是对当前Redis节点记录的集群所有主节点都进行了遍历*/</span>
        <span class="n">clusterNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">dictGetVal</span><span class="p">(</span><span class="n">de</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">start</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
 
        <span class="cm">/* Skip slaves (that are iterated when producing the output of their
</span><span class="cm">         * master) and  masters not serving any slot. */</span>
        <span class="cm">/*跳过备节点。备节点的信息会从主节点侧获取。*/</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nodeIsMaster</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">||</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">numslots</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">CLUSTER_SLOTS</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/*注意：此处是对当前节点中记录的所有slot进行了遍历*/</span>
            <span class="kt">int</span> <span class="n">bit</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
            <span class="cm">/*确认当前节点是不是占有循环终端的slot*/</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">bit</span> <span class="o">=</span> <span class="n">clusterNodeGetSlotBit</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="n">j</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">start</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="cm">/*简单分析，此处的逻辑大概就是找出连续的区间，是的话放到返回中；不是的话继续往下递归slot。
</span><span class="cm">              如果是开始的话，开始一个连续区间，直到和当前的不连续。*/</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">bit</span> <span class="o">||</span> <span class="n">j</span> <span class="o">==</span> <span class="n">CLUSTER_SLOTS</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
                <span class="kt">int</span> <span class="n">nested_elements</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="cm">/* slots (2) + master addr (1). */</span>
                <span class="kt">void</span> <span class="o">*</span><span class="n">nested_replylen</span> <span class="o">=</span> <span class="n">addDeferredMultiBulkLength</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
 
                <span class="k">if</span> <span class="p">(</span><span class="n">bit</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">==</span> <span class="n">CLUSTER_SLOTS</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">j</span><span class="o">++</span><span class="p">;</span>
 
                <span class="cm">/* If slot exists in output map, add to it&#39;s list.
</span><span class="cm">                 * else, create a new output map for this slot */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">==</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">addReplyLongLong</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span> <span class="cm">/* only one slot; low==high */</span>
                    <span class="n">addReplyLongLong</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="n">addReplyLongLong</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span> <span class="cm">/* low */</span>
                    <span class="n">addReplyLongLong</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>   <span class="cm">/* high */</span>
                <span class="p">}</span>
                <span class="n">start</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
 
                <span class="cm">/* First node reply position is always the master */</span>
                <span class="n">addReplyMultiBulkLen</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
                <span class="n">addReplyBulkCString</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">);</span>
                <span class="n">addReplyLongLong</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>
                <span class="n">addReplyBulkCBuffer</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">CLUSTER_NAMELEN</span><span class="p">);</span>
 
                <span class="cm">/* Remaining nodes in reply are replicas for slot range */</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">numslaves</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                    <span class="cm">/*注意：此处遍历了节点下面的备节点信息，用于返回*/</span>
                    <span class="cm">/* This loop is copy/pasted from clusterGenNodeDescription()
</span><span class="cm">                     * with modifications for per-slot node aggregation */</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">nodeFailed</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">slaves</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="k">continue</span><span class="p">;</span>
                    <span class="n">addReplyMultiBulkLen</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
                    <span class="n">addReplyBulkCString</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">slaves</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">);</span>
                    <span class="n">addReplyLongLong</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">slaves</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>
                    <span class="n">addReplyBulkCBuffer</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">slaves</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">CLUSTER_NAMELEN</span><span class="p">);</span>
                    <span class="n">nested_elements</span><span class="o">++</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">setDeferredMultiBulkLength</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">nested_replylen</span><span class="p">,</span> <span class="n">nested_elements</span><span class="p">);</span>
                <span class="n">num_masters</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">dictReleaseIterator</span><span class="p">(</span><span class="n">di</span><span class="p">);</span>
    <span class="n">setDeferredMultiBulkLength</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">slot_replylen</span><span class="p">,</span> <span class="n">num_masters</span><span class="p">);</span>
<span class="p">}</span>
 
<span class="cm">/* Return the slot bit from the cluster node structure. */</span>
<span class="cm">/*该函数用于判断指定的slot是否属于当前clusterNodes节点*/</span>
<span class="kt">int</span> <span class="nf">clusterNodeGetSlotBit</span><span class="p">(</span><span class="n">clusterNode</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slot</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">bitmapTestBit</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">,</span><span class="n">slot</span><span class="p">);</span>
<span class="p">}</span>
 
<span class="cm">/* Test bit &#39;pos&#39; in a generic bitmap. Return 1 if the bit is set,
</span><span class="cm"> * otherwise 0. */</span>
<span class="cm">/*此处流程用于判断指定的的位置在bitmap上是否为1*/</span>
<span class="kt">int</span> <span class="nf">bitmapTestBit</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">bitmap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">off_t</span> <span class="n">byte</span> <span class="o">=</span> <span class="n">pos</span><span class="o">/</span><span class="mi">8</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">bit</span> <span class="o">=</span> <span class="n">pos</span><span class="o">&amp;</span><span class="mi">7</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">bitmap</span><span class="p">[</span><span class="n">byte</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">bit</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">clusterNode</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="cm">/*使用一个长度为CLUSTER_SLOTS/8的char数组对当前分配的slot进行记录*/</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">slots</span><span class="p">[</span><span class="n">CLUSTER_SLOTS</span><span class="o">/</span><span class="mi">8</span><span class="p">];</span> <span class="cm">/* slots handled by this node */</span>
    <span class="p">...</span>
<span class="p">}</span> <span class="n">clusterNode</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>Each node (ClusterNode) uses a bitmap (char slots[CLUSTER_SLOTS/8]) to store information about the allocation of slots.</p>
<p>A brief description of the logic of BitmapTestBit: clusterNode-&gt;slots is an array of length CLUSTER_SLOTS/8. CLUSTER_SLOTS is a fixed value 16384. each bit of the array represents a slot. the subscript of the bitmap array here is 0 to 2047, and the range of slots is 0 to 16383. The slot range is 0 to 16383.</p>
<p>Because we have to determine whether the bit at the pos position is a 1 or not, therefore.</p>
<ul>
<li>off_t byte = pos/8: Get the information about which byte (Byte) on the bitmap holds this pos position. Since there are 8 bits in a byte, using pos/8 can guide which byte you need to find. Here the bitmap is treated as an array, and here it corresponds to the Byte with the corresponding subscript.</li>
<li>int bit = pos&amp;7: Get the information of which bit corresponds to the pos position on this byte. You can imagine grouping pos in groups of 8, and the last group (not satisfying 8) corresponds to the subscript position of the bit array on the corresponding byte of the bitmap.</li>
<li><code>(bitmap[byte] &amp; (1&lt;&lt;bit))</code>: determine whether the corresponding bit exists on the bitmap[byte].</li>
</ul>
<p>Example with a slot of 10001.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/19/5759fa866f584100915fd311366c5f6e.png" alt=""></p>
<p>Therefore, the slot 10001 corresponds to the byte with subscript 1250, and the bit to be verified is the subscript 1.</p>
<p>The corresponding position on ClusterNode-&gt;slots.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/19/e8a56ef342aa4a50823281dd46b43020.png" alt=""></p>
<p>The green square shows bitmap[1250], which is the byte corresponding to slot 10001; the red box (bit[1]) corresponds to the position of <code>1&lt;&lt;bit. bitmap[byte] &amp; (1&lt;&lt;bit)</code>, which is to confirm whether the position corresponding to the red box is 1. If yes, it means that 10001 on the bitmap has been marked. If yes, the bitmap is marked with 10001.</p>
<p>The summary logic of ClusterNodeGetSlotBit is: <strong>Determine whether the current slot is allocated on the current node</strong> . Therefore, the approximate logic of ClusterReplyMultiBulkSlots is as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/19/a49b1ea831414f19957299937f2810ac.png" alt=""></p>
<p>The approximate steps are as follows.</p>
<ul>
<li>Iterate over each node.</li>
<li>For each node, traverse all slots and use ClusterNodeGetSlotBit to determine whether the slots in the traversal are assigned to the current node.</li>
</ul>
<p>From the result of getting CLUSTER SLOTS command, we can see that the complexity is <code>&lt;number of cluster master nodes&gt; * &lt;total number of slots&gt;</code>. The total number of slots is 16384, a fixed value.</p>
<h4 id="redis-hotspot-exclusion-summary">Redis Hotspot Exclusion Summary</h4>
<p>As of now, the CLUSTER SLOTS instruction latency increases linearly with the number of master nodes in the Redis cluster. The larger number of master nodes in the cluster we are investigating explains the larger latency of the CLUSTER SLOTS instruction in the current network phenomenon.</p>
<h3 id="client-troubleshooting">Client troubleshooting</h3>
<p>Understand that the operations and maintenance students exist expansion operations, expansion is bound to involve some key in the time of access there is a MOVED error.</p>
<p>The current use of Hiredis-vip client code for a simple browse, a brief analysis of the following current business use of Hiredis-vip client in the event of MOVED how to deal with. As most of the other business commonly used Jedis client, here is also a simple analysis of the corresponding process of the Jedis client.</p>
<h4 id="hiredis-vip-on-moved-processing-implementation-principle">Hiredis-vip on MOVED processing implementation principle</h4>
<p>Hiredis-vip for MOVED operations.</p>
<p>To view the call procedure for Cluster_update_route.</p>
<p>Here the cluster_update_route_by_addr performs a CLUSTER SLOT operation. As you can see, when a MOVED error is obtained, Hiredis-vip re-updates the Redis cluster topology with the following characteristics.</p>
<ul>
<li>Because the nodes are hashed the same way through ip:port as the key, multiple clients can easily access the same node at the same time if the cluster topology is similar.</li>
<li>If a node fails to access, it will find the next node through an iterator. Due to the above, multiple clients can easily access to the next node at the same time.</li>
</ul>
<h4 id="jedis-on-moved-processing-implementation-principle">Jedis on MOVED processing implementation principle</h4>
<p>A brief look at the Jedis client code shows that if there is a MOVED error, renewSlotCache will be called.</p>
<p>Looking at the renewSlotCache call, we can confirm that Jedis sends the Redis command CLUSTER SLOTS to re-pull the Redis cluster&rsquo;s slot topology when it encounters a MOVED error in cluster mode.</p>
<h4 id="summary-of-client-side-implementation-principles">Summary of client-side implementation principles</h4>
<p>Since Jedis is the Redis client for Java and Hiredis-vip is the Redis client for C++, it can be simply assumed that this exception handling mechanism is a common operation.</p>
<p>The process for combing MOVED in client cluster mode is roughly as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/19/bee25a2a562745e6bae51f3e6af82989.png" alt=""></p>
<p>In summary.</p>
<ol>
<li>
<p>access to the key using the client-side cached slot topology.</p>
</li>
<li>
<p>Redis node returns normal.</p>
<ul>
<li>Access is normal, continue with subsequent operations</li>
</ul>
</li>
<li>
<p>Redis node returns MOVED.</p>
<ul>
<li>Perform CLUSTER SLOTS command execution on the Redis node to update the topology.</li>
<li>Re-access to the key using the new topology.</li>
</ul>
</li>
</ol>
<h4 id="summary-of-client-side-troubleshooting">Summary of client-side troubleshooting</h4>
<p>The Redis cluster is expanding, which means that there are bound to be some Redis clients that are accessing the Redis cluster and encountering MOVED, executing the Redis command CLUSTER SLOTS for topology updates.</p>
<p>If the migration key hit rate is high, the CLUSTER SLOTS instruction will be executed more frequently. This results in the Redis cluster being continuously executed by the client during the migration process with the CLUSTER SLOTS instruction.</p>
<h3 id="summary-of-the-survey">Summary of the survey</h3>
<p>Here, combined with the Redis-side CLUSTER SLOTS mechanism and the client-side logic for MOVED, several questions can be answered.</p>
<p><strong>Why are there more Cluster instructions being executed?</strong></p>
<ul>
<li>Because of the migration operation, the business accessing some migrated keys will get the MOVED return, and the client will re-pull the slot topology information and execute CLUSTER SLOTS on the return.</li>
</ul>
<p><strong>Why are CPU resources higher when Cluster instructions are executed?</strong></p>
<ul>
<li>Analyzing the Redis source code, I found that the time complexity of the CLUSTER SLOT instruction is proportional to the number of master nodes. The current Redis cluster has a high number of master nodes, which naturally consumes a high amount of time and CPU resources.</li>
</ul>
<p><strong>Why is it easy to have problems with migrating slot operations for clusters with large node sizes?</strong></p>
<ul>
<li>The migration operation is bound to bring some clients to access the key when it returns MOVED.</li>
<li>The client will execute CLUSTER SLOTS command for the return of MOVED.</li>
<li>CLUSTER SLOTS instruction will increase the latency with the increase of the number of cluster master nodes.</li>
<li>Business accesses rise during the migration of slots because of the CLUSTER SLOTS latency, which is perceived externally as elevated latency in executing instructions.</li>
</ul>
<h2 id="optimization">Optimization</h2>
<h3 id="analysis-of-the-current-situation">Analysis of the current situation</h3>
<p>According to the current situation, it is a normal process for clients to encounter MOVED for CLUSTER SLOTS execution, because the cluster&rsquo;s slot topology needs to be updated to improve the efficiency of subsequent cluster access.</p>
<p>This process in addition to Jedis, Hiredis-vip, other clients should also be similar to the slot information cache optimization. There is not much room for optimization of this process, which is determined by the cluster access mechanism of Redis.</p>
<p>Therefore, the cluster information record of Redis is analyzed.</p>
<h4 id="redis-cluster-metadata-analysis">Redis Cluster Metadata Analysis</h4>
<p>Each Redis node in the cluster will have some cluster metadata records, recorded in server.cluster, as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">clusterState</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">dict</span> <span class="o">*</span><span class="n">nodes</span><span class="p">;</span>          <span class="cm">/* Hash table of name -&gt; clusterNode structures */</span>
    <span class="cm">/*nodes记录的是所有的节点，使用dict记录*/</span>
    <span class="p">...</span>
    <span class="n">clusterNode</span> <span class="o">*</span><span class="n">slots</span><span class="p">[</span><span class="n">CLUSTER_SLOTS</span><span class="p">];</span><span class="cm">/*slots记录的是slot数组，内容是node的指针*/</span>
    <span class="p">...</span>
<span class="p">}</span> <span class="n">clusterState</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>As described in 2.1, the original logic obtains the topology by traversing the slot information of each node.</p>
<h4 id="redis-cluster-metadata-analysis-1">Redis Cluster Metadata Analysis</h4>
<p>Observe the results returned by CLUSTER SLOTS.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* Format: 1) 1) start slot
</span><span class="cm"> *            2) end slot
</span><span class="cm"> *            3) 1) master IP
</span><span class="cm"> *               2) master port
</span><span class="cm"> *               3) node ID
</span><span class="cm"> *            4) 1) replica IP
</span><span class="cm"> *               2) replica port
</span><span class="cm"> *               3) node ID
</span><span class="cm"> *           ... continued until done
</span><span class="cm"> */</span>
</code></pre></td></tr></table>
</div>
</div><p>Combined with the cluster information stored in server.cluster, I think we can use server.cluster-&gt;slots for traversal here. Because server.cluster-&gt;slots has been updated at every topology change of the cluster, the node pointers are saved.</p>
<h3 id="optimization-solutions">Optimization Solutions</h3>
<p>A simple optimization idea is as follows.</p>
<ul>
<li>Iterate over the slot to find out which nodes in the slot are consecutive blocks.</li>
<li>If the node of the currently traversed slot is the same as the previously traversed node, it means that the currently visited slot is under the same node as the previous one, i.e., it is in the &ldquo;contiguous&rdquo; slot region under a certain node.</li>
<li>If the node of the currently traversed slot does not match the previously traversed node, it means that the currently visited slot is different from the previous one, and the previous &ldquo;continuous&rdquo; slot area can be output; and the current slot is used as the start of the next new &ldquo;continuous&rdquo; slot area.</li>
</ul>
<p>Therefore, it is sufficient to iterate over server.cluster-&gt;slots to satisfy the requirement. A simple representation would be as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/19/392665dab41647cfb2f9119c2a8fb6de.png" alt=""></p>
<p>This reduces the time complexity to <code>&lt;total number of slots&gt;</code>.</p>
<h3 id="realization">Realization</h3>
<p>The optimization logic is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">clusterReplyMultiBulkSlots</span><span class="p">(</span><span class="n">client</span> <span class="o">*</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* Format: 1) 1) start slot
</span><span class="cm">     *            2) end slot
</span><span class="cm">     *            3) 1) master IP
</span><span class="cm">     *               2) master port
</span><span class="cm">     *               3) node ID
</span><span class="cm">     *            4) 1) replica IP
</span><span class="cm">     *               2) replica port
</span><span class="cm">     *               3) node ID
</span><span class="cm">     *           ... continued until done
</span><span class="cm">     */</span>
    <span class="n">clusterNode</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">num_masters</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">start</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">slot_replylen</span> <span class="o">=</span> <span class="n">addReplyDeferredLen</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
 
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">CLUSTER_SLOTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/*对所有slot进行遍历*/</span>
        <span class="cm">/* Find start node and slot id. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">CLUSTER_SLOTS</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
 
        <span class="cm">/* Add cluster slots info when occur different node with start
</span><span class="cm">         * or end of slot. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">CLUSTER_SLOTS</span> <span class="o">||</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="cm">/*遍历主节点下面的备节点，添加返回客户端的信息*/</span>
            <span class="n">addNodeReplyForClusterSlot</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
            <span class="n">num_masters</span><span class="o">++</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">CLUSTER_SLOTS</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">setDeferredArrayLen</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">slot_replylen</span><span class="p">,</span> <span class="n">num_masters</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>By traversing server.cluster-&gt;slots, we find the &ldquo;contiguous&rdquo; slot area under a node, and if it is not contiguous, we output the node information of the previous &ldquo;contiguous&rdquo; slot area and its backup nodes, and then continue to find the next &ldquo;contiguous&rdquo; slot area in the output. If the node is not contiguous, the node information of the previous &ldquo;contiguous&rdquo; slot area and its backup node information are output, and then the next &ldquo;contiguous&rdquo; slot area is found and output.</p>
<h2 id="comparison-of-optimization-results">Comparison of optimization results</h2>
<p>A side-by-side comparison of the CLUSTER SLOTS directive for both versions of Redis.</p>
<h3 id="test-environment--pressure-test-scenarios">Test environment &amp; pressure test scenarios</h3>
<p>Operating system: manjaro 20.2</p>
<p><strong>Hardware configuration:</strong></p>
<ul>
<li>CPU：AMD Ryzen 7 4800H</li>
<li>DRAM：DDR4 3200MHz 8G*2</li>
</ul>
<p><strong>Redis Cluster Information:</strong></p>
<ol>
<li>
<p>Persistence Configuration</p>
<ul>
<li>Turn off aof</li>
<li>Turn off bgsave</li>
</ul>
</li>
<li>
<p>Cluster node information.</p>
<ul>
<li>Number of nodes: 100</li>
<li>All nodes are master nodes</li>
</ul>
</li>
</ol>
<p><strong>Pressure testing scenarios:</strong></p>
<ul>
<li>Using the benchmark tool to continuously send CLUSTER SLOTS commands to individual nodes of the cluster.</li>
<li>After pressure testing one of the versions, recycle the cluster and redeploy it for the next round of pressure testing.</li>
</ul>
<h3 id="cpu-resource-usage-comparison">CPU resource usage comparison</h3>
<p>perf export flame map. Original version.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/19/6245b77db30e4a12b7235a57b39c03a6.png" alt=""></p>
<p>After optimization.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/19/1813eceaa1b9406cbcdf1706ed8887eb.png" alt=""></p>
<p>It can be clearly seen that the optimized share has dropped significantly. It is basically as expected.</p>
<h3 id="time-consumption-comparison">Time consumption comparison</h3>
<p>To test on, embed the time-consuming test code at</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span><span class="s">&#34;slots&#34;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* CLUSTER SLOTS */</span>
        <span class="kt">long</span> <span class="kt">long</span> <span class="n">now</span> <span class="o">=</span> <span class="n">ustime</span><span class="p">();</span>
        <span class="n">clusterReplyMultiBulkSlots</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
        <span class="n">serverLog</span><span class="p">(</span><span class="n">LL_NOTICE</span><span class="p">,</span>
            <span class="s">&#34;cluster slots cost time:%lld us&#34;</span><span class="p">,</span> <span class="n">ustime</span><span class="p">()</span> <span class="o">-</span> <span class="n">now</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Input logs for comparison.</p>
<p><strong>Original log output:</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">37351:M 06 Mar 2021 16:11:39.313 * cluster slots cost time:2061 us.
</code></pre></td></tr></table>
</div>
</div><p><strong>Optimized version log output:</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">35562:M 06 Mar 2021 16:11:27.862 * cluster slots cost time:168 us.
</code></pre></td></tr></table>
</div>
</div><p>The decrease in time consumption is obvious: from 2000+us to 200-us; the time consumption in a cluster of 100 master nodes is reduced to 8.2% of the original; the optimization results are basically as expected.</p>
<h2 id="summary">Summary</h2>
<p>Here we can briefly describe the above actions of the article to draw such a conclusion: performance defects.</p>
<p>To briefly summarize the above troubleshooting and optimization process.</p>
<ul>
<li>A large Redis cluster was experiencing significant access latency on some nodes due to the CLUSTER command.</li>
<li>Using the perf top command to troubleshoot Redis instances, I found that the clusterReplyMultiBulkSlots command was using abnormal CPU resources.</li>
<li>Analysis of clusterReplyMultiBulkSlots revealed significant performance issues with this function.</li>
<li>Optimization of clusterReplyMultiBulkSlots resulted in significant performance improvements.</li>
</ul>
<p>From the above troubleshooting and optimization process, we can conclude that the current Redis has a performance defect in the CLUSTER SLOT instruction.</p>
<p>Because of Redis' data slicing mechanism, the key access method in Redis cluster mode is to cache the topological information of the slot. The optimization point can only be started at CLUSTER SLOTS. The number of Redis cluster nodes is generally not so large, and the problem is not obvious.</p>
<p>In fact, the logic of Hiredis-vip also has some problems. As mentioned in 2.2.1, Hiredis-vip&rsquo;s slot topology update method is to iterate through all nodes one by one to perform CLUSTER SLOTS, which can have a knock-on effect if the Redis cluster is large and the client size on the business side is large.</p>
<ol>
<li>
<p>If the Redis cluster is large, CLUSTER SLOTS responds more slowly.</p>
</li>
<li>
<p>if a node does not respond or returns an error, the Hiredis-vip client will continue the request to the next node.</p>
</li>
<li>
<p>the same method of iterative traversal of the Redis cluster nodes in the Hiredis-vip client (since the information about the cluster is basically the same across clients), when the client size is large, there may be blocking at a Redis node, which causes the hiredis-vip client to traverse the next Redis node.</p>
</li>
<li>
<p>A large number of Hiredis-vip clients accessing a number of Redis nodes one by one, which can lead to Redis nodes being requested one by one under the &ldquo;traversal&rdquo; of a large number of Hiredis-vip clients if the Redis nodes cannot handle such requests.</p>
<blockquote>
<p>In conjunction with point 3 above, imagine that there are 1w clients accessing the Redis cluster. Because there is a migration operation for a key with a high hit rate, all the clients need to update the slot topology. Since all clients have the same cluster node information cached, the order of traversing each node is the same. Redis nodes are accessed by most of the clients (e.g., 9k+ clients) in the same order of traversal, and the CLUSTER SLOTS command is executed. Executing the CLUSTER SLOTS command causes Redis nodes to block one by one.</p>
</blockquote>
</li>
<li>
<p>The end result is that the CPU load on most Redis nodes spikes, and many Hiredis-vip clients continue to fail to update the slot topology.</p>
</li>
</ol>
<p>The end result is that after a large-scale Redis cluster undergoes a slot migration operation, the business-side perception under large-scale Hiredis-vip client access is that the common command latency becomes high, while the Redis instance CPU resource usage rises high. This logic can be optimized to some extent.</p>
<p>The optimizations in subsection 3 above have now been committed and merged into Redis 6.2.2.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/redis/">redis</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2021-10/python-decorator/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">How to understand Python decorators</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2021-10/spring-boot-hot-load-jars/">
            <span class="next-text nav-default">How to hot load jars for Spring Boot to implement dynamic plugins?</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
