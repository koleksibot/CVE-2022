<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Understanding Linux network namespaces - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="In this article I will demonstrate how to use the command to connect processes in different subnets of the network namespace through a pair of veth interfaces. Network Namespaces We know that the container runtime uses the namespace (namespace) kernel function to partition system resources for some form of process isolation, so that changes to resources in one namespace do not affect resources in other namespaces, including process IDs, host" /><meta name="keywords" content="linux, Namespace" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2021-10/learn-linux-net-namespace/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Understanding Linux network namespaces" />
<meta property="og:description" content="In this article I will demonstrate how to use the command to connect processes in different subnets of the network namespace through a pair of veth interfaces. Network Namespaces We know that the container runtime uses the namespace (namespace) kernel function to partition system resources for some form of process isolation, so that changes to resources in one namespace do not affect resources in other namespaces, including process IDs, host" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2021-10/learn-linux-net-namespace/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-10-10T13:07:36+08:00" />
<meta property="article:modified_time" content="2021-10-10T13:07:36+08:00" />

<meta itemprop="name" content="Understanding Linux network namespaces">
<meta itemprop="description" content="In this article I will demonstrate how to use the command to connect processes in different subnets of the network namespace through a pair of veth interfaces. Network Namespaces We know that the container runtime uses the namespace (namespace) kernel function to partition system resources for some form of process isolation, so that changes to resources in one namespace do not affect resources in other namespaces, including process IDs, host"><meta itemprop="datePublished" content="2021-10-10T13:07:36+08:00" />
<meta itemprop="dateModified" content="2021-10-10T13:07:36+08:00" />
<meta itemprop="wordCount" content="3014">
<meta itemprop="keywords" content="linux," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Understanding Linux network namespaces"/>
<meta name="twitter:description" content="In this article I will demonstrate how to use the command to connect processes in different subnets of the network namespace through a pair of veth interfaces. Network Namespaces We know that the container runtime uses the namespace (namespace) kernel function to partition system resources for some form of process isolation, so that changes to resources in one namespace do not affect resources in other namespaces, including process IDs, host"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Understanding Linux network namespaces</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-10-10 13:07:36 </span>
        <div class="post-category">
            <a href="/categories/skills/"> skills </a>
            </div>
          <span class="more-meta"> 3014 words </span>
          <span class="more-meta"> 7 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#network-namespaces">Network Namespaces</a></li>
        <li><a href="#ip-command">ip command</a></li>
        <li><a href="#configure-the-first-network-namespace">Configure the first network namespace</a></li>
        <li><a href="#configure-a-second-network-namespace">Configure a second network namespace</a></li>
        <li><a href="#configure-subnet-routing">Configure subnet routing</a></li>
        <li><a href="#tcp-connection">TCP connection</a></li>
        <li><a href="#summary">Summary</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>In this article I will demonstrate how to use the command to connect processes in different subnets of the network namespace through a pair of <code>veth</code> interfaces.</p>
<h2 id="network-namespaces">Network Namespaces</h2>
<p>We know that the container runtime uses the namespace (namespace) kernel function to partition system resources for some form of process isolation, so that changes to resources in one namespace do not affect resources in other namespaces, including process IDs, host names, user IDs, file names, network interfaces, etc.</p>
<p>Network namespaces can virtualize network stacks, and each network namespace has its own resources, such as network interfaces, IP addresses, routing tables, tunnels, firewalls, etc. For example, rules added to a network namespace by iptables will only affect traffic entering and leaving that namespace.</p>
<h2 id="ip-command">ip command</h2>
<p>The ip command is used to display or manipulate routes, network devices, policy routes, and tunnels for Linux hosts, and is a newer and powerful network configuration tool for Linux.</p>
<p>The usage of this command is shown below.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">ip <span class="o">[</span>OPTIONS<span class="o">]</span> OBJECT COMMAND <span class="o">[</span>ARGUMENTS<span class="o">]</span>
<span class="c1"># where </span>
<span class="c1">#   OPTIONS are general global options</span>
<span class="c1">#   OBJECT := { link | address | addrlabel | route |</span>
<span class="c1">#     rule | neigh | ntable | tunnel | tuntap | maddress | </span>
<span class="c1">#     mroute | mrule | monitor | xfrm | netns | l2tp | </span>
<span class="c1">#     tcp_metrics }</span>
<span class="c1">#   COMMAND is the action to perform on the object, such as,</span>
<span class="c1">#     show, add, del etc.</span>
<span class="c1">#   ARGUMENTS are arguments specific to the kind of OBJECT </span>
<span class="c1">#     and COMMAND</span>
</code></pre></td></tr></table>
</div>
</div><p>Example.</p>
<ul>
<li>To add a new network interface, use the <code>ip link add &lt;interface-name&gt; type &lt;interface-type&gt; &lt;interface-arguments&gt;...</code> command</li>
<li>To assign a new IP address range to an interface, use the <code>ip addr add &lt;ip-address-range&gt; dev &lt;device-name&gt;</code> command</li>
<li>To remove a route from the routing table, use the <code>ip route del &lt;route-ip-range&gt; dev &lt;device-name&gt;</code> command</li>
</ul>
<p>The <code>-n</code> option can be used to switch the destination namespace, for example, to assign the <code>10.0.1.0/24</code> IP address range to interface veth0 in the ns1 network namespace, use the <code>ip -n ns1 addr add 10.0.1.0/24 dev veth0</code> command .</p>
<blockquote>
<p>💡 The <code>-n</code> option is short for <code>ip netns exec</code></p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/10/993e96fad1a54782aff2a877f0d28530.png" alt=""></p>
<h2 id="configure-the-first-network-namespace">Configure the first network namespace</h2>
<p>First we use the <code>ip link add</code> command to create a new pair of veth interfaces: veth0 and veth1.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># 创建一对名为 veth0 和 veth1 的 veth 接口。</span>
$ ip link add veth0 <span class="nb">type</span> veth peer name veth1

<span class="c1"># 确认 veth0 已创建</span>
$ ip link show veth0
289: veth0@veth1: &lt;BROADCAST,MULTICAST&gt; mtu <span class="m">1500</span> qdisc noop state DOWN mode DEFAULT group default qlen <span class="m">1000</span>
    link/ether 5e:87:df:87:af:c7 brd ff:ff:ff:ff:ff:ff

<span class="c1"># 确认 veth1 已创建</span>
$ ip link show veth1
288: veth1@veth0: &lt;BROADCAST,MULTICAST&gt; mtu <span class="m">1500</span> qdisc noop state DOWN mode DEFAULT group default qlen <span class="m">1000</span>
    link/ether be:0d:a4:8c:9f:2a brd ff:ff:ff:ff:ff:ff
</code></pre></td></tr></table>
</div>
</div><p>A veth interface is usually created as a pair in which data transmitted at one end is immediately received at the other end, and this type of interface is typically used to transfer packets between different network namespaces when the container is running.</p>
<p>Let&rsquo;s create the first network namespace, ns1, and then we can assign the veth0 interface to this network namespace and the IP address range of 10.0.1.0/24 to it.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># 创建 ns1 网络命名空间</span>
$ ip netns add ns1

<span class="c1"># 分配 veth0 接口到 ns1 网络命名空间</span>
$ ip link <span class="nb">set</span> veth0 netns ns1

<span class="c1"># 将 10.0.1.0/24 IP 地址范围分配给 veth0 接口</span>
$ ip -n ns1 addr add 10.0.1.0/24 dev veth0

<span class="c1"># 将 veth0 接口 up 起来</span>
$ ip -n ns1 link <span class="nb">set</span> veth0 up

<span class="c1"># 将 lo 接口 up 起来，因为发往 10.0.1.0/24 的数据（本地的）</span>
<span class="c1"># （像 ping）要通过 local（本地）路由表</span>
<span class="c1"># 比如要 ping 自己</span>
$ ip -n ns1 link <span class="nb">set</span> lo up 

<span class="c1"># 确认接口已经 up 起来</span>
$ ip -n ns1 addr show
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span class="m">65536</span> qdisc noqueue state UNKNOWN group default qlen <span class="m">1000</span>
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
289: veth0@if288: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu <span class="m">1500</span> qdisc noqueue state LOWERLAYERDOWN group default qlen <span class="m">1000</span>
    link/ether 5e:87:df:87:af:c7 brd ff:ff:ff:ff:ff:ff link-netnsid <span class="m">0</span>
    inet 10.0.1.0/24 scope global veth0
       valid_lft forever preferred_lft forever
</code></pre></td></tr></table>
</div>
</div><p>Now what happens if we go ping the veth0 interface from both the host and ns1 network namespaces?</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># veth0 不在主机的根网络命名空间中</span>
$ ip link show veth0            
Device <span class="s2">&#34;veth0&#34;</span> does not exist.

<span class="c1"># 从主机网络命名空间中 ping 不通</span>
$ ping -c10 10.0.1.0
PING 10.0.1.0 <span class="o">(</span>10.0.1.0<span class="o">)</span> 56<span class="o">(</span>84<span class="o">)</span> bytes of data.
^C
--- 10.0.1.0 ping statistics ---
<span class="m">3</span> packets transmitted, <span class="m">0</span> received, 100% packet loss, <span class="nb">time</span> 1999ms
</code></pre></td></tr></table>
</div>
</div><p>We can see that the interface veth0 is not found directly in the root network namespace of the host, and of course it is also pinging different 10.0.1.0 addresses because they are bound to the ns1 network namespace, so we need to switch to this namespace when we operate.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">$ ip netns <span class="nb">exec</span> ns1 ping -c10 10.0.1.0
PING 10.0.1.0 <span class="o">(</span>10.0.1.0<span class="o">)</span> 56<span class="o">(</span>84<span class="o">)</span> bytes of data.
<span class="m">64</span> bytes from 10.0.1.0: <span class="nv">icmp_seq</span><span class="o">=</span><span class="m">1</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">64</span> <span class="nv">time</span><span class="o">=</span>0.121 ms
<span class="m">64</span> bytes from 10.0.1.0: <span class="nv">icmp_seq</span><span class="o">=</span><span class="m">2</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">64</span> <span class="nv">time</span><span class="o">=</span>0.063 ms
<span class="m">64</span> bytes from 10.0.1.0: <span class="nv">icmp_seq</span><span class="o">=</span><span class="m">3</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">64</span> <span class="nv">time</span><span class="o">=</span>0.066 ms
<span class="m">64</span> bytes from 10.0.1.0: <span class="nv">icmp_seq</span><span class="o">=</span><span class="m">4</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">64</span> <span class="nv">time</span><span class="o">=</span>0.109 ms
^C
--- 10.0.1.0 ping statistics ---
<span class="m">4</span> packets transmitted, <span class="m">4</span> received, 0% packet loss, <span class="nb">time</span> 3000ms
rtt min/avg/max/mdev <span class="o">=</span> 0.063/0.089/0.121/0.028 ms
</code></pre></td></tr></table>
</div>
</div><p>Here we use an <code>ip netns exec</code> command, which allows us to execute any command in the specified network namespace, and we can see that we can now ping <code>10.0.1.0</code> in the ns1 network namespace.</p>
<h2 id="configure-a-second-network-namespace">Configure a second network namespace</h2>
<p>Let&rsquo;s use the above to create a second network namespace <code>ns2</code>, then assign the veth1 interface to this network namespace and the IP address range <code>10.0.2.0/24</code> to this interface.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># 创建名为 ns2 的网络命名空间</span>
$ ip netns add ns2

<span class="c1"># 分配 veth1 接口到 ns2 网络命名空间</span>
$ ip link <span class="nb">set</span> veth1 netns ns2

<span class="c1"># 将 10.0.2.0/24 IP 地址范围分配给 veth1 接口</span>
$ ip -n ns2 addr add 10.0.2.0/24 dev veth1

<span class="c1"># 将 veth1 接口 up 起来</span>
$ ip -n ns2 link <span class="nb">set</span> veth1 up

<span class="c1"># 将 lo 口 up 起来（这样可以 ping 通自己）</span>
$ ip -n ns2 link <span class="nb">set</span> lo up 

$ ip -n ns2 addr show
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span class="m">65536</span> qdisc noqueue state UNKNOWN group default qlen <span class="m">1000</span>
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
288: veth1@if289: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="m">1500</span> qdisc noqueue state UP group default qlen <span class="m">1000</span>
    link/ether be:0d:a4:8c:9f:2a brd ff:ff:ff:ff:ff:ff link-netnsid <span class="m">0</span>
    inet 10.0.2.0/24 scope global veth1
       valid_lft forever preferred_lft forever
    inet6 fe80::bc0d:a4ff:fe8c:9f2a/64 scope link
       valid_lft forever preferred_lft forever
</code></pre></td></tr></table>
</div>
</div><p>To make it easier to set up routes later, here we assign a different subnet IP range to the veth1 interface. Similar to the veth0 interface, the veth1 interface cannot be reached from the host network namespace and can only work within the ns2&rsquo;s own network namespace.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">$ ip link show veth1
Device <span class="s2">&#34;veth1&#34;</span> does not exist.
$ ping -c10 10.0.2.0
PING 10.0.2.0 <span class="o">(</span>10.0.2.0<span class="o">)</span> 56<span class="o">(</span>84<span class="o">)</span> bytes of data.
From 180.149.159.13 <span class="nv">icmp_seq</span><span class="o">=</span><span class="m">2</span> Packet filtered
^C
--- 10.0.2.0 ping statistics ---
<span class="m">2</span> packets transmitted, <span class="m">0</span> received, +1 errors, 100% packet loss, <span class="nb">time</span> <span class="m">999</span>
$ ip netns <span class="nb">exec</span> ns2 ping -c10 10.0.2.0
PING 10.0.2.0 <span class="o">(</span>10.0.2.0<span class="o">)</span> 56<span class="o">(</span>84<span class="o">)</span> bytes of data.
<span class="m">64</span> bytes from 10.0.2.0: <span class="nv">icmp_seq</span><span class="o">=</span><span class="m">1</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">64</span> <span class="nv">time</span><span class="o">=</span>0.100 ms
<span class="m">64</span> bytes from 10.0.2.0: <span class="nv">icmp_seq</span><span class="o">=</span><span class="m">2</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">64</span> <span class="nv">time</span><span class="o">=</span>0.096 ms
<span class="m">64</span> bytes from 10.0.2.0: <span class="nv">icmp_seq</span><span class="o">=</span><span class="m">3</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">64</span> <span class="nv">time</span><span class="o">=</span>0.068 ms
^C
--- 10.0.2.0 ping statistics ---
<span class="m">3</span> packets transmitted, <span class="m">3</span> received, 0% packet loss, <span class="nb">time</span> 1999ms
rtt min/avg/max/mdev <span class="o">=</span> 0.068/0.088/0.100/0.014 ms
</code></pre></td></tr></table>
</div>
</div><h2 id="configure-subnet-routing">Configure subnet routing</h2>
<p>Although each can access itself in the above two network spaces, they cannot ping through to each other.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">$ ip netns <span class="nb">exec</span> ns1 ping -c10 10.0.2.0
connect: Network is unreachable
$ ip netns <span class="nb">exec</span> ns2 ping -c10 10.0.1.0
connect: Network is unreachable
</code></pre></td></tr></table>
</div>
</div><p>Both veth0 and veth1 interfaces are up and pinging in various network namespaces works fine, so they are not directly connected to each other, which is probably related to routing. Let&rsquo;s use the ip command to debug this. We can use the <code>ip route get</code> command to determine the route a packet is taking.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">$ ip -n ns1 route get 10.0.2.0
RTNETLINK answers: Network is unreachable
$ ip -n ns2 route get 10.0.1.0
RTNETLINK answers: Network is unreachable
</code></pre></td></tr></table>
</div>
</div><p>We can see that both are network unreachable. Let&rsquo;s check the routing table information in the two network namespaces.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">$ ip -n ns1 route
10.0.1.0/24 dev veth0 proto kernel scope link src 10.0.1.0
$ ip -n ns2 route
10.0.2.0/24 dev veth1 proto kernel scope link src 10.0.2.0
</code></pre></td></tr></table>
</div>
</div><p>See the routing table is not very clear, the routing table of two network namespaces are only the routing entries of their respective IP ranges, and there is no route to other subnets, so of course can not interoperate, to solve is also very simple, you can use the <code>ip route add</code> command to insert a new route entry in the routing table is not it can be.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># 更新 veth0 路由表，添加一条通往 10.0.2.0/24 的路由</span>
$ ip -n ns1 route add 10.0.2.0/24 dev veth0

<span class="c1"># 确认发往 10.0.2.0/24 的数据包被路由到 veth0</span>
$ ip -n ns1 route get 10.0.2.0
10.0.2.0 dev veth0 src 10.0.1.0
    cache

<span class="c1"># 同样更新 veth1 路由表，添加一条通往 10.0.1.0/24 的路由</span>
$ ip -n ns2 route add 10.0.1.0/24 dev veth1

<span class="c1"># 确认发往 10.0.1.0/24 的数据包被路由到 veth1</span>
$ ip -n ns2 route get 10.0.1.0
10.0.1.0 dev veth1 src 10.0.2.0
    cache
</code></pre></td></tr></table>
</div>
</div><p>Above we added each other&rsquo;s routing information to our respective network namespaces, now let&rsquo;s try to ping each other&rsquo;s veth interfaces.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">$ ip netns <span class="nb">exec</span> ns1 ping -c10 10.0.2.0
PING 10.0.2.0 <span class="o">(</span>10.0.2.0<span class="o">)</span> 56<span class="o">(</span>84<span class="o">)</span> bytes of data.
<span class="m">64</span> bytes from 10.0.2.0: <span class="nv">icmp_seq</span><span class="o">=</span><span class="m">1</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">64</span> <span class="nv">time</span><span class="o">=</span>0.140 ms
<span class="m">64</span> bytes from 10.0.2.0: <span class="nv">icmp_seq</span><span class="o">=</span><span class="m">2</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">64</span> <span class="nv">time</span><span class="o">=</span>0.080 ms
<span class="m">64</span> bytes from 10.0.2.0: <span class="nv">icmp_seq</span><span class="o">=</span><span class="m">3</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">64</span> <span class="nv">time</span><span class="o">=</span>0.091 ms
^C
--- 10.0.2.0 ping statistics ---
<span class="m">3</span> packets transmitted, <span class="m">3</span> received, 0% packet loss, <span class="nb">time</span> 1999ms
rtt min/avg/max/mdev <span class="o">=</span> 0.080/0.103/0.140/0.028 ms

$ ip netns <span class="nb">exec</span> ns2 ping -c10 10.0.1.0
PING 10.0.1.0 <span class="o">(</span>10.0.1.0<span class="o">)</span> 56<span class="o">(</span>84<span class="o">)</span> bytes of data.
<span class="m">64</span> bytes from 10.0.1.0: <span class="nv">icmp_seq</span><span class="o">=</span><span class="m">1</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">64</span> <span class="nv">time</span><span class="o">=</span>0.114 ms
<span class="m">64</span> bytes from 10.0.1.0: <span class="nv">icmp_seq</span><span class="o">=</span><span class="m">2</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">64</span> <span class="nv">time</span><span class="o">=</span>0.084 ms
<span class="m">64</span> bytes from 10.0.1.0: <span class="nv">icmp_seq</span><span class="o">=</span><span class="m">3</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">64</span> <span class="nv">time</span><span class="o">=</span>0.086 ms
^C
--- 10.0.1.0 ping statistics ---
<span class="m">3</span> packets transmitted, <span class="m">3</span> received, 0% packet loss, <span class="nb">time</span> 2000ms
rtt min/avg/max/mdev <span class="o">=</span> 0.084/0.094/0.114/0.017 ms
</code></pre></td></tr></table>
</div>
</div><p>You can see that it has been passed! 🎉🎉🎉🎉</p>
<p>We can also use <code>tcpdump</code> to capture the packets transmitted between two network namespaces.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">$ ip netns <span class="nb">exec</span> ns1 tcpdump -i veth0 icmp -l
tcpdump: verbose output suppressed, use -v or -vv <span class="k">for</span> full protocol decode
listening on veth0, link-type EN10MB <span class="o">(</span>Ethernet<span class="o">)</span>, capture size <span class="m">262144</span> bytes
11:29:22.080392 IP 10.0.2.0 &gt; 10.0.1.0: ICMP <span class="nb">echo</span> request, id 7253, seq 1, length <span class="m">64</span>
11:29:22.080464 IP 10.0.1.0 &gt; 10.0.2.0: ICMP <span class="nb">echo</span> reply, id 7253, seq 1, length <span class="m">64</span>
11:29:23.080409 IP 10.0.2.0 &gt; 10.0.1.0: ICMP <span class="nb">echo</span> request, id 7253, seq 2, length <span class="m">64</span>
11:29:23.080472 IP 10.0.1.0 &gt; 10.0.2.0: ICMP <span class="nb">echo</span> reply, id 7253, seq 2, length <span class="m">64</span>
11:29:24.080357 IP 10.0.2.0 &gt; 10.0.1.0: ICMP <span class="nb">echo</span> request, id 7253, seq 3, length <span class="m">64</span>
11:29:24.080418 IP 10.0.1.0 &gt; 10.0.2.0: ICMP <span class="nb">echo</span> reply, id 7253, seq 3, length <span class="m">64</span>
11:29:25.080346 IP 10.0.2.0 &gt; 10.0.1.0: ICMP <span class="nb">echo</span> request, id 7253, seq 4, length <span class="m">64</span>
11:29:25.080401 IP 10.0.1.0 &gt; 10.0.2.0: ICMP <span class="nb">echo</span> reply, id 7253, seq 4, length <span class="m">64</span>
11:29:26.080417 IP 10.0.2.0 &gt; 10.0.1.0: ICMP <span class="nb">echo</span> request, id 7253, seq 5, length <span class="m">64</span>
11:29:26.080496 IP 10.0.1.0 &gt; 10.0.2.0: ICMP <span class="nb">echo</span> reply, id 7253, seq 5, length <span class="m">64</span>
11:29:27.080454 IP 10.0.2.0 &gt; 10.0.1.0: ICMP <span class="nb">echo</span> request, id 7253, seq 6, length <span class="m">64</span>
11:29:27.080507 IP 10.0.1.0 &gt; 10.0.2.0: ICMP <span class="nb">echo</span> reply, id 7253, seq 6, length <span class="m">64</span>
11:29:28.080398 IP 10.0.2.0 &gt; 10.0.1.0: ICMP <span class="nb">echo</span> request, id 7253, seq 7, length <span class="m">64</span>
11:29:28.080456 IP 10.0.1.0 &gt; 10.0.2.0: ICMP <span class="nb">echo</span> reply, id 7253, seq 7, length <span class="m">64</span>
11:29:29.080390 IP 10.0.2.0 &gt; 10.0.1.0: ICMP <span class="nb">echo</span> request, id 7253, seq 8, length <span class="m">64</span>
11:29:29.080431 IP 10.0.1.0 &gt; 10.0.2.0: ICMP <span class="nb">echo</span> reply, id 7253, seq 8, length <span class="m">64</span>
11:29:30.080524 IP 10.0.2.0 &gt; 10.0.1.0: ICMP <span class="nb">echo</span> request, id 7253, seq 9, length <span class="m">64</span>
11:29:30.080576 IP 10.0.1.0 &gt; 10.0.2.0: ICMP <span class="nb">echo</span> reply, id 7253, seq 9, length <span class="m">64</span>
11:29:31.081895 IP 10.0.2.0 &gt; 10.0.1.0: ICMP <span class="nb">echo</span> request, id 7253, seq 10, length <span class="m">64</span>
11:29:31.081942 IP 10.0.1.0 &gt; 10.0.2.0: ICMP <span class="nb">echo</span> reply, id 7253, seq 10, length <span class="m">64</span>
^C
<span class="m">20</span> packets captured
<span class="m">20</span> packets received by filter
<span class="m">0</span> packets dropped by kernel
</code></pre></td></tr></table>
</div>
</div><h2 id="tcp-connection">TCP connection</h2>
<p>Better yet, let&rsquo;s test the TCP connection by starting a TCP server on port 7096 in the ns1 namespace using the nc command, and then initiating a TCP handshake connection from the ns2 network namespace.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">$ ip netns <span class="nb">exec</span> ns1 nc -l 10.0.1.0 <span class="m">7096</span> -v
<span class="nb">exec</span> of <span class="s2">&#34;nc&#34;</span> failed: No such file or directory
</code></pre></td></tr></table>
</div>
</div><p>The above command reports an error because we haven&rsquo;t installed the ns tool yet, once it is installed it will be fine.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">$ yum install -y nc

$ ip netns <span class="nb">exec</span> ns1 nc -l 10.0.1.0 <span class="m">7096</span> -v
Ncat: Version 7.50 <span class="o">(</span> https://nmap.org/ncat <span class="o">)</span>
Ncat: Listening on 10.0.1.0:7096
</code></pre></td></tr></table>
</div>
</div><p>Then reopen a terminal to connect.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># 使用 nc 从 ns2 发起 TCP 握手</span>
$ ip netns <span class="nb">exec</span> ns2 nc -4t 10.0.1.0 <span class="m">7096</span> -v
Ncat: Version 7.50 <span class="o">(</span> https://nmap.org/ncat <span class="o">)</span>
Ncat: Connected to 10.0.1.0:7096.

<span class="c1"># 这个时候正常会在前面的服务中看到连接状态</span>
$ ip netns <span class="nb">exec</span> ns1 nc -l 10.0.1.0 <span class="m">7096</span> -v
Ncat: Version 7.50 <span class="o">(</span> https://nmap.org/ncat <span class="o">)</span>
Ncat: Listening on 10.0.1.0:7096
Ncat: Connection from 10.0.2.0.
Ncat: Connection from 10.0.2.0:34090.
</code></pre></td></tr></table>
</div>
</div><p>Once the TCP connection is established, we can send test messages from ns2 to ns1.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">$ ip netns <span class="nb">exec</span> ns2 nc -4t 10.0.1.0 <span class="m">7096</span> -v
Ncat: Version 7.50 <span class="o">(</span> https://nmap.org/ncat <span class="o">)</span>
Ncat: Connected to 10.0.1.0:7096.
this is a <span class="nb">test</span> message  <span class="c1"># 在这里输入一段信息</span>
</code></pre></td></tr></table>
</div>
</div><p>At this point, our server side on the ns1 side will also receive the message sent.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">$ ip netns <span class="nb">exec</span> ns1 nc -l 10.0.1.0 <span class="m">7096</span> -v
Ncat: Version 7.50 <span class="o">(</span> https://nmap.org/ncat <span class="o">)</span>
Ncat: Listening on 10.0.1.0:7096
Ncat: Connection from 10.0.2.0.
Ncat: Connection from 10.0.2.0:34090.
this is a <span class="nb">test</span> message
</code></pre></td></tr></table>
</div>
</div><p>We can also use tcpdump to grab all packets transmitted between two network namespaces.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">$ ip netns <span class="nb">exec</span> ns1 tcpdump -X -i veth0 -n tcp -l
tcpdump: verbose output suppressed, use -v or -vv <span class="k">for</span> full protocol decode
listening on veth0, link-type EN10MB <span class="o">(</span>Ethernet<span class="o">)</span>, capture size <span class="m">262144</span> bytes
11:42:59.912176 IP 10.0.2.0.34090 &gt; 10.0.1.0.7096: Flags <span class="o">[</span>P.<span class="o">]</span>, seq 118819706:118819735, ack 1587208228, win 229, options <span class="o">[</span>nop,nop,TS val <span class="m">1970393377</span> ecr 1970365937<span class="o">]</span>, length <span class="m">29</span>
	0x0000:  <span class="m">4500</span> <span class="m">0051</span> ad52 <span class="m">4000</span> <span class="m">4006</span> <span class="m">7655</span> 0a00 <span class="m">0200</span>  E..Q.R@.@.vU....
	0x0010:  0a00 <span class="m">0100</span> 852a 1bb8 <span class="m">0715</span> 0b7a 5e9a e024  .....*.....z^..$
	0x0020:  <span class="m">8018</span> 00e5 <span class="m">1743</span> <span class="m">0000</span> <span class="m">0101</span> 080a <span class="m">7571</span> d121  .....C......uq.!
	0x0030:  <span class="m">7571</span> 65f1 <span class="m">7468</span> <span class="m">6973</span> <span class="m">2069</span> <span class="m">7320</span> 616e 6f74  uqe.this.is.anot
	0x0040:  <span class="m">6865</span> <span class="m">7220</span> <span class="m">7465</span> <span class="m">7374</span> 206d <span class="m">6573</span> <span class="m">7361</span> <span class="m">6765</span>  her.test.message
	0x0050:  0a                                       .
11:42:59.912207 IP 10.0.1.0.7096 &gt; 10.0.2.0.34090: Flags <span class="o">[</span>.<span class="o">]</span>, ack 29, win 227, options <span class="o">[</span>nop,nop,TS val <span class="m">1970393377</span> ecr 1970393377<span class="o">]</span>, length <span class="m">0</span>
	0x0000:  <span class="m">4500</span> <span class="m">0034</span> <span class="m">4612</span> <span class="m">4000</span> <span class="m">4006</span> ddb2 0a00 <span class="m">0100</span>  E..4F.@.@.......
	0x0010:  0a00 <span class="m">0200</span> 1bb8 852a 5e9a e024 <span class="m">0715</span> 0b97  .......*^..$....
	0x0020:  <span class="m">8010</span> 00e3 <span class="m">1726</span> <span class="m">0000</span> <span class="m">0101</span> 080a <span class="m">7571</span> d121  .....<span class="p">&amp;</span>......uq.!
	0x0030:  <span class="m">7571</span> d121                                uq.!
</code></pre></td></tr></table>
</div>
</div><p>Of course, you can also save this packet capture result and then use other tools such as Jaws to analyze it in detail.</p>
<h2 id="summary">Summary</h2>
<p>In this article, we use the ip subcommand to create and configure network namespaces, interfaces, routes, etc. We create a pair of veth interfaces that are assigned to two different network namespaces with different subnet IP address ranges, and configure additional routes in the routing table of the network namespace, which enables communication between the two subnets.</p>
<p>Neither veth interface is directly reachable from the host network namespace because their IP address ranges and routing table changes are also isolated in their own network namespaces.</p>
<p>We can use the <code>ip netns exec</code> command to run the tool and tcpdump to debug connectivity issues between the network namespaces.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/linux/">linux</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2021-10/code-k8s-yaml-templating/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Write a do-it-yourself Kubernetes YAML templating tool</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2021-10/add-dns-record-for-pod/">
            <span class="next-text nav-default">Adding DNS records to Pods</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
