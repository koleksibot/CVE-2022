<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>More than 100,000 words of detailed analysis of the implementation principle of Stream in the JDK - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Prerequisites Stream was first introduced in JDK1.8, nearly 8 years ago (JDK1.8 was released at the end of 2013), and the introduction of Stream greatly simplified some development scenarios, but on the other hand, it may have reduced the readability of the code (it is true that many people say that Stream will reduce the readability of the code, but in my opinion, the readability of the code is improved" /><meta name="keywords" content="Java, Stream" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2021-10/stream-of-jdk/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="More than 100,000 words of detailed analysis of the implementation principle of Stream in the JDK" />
<meta property="og:description" content="Prerequisites Stream was first introduced in JDK1.8, nearly 8 years ago (JDK1.8 was released at the end of 2013), and the introduction of Stream greatly simplified some development scenarios, but on the other hand, it may have reduced the readability of the code (it is true that many people say that Stream will reduce the readability of the code, but in my opinion, the readability of the code is improved" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2021-10/stream-of-jdk/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-10-06T22:20:38+08:00" />
<meta property="article:modified_time" content="2021-10-06T22:20:38+08:00" />

<meta itemprop="name" content="More than 100,000 words of detailed analysis of the implementation principle of Stream in the JDK">
<meta itemprop="description" content="Prerequisites Stream was first introduced in JDK1.8, nearly 8 years ago (JDK1.8 was released at the end of 2013), and the introduction of Stream greatly simplified some development scenarios, but on the other hand, it may have reduced the readability of the code (it is true that many people say that Stream will reduce the readability of the code, but in my opinion, the readability of the code is improved"><meta itemprop="datePublished" content="2021-10-06T22:20:38+08:00" />
<meta itemprop="dateModified" content="2021-10-06T22:20:38+08:00" />
<meta itemprop="wordCount" content="36178">
<meta itemprop="keywords" content="java," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="More than 100,000 words of detailed analysis of the implementation principle of Stream in the JDK"/>
<meta name="twitter:description" content="Prerequisites Stream was first introduced in JDK1.8, nearly 8 years ago (JDK1.8 was released at the end of 2013), and the introduction of Stream greatly simplified some development scenarios, but on the other hand, it may have reduced the readability of the code (it is true that many people say that Stream will reduce the readability of the code, but in my opinion, the readability of the code is improved"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">More than 100,000 words of detailed analysis of the implementation principle of Stream in the JDK</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-10-06 22:20:38 </span>
        <div class="post-category">
            <a href="/categories/skills/"> skills </a>
            <a href="/categories/implementation-details/"> implementation-details </a>
            </div>
          <span class="more-meta"> 36178 words </span>
          <span class="more-meta"> 73 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#prerequisites">Prerequisites</a></li>
        <li><a href="#how-stream-is-forward-compatible">How Stream is forward compatible</a></li>
        <li><a href="#splittable-iterator-spliterator">Splittable Iterator Spliterator</a>
          <ul>
            <li><a href="#spliterator-interface-methods">Spliterator interface methods</a></li>
            <li><a href="#spliterator-self-splitting">Spliterator Self-Splitting</a></li>
            <li><a href="#features-supported-by-spliterator">Features supported by Spliterator</a></li>
          </ul>
        </li>
        <li><a href="#the-principle-of-stream-implementation-and-source-code-analysis">The principle of stream implementation and source code analysis</a>
          <ul>
            <li><a href="#streamopflag-source-code-analysis">StreamOpFlag source code analysis</a></li>
          </ul>
        </li>
        <li><a href="#referencepipeline-source-code-analysis">ReferencePipeline source code analysis</a>
          <ul>
            <li><a href="#main-interfaces">Main interfaces</a></li>
            <li><a href="#sink-and-reference-type-chains">Sink and reference type chains</a></li>
            <li><a href="#implementation-of-abstractpipeline-and-referencepipeline">Implementation of AbstractPipeline and ReferencePipeline</a></li>
          </ul>
        </li>
        <li><a href="#source-code-implementation-of-stream-intermediate-operations">Source code implementation of stream intermediate operations</a></li>
        <li><a href="#source-code-implementation-of-synchronous-execution-of-stream-termination-operations">Source code implementation of synchronous execution of stream termination operations</a></li>
        <li><a href="#source-code-implementation-of-stream-concurrent-execution">Source code implementation of stream concurrent execution</a></li>
        <li><a href="#state-operation-and-short-circuit-operation">State operation and short-circuit operation</a></li>
        <li><a href="#summary">Summary</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="prerequisites">Prerequisites</h2>
<p>Stream was first introduced in JDK1.8, nearly 8 years ago (JDK1.8 was released at the end of 2013), and the introduction of Stream greatly simplified some development scenarios, but on the other hand, it may have reduced the readability of the code (it is true that many people say that Stream will reduce the readability of the code, but in my opinion, the readability of the code is improved after proficient use). (I think the readability of the code has been improved after using it skillfully). This article will spend a huge amount of space to analyze in detail the underlying implementation principle of Stream, the reference source code is the source code of JDK11, other versions of the JDK may not apply to this article in the source code display and related examples.</p>
<blockquote>
<p>This article has taken a lot of time and effort to sort out and write, and I hope it will help the readers of this article</p>
</blockquote>
<h2 id="how-stream-is-forward-compatible">How Stream is forward compatible</h2>
<p>Stream is introduced in JDK1.8, such as the need for JDK1.7 or previous code can also run in JDK1.8 or above, then the introduction of Stream must not have been released in the original interface methods to modify, otherwise it will certainly be due to compatibility issues that lead to the old version of the interface implementation can not run in the new version (method signature exceptions), guess is based on this The problem is based on the introduction of the interface default method, that is, the default keyword. A look at the source code shows that ArrayList&rsquo;s superclasses Collection and Iterable have added several default methods.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="c1">// java.util.Collection部分源码
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Collection</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="c1">// 省略其他代码
</span><span class="c1"></span>
    <span class="nd">@Override</span>
    <span class="k">default</span> <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="nf">spliterator</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">Spliterators</span><span class="o">.</span><span class="na">spliterator</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">0</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">default</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="nf">stream</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">StreamSupport</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">spliterator</span><span class="o">(),</span> <span class="kc">false</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">default</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="nf">parallelStream</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">StreamSupport</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">spliterator</span><span class="o">(),</span> <span class="kc">true</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// java.lang.Iterable部分源码
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Iterable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="c1">// 省略其他代码
</span><span class="c1"></span>
    <span class="k">default</span> <span class="kt">void</span> <span class="nf">forEach</span><span class="o">(</span><span class="n">Consumer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">action</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Objects</span><span class="o">.</span><span class="na">requireNonNull</span><span class="o">(</span><span class="n">action</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">T</span> <span class="n">t</span> <span class="o">:</span> <span class="k">this</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">action</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">default</span> <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">spliterator</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">Spliterators</span><span class="o">.</span><span class="na">spliteratorUnknownSize</span><span class="o">(</span><span class="n">iterator</span><span class="o">(),</span> <span class="n">0</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>From intuition, these new methods should be the key methods implemented in Stream (later will confirm that this is not intuition, but the result of viewing the source code). Interface default methods are consistent in use with the instance methods, in the implementation can be written directly in the interface methods method body, a bit of static methods, but subclasses can override its implementation (that is, the interface default methods in this interface implementation is a bit like static methods, can be overridden by subclasses, consistent in use with the instance methods). This implementation could be a breakthrough or a compromise, but both the compromise and the breakthrough achieve forward compatibility.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="c1">// JDK1.7中的java.lang.Iterable
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Iterable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="n">Iterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">iterator</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// JDK1.7中的Iterable实现
</span><span class="c1"></span><span class="kd">public</span> <span class="n">MyIterable</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;{</span>

    <span class="kd">public</span> <span class="n">Iterator</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="nf">iterator</span><span class="o">(){</span>
         <span class="o">....</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>As above, MyIterable is defined in JDK1.7, if the class runs in JDK1.8, then calling its forEach() and spliterator() methods in its example is equivalent to directly calling the default methods forEach() and spliterator() of the interface in Iterable in JDK1.8. Of course, limited by the JDK version, here can only ensure that the compilation passed, the old function is used normally, and can not use the JDK1.7 in the Stream-related functions or use the default method keyword. To sum up so much, is to explain why the code developed and compiled using JDK7 can run in the JDK8 environment.</p>
<h2 id="splittable-iterator-spliterator">Splittable Iterator Spliterator</h2>
<p>The cornerstone of Stream implementation is Spliterator, which stands for &ldquo;splitable iterator&rdquo; and is used to iterate over elements in a specified data source (e.g., array, collection, or IO Channel). It is designed with serial and parallel scenarios in mind. As mentioned in the previous section, Collection has a default interface method spliterator(), which generates a Spliterator<E> instance, meaning that all collection subclasses have the ability to create Spliterator instances. The Stream implementation is very similar in design to the ChannelHandlerContext in Netty, which is essentially a chain table, and the Spliterator is the Head node of this chain (the Spliterator instance is the head node of a stream instance, which will be expanded later when the specific source code is analyzed).</p>
<h3 id="spliterator-interface-methods">Spliterator interface methods</h3>
<p>Moving on to the methods defined by the Spliterator interface.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Spliterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="c1">// 暂时省略其他代码
</span><span class="c1"></span>
    <span class="kt">boolean</span> <span class="nf">tryAdvance</span><span class="o">(</span><span class="n">Consumer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">action</span><span class="o">);</span>

    <span class="k">default</span> <span class="kt">void</span> <span class="nf">forEachRemaining</span><span class="o">(</span><span class="n">Consumer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">action</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">do</span> <span class="o">{</span> <span class="o">}</span> <span class="k">while</span> <span class="o">(</span><span class="n">tryAdvance</span><span class="o">(</span><span class="n">action</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">trySplit</span><span class="o">();</span>

    <span class="kt">long</span> <span class="nf">estimateSize</span><span class="o">();</span>

    <span class="k">default</span> <span class="kt">long</span> <span class="nf">getExactSizeIfKnown</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">characteristics</span><span class="o">()</span> <span class="o">&amp;</span> <span class="n">SIZED</span><span class="o">)</span> <span class="o">==</span> <span class="n">0</span> <span class="o">?</span> <span class="o">-</span><span class="n">1L</span> <span class="o">:</span> <span class="n">estimateSize</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kt">int</span> <span class="nf">characteristics</span><span class="o">();</span>

    <span class="k">default</span> <span class="kt">boolean</span> <span class="nf">hasCharacteristics</span><span class="o">(</span><span class="kt">int</span> <span class="n">characteristics</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">characteristics</span><span class="o">()</span> <span class="o">&amp;</span> <span class="n">characteristics</span><span class="o">)</span> <span class="o">==</span> <span class="n">characteristics</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">default</span> <span class="n">Comparator</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="nf">getComparator</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="c1">// 暂时省略其他代码
</span><span class="c1"></span><span class="o">}</span>

</code></pre></td></tr></table>
</div>
</div><p>tryAdvance</p>
<ul>
<li>Method signature: <code>boolean tryAdvance(Consumer&lt;? super T&gt; action)</code></li>
<li>Function: If the Spliterator has the ORDERED feature enabled, the action callback passed in is executed for one of the elements and returns true, otherwise it returns false. if the Spliterator has the ORDERED feature enabled, it will process the next element in order (where the order value can be analogous to the subscript of the container array elements in an ArrayList. Adding new elements to an ArrayList is naturally ordered, with subscripts incrementing from zero) to the next element</li>
<li>Example.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">2</span><span class="o">);</span>
    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">3</span><span class="o">);</span>
    <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">spliterator</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">spliterator</span><span class="o">();</span>
    <span class="kd">final</span> <span class="n">AtomicInteger</span> <span class="n">round</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicInteger</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
    <span class="kd">final</span> <span class="n">AtomicInteger</span> <span class="n">loop</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicInteger</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">spliterator</span><span class="o">.</span><span class="na">tryAdvance</span><span class="o">(</span><span class="n">num</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">&#34;第%d轮回调Action,值:%d\n&#34;</span><span class="o">,</span> <span class="n">round</span><span class="o">.</span><span class="na">getAndIncrement</span><span class="o">(),</span> <span class="n">num</span><span class="o">)))</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">&#34;第%d轮循环\n&#34;</span><span class="o">,</span> <span class="n">loop</span><span class="o">.</span><span class="na">getAndIncrement</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 控制台输出
</span><span class="c1"></span><span class="n">第1轮回调Action</span><span class="o">,</span><span class="n">值</span><span class="o">:</span><span class="n">2</span>
<span class="n">第1轮循环</span>
<span class="n">第2轮回调Action</span><span class="o">,</span><span class="n">值</span><span class="o">:</span><span class="n">1</span>
<span class="n">第2轮循环</span>
<span class="n">第3轮回调Action</span><span class="o">,</span><span class="n">值</span><span class="o">:</span><span class="n">3</span>
<span class="n">第3轮循环</span>
</code></pre></td></tr></table>
</div>
</div><p>forEachRemaining</p>
<ul>
<li>Method Signature: <code>default void forEachRemaining(Consumer&lt;? super T&gt; action)</code></li>
<li>Function: If there are remaining elements in the Spliterator, the incoming action callback is executed in the current thread for all remaining elements in it. If the Spliterator has the ORDERED feature enabled, all remaining elements are processed in order. This is the default method of the interface, and the method body is rather brutal, directly a dead loop wrapped around the tryAdvance() method until false exits the loop</li>
<li>Example.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">2</span><span class="o">);</span>
    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">3</span><span class="o">);</span>
    <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">spliterator</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">spliterator</span><span class="o">();</span>
    <span class="kd">final</span> <span class="n">AtomicInteger</span> <span class="n">round</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicInteger</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
    <span class="n">spliterator</span><span class="o">.</span><span class="na">forEachRemaining</span><span class="o">(</span><span class="n">num</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">&#34;第%d轮回调Action,值:%d\n&#34;</span><span class="o">,</span> <span class="n">round</span><span class="o">.</span><span class="na">getAndIncrement</span><span class="o">(),</span> <span class="n">num</span><span class="o">));</span>
<span class="o">}</span>

<span class="c1">// 控制台输出
</span><span class="c1"></span><span class="n">第1轮回调Action</span><span class="o">,</span><span class="n">值</span><span class="o">:</span><span class="n">2</span>
<span class="n">第2轮回调Action</span><span class="o">,</span><span class="n">值</span><span class="o">:</span><span class="n">1</span>
<span class="n">第3轮回调Action</span><span class="o">,</span><span class="n">值</span><span class="o">:</span><span class="n">3</span>
</code></pre></td></tr></table>
</div>
</div><p>trySplit</p>
<ul>
<li>Method Signature: <code>Spliterator&lt;T&gt; trySplit()</code></li>
<li>Function: If the current Spliterator is partitionable, then this method will return a new Spliterator instance, and the elements inside this new Spliterator instance will not be overwritten by the elements in the current Spliterator instance (this is a direct translation of the API comment, what it actually means is: the current Spliterator instance X is splittable, trySplit() method will split X to generate a new Spliterator instance Y, and the elements (range) contained in the original X will be shrunk, similar to X = [a,b,c,d] =&gt; X = [a,b], Y = [c,d]; if the current Spliterator instance X is (if the current Spliterator instance X is indivisible, this method will return NULL), the specific splitting algorithm is determined by the implementation class</li>
<li>Example.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">2</span><span class="o">);</span>
    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">3</span><span class="o">);</span>
    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">4</span><span class="o">);</span>
    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
    <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">first</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">spliterator</span><span class="o">();</span>
    <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">second</span> <span class="o">=</span> <span class="n">first</span><span class="o">.</span><span class="na">trySplit</span><span class="o">();</span>
    <span class="n">first</span><span class="o">.</span><span class="na">forEachRemaining</span><span class="o">(</span><span class="n">num</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">&#34;first spliterator item: %d\n&#34;</span><span class="o">,</span> <span class="n">num</span><span class="o">);</span>
    <span class="o">});</span>
    <span class="n">second</span><span class="o">.</span><span class="na">forEachRemaining</span><span class="o">(</span><span class="n">num</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">&#34;second spliterator item: %d\n&#34;</span><span class="o">,</span> <span class="n">num</span><span class="o">);</span>
    <span class="o">});</span>
<span class="o">}</span>

<span class="c1">// 控制台输出
</span><span class="c1"></span><span class="n">first</span> <span class="n">spliterator</span> <span class="n">item</span><span class="o">:</span> <span class="n">4</span>
<span class="n">first</span> <span class="n">spliterator</span> <span class="n">item</span><span class="o">:</span> <span class="n">1</span>
<span class="n">second</span> <span class="n">spliterator</span> <span class="n">item</span><span class="o">:</span> <span class="n">2</span>
<span class="n">second</span> <span class="n">spliterator</span> <span class="n">item</span><span class="o">:</span> <span class="n">3</span>
</code></pre></td></tr></table>
</div>
</div><p>estimateSize</p>
<ul>
<li>Method Signature: <code>long estimateSize()</code></li>
<li>Function: Returns an estimate of the total number of elements to be traversed by the forEachRemaining() method, or Long.MAX_VALUE if the number of samples is infinite, too expensive to compute, or unknown.</li>
<li>Example.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">2</span><span class="o">);</span>
    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">3</span><span class="o">);</span>
    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">4</span><span class="o">);</span>
    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
    <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">spliterator</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">spliterator</span><span class="o">();</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">spliterator</span><span class="o">.</span><span class="na">estimateSize</span><span class="o">());</span>
<span class="o">}</span>

<span class="c1">// 控制台输出
</span><span class="c1"></span><span class="n">4</span>
</code></pre></td></tr></table>
</div>
</div><p>getExactSizeIfKnown</p>
<ul>
<li>Method Signature: <code>default long getExactSizeIfKnown()</code></li>
<li>Function: If the current Spliterator has the SIZED feature (more on the feature below), then call the optimizeSize() method directly, otherwise it returns -1.</li>
<li>Example.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">2</span><span class="o">);</span>
    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">3</span><span class="o">);</span>
    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">4</span><span class="o">);</span>
    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
    <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">spliterator</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">spliterator</span><span class="o">();</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">spliterator</span><span class="o">.</span><span class="na">getExactSizeIfKnown</span><span class="o">());</span>
<span class="o">}</span>

<span class="c1">// 控制台输出
</span><span class="c1"></span><span class="n">4</span>
</code></pre></td></tr></table>
</div>
</div><p>int characteristics()</p>
<ul>
<li>Method Signature: <code>long estimateSize()</code></li>
<li>Function: The current Spliterator has features (collections) that use bitwise operations and are stored in 32-bit integers (more on features below)</li>
</ul>
<p>hasCharacteristics</p>
<ul>
<li>Method Signature: <code>default boolean hasCharacteristics(int characteristics)</code></li>
<li>Function: Determine if the current Spliterator has the incoming features</li>
</ul>
<p>getComparator</p>
<ul>
<li>Method Signature: <code>default Comparator&lt;? super T&gt; getComparator()</code></li>
<li>Function: If the current Spliterator has the SORTED feature, a Comparator instance is returned; if the elements in the Spliterator are naturally ordered (e.g. the elements implement the Comparable interface), NULL is returned; otherwise, an IllegalStateException is thrown directly.</li>
</ul>
<h3 id="spliterator-self-splitting">Spliterator Self-Splitting</h3>
<p>Spliterator#trySplit() can split an existing Spliterator instance into two Spliterator instances, which I refer to here as Spliterator self splitting, schematically as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/06/61d7e034c56341d787b1e54c9a5e480b.png" alt=""></p>
<p>The split here can be implemented in two ways.</p>
<ul>
<li>Physical Partitioning: For ArrayList, copying the underlying array and partitioning it is equivalent to X = [1,3,4,2] =&gt; X = [4,2], Y = [1,3] using the above example, which is obviously not very reasonable when combined with the array of elements in the ArrayList itself, which is equivalent to storing an extra copy of the data.</li>
<li>Logical partitioning: For ArrayList, since the array of element containers is naturally ordered, you can use the index (subscript) of the array for partitioning, using the above example is equivalent to X = index table [0,1,2,3] =&gt; X = index table [2,3], Y = index table [0,1], this way is to share the underlying array of containers, only the index of the elements for partitioning, the implementation is relatively simple and relatively reasonable</li>
</ul>
<p>See the source code of ArrayListSpliterator to analyze the implementation of its segmentation algorithm.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="c1">// ArrayList#spliterator()
</span><span class="c1"></span><span class="kd">public</span> <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="nf">spliterator</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">ArrayListSpliterator</span><span class="o">(</span><span class="n">0</span><span class="o">,</span> <span class="o">-</span><span class="n">1</span><span class="o">,</span> <span class="n">0</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// ArrayList中内部类ArrayListSpliterator
</span><span class="c1"></span><span class="kd">final</span> <span class="kd">class</span> <span class="nc">ArrayListSpliterator</span> <span class="kd">implements</span> <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="o">{</span>
    
    <span class="c1">// 当前的处理的元素索引值，其实是剩余元素的下边界值(包含)，在tryAdvance()或者trySplit()方法中被修改，一般初始值为0
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">index</span><span class="o">;</span>
    <span class="c1">// 栅栏，其实是元素索引值的上边界值(不包含)，一般初始化的时候为-1，使用时具体值为元素索引值上边界加1
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">fence</span><span class="o">;</span>
    <span class="c1">// 预期的修改次数，一般初始化值等于modCount
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">expectedModCount</span><span class="o">;</span>

    <span class="n">ArrayListSpliterator</span><span class="o">(</span><span class="kt">int</span> <span class="n">origin</span><span class="o">,</span> <span class="kt">int</span> <span class="n">fence</span><span class="o">,</span> <span class="kt">int</span> <span class="n">expectedModCount</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">index</span> <span class="o">=</span> <span class="n">origin</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">fence</span> <span class="o">=</span> <span class="n">fence</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">expectedModCount</span> <span class="o">=</span> <span class="n">expectedModCount</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="c1">// 获取元素索引值的上边界值，如果小于0，则把hi和fence都赋值为(ArrayList中的)size，expectedModCount赋值为(ArrayList中的)modCount，返回上边界值
</span><span class="c1"></span>    <span class="c1">// 这里注意if条件中有赋值语句hi = fence，也就是此方法调用过程中临时变量hi总是重新赋值为fence，fence是ArrayListSpliterator实例中的成员属性
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">getFence</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">hi</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">hi</span> <span class="o">=</span> <span class="n">fence</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">expectedModCount</span> <span class="o">=</span> <span class="n">modCount</span><span class="o">;</span>
            <span class="n">hi</span> <span class="o">=</span> <span class="n">fence</span> <span class="o">=</span> <span class="n">size</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">hi</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="c1">// Spliterator自分割，这里采用了二分法
</span><span class="c1"></span>    <span class="kd">public</span> <span class="n">ArrayListSpliterator</span> <span class="nf">trySplit</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// hi等于当前ArrayListSpliterator实例中的fence变量，相当于获取剩余元素的上边界值
</span><span class="c1"></span>        <span class="c1">// lo等于当前ArrayListSpliterator实例中的index变量，相当于获取剩余元素的下边界值
</span><span class="c1"></span>        <span class="c1">// mid = (lo + hi) &gt;&gt;&gt; 1，这里的无符号右移动1位运算相当于(lo + hi)/2
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">getFence</span><span class="o">(),</span> <span class="n">lo</span> <span class="o">=</span> <span class="n">index</span><span class="o">,</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">lo</span> <span class="o">+</span> <span class="n">hi</span><span class="o">)</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">1</span><span class="o">;</span>
        <span class="c1">// 当lo &gt;= mid的时候为不可分割，返回NULL，否则，以index = lo,fence = mid和expectedModCount = expectedModCount创建一个新的ArrayListSpliterator
</span><span class="c1"></span>        <span class="c1">// 这里有个细节之处，在新的ArrayListSpliterator构造参数中，当前的index被重新赋值为index = mid，这一点容易看漏，老程序员都喜欢做这样的赋值简化
</span><span class="c1"></span>        <span class="c1">// lo &gt;= mid返回NULL的时候，不会创建新的ArrayListSpliterator，也不会修改当前ArrayListSpliterator中的参数
</span><span class="c1"></span>        <span class="k">return</span> <span class="o">(</span><span class="n">lo</span> <span class="o">&gt;=</span> <span class="n">mid</span><span class="o">)</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="k">new</span> <span class="n">ArrayListSpliterator</span><span class="o">(</span><span class="n">lo</span><span class="o">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">mid</span><span class="o">,</span> <span class="n">expectedModCount</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="c1">// tryAdvance实现
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">tryAdvance</span><span class="o">(</span><span class="n">Consumer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">E</span><span class="o">&gt;</span> <span class="n">action</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">action</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">NullPointerException</span><span class="o">();</span>
        <span class="c1">// 获取迭代的上下边界
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">getFence</span><span class="o">(),</span> <span class="n">i</span> <span class="o">=</span> <span class="n">index</span><span class="o">;</span>
        <span class="c1">// 由于前面分析下边界是包含关系，上边界是非包含关系，所以这里要i &lt; hi而不是i &lt;= hi
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span>
            <span class="c1">// 这里的elementData来自ArrayList中，也就是前文经常提到的元素数组容器，这里是直接通过元素索引访问容器中的数据
</span><span class="c1"></span>            <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">&#34;unchecked&#34;</span><span class="o">)</span> <span class="n">E</span> <span class="n">e</span> <span class="o">=</span> <span class="o">(</span><span class="n">E</span><span class="o">)</span><span class="n">elementData</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="c1">// 对传入的Action进行回调
</span><span class="c1"></span>            <span class="n">action</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
            <span class="c1">// 并发修改异常判断
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">modCount</span> <span class="o">!=</span> <span class="n">expectedModCount</span><span class="o">)</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="n">ConcurrentModificationException</span><span class="o">();</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="c1">// forEachRemaining实现，这里没有采用默认实现，而是完全覆盖实现一个新方法
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">forEachRemaining</span><span class="o">(</span><span class="n">Consumer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">E</span><span class="o">&gt;</span> <span class="n">action</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 这里会新建所需的中间变量，i为index的中间变量，hi为fence的中间变量，mc为expectedModCount的中间变量
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="n">hi</span><span class="o">,</span> <span class="n">mc</span><span class="o">;</span>
        <span class="n">Object</span><span class="o">[]</span> <span class="n">a</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">action</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">NullPointerException</span><span class="o">();</span>
        <span class="c1">// 判断容器数组存在性
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">((</span><span class="n">a</span> <span class="o">=</span> <span class="n">elementData</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// hi、fence和mc初始化
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">((</span><span class="n">hi</span> <span class="o">=</span> <span class="n">fence</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">mc</span> <span class="o">=</span> <span class="n">modCount</span><span class="o">;</span>
                <span class="n">hi</span> <span class="o">=</span> <span class="n">size</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">else</span>
                <span class="n">mc</span> <span class="o">=</span> <span class="n">expectedModCount</span><span class="o">;</span>
            <span class="c1">// 这里就是先做参数合法性校验，再遍历临时数组容器a中中[i,hi)的剩余元素对传入的Action进行回调
</span><span class="c1"></span>            <span class="c1">// 这里注意有一处隐蔽的赋值(index = hi)，下界被赋值为上界，意味着每个ArrayListSpliterator实例只能调用一次forEachRemaining()方法
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">((</span><span class="n">i</span> <span class="o">=</span> <span class="n">index</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="n">0</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">index</span> <span class="o">=</span> <span class="n">hi</span><span class="o">)</span> <span class="o">&lt;=</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">for</span> <span class="o">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hi</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                    <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">&#34;unchecked&#34;</span><span class="o">)</span> <span class="n">E</span> <span class="n">e</span> <span class="o">=</span> <span class="o">(</span><span class="n">E</span><span class="o">)</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                    <span class="n">action</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="c1">// 这里校验ArrayList的modCount和mc是否一致，理论上在forEachRemaining()遍历期间，不能对数组容器进行元素的新增或者移除，一旦发生modCount更变会抛出异常
</span><span class="c1"></span>                <span class="k">if</span> <span class="o">(</span><span class="n">modCount</span> <span class="o">==</span> <span class="n">mc</span><span class="o">)</span>
                    <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">ConcurrentModificationException</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="c1">// 获取剩余元素估计值，就是用剩余元素索引上边界直接减去下边界
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">estimateSize</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">getFence</span><span class="o">()</span> <span class="o">-</span> <span class="n">index</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="c1">// 具备ORDERED、SIZED和SUBSIZED特性
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">characteristics</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">Spliterator</span><span class="o">.</span><span class="na">ORDERED</span> <span class="o">|</span> <span class="n">Spliterator</span><span class="o">.</span><span class="na">SIZED</span> <span class="o">|</span> <span class="n">Spliterator</span><span class="o">.</span><span class="na">SUBSIZED</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>When reading the source code be sure to pay attention to the older generation of programmers sometimes use a more covert assignment, the author believes that it needs to be expanded.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/06/6308570fbfa64d458f8aae42a67429a7.png" alt=""></p>
<p>The first red circle position in the construction of the new ArrayListSpliterator, the index property of the current ArrayListSpliterator is also modified, the process is as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/06/9a655c4dcf2941e8ab4935a82190b9b5.png" alt=""></p>
<p>In the second red circle, if the forEachRemaining() method is called with parameter checking and the index (lower bound value) is assigned to hi (upper bound value) in the if branch, then the forEachRemaining() method of an ArrayListSpliterator instance must perform the traversal operation only once. once. This can be verified as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">2</span><span class="o">);</span>
    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">3</span><span class="o">);</span>
    <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">spliterator</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">spliterator</span><span class="o">();</span>
    <span class="kd">final</span> <span class="n">AtomicInteger</span> <span class="n">round</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicInteger</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
    <span class="n">spliterator</span><span class="o">.</span><span class="na">forEachRemaining</span><span class="o">(</span><span class="n">num</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">&#34;[第一次遍历forEachRemaining]第%d轮回调Action,值:%d\n&#34;</span><span class="o">,</span> <span class="n">round</span><span class="o">.</span><span class="na">getAndIncrement</span><span class="o">(),</span> <span class="n">num</span><span class="o">));</span>
    <span class="n">round</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
    <span class="n">spliterator</span><span class="o">.</span><span class="na">forEachRemaining</span><span class="o">(</span><span class="n">num</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">&#34;[第二次遍历forEachRemaining]第%d轮回调Action,值:%d\n&#34;</span><span class="o">,</span> <span class="n">round</span><span class="o">.</span><span class="na">getAndIncrement</span><span class="o">(),</span> <span class="n">num</span><span class="o">));</span>
<span class="o">}</span>

<span class="c1">// 控制台输出
</span><span class="c1"></span><span class="o">[</span><span class="n">第一次遍历forEachRemaining</span><span class="o">]</span><span class="n">第1轮回调Action</span><span class="o">,</span><span class="n">值</span><span class="o">:</span><span class="n">2</span>
<span class="o">[</span><span class="n">第一次遍历forEachRemaining</span><span class="o">]</span><span class="n">第2轮回调Action</span><span class="o">,</span><span class="n">值</span><span class="o">:</span><span class="n">1</span>
<span class="o">[</span><span class="n">第一次遍历forEachRemaining</span><span class="o">]</span><span class="n">第3轮回调Action</span><span class="o">,</span><span class="n">值</span><span class="o">:</span><span class="n">3</span>
</code></pre></td></tr></table>
</div>
</div><p>The following points can be confirmed for the implementation of ArrayListSpliterator.</p>
<ul>
<li>The forEachRemaining() method in a new instance of ArrayListSpliterator can only be called once</li>
<li>The bound of the forEachRemaining() method in the ArrayListSpliterator instance to traverse the elements is [index, fence)</li>
<li>When ArrayListSpliterator splits itself, the new ArrayListSpliterator is responsible for handling the segments with small subscripts (analogous to fork&rsquo;s left branch), while the original ArrayListSpliterator is responsible for handling the segments with large subscripts (analogous to fork&rsquo;s right branch).</li>
<li>The number of remaining elements in the segment is an exact value, as provided by the estimSize() method of the ArrayListSpliterator.</li>
</ul>
<p>If the above example is further divided, the following process can be obtained.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/06/a85af2e70bea4463b951e5eb20bf5bf0.png" alt=""></p>
<p>Spliterator self splitting is the basis of parallel stream implementation, the parallel stream computation process is actually fork-join processing, the implementation of trySplit() method determines the granularity of fork tasks, each fork task is concurrently safe when computing, this is guaranteed by thread closure (thread stack closure), each fork task computation The final result is then joined by a single thread to get the correct result. The following example is to find the sum of integers 1 to 100.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ConcurrentSplitCalculateSum</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">ForkTask</span> <span class="kd">extends</span> <span class="n">Thread</span> <span class="o">{</span>

        <span class="kd">private</span> <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>

        <span class="kd">private</span> <span class="kd">final</span> <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">spliterator</span><span class="o">;</span>
        <span class="kd">private</span> <span class="kd">final</span> <span class="n">CountDownLatch</span> <span class="n">latch</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">ForkTask</span><span class="o">(</span><span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">spliterator</span><span class="o">,</span>
                        <span class="n">CountDownLatch</span> <span class="n">latch</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">spliterator</span> <span class="o">=</span> <span class="n">spliterator</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">latch</span> <span class="o">=</span> <span class="n">latch</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
            <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
            <span class="n">spliterator</span><span class="o">.</span><span class="na">forEachRemaining</span><span class="o">(</span><span class="n">num</span> <span class="o">-&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">+</span> <span class="n">num</span><span class="o">);</span>
            <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">&#34;线程[%s]完成计算任务,当前段计算结果:%d,耗时:%d ms\n&#34;</span><span class="o">,</span>
                    <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">(),</span> <span class="n">result</span><span class="o">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="o">);</span>
            <span class="n">latch</span><span class="o">.</span><span class="na">countDown</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">result</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">join</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">ForkTask</span><span class="o">&gt;</span> <span class="n">tasks</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">ForkTask</span> <span class="n">task</span> <span class="o">:</span> <span class="n">tasks</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">+</span> <span class="n">task</span><span class="o">.</span><span class="na">result</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">THREAD_NUM</span> <span class="o">=</span> <span class="n">4</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">101</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">source</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">root</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">spliterator</span><span class="o">();</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">spliteratorList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">trySplit</span><span class="o">();</span>
        <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">trySplit</span><span class="o">();</span>
        <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">z</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">trySplit</span><span class="o">();</span>
        <span class="n">spliteratorList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="n">spliteratorList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
        <span class="n">spliteratorList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">y</span><span class="o">);</span>
        <span class="n">spliteratorList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">z</span><span class="o">);</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">ForkTask</span><span class="o">&gt;</span> <span class="n">tasks</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">CountDownLatch</span> <span class="n">latch</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CountDownLatch</span><span class="o">(</span><span class="n">THREAD_NUM</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">THREAD_NUM</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">ForkTask</span> <span class="n">task</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ForkTask</span><span class="o">(</span><span class="n">spliteratorList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">),</span> <span class="n">latch</span><span class="o">);</span>
            <span class="n">task</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">&#34;fork-task-&#34;</span> <span class="o">+</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">1</span><span class="o">));</span>
            <span class="n">tasks</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">task</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">tasks</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">Thread</span><span class="o">::</span><span class="n">start</span><span class="o">);</span>
        <span class="n">latch</span><span class="o">.</span><span class="na">await</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">join</span><span class="o">(</span><span class="n">tasks</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;最终计算结果为:&#34;</span> <span class="o">+</span> <span class="n">result</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 控制台输出结果
</span><span class="c1"></span><span class="n">线程</span><span class="o">[</span><span class="n">fork</span><span class="o">-</span><span class="n">task</span><span class="o">-</span><span class="n">4</span><span class="o">]</span><span class="n">完成计算任务</span><span class="o">,</span><span class="n">当前段计算结果</span><span class="o">:</span><span class="n">1575</span><span class="o">,</span><span class="n">耗时</span><span class="o">:</span><span class="n">0</span> <span class="n">ms</span>
<span class="n">线程</span><span class="o">[</span><span class="n">fork</span><span class="o">-</span><span class="n">task</span><span class="o">-</span><span class="n">2</span><span class="o">]</span><span class="n">完成计算任务</span><span class="o">,</span><span class="n">当前段计算结果</span><span class="o">:</span><span class="n">950</span><span class="o">,</span><span class="n">耗时</span><span class="o">:</span><span class="n">1</span> <span class="n">ms</span>
<span class="n">线程</span><span class="o">[</span><span class="n">fork</span><span class="o">-</span><span class="n">task</span><span class="o">-</span><span class="n">3</span><span class="o">]</span><span class="n">完成计算任务</span><span class="o">,</span><span class="n">当前段计算结果</span><span class="o">:</span><span class="n">325</span><span class="o">,</span><span class="n">耗时</span><span class="o">:</span><span class="n">1</span> <span class="n">ms</span>
<span class="n">线程</span><span class="o">[</span><span class="n">fork</span><span class="o">-</span><span class="n">task</span><span class="o">-</span><span class="n">1</span><span class="o">]</span><span class="n">完成计算任务</span><span class="o">,</span><span class="n">当前段计算结果</span><span class="o">:</span><span class="n">2200</span><span class="o">,</span><span class="n">耗时</span><span class="o">:</span><span class="n">1</span> <span class="n">ms</span>
<span class="nl">最终计算结果为:</span><span class="n">5050</span>
</code></pre></td></tr></table>
</div>
</div><p>Of course, the computation of the final parallel stream uses ForkJoinPool and is not executed asynchronously as brute-force as in this example. The implementation of parallel streams will be analyzed in detail below.</p>
<h3 id="features-supported-by-spliterator">Features supported by Spliterator</h3>
<p>The characteristics supported by a particular Spliterator instance are determined by the method characteristics(), which returns a 32-bit value that in practice is expanded into a bit array with all characteristics assigned to different bits, and hasCharacteristics(int characteristics) is By inputting the specific characteristics value through the bit operation to determine whether the characteristics exist in characteristics(). The following is an analysis of this technique by simplifying characteristics to byte.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">假设：byte characteristics<span class="o">()</span>  <span class="o">=</span>&gt; 也就是最多8个位用于表示特性集合，如果每个位只表示一种特性，那么可以总共表示8种特性
特性X：0000 <span class="m">0001</span>
特性Y：0000 <span class="m">0010</span>
以此类推
假设：characteristics <span class="o">=</span> X <span class="p">|</span> <span class="nv">Y</span> <span class="o">=</span> <span class="m">0000</span> <span class="m">0001</span> <span class="p">|</span> <span class="m">0000</span> <span class="nv">0010</span> <span class="o">=</span> <span class="m">0000</span> <span class="m">0011</span>
那么：characteristics <span class="p">&amp;</span> <span class="nv">X</span> <span class="o">=</span> <span class="m">0000</span> <span class="m">0011</span> <span class="p">&amp;</span> <span class="m">0000</span> <span class="nv">0001</span> <span class="o">=</span> <span class="m">0000</span> <span class="m">0001</span>
判断characteristics是否包含X：<span class="o">(</span>characteristics <span class="p">&amp;</span> X<span class="o">)</span> <span class="o">==</span> X
</code></pre></td></tr></table>
</div>
</div><p>The process inferred above is the processing logic of the feature determination method in Spliterator.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 返回特性集合
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">characteristics</span><span class="o">();</span>

<span class="c1">// 基于位运算判断特性集合中是否存在输入的特性
</span><span class="c1"></span><span class="k">default</span> <span class="kt">boolean</span> <span class="nf">hasCharacteristics</span><span class="o">(</span><span class="kt">int</span> <span class="n">characteristics</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">(</span><span class="n">characteristics</span><span class="o">()</span> <span class="o">&amp;</span> <span class="n">characteristics</span><span class="o">)</span> <span class="o">==</span> <span class="n">characteristics</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Here it can be verified.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CharacteristicsCheck</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">&#34;是否存在ORDERED特性:%s\n&#34;</span><span class="o">,</span> <span class="n">hasCharacteristics</span><span class="o">(</span><span class="n">Spliterator</span><span class="o">.</span><span class="na">ORDERED</span><span class="o">));</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">&#34;是否存在SIZED特性:%s\n&#34;</span><span class="o">,</span> <span class="n">hasCharacteristics</span><span class="o">(</span><span class="n">Spliterator</span><span class="o">.</span><span class="na">SIZED</span><span class="o">));</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">&#34;是否存在DISTINCT特性:%s\n&#34;</span><span class="o">,</span> <span class="n">hasCharacteristics</span><span class="o">(</span><span class="n">Spliterator</span><span class="o">.</span><span class="na">DISTINCT</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">characteristics</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">Spliterator</span><span class="o">.</span><span class="na">ORDERED</span> <span class="o">|</span> <span class="n">Spliterator</span><span class="o">.</span><span class="na">SIZED</span> <span class="o">|</span> <span class="n">Spliterator</span><span class="o">.</span><span class="na">SORTED</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">hasCharacteristics</span><span class="o">(</span><span class="kt">int</span> <span class="n">characteristics</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">characteristics</span><span class="o">()</span> <span class="o">&amp;</span> <span class="n">characteristics</span><span class="o">)</span> <span class="o">==</span> <span class="n">characteristics</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 控制台输出
</span><span class="c1"></span><span class="nl">是否存在ORDERED特性:</span><span class="kc">true</span>
<span class="nl">是否存在SIZED特性:</span><span class="kc">true</span>
<span class="nl">是否存在DISTINCT特性:</span><span class="kc">false</span>
</code></pre></td></tr></table>
</div>
</div><p>There are currently eight features supported by Spliterator, as follows.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Features</th>
<th style="text-align:left">Hex value</th>
<th style="text-align:left">Binary value</th>
<th style="text-align:left">Function</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">DISTINCT</td>
<td style="text-align:left">0x00000001</td>
<td style="text-align:left">0000 0000 0000 0001</td>
<td style="text-align:left">De-weighting, e.g. for each pair of elements (x,y) to be processed, use !x.equals(y) to compare, de-weighting in Spliterator is actually based on Set processing</td>
</tr>
<tr>
<td style="text-align:left">ORDERED</td>
<td style="text-align:left">0x00000010</td>
<td style="text-align:left">0000 0000 0001 0000</td>
<td style="text-align:left">The (element) order processing can be understood as trySplit(), tryAdvance() and forEachRemaining() methods guarantee a strict prefix order for all element processing</td>
</tr>
<tr>
<td style="text-align:left">SORTED</td>
<td style="text-align:left">0x00000004</td>
<td style="text-align:left">0000 0000 0000 0100</td>
<td style="text-align:left">Sorting, elements are sorted using the Comparator provided by the getComparator() method, and if the SORTED feature is defined, the ORDERED feature must be defined</td>
</tr>
<tr>
<td style="text-align:left">SIZED</td>
<td style="text-align:left">0x00000040</td>
<td style="text-align:left">0000 0000 0100 0000</td>
<td style="text-align:left">If this feature is enabled, the exact number of elements will be returned by estimateSize() before Spliterator is split or iterated.</td>
</tr>
<tr>
<td style="text-align:left">NONNULL</td>
<td style="text-align:left">0x00000040</td>
<td style="text-align:left">0000 0001 0000 0000</td>
<td style="text-align:left">(element) is not NULL, the data source ensures that the elements Spliterator needs to process cannot be NULL, most commonly used in concurrent containers in collections, queues and Map</td>
</tr>
<tr>
<td style="text-align:left">IMMUTABLE</td>
<td style="text-align:left">0x00000400</td>
<td style="text-align:left">0000 0100 0000 0000</td>
<td style="text-align:left">(elements) are immutable, the data source cannot be modified, i.e. elements cannot be added, replaced and removed during processing (updating attributes is allowed)</td>
</tr>
<tr>
<td style="text-align:left">CONCURRENT</td>
<td style="text-align:left">0x00001000</td>
<td style="text-align:left">0001 0000 0000 0000</td>
<td style="text-align:left">Modifications (to the element source) are concurrently safe, meaning that multiple threads adding, replacing, or removing elements from the data source are concurrently safe without additional synchronization conditions</td>
</tr>
<tr>
<td style="text-align:left">SUBSIZED</td>
<td style="text-align:left">0x00004000</td>
<td style="text-align:left">0100 0000 0000 0000</td>
<td style="text-align:left">The estimated number of Spliterator elements (sub-Spliterator elements), enabling this feature means that all sub-Spliterators split by trySplit() method (the current Spliterator is also a sub-Spliterator after splitting) are enabled with SIZED feature</td>
</tr>
</tbody>
</table>
<blockquote>
<p>A closer look reveals that all features are stored in 32-bit integers, using a 1-bit interval storage strategy, and the mapping of bit subscripts to features is: (0 =&gt; DISTINCT), (3 =&gt; SORTED), (5 =&gt; ORDERED), (7 =&gt; SIZED), (9 =&gt; NONNULL), (11 =&gt; IMMUTABLE), (13 =&gt; CONCURRENT), (15 =&gt; SUBSIZED)</p>
</blockquote>
<p>All the features of the function here only outlines the core definition, there are some small words or special case description limited to space did not add completely, which can refer to the specific source code in the API comments. These features will eventually be converted into StreamOpFlag and then provided to the operation judgment in Stream, as StreamOpFlag will be more complex, the following detailed analysis.</p>
<h2 id="the-principle-of-stream-implementation-and-source-code-analysis">The principle of stream implementation and source code analysis</h2>
<p>Since the stream implementation is highly abstract engineering code, it can be a bit difficult to read in source code. The whole system involves a large number of interfaces, classes and enumerations, as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/06/25641eff66ce4fb3b070365764083de9.png" alt=""></p>
<p>The top-level class structure diagram describes the pipeline-related class inheritance relationship of the stream, in which IntStream, LongStream and DoubleStream are special types, respectively, for Integer, Long and Double types, other reference types to build the Pipeline are ReferencePipeline instances, so I believe that the ReferencePipeline (reference type pipeline) is the core data structure of the stream, the following will be based on the implementation of the ReferencePipeline to do in-depth analysis.</p>
<h3 id="streamopflag-source-code-analysis">StreamOpFlag source code analysis</h3>
<blockquote>
<p>Note that this subsection is very brain-burning, it is also possible that the author&rsquo;s bit operation is not very skilled, most of the time consumed in this article in this subsection</p>
</blockquote>
<p>StreamOpFlag is an enumeration that functions to store Flags corresponding to characteristics of streams and operations (hereafter referred to as Stream Flags) that are provided to the Stream framework for control, customization and Stream flags can be used to characterize a number of different entities associated with a stream, including the source of the stream, the intermediate operation (Op) of the stream, and the terminal operation (Op) of the stream. However, not all Stream flags have meaning for all Stream entities, which are currently mapped to flags as follows.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Type(Stream Entity Type)</th>
<th style="text-align:left">DISTINCT</th>
<th style="text-align:left">SORTED</th>
<th style="text-align:left">ORDERED</th>
<th style="text-align:left">SIZED</th>
<th style="text-align:left">SHORT_CIRCUIT</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">SPLITERATOR</td>
<td style="text-align:left">01</td>
<td style="text-align:left">01</td>
<td style="text-align:left">01</td>
<td style="text-align:left">01</td>
<td style="text-align:left">00</td>
</tr>
<tr>
<td style="text-align:left">STREAM</td>
<td style="text-align:left">01</td>
<td style="text-align:left">01</td>
<td style="text-align:left">01</td>
<td style="text-align:left">01</td>
<td style="text-align:left">00</td>
</tr>
<tr>
<td style="text-align:left">OP</td>
<td style="text-align:left">11</td>
<td style="text-align:left">11</td>
<td style="text-align:left">11</td>
<td style="text-align:left">10</td>
<td style="text-align:left">01</td>
</tr>
<tr>
<td style="text-align:left">TERMINAL_OP</td>
<td style="text-align:left">00</td>
<td style="text-align:left">00</td>
<td style="text-align:left">10</td>
<td style="text-align:left">00</td>
<td style="text-align:left">01</td>
</tr>
<tr>
<td style="text-align:left">UPSTREAM_TERMINAL_OP</td>
<td style="text-align:left">00</td>
<td style="text-align:left">00</td>
<td style="text-align:left">10</td>
<td style="text-align:left">00</td>
<td style="text-align:left">00</td>
</tr>
</tbody>
</table>
<p>Among them.</p>
<ul>
<li>01: indicates set/inject</li>
<li>10: indicates clear</li>
<li>11: indicates reserved</li>
<li>00: indicates the initialization value (default fill value), which is a key point, the 0 value indicates that it will never be a certain type of flag</li>
</ul>
<p>The top comment of StreamOpFlag also contains a table as follows.</p>
<table>
<thead>
<tr>
<th style="text-align:left">-</th>
<th style="text-align:left">DISTINCT</th>
<th style="text-align:left">SORTED</th>
<th style="text-align:left">ORDERED</th>
<th style="text-align:left">SIZED</th>
<th style="text-align:left">SHORT_CIRCUIT</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Stream source</td>
<td style="text-align:left">Y</td>
<td style="text-align:left">Y</td>
<td style="text-align:left">Y</td>
<td style="text-align:left">Y</td>
<td style="text-align:left">N</td>
</tr>
<tr>
<td style="text-align:left">Intermediate operation</td>
<td style="text-align:left">PCI</td>
<td style="text-align:left">PCI</td>
<td style="text-align:left">PCI</td>
<td style="text-align:left">PC</td>
<td style="text-align:left">PI</td>
</tr>
<tr>
<td style="text-align:left">Terminal operation</td>
<td style="text-align:left">N</td>
<td style="text-align:left">N</td>
<td style="text-align:left">PC</td>
<td style="text-align:left">N</td>
<td style="text-align:left">PI</td>
</tr>
</tbody>
</table>
<p>Tag -&gt; Meaning.</p>
<ul>
<li>Y: Allowed</li>
<li>N: illegal</li>
<li>P: Reserved</li>
<li>C: Clear</li>
<li>I: Inject</li>
<li>Combination PCI: can be retained, cleared or injected</li>
<li>Combination PC: can be retained or cleared</li>
<li>Combination PI: can be retained or injected</li>
</ul>
<p>The two tables actually describe the same conclusion and can be compared and understood, but the final implementation refers to the definition of the first table. Note one thing: preserved(P) here means preserved. If a flag of a Stream entity is assigned to preserved, it means that the entity can use the characteristics represented by this flag. For example, the DISTINCT, SORTED and ORDERED of the OP in the first table of this subsection are all assigned the value 11 (reserved), which means that entities of type OP are allowed to use the de-duplication, natural ordering and sequential processing features. Returning to the source code section, first look at the core properties and constructors of StreamOpFlag.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">enum</span> <span class="n">StreamOpFlag</span> <span class="o">{</span>

    <span class="c1">// 暂时忽略其他代码
</span><span class="c1"></span>
    <span class="c1">// 类型枚举，Stream相关实体类型
</span><span class="c1"></span>    <span class="kd">enum</span> <span class="n">Type</span> <span class="o">{</span>
         
        <span class="c1">// SPLITERATOR类型，关联所有和Spliterator相关的特性
</span><span class="c1"></span>        <span class="n">SPLITERATOR</span><span class="o">,</span>

        <span class="c1">// STREAM类型，关联所有和Stream相关的标志
</span><span class="c1"></span>        <span class="n">STREAM</span><span class="o">,</span>

        <span class="c1">// STREAM类型，关联所有和Stream中间操作相关的标志
</span><span class="c1"></span>        <span class="n">OP</span><span class="o">,</span>

        <span class="c1">// TERMINAL_OP类型，关联所有和Stream终结操作相关的标志
</span><span class="c1"></span>        <span class="n">TERMINAL_OP</span><span class="o">,</span>

        <span class="c1">// UPSTREAM_TERMINAL_OP类型，关联所有在最后一个有状态操作边界上游传播的终止操作标志
</span><span class="c1"></span>        <span class="c1">// 这个类型的意义直译有点拗口，不过实际上在JDK11源码中，这个类型没有被流相关功能引用，暂时可以忽略
</span><span class="c1"></span>        <span class="n">UPSTREAM_TERMINAL_OP</span>
    <span class="o">}</span>

    <span class="c1">// 设置/注入标志的bit模式，二进制数0001，十进制数1
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">SET_BITS</span> <span class="o">=</span> <span class="n">0b01</span><span class="o">;</span>

    <span class="c1">// 清除标志的bit模式，二进制数0010，十进制数2
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">CLEAR_BITS</span> <span class="o">=</span> <span class="n">0b10</span><span class="o">;</span>

    <span class="c1">// 保留标志的bit模式，二进制数0011，十进制数3
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">PRESERVE_BITS</span> <span class="o">=</span> <span class="n">0b11</span><span class="o">;</span>
    
    <span class="c1">// 掩码建造器工厂方法，注意这个方法用于实例化MaskBuilder
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="n">MaskBuilder</span> <span class="nf">set</span><span class="o">(</span><span class="n">Type</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">MaskBuilder</span><span class="o">(</span><span class="k">new</span> <span class="n">EnumMap</span><span class="o">&lt;&gt;(</span><span class="n">Type</span><span class="o">.</span><span class="na">class</span><span class="o">)).</span><span class="na">set</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="c1">// 私有静态内部类，掩码建造器，里面的map由上面的set(Type t)方法得知是EnumMap实例
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">MaskBuilder</span> <span class="o">{</span>
        <span class="c1">// Type -&gt; SET_BITS|CLEAR_BITS|PRESERVE_BITS|0
</span><span class="c1"></span>        <span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">;</span>

        <span class="n">MaskBuilder</span><span class="o">(</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">map</span> <span class="o">=</span> <span class="n">map</span><span class="o">;</span>
        <span class="o">}</span>
       
        <span class="c1">// 设置类型和对应的掩码
</span><span class="c1"></span>        <span class="n">MaskBuilder</span> <span class="nf">mask</span><span class="o">(</span><span class="n">Type</span> <span class="n">t</span><span class="o">,</span> <span class="n">Integer</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="c1">// 对类型添加/inject
</span><span class="c1"></span>        <span class="n">MaskBuilder</span> <span class="nf">set</span><span class="o">(</span><span class="n">Type</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">mask</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">SET_BITS</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="n">MaskBuilder</span> <span class="nf">clear</span><span class="o">(</span><span class="n">Type</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">mask</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">CLEAR_BITS</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="n">MaskBuilder</span> <span class="nf">setAndClear</span><span class="o">(</span><span class="n">Type</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">mask</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">PRESERVE_BITS</span><span class="o">);</span>
        <span class="o">}</span>
        
        <span class="c1">// 这里的build方法对于类型中的NULL掩码填充为0，然后把map返回
</span><span class="c1"></span>        <span class="n">Map</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">build</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="n">Type</span> <span class="n">t</span> <span class="o">:</span> <span class="n">Type</span><span class="o">.</span><span class="na">values</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">map</span><span class="o">.</span><span class="na">putIfAbsent</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">0b00</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">map</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="c1">// 类型-&gt;掩码映射
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">maskTable</span><span class="o">;</span>
    
    <span class="c1">// bit的起始偏移量，控制下面set、clear和preserve的起始偏移量
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">bitPosition</span><span class="o">;</span>

    <span class="c1">// set/inject的bit set(map)，其实准确来说应该是一个表示set/inject的bit map
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">set</span><span class="o">;</span>

    <span class="c1">// clear的bit set(map)，其实准确来说应该是一个表示clear的bit map
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">clear</span><span class="o">;</span>

    <span class="c1">// preserve的bit set(map)，其实准确来说应该是一个表示preserve的bit map
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">preserve</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nf">StreamOpFlag</span><span class="o">(</span><span class="kt">int</span> <span class="n">position</span><span class="o">,</span> <span class="n">MaskBuilder</span> <span class="n">maskBuilder</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 这里会基于MaskBuilder初始化内部的EnumMap
</span><span class="c1"></span>        <span class="k">this</span><span class="o">.</span><span class="na">maskTable</span> <span class="o">=</span> <span class="n">maskBuilder</span><span class="o">.</span><span class="na">build</span><span class="o">();</span>
        <span class="c1">// Two bits per flag &lt;= 这里会把入参position放大一倍
</span><span class="c1"></span>        <span class="n">position</span> <span class="o">*=</span> <span class="n">2</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">bitPosition</span> <span class="o">=</span> <span class="n">position</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">set</span> <span class="o">=</span> <span class="n">SET_BITS</span> <span class="o">&lt;&lt;</span> <span class="n">position</span><span class="o">;</span> <span class="c1">// 设置/注入标志的bit模式左移2倍position
</span><span class="c1"></span>        <span class="k">this</span><span class="o">.</span><span class="na">clear</span> <span class="o">=</span> <span class="n">CLEAR_BITS</span> <span class="o">&lt;&lt;</span> <span class="n">position</span><span class="o">;</span> <span class="c1">// 清除标志的bit模式左移2倍position
</span><span class="c1"></span>        <span class="k">this</span><span class="o">.</span><span class="na">preserve</span> <span class="o">=</span> <span class="n">PRESERVE_BITS</span> <span class="o">&lt;&lt;</span> <span class="n">position</span><span class="o">;</span> <span class="c1">// 保留标志的bit模式左移2倍position
</span><span class="c1"></span>    <span class="o">}</span>

    <span class="c1">// 省略中间一些方法
</span><span class="c1"></span>
    <span class="c1">// 下面这些静态变量就是直接返回标志对应的set/injec、清除和保留的bit map
</span><span class="c1"></span>    <span class="cm">/**
</span><span class="cm">     * The bit value to set or inject {@link #DISTINCT}.
</span><span class="cm">     */</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">IS_DISTINCT</span> <span class="o">=</span> <span class="n">DISTINCT</span><span class="o">.</span><span class="na">set</span><span class="o">;</span>

    <span class="cm">/**
</span><span class="cm">     * The bit value to clear {@link #DISTINCT}.
</span><span class="cm">     */</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">NOT_DISTINCT</span> <span class="o">=</span> <span class="n">DISTINCT</span><span class="o">.</span><span class="na">clear</span><span class="o">;</span>

    <span class="cm">/**
</span><span class="cm">     * The bit value to set or inject {@link #SORTED}.
</span><span class="cm">     */</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">IS_SORTED</span> <span class="o">=</span> <span class="n">SORTED</span><span class="o">.</span><span class="na">set</span><span class="o">;</span>

    <span class="cm">/**
</span><span class="cm">     * The bit value to clear {@link #SORTED}.
</span><span class="cm">     */</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">NOT_SORTED</span> <span class="o">=</span> <span class="n">SORTED</span><span class="o">.</span><span class="na">clear</span><span class="o">;</span>

    <span class="cm">/**
</span><span class="cm">     * The bit value to set or inject {@link #ORDERED}.
</span><span class="cm">     */</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">IS_ORDERED</span> <span class="o">=</span> <span class="n">ORDERED</span><span class="o">.</span><span class="na">set</span><span class="o">;</span>

    <span class="cm">/**
</span><span class="cm">     * The bit value to clear {@link #ORDERED}.
</span><span class="cm">     */</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">NOT_ORDERED</span> <span class="o">=</span> <span class="n">ORDERED</span><span class="o">.</span><span class="na">clear</span><span class="o">;</span>

    <span class="cm">/**
</span><span class="cm">     * The bit value to set {@link #SIZED}.
</span><span class="cm">     */</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">IS_SIZED</span> <span class="o">=</span> <span class="n">SIZED</span><span class="o">.</span><span class="na">set</span><span class="o">;</span>

    <span class="cm">/**
</span><span class="cm">     * The bit value to clear {@link #SIZED}.
</span><span class="cm">     */</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">NOT_SIZED</span> <span class="o">=</span> <span class="n">SIZED</span><span class="o">.</span><span class="na">clear</span><span class="o">;</span>

    <span class="cm">/**
</span><span class="cm">     * The bit value to inject {@link #SHORT_CIRCUIT}.
</span><span class="cm">     */</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">IS_SHORT_CIRCUIT</span> <span class="o">=</span> <span class="n">SHORT_CIRCUIT</span><span class="o">.</span><span class="na">set</span><span class="o">;</span>
<span class="o">}</span>

</code></pre></td></tr></table>
</div>
</div><p>And because StreamOpFlag is an enumeration, an enumeration member is a separate flag, and a flag will act on multiple Stream entity types, so one of its members describes a column of the above entity-flag mapping relationship (viewed vertically):</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/07/2032fc25302f4309870ea4cf5841e59a.png" alt=""></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 纵向看
</span><span class="c1"></span><span class="n">DISTINCT</span> <span class="n">Flag</span><span class="o">:</span>
<span class="nl">maskTable:</span> <span class="o">{</span>
    <span class="n">SPLITERATOR</span><span class="o">:</span>           <span class="n">0000</span> <span class="n">0001</span><span class="o">,</span>
    <span class="n">STREAM</span><span class="o">:</span>                <span class="n">0000</span> <span class="n">0001</span><span class="o">,</span>
    <span class="n">OP</span><span class="o">:</span>                    <span class="n">0000</span> <span class="n">0011</span><span class="o">,</span>
    <span class="n">TERMINAL_OP</span><span class="o">:</span>           <span class="n">0000</span> <span class="n">0000</span><span class="o">,</span>
    <span class="n">UPSTREAM_TERMINAL_OP</span><span class="o">:</span>  <span class="n">0000</span> <span class="n">0000</span>
<span class="o">}</span>
<span class="n">position</span><span class="o">(</span><span class="n">input</span><span class="o">):</span> <span class="n">0</span>
<span class="nl">bitPosition:</span>     <span class="n">0</span>
<span class="nl">set:</span>             <span class="n">1</span> <span class="o">=&gt;</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0001</span>
<span class="nl">clear:</span>           <span class="n">2</span> <span class="o">=&gt;</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0010</span>
<span class="nl">preserve:</span>        <span class="n">3</span> <span class="o">=&gt;</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0011</span>

<span class="n">SORTED</span> <span class="n">Flag</span><span class="o">:</span>
<span class="nl">maskTable:</span> <span class="o">{</span>
    <span class="n">SPLITERATOR</span><span class="o">:</span>           <span class="n">0000</span> <span class="n">0001</span><span class="o">,</span>
    <span class="n">STREAM</span><span class="o">:</span>                <span class="n">0000</span> <span class="n">0001</span><span class="o">,</span>
    <span class="n">OP</span><span class="o">:</span>                    <span class="n">0000</span> <span class="n">0011</span><span class="o">,</span>
    <span class="n">TERMINAL_OP</span><span class="o">:</span>           <span class="n">0000</span> <span class="n">0000</span><span class="o">,</span>
    <span class="n">UPSTREAM_TERMINAL_OP</span><span class="o">:</span>  <span class="n">0000</span> <span class="n">0000</span>
<span class="o">}</span>
<span class="n">position</span><span class="o">(</span><span class="n">input</span><span class="o">):</span> <span class="n">1</span> 
<span class="nl">bitPosition:</span>     <span class="n">2</span>
<span class="nl">set:</span>             <span class="n">4</span> <span class="o">=&gt;</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0100</span>
<span class="nl">clear:</span>           <span class="n">8</span> <span class="o">=&gt;</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">1000</span>
<span class="nl">preserve:</span>       <span class="n">12</span> <span class="o">=&gt;</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">1100</span>

<span class="n">ORDERED</span> <span class="n">Flag</span><span class="o">:</span>
<span class="nl">maskTable:</span> <span class="o">{</span>
    <span class="n">SPLITERATOR</span><span class="o">:</span>           <span class="n">0000</span> <span class="n">0001</span><span class="o">,</span>
    <span class="n">STREAM</span><span class="o">:</span>                <span class="n">0000</span> <span class="n">0001</span><span class="o">,</span>
    <span class="n">OP</span><span class="o">:</span>                    <span class="n">0000</span> <span class="n">0011</span><span class="o">,</span>
    <span class="n">TERMINAL_OP</span><span class="o">:</span>           <span class="n">0000</span> <span class="n">0010</span><span class="o">,</span>
    <span class="n">UPSTREAM_TERMINAL_OP</span><span class="o">:</span>  <span class="n">0000</span> <span class="n">0010</span>
<span class="o">}</span>
<span class="n">position</span><span class="o">(</span><span class="n">input</span><span class="o">):</span> <span class="n">2</span>
<span class="nl">bitPosition:</span>     <span class="n">4</span> 
<span class="nl">set:</span>            <span class="n">16</span> <span class="o">=&gt;</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0001</span> <span class="n">0000</span>
<span class="nl">clear:</span>          <span class="n">32</span> <span class="o">=&gt;</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0010</span> <span class="n">0000</span>
<span class="nl">preserve:</span>       <span class="n">48</span> <span class="o">=&gt;</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0011</span> <span class="n">0000</span>

<span class="n">SIZED</span> <span class="n">Flag</span><span class="o">:</span>
<span class="nl">maskTable:</span> <span class="o">{</span>
    <span class="n">SPLITERATOR</span><span class="o">:</span>           <span class="n">0000</span> <span class="n">0001</span><span class="o">,</span>
    <span class="n">STREAM</span><span class="o">:</span>                <span class="n">0000</span> <span class="n">0001</span><span class="o">,</span>
    <span class="n">OP</span><span class="o">:</span>                    <span class="n">0000</span> <span class="n">0010</span><span class="o">,</span>
    <span class="n">TERMINAL_OP</span><span class="o">:</span>           <span class="n">0000</span> <span class="n">0000</span><span class="o">,</span>
    <span class="n">UPSTREAM_TERMINAL_OP</span><span class="o">:</span>  <span class="n">0000</span> <span class="n">0000</span>
<span class="o">}</span>
<span class="n">position</span><span class="o">(</span><span class="n">input</span><span class="o">):</span> <span class="n">3</span>
<span class="nl">bitPosition:</span>     <span class="n">6</span> 
<span class="nl">set:</span>            <span class="n">64</span> <span class="o">=&gt;</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0100</span> <span class="n">0000</span>
<span class="nl">clear:</span>         <span class="n">128</span> <span class="o">=&gt;</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">1000</span> <span class="n">0000</span>
<span class="nl">preserve:</span>      <span class="n">192</span> <span class="o">=&gt;</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">1100</span> <span class="n">0000</span>

<span class="n">SHORT_CIRCUIT</span> <span class="n">Flag</span><span class="o">:</span>
<span class="nl">maskTable:</span> <span class="o">{</span>
    <span class="n">SPLITERATOR</span><span class="o">:</span>           <span class="n">0000</span> <span class="n">0000</span><span class="o">,</span>
    <span class="n">STREAM</span><span class="o">:</span>                <span class="n">0000</span> <span class="n">0000</span><span class="o">,</span>
    <span class="n">OP</span><span class="o">:</span>                    <span class="n">0000</span> <span class="n">0001</span><span class="o">,</span>
    <span class="n">TERMINAL_OP</span><span class="o">:</span>           <span class="n">0000</span> <span class="n">0001</span><span class="o">,</span>
    <span class="n">UPSTREAM_TERMINAL_OP</span><span class="o">:</span>  <span class="n">0000</span> <span class="n">0000</span>
<span class="o">}</span>
<span class="n">position</span><span class="o">(</span><span class="n">input</span><span class="o">):</span> <span class="n">12</span>
<span class="nl">bitPosition:</span>     <span class="n">24</span> 
<span class="nl">set:</span>       <span class="n">16777216</span> <span class="o">=&gt;</span> <span class="n">0000</span> <span class="n">0001</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span>
<span class="nl">clear:</span>     <span class="n">33554432</span> <span class="o">=&gt;</span> <span class="n">0000</span> <span class="n">0010</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span>   
<span class="nl">preserve:</span>  <span class="n">50331648</span> <span class="o">=&gt;</span> <span class="n">0000</span> <span class="n">0011</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span> <span class="n">0000</span>
</code></pre></td></tr></table>
</div>
</div><p>Then the by-and (&amp;) and by-or (|) operations are used. Suppose A = 0001, B = 0010, C = 1000, then.</p>
<ul>
<li>A|B = A | B = 0001 | 0010 = 0011 (by bit or, 1|0=1, 0|1=1,0|0 =0,1|1=1)</li>
<li>A&amp;B = A &amp; B = 0001 | 0010 = 0000 (by bit with, 1|0=0, 0|1=0,0|0 =0,1|1=1)</li>
<li>MASK = A | B | C = 0001 | 0010 | 1000 = 1011</li>
<li>Then the condition to determine whether A|B contains A is: A == (A|B &amp; A)</li>
<li>Then the condition to determine whether MASK contains A is: A == MASK &amp; A</li>
</ul>
<p>The enumeration in StreamOpFlag is applied here for analysis.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">static</span> <span class="kt">int</span> <span class="n">DISTINCT_SET</span> <span class="o">=</span> <span class="n">0b0001</span><span class="o">;</span>
<span class="kd">static</span> <span class="kt">int</span> <span class="n">SORTED_CLEAR</span> <span class="o">=</span> <span class="n">0b1000</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
    <span class="c1">// 支持DISTINCT标志和不支持SORTED标志
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">DISTINCT_SET</span> <span class="o">|</span> <span class="n">SORTED_CLEAR</span><span class="o">;</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Integer</span><span class="o">.</span><span class="na">toBinaryString</span><span class="o">(</span><span class="n">flags</span><span class="o">));</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">&#34;支持DISTINCT标志:%s\n&#34;</span><span class="o">,</span> <span class="n">DISTINCT_SET</span> <span class="o">==</span> <span class="o">(</span><span class="n">DISTINCT_SET</span> <span class="o">&amp;</span> <span class="n">flags</span><span class="o">));</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">&#34;不支持SORTED标志:%s\n&#34;</span><span class="o">,</span> <span class="n">SORTED_CLEAR</span> <span class="o">==</span> <span class="o">(</span><span class="n">SORTED_CLEAR</span> <span class="o">&amp;</span> <span class="n">flags</span><span class="o">));</span>
<span class="o">}</span>

<span class="c1">// 控制台输出
</span><span class="c1"></span><span class="n">1001</span>
<span class="nl">支持DISTINCT标志:</span><span class="kc">true</span>
<span class="nl">不支持SORTED标志:</span><span class="kc">true</span>
</code></pre></td></tr></table>
</div>
</div><p>Since StreamOpFlag&rsquo;s modifier is the default, it cannot be used directly, and its code can be copied out to modify the package name to verify the functionality inside:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">StreamOpFlag</span><span class="o">.</span><span class="na">DISTINCT</span><span class="o">.</span><span class="na">set</span> <span class="o">|</span> <span class="n">StreamOpFlag</span><span class="o">.</span><span class="na">SORTED</span><span class="o">.</span><span class="na">clear</span><span class="o">;</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">StreamOpFlag</span><span class="o">.</span><span class="na">DISTINCT</span><span class="o">.</span><span class="na">set</span> <span class="o">==</span> <span class="o">(</span><span class="n">StreamOpFlag</span><span class="o">.</span><span class="na">DISTINCT</span><span class="o">.</span><span class="na">set</span> <span class="o">&amp;</span> <span class="n">flags</span><span class="o">));</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">StreamOpFlag</span><span class="o">.</span><span class="na">SORTED</span><span class="o">.</span><span class="na">clear</span> <span class="o">==</span> <span class="o">(</span><span class="n">StreamOpFlag</span><span class="o">.</span><span class="na">SORTED</span><span class="o">.</span><span class="na">clear</span> <span class="o">&amp;</span> <span class="n">flags</span><span class="o">));</span>
<span class="o">}</span>

<span class="c1">// 输出
</span><span class="c1"></span>
<span class="kc">true</span>
<span class="kc">true</span>
</code></pre></td></tr></table>
</div>
</div><p>The following methods are defined based on these arithmetic properties.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">enum</span> <span class="n">StreamOpFlag</span> <span class="o">{</span>

    <span class="c1">// 暂时忽略其他代码
</span><span class="c1"></span>
    <span class="c1">// 返回当前StreamOpFlag的set/inject的bit map
</span><span class="c1"></span>    <span class="kt">int</span> <span class="nf">set</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">set</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 返回当前StreamOpFlag的清除的bit map
</span><span class="c1"></span>    <span class="kt">int</span> <span class="nf">clear</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">clear</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 这里判断当前StreamOpFlag类型-&gt;标记映射中Stream类型的标记，如果大于0说明不是初始化状态，那么当前StreamOpFlag就是Stream相关的标志
</span><span class="c1"></span>    <span class="kt">boolean</span> <span class="nf">isStreamFlag</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">maskTable</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">Type</span><span class="o">.</span><span class="na">STREAM</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 这里就用到按位与判断输入的flags中是否设置当前StreamOpFlag(StreamOpFlag.set)
</span><span class="c1"></span>    <span class="kt">boolean</span> <span class="nf">isKnown</span><span class="o">(</span><span class="kt">int</span> <span class="n">flags</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">preserve</span><span class="o">)</span> <span class="o">==</span> <span class="n">set</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 这里就用到按位与判断输入的flags中是否清除当前StreamOpFlag(StreamOpFlag.clear)
</span><span class="c1"></span>    <span class="kt">boolean</span> <span class="nf">isCleared</span><span class="o">(</span><span class="kt">int</span> <span class="n">flags</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">preserve</span><span class="o">)</span> <span class="o">==</span> <span class="n">clear</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 这里就用到按位与判断输入的flags中是否保留当前StreamOpFlag(StreamOpFlag.clear)
</span><span class="c1"></span>    <span class="kt">boolean</span> <span class="nf">isPreserved</span><span class="o">(</span><span class="kt">int</span> <span class="n">flags</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">preserve</span><span class="o">)</span> <span class="o">==</span> <span class="n">preserve</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 判断当前的Stream实体类型是否可以设置本标志，要求Stream实体类型的标志位为set或者preserve，按位与要大于0
</span><span class="c1"></span>    <span class="kt">boolean</span> <span class="nf">canSet</span><span class="o">(</span><span class="n">Type</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">maskTable</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">t</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">SET_BITS</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 暂时忽略其他代码
</span><span class="c1"></span><span class="o">}</span>

</code></pre></td></tr></table>
</div>
</div><p>Here is a special operation, the bit operation is used (flags &amp; preserve), the reason is: the same Stream entity type in the same flag can only exist one of set/inject, clear and preserve, that is, the same flags can not exist both StreamOpFlag. SORTED.set and StreamOpFlag.SORTED.clear, which are semantically contradictory, while the size (2 bits) and position of set/inject, clear and preserve in the bit map are already fixed, and preserve is designed to be 0b11 exactly 2 bits inverse, so it can be specialised to (This specialization also makes the judgment more rigorous).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="o">(</span>flags <span class="p">&amp;</span> <span class="nb">set</span><span class="o">)</span> <span class="o">==</span> <span class="nb">set</span> <span class="o">=</span>&gt; <span class="o">(</span>flags <span class="p">&amp;</span> preserve<span class="o">)</span> <span class="o">==</span> <span class="nb">set</span>
<span class="o">(</span>flags <span class="p">&amp;</span> clear<span class="o">)</span> <span class="o">==</span> <span class="nv">clear</span> <span class="o">=</span>&gt; <span class="o">(</span>flags <span class="p">&amp;</span> preserve<span class="o">)</span> <span class="o">==</span> clear
<span class="o">(</span>flags <span class="p">&amp;</span> preserve<span class="o">)</span> <span class="o">==</span> <span class="nv">preserve</span> <span class="o">=</span>&gt; <span class="o">(</span>flags <span class="p">&amp;</span> preserve<span class="o">)</span> <span class="o">==</span> preserve
</code></pre></td></tr></table>
</div>
</div><p>Analyze so much, in general, is to want to pass a 32-bit integer, every 2 bits indicate 3 kinds of state, then a complete Flags (Flags collection) can represent a total of 16 kinds of flags (position = [0,15], you can check the API notes, [4,11] and [13,15] position is not required to achieve or reserved, belong to the gap). Then we analyze the example of MaskMask calculation process</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">// 横向看<span class="o">(</span>位移动运算符优先级高于与或，例如&lt;&lt;的优先级比<span class="p">|</span>高<span class="o">)</span>
SPLITERATOR_CHARACTERISTICS_MASK:
mask<span class="o">(</span>init<span class="o">)</span> <span class="o">=</span> <span class="m">0</span>
mask<span class="o">(</span>DISTINCT,SPLITERATOR<span class="o">[</span>DISTINCT<span class="o">]=</span>01,bitPosition<span class="o">=</span>0<span class="o">)</span> <span class="o">=</span> <span class="m">0000</span> <span class="m">0000</span> <span class="p">|</span> <span class="m">0000</span> <span class="m">0001</span> <span class="s">&lt;&lt; 0 = 0</span><span class="m">000</span> <span class="m">0000</span> <span class="p">|</span> <span class="m">0000</span> <span class="nv">0001</span> <span class="o">=</span> <span class="m">0000</span> <span class="m">0001</span>
mask<span class="o">(</span>SORTED,SPLITERATOR<span class="o">[</span>SORTED<span class="o">]=</span>01,bitPosition<span class="o">=</span>2<span class="o">)</span> <span class="o">=</span> <span class="m">0000</span> <span class="m">0001</span> <span class="p">|</span> <span class="m">0000</span> <span class="m">0001</span> <span class="s">&lt;&lt; 2 = 0000 0001 | 0000 0100 = 0000 0101
</span><span class="s">mask(ORDERED,SPLITERATOR[ORDERED]=01,bitPosition=4) = 0000 0101 | 0000 0001 &lt;&lt; 4 = 0000 0101 | 0001 0000 = 0001 0101
</span><span class="s">mask(SIZED,SPLITERATOR[SIZED]=01,bitPosition=6) = 0001 0101 | 0000 0001 &lt;&lt; 6 = 0001 0101 | 0100 0000 = 0101 0101
</span><span class="s">mask(SHORT_CIRCUIT,SPLITERATOR[SHORT_CIRCUIT]=00,bitPosition=2</span>4<span class="o">)</span> <span class="o">=</span> <span class="m">0101</span> <span class="m">0101</span> <span class="p">|</span> <span class="m">0000</span> <span class="m">0000</span> <span class="s">&lt;&lt; 24 = 0101 0101 | 0000 0000 = 0101 0101
</span><span class="s">mask(final) = 0000 0000 0000 0000 0000 0000 0101 0101(二进制)、85(十进制)
</span><span class="s">
</span><span class="s">STREAM_MASK:
</span><span class="s">mask(init) = 0
</span><span class="s">mask(DISTINCT,SPLITERATOR[DISTINCT]=01,bitPosition=0) = 0000 0000 | 0000 0001 &lt;&lt; 0 = 0000 0000 | 0000 0001 = 0000 0001
</span><span class="s">mask(SORTED,SPLITERATOR[SORTED]=01,bitPosition=2) = 0000 0001 | 0000 0001 &lt;&lt; 2 = 0000 0001 | 0000 0100 = 0000 0101
</span><span class="s">mask(ORDERED,SPLITERATOR[ORDERED]=01,bitPosition=4) = 0000 0101 | 0000 0001 &lt;&lt; 4 = 0000 0101 | 0001 0000 = 0001 0101
</span><span class="s">mask(SIZED,SPLITERATOR[SIZED]=01,bitPosition=6) = 0001 0101 | 0000 0001 &lt;&lt; 6 = 0001 0101 | 0100 0000 = 0101 0101
</span><span class="s">mask(SHORT_CIRCUIT,SPLITERATOR[SHORT_CIRCUIT]=00,bitPosition=24</span><span class="o">)</span> <span class="o">=</span> <span class="m">0101</span> <span class="m">0101</span> <span class="p">|</span> <span class="m">0000</span> <span class="m">0000</span> <span class="s">&lt;&lt; 24 = 0101 0101 | 0000 0000 = 0101 0101
</span><span class="s">mask(final) = 0000 0000 0000 0000 0000 0000 0101 0101(二进制)、85(十进制)
</span><span class="s">
</span><span class="s">OP_MASK:
</span><span class="s">mask(init) = 0
</span><span class="s">mask(DISTINCT,SPLITERATOR[DISTINCT]=11,bitPosition=0) = 0000 0000 | 0000 0011 &lt;&lt; 0 = 0000 0000 | 0000 0011 = 0000 0011
</span><span class="s">mask(SORTED,SPLITERATOR[SORTED]=11,bitPosition=2) = 0000 0011 | 0000 0011 &lt;&lt; 2 = 0000 0011 | 0000 1100 = 0000 1111
</span><span class="s">mask(ORDERED,SPLITERATOR[ORDERED]=11,bitPosition=4) = 0000 1111 | 0000 0011 &lt;&lt; 4 = 0000 1111 | 0011 0000 = 0011 1111
</span><span class="s">mask(SIZED,SPLITERATOR[SIZED]=10,bitPosition=6) = 0011 1111 | 0000 0010 &lt;&lt; 6 = 0011 1111 | 1000 0000 = 1011 1111
</span><span class="s">mask(SHORT_CIRCUIT,SPLITERATOR[SHORT_CIRCUIT]=01,bitPosition=24</span><span class="o">)</span> <span class="o">=</span> <span class="m">1011</span> <span class="m">1111</span> <span class="p">|</span> <span class="m">0000</span> <span class="m">0001</span> <span class="s">&lt;&lt; 24 = 1011 1111 | 0100 0000 0000 0000 0000 0000 0000 = 0100 0000 0000 0000 0000 1011 1111
</span><span class="s">mask(final) = 0000 0000 1000 0000 0000 0000 1011 1111(二进制)、16777407(十进制)
</span><span class="s">
</span><span class="s">TERMINAL_OP_MASK:
</span><span class="s">mask(init) = 0
</span><span class="s">mask(DISTINCT,SPLITERATOR[DISTINCT]=00,bitPosition=0) = 0000 0000 | 0000 0000 &lt;&lt; 0 = 0000 0000 | 0000 0000 = 0000 0000
</span><span class="s">mask(SORTED,SPLITERATOR[SORTED]=00,bitPosition=2) = 0000 0000 | 0000 0000 &lt;&lt; 2 = 0000 0000 | 0000 0000 = 0000 0000
</span><span class="s">mask(ORDERED,SPLITERATOR[ORDERED]=10,bitPosition=4) = 0000 0000 | 0000 0010 &lt;&lt; 4 = 0000 0000 | 0010 0000 = 0010 0000
</span><span class="s">mask(SIZED,SPLITERATOR[SIZED]=00,bitPosition=6) = 0010 0000 | 0000 0000 &lt;&lt; 6 = 0010 0000 | 0000 0000 = 0010 0000
</span><span class="s">mask(SHORT_CIRCUIT,SPLITERATOR[SHORT_CIRCUIT]=01,bitPosition=24</span><span class="o">)</span> <span class="o">=</span> <span class="m">0010</span> <span class="m">0000</span> <span class="p">|</span> <span class="m">0000</span> <span class="m">0001</span> <span class="s">&lt;&lt; 24 = 0010 0000 | 0001 0000 0000 0000 0000 0000 0000 = 0001 0000 0000 0000 0000 0010 0000
</span><span class="s">mask(final) = 0000 0001 0000 0000 0000 0000 0010 0000(二进制)、1677724</span>8<span class="o">(</span>十进制<span class="o">)</span>

UPSTREAM_TERMINAL_OP_MASK:
mask<span class="o">(</span>init<span class="o">)</span> <span class="o">=</span> <span class="m">0</span>
mask<span class="o">(</span>DISTINCT,SPLITERATOR<span class="o">[</span>DISTINCT<span class="o">]=</span>00,bitPosition<span class="o">=</span>0<span class="o">)</span> <span class="o">=</span> <span class="m">0000</span> <span class="m">0000</span> <span class="p">|</span> <span class="m">0000</span> <span class="m">0000</span> <span class="s">&lt;&lt; 0 = 0</span><span class="m">000</span> <span class="m">0000</span> <span class="p">|</span> <span class="m">0000</span> <span class="nv">0000</span> <span class="o">=</span> <span class="m">0000</span> <span class="m">0000</span>
mask<span class="o">(</span>SORTED,SPLITERATOR<span class="o">[</span>SORTED<span class="o">]=</span>00,bitPosition<span class="o">=</span>2<span class="o">)</span> <span class="o">=</span> <span class="m">0000</span> <span class="m">0000</span> <span class="p">|</span> <span class="m">0000</span> <span class="m">0000</span> <span class="s">&lt;&lt; 2 = 0000 0000 | 0000 0000 = 0000 0000
</span><span class="s">mask(ORDERED,SPLITERATOR[ORDERED]=10,bitPosition=4) = 0000 0000 | 0000 0010 &lt;&lt; 4 = 0000 0000 | 0010 0000 = 0010 0000
</span><span class="s">mask(SIZED,SPLITERATOR[SIZED]=00,bitPosition=6) = 0010 0000 | 0000 0000 &lt;&lt; 6 = 0010 0000 | 0000 0000 = 0010 0000
</span><span class="s">mask(SHORT_CIRCUIT,SPLITERATOR[SHORT_CIRCUIT]=00,bitPosition=2</span>4<span class="o">)</span> <span class="o">=</span> <span class="m">0010</span> <span class="m">0000</span> <span class="p">|</span> <span class="m">0000</span> <span class="m">0000</span> <span class="s">&lt;&lt; 24 = 0010 0000 | 0000 0000 = 0010 0000
</span><span class="s">mask(final) = 0000 0000 0000 0000 0000 0000 0010 0000(二进制)、32</span><span class="o">(</span>十进制<span class="o">)</span>
</code></pre></td></tr></table>
</div>
</div><p>The related methods and properties are as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">enum</span> <span class="n">StreamOpFlag</span> <span class="o">{</span>

    <span class="c1">// SPLITERATOR类型的标志bit map
</span><span class="c1"></span>    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">SPLITERATOR_CHARACTERISTICS_MASK</span> <span class="o">=</span> <span class="n">createMask</span><span class="o">(</span><span class="n">Type</span><span class="o">.</span><span class="na">SPLITERATOR</span><span class="o">);</span>

    <span class="c1">// STREAM类型的标志bit map
</span><span class="c1"></span>    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">STREAM_MASK</span> <span class="o">=</span> <span class="n">createMask</span><span class="o">(</span><span class="n">Type</span><span class="o">.</span><span class="na">STREAM</span><span class="o">);</span>

    <span class="c1">// OP类型的标志bit map
</span><span class="c1"></span>    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">OP_MASK</span> <span class="o">=</span> <span class="n">createMask</span><span class="o">(</span><span class="n">Type</span><span class="o">.</span><span class="na">OP</span><span class="o">);</span>

    <span class="c1">// TERMINAL_OP类型的标志bit map
</span><span class="c1"></span>    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">TERMINAL_OP_MASK</span> <span class="o">=</span> <span class="n">createMask</span><span class="o">(</span><span class="n">Type</span><span class="o">.</span><span class="na">TERMINAL_OP</span><span class="o">);</span>

    <span class="c1">// UPSTREAM_TERMINAL_OP类型的标志bit map
</span><span class="c1"></span>    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">UPSTREAM_TERMINAL_OP_MASK</span> <span class="o">=</span> <span class="n">createMask</span><span class="o">(</span><span class="n">Type</span><span class="o">.</span><span class="na">UPSTREAM_TERMINAL_OP</span><span class="o">);</span>

    <span class="c1">// 基于Stream类型，创建对应类型填充所有标志的bit map
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">createMask</span><span class="o">(</span><span class="n">Type</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">StreamOpFlag</span> <span class="n">flag</span> <span class="o">:</span> <span class="n">StreamOpFlag</span><span class="o">.</span><span class="na">values</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">mask</span> <span class="o">|=</span> <span class="n">flag</span><span class="o">.</span><span class="na">maskTable</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">t</span><span class="o">)</span> <span class="o">&lt;&lt;</span> <span class="n">flag</span><span class="o">.</span><span class="na">bitPosition</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">mask</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 构造一个标志本身的掩码，就是所有标志都采用保留位表示，目前作为flags == 0时候的初始值
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">FLAG_MASK</span> <span class="o">=</span> <span class="n">createFlagMask</span><span class="o">();</span>
    
    <span class="c1">// 构造一个包含全部标志中的preserve位的bit map，按照目前来看是暂时是一个固定值，二进制表示为0011 0000 0000 0000 0000 1111 1111
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">createFlagMask</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">StreamOpFlag</span> <span class="n">flag</span> <span class="o">:</span> <span class="n">StreamOpFlag</span><span class="o">.</span><span class="na">values</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">mask</span> <span class="o">|=</span> <span class="n">flag</span><span class="o">.</span><span class="na">preserve</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">mask</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 构造一个Stream类型包含全部标志中的set位的bit map，这里直接使用了STREAM_MASK，按照目前来看是暂时是一个固定值，二进制表示为0000 0000 0000 0000 0000 0000 0101 0101
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">FLAG_MASK_IS</span> <span class="o">=</span> <span class="n">STREAM_MASK</span><span class="o">;</span>

    <span class="c1">// 构造一个Stream类型包含全部标志中的clear位的bit map，按照目前来看是暂时是一个固定值，二进制表示为0000 0000 0000 0000 0000 0000 1010 1010
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">FLAG_MASK_NOT</span> <span class="o">=</span> <span class="n">STREAM_MASK</span> <span class="o">&lt;&lt;</span> <span class="n">1</span><span class="o">;</span>

    <span class="c1">// 初始化操作的标志bit map，目前来看就是Stream的头节点初始化时候需要合并在flags里面的初始化值，照目前来看是暂时是一个固定值，二进制表示为0000 0000 0000 0000 0000 0000 1111 1111
</span><span class="c1"></span>    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">INITIAL_OPS_VALUE</span> <span class="o">=</span> <span class="n">FLAG_MASK_IS</span> <span class="o">|</span> <span class="n">FLAG_MASK_NOT</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The 5 members of SPLITERATOR_CHARACTERISTICS_MASK (see the Mask calculation example above) are actually the bit map of all StreamOpFlag flags of the corresponding Stream entity type, which is the &ldquo;horizontal&rdquo; display of the mapping of the Stream&rsquo;s type and flags.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/07/844f1fcc346f458c888ee4f8caedc928.png" alt=""></p>
<p>The previous analysis has been relatively detailed and the process is very complex, but the more complex application of Mask is still in the later methods. the initialization of Mask is provided for the operation of merging (combine) and transforming (transforming from characteristics in Spliterator to flags) of flags, see the following methods.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">enum</span> <span class="n">StreamOpFlag</span> <span class="o">{</span>
    
    <span class="c1">// 这个方法完全没有注释，只使用在下面的combineOpFlags()方法中
</span><span class="c1"></span>    <span class="c1">// 从源码来看
</span><span class="c1"></span>    <span class="c1">// 入参flags == 0的时候，那么直接返回0011 0000 0000 0000 0000 1111 1111
</span><span class="c1"></span>    <span class="c1">// 入参flags != 0的时候，那么会把当前flags的所有set/inject、clear和preserve所在位在bit map中全部置为0，然后其他位全部置为1
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">getMask</span><span class="o">(</span><span class="kt">int</span> <span class="n">flags</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">flags</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span>
               <span class="o">?</span> <span class="n">FLAG_MASK</span>
               <span class="o">:</span> <span class="o">~(</span><span class="n">flags</span> <span class="o">|</span> <span class="o">((</span><span class="n">FLAG_MASK_IS</span> <span class="o">&amp;</span> <span class="n">flags</span><span class="o">)</span> <span class="o">&lt;&lt;</span> <span class="n">1</span><span class="o">)</span> <span class="o">|</span> <span class="o">((</span><span class="n">FLAG_MASK_NOT</span> <span class="o">&amp;</span> <span class="n">flags</span><span class="o">)</span> <span class="o">&gt;&gt;</span> <span class="n">1</span><span class="o">));</span>
    <span class="o">}</span>
    
    <span class="c1">// 合并新的flags和前一个flags，这里还是用到老套路先和Mask按位与，再进行一次按位或
</span><span class="c1"></span>    <span class="c1">// 作为Stream的头节点的时候，prevCombOpFlags必须为INITIAL_OPS_VALUE
</span><span class="c1"></span>    <span class="kd">static</span> <span class="kt">int</span> <span class="nf">combineOpFlags</span><span class="o">(</span><span class="kt">int</span> <span class="n">newStreamOrOpFlags</span><span class="o">,</span> <span class="kt">int</span> <span class="n">prevCombOpFlags</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 0x01 or 0x10 nibbles are transformed to 0x11
</span><span class="c1"></span>        <span class="c1">// 0x00 nibbles remain unchanged
</span><span class="c1"></span>        <span class="c1">// Then all the bits are flipped
</span><span class="c1"></span>        <span class="c1">// Then the result is logically or&#39;ed with the operation flags.
</span><span class="c1"></span>        <span class="k">return</span> <span class="o">(</span><span class="n">prevCombOpFlags</span> <span class="o">&amp;</span> <span class="n">StreamOpFlag</span><span class="o">.</span><span class="na">getMask</span><span class="o">(</span><span class="n">newStreamOrOpFlags</span><span class="o">))</span> <span class="o">|</span> <span class="n">newStreamOrOpFlags</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="c1">// 通过合并后的flags，转换出Stream类型的flags
</span><span class="c1"></span>    <span class="kd">static</span> <span class="kt">int</span> <span class="nf">toStreamFlags</span><span class="o">(</span><span class="kt">int</span> <span class="n">combOpFlags</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// By flipping the nibbles 0x11 become 0x00 and 0x01 become 0x10
</span><span class="c1"></span>        <span class="c1">// Shift left 1 to restore set flags and mask off anything other than the set flags
</span><span class="c1"></span>        <span class="k">return</span> <span class="o">((~</span><span class="n">combOpFlags</span><span class="o">)</span> <span class="o">&gt;&gt;</span> <span class="n">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">FLAG_MASK_IS</span> <span class="o">&amp;</span> <span class="n">combOpFlags</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="c1">// Stream的标志转换为Spliterator的characteristics
</span><span class="c1"></span>    <span class="kd">static</span> <span class="kt">int</span> <span class="nf">toCharacteristics</span><span class="o">(</span><span class="kt">int</span> <span class="n">streamFlags</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">streamFlags</span> <span class="o">&amp;</span> <span class="n">SPLITERATOR_CHARACTERISTICS_MASK</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="c1">// Spliterator的characteristics转换为Stream的标志，入参是Spliterator实例
</span><span class="c1"></span>    <span class="kd">static</span> <span class="kt">int</span> <span class="nf">fromCharacteristics</span><span class="o">(</span><span class="n">Spliterator</span><span class="o">&lt;?&gt;</span> <span class="n">spliterator</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">characteristics</span> <span class="o">=</span> <span class="n">spliterator</span><span class="o">.</span><span class="na">characteristics</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">characteristics</span> <span class="o">&amp;</span> <span class="n">Spliterator</span><span class="o">.</span><span class="na">SORTED</span><span class="o">)</span> <span class="o">!=</span> <span class="n">0</span> <span class="o">&amp;&amp;</span> <span class="n">spliterator</span><span class="o">.</span><span class="na">getComparator</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Do not propagate the SORTED characteristic if it does not correspond
</span><span class="c1"></span>            <span class="c1">// to a natural sort order
</span><span class="c1"></span>            <span class="k">return</span> <span class="n">characteristics</span> <span class="o">&amp;</span> <span class="n">SPLITERATOR_CHARACTERISTICS_MASK</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">Spliterator</span><span class="o">.</span><span class="na">SORTED</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">characteristics</span> <span class="o">&amp;</span> <span class="n">SPLITERATOR_CHARACTERISTICS_MASK</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// Spliterator的characteristics转换为Stream的标志，入参是Spliterator的characteristics
</span><span class="c1"></span>    <span class="kd">static</span> <span class="kt">int</span> <span class="nf">fromCharacteristics</span><span class="o">(</span><span class="kt">int</span> <span class="n">characteristics</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">characteristics</span> <span class="o">&amp;</span> <span class="n">SPLITERATOR_CHARACTERISTICS_MASK</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The bitwise operations here are complex, and only simple calculations and related functions are shown.</p>
<ul>
<li>combineOpFlags(): used to merge the new flags and the previous flags, because the data structure of Stream is a Pipeline, the successor node needs to merge the flags of the predecessor node, for example, the predecessor node flags is ORDERED.set, the current new node (successor node) that joins the Pipeline has new flags is SIZED.set, then the flags of the predecessor node should be merged in the successor node, simply imagine SIZED.set | ORDERED.set, if it is the head node, then the flags when initializing the head node should be merged INITIAL_OPS_VALUE, here is an example.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">ORDERED</span><span class="o">.</span><span class="na">set</span> <span class="o">|</span> <span class="n">DISTINCT</span><span class="o">.</span><span class="na">set</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">SIZED</span><span class="o">.</span><span class="na">clear</span> <span class="o">|</span> <span class="n">SORTED</span><span class="o">.</span><span class="na">clear</span><span class="o">;</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;left:&#34;</span> <span class="o">+</span> <span class="n">Integer</span><span class="o">.</span><span class="na">toBinaryString</span><span class="o">(</span><span class="n">left</span><span class="o">));</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;right:&#34;</span> <span class="o">+</span> <span class="n">Integer</span><span class="o">.</span><span class="na">toBinaryString</span><span class="o">(</span><span class="n">right</span><span class="o">));</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;right mask:&#34;</span> <span class="o">+</span> <span class="n">Integer</span><span class="o">.</span><span class="na">toBinaryString</span><span class="o">(</span><span class="n">getMask</span><span class="o">(</span><span class="n">right</span><span class="o">)));</span>
<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;combine:&#34;</span> <span class="o">+</span> <span class="n">Integer</span><span class="o">.</span><span class="na">toBinaryString</span><span class="o">(</span><span class="n">combineOpFlags</span><span class="o">(</span><span class="n">right</span><span class="o">,</span> <span class="n">left</span><span class="o">)));</span>

<span class="c1">// 输出结果
</span><span class="c1"></span><span class="nl">left:</span><span class="n">1010001</span>
<span class="nl">right:</span><span class="n">10001000</span>
<span class="n">right</span> <span class="n">mask</span><span class="o">:</span><span class="n">11111111111111111111111100110011</span>
<span class="nl">combine:</span><span class="n">10011001</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>The reason why the characteristics in Spliterator can be converted to flags by a simple bitwise conversion is that the characteristics in Spliterator are designed to match the StreamOpFlag, or to be precise, the bit map&rsquo;s bit distribution is matched, so it can be done directly with SPLITERATOR_CHARACTERISTICS_MASK by bitwise conversion, see the following example.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">// 这里简单点只展示8 bit
SPLITERATOR_CHARACTERISTICS_MASK: <span class="m">0101</span> <span class="m">0101</span>
Spliterator.ORDERED:              <span class="m">0001</span> <span class="m">0000</span>
StreamOpFlag.ORDERED.set:         <span class="m">0001</span> <span class="m">0000</span>
</code></pre></td></tr></table>
</div>
</div><p>At this point, the complete implementation of StreamOpFlag has been analyzed, Mask-related methods are not intended to be expanded in detail, the following will begin to analyze the implementation of the &ldquo;pipeline&rdquo; structure in Stream, because of habit, the following two terms &ldquo;flag&rdquo; and &ldquo;characteristics&rdquo; will be mixed.</p>
<h2 id="referencepipeline-source-code-analysis">ReferencePipeline source code analysis</h2>
<p>Since Stream has the characteristics of stream, it needs a chain data structure, so that the elements can &ldquo;flow&rdquo; from the Source all the way down and pass to each chain node, the common data structure to achieve this scenario is a two-way chain table (considering the need for backtracking, a one-way chain table is not suitable), the more famous implementations are AQS and Netty&rsquo;s ChannelHandlerContext. For example, the pipeline ChannelPipeline in Netty is designed as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/07/e5edd436e35540fb8a1e630bec67b108.png" alt=""></p>
<p>For this bi-directional linked table data structure, the corresponding class in Stream is AbstractPipeline, and the core implementation classes are in ReferencePipeline and ReferencePipeline&rsquo;s internal classes.</p>
<h3 id="main-interfaces">Main interfaces</h3>
<p>First, a brief demonstration of AbstractPipeline&rsquo;s core parent class method definitions, the main parent classes are Stream, BaseStream and PipelineHelper.</p>
<ul>
<li>Stream represents a sequence of elements supporting serial and parallel aggregation operations. This top-level interface provides definitions for stream intermediate operations, termination operations and some static factory methods (too many to list here), which are essentially a builder-type interface (for picking up intermediate operations) and can form a chain of multiple intermediate operations and single termination operations, e.g.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Stream</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">BaseStream</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="o">{</span>
    
    <span class="c1">// 忽略其他代码
</span><span class="c1"></span>
    <span class="c1">// 过滤Op
</span><span class="c1"></span>    <span class="n">Stream</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">filter</span><span class="o">(</span><span class="n">Predicate</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">predicate</span><span class="o">);</span>

    <span class="c1">// 映射Op
</span><span class="c1"></span>    <span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="nf">map</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">,</span> <span class="o">?</span> <span class="kd">extends</span> <span class="n">R</span><span class="o">&gt;</span> <span class="n">mapper</span><span class="o">);</span>
    
    <span class="c1">// 终结操作 - 遍历
</span><span class="c1"></span>    <span class="kt">void</span> <span class="nf">forEach</span><span class="o">(</span><span class="n">Consumer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">action</span><span class="o">);</span>

    <span class="c1">// 忽略其他代码
</span><span class="c1"></span><span class="o">}</span>

<span class="c1">// init
</span><span class="c1"></span><span class="n">Stream</span> <span class="n">x</span> <span class="o">=</span> <span class="n">buildStream</span><span class="o">();</span>
<span class="c1">// chain: head -&gt; filter(Op) -&gt; map(Op) -&gt; forEach(Terminal Op)
</span><span class="c1"></span><span class="n">x</span><span class="o">.</span><span class="na">filter</span><span class="o">().</span><span class="na">map</span><span class="o">().</span><span class="na">forEach</span><span class="o">()</span>

</code></pre></td></tr></table>
</div>
</div><ul>
<li>BaseStream: The basic interface of Stream, defining the iterator of streams, equivalent variants of streams (concurrent processing variants, synchronous processing variants and variants that do not support sequential processing of elements), concurrent and synchronous judgments and closing related methods</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="c1">// T是元素类型，S是BaseStream&lt;T, S&gt;类型
</span><span class="c1">// 流的基础接口，这里的流指定的支持同步执行和异步执行的聚合操作的元素序列
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">BaseStream</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">S</span> <span class="kd">extends</span> <span class="n">BaseStream</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">S</span><span class="o">&gt;&gt;</span> <span class="kd">extends</span> <span class="n">AutoCloseable</span> <span class="o">{</span>
    
    <span class="c1">// 返回一个当前Stream实例中所有元素的迭代器
</span><span class="c1"></span>    <span class="c1">// 这是一个终结操作
</span><span class="c1"></span>    <span class="n">Iterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">iterator</span><span class="o">();</span>
    
    <span class="c1">// 返回一个当前Stream实例中所有元素的可拆分迭代器
</span><span class="c1"></span>    <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">spliterator</span><span class="o">();</span>
    
    <span class="c1">// 当前的Stream实例是否支持并发
</span><span class="c1"></span>    <span class="kt">boolean</span> <span class="nf">isParallel</span><span class="o">();</span>
    
    <span class="c1">// 返回一个等效的同步处理的Stream实例
</span><span class="c1"></span>    <span class="n">S</span> <span class="nf">sequential</span><span class="o">();</span>
    
    <span class="c1">// 返回一个等效的并发处理的Stream实例
</span><span class="c1"></span>    <span class="n">S</span> <span class="nf">parallel</span><span class="o">();</span>
    
    <span class="c1">// 返回一个等效的不支持StreamOpFlag.ORDERED特性的Stream实例
</span><span class="c1"></span>    <span class="c1">// 或者说支持StreamOpFlag.NOT_ORDERED的特性，也就返回的变体Stream在处理元素的时候不需要顺序处理
</span><span class="c1"></span>    <span class="n">S</span> <span class="nf">unordered</span><span class="o">();</span>
    
    <span class="c1">// 返回一个添加了close处理器的Stream实例，close处理器会在下面的close方法中回调
</span><span class="c1"></span>    <span class="n">S</span> <span class="nf">onClose</span><span class="o">(</span><span class="n">Runnable</span> <span class="n">closeHandler</span><span class="o">);</span>
    
    <span class="c1">// 关闭当前Stream实例，回调关联本Stream的所有close处理器
</span><span class="c1"></span>    <span class="nd">@Override</span>
    <span class="kt">void</span> <span class="nf">close</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>PipelineHelper：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">PipelineHelper</span><span class="o">&lt;</span><span class="n">P_OUT</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="c1">// 获取流的流水线的数据源的&#34;形状&#34;，其实就是数据源元素的类型
</span><span class="c1"></span>    <span class="c1">// 主要有四种类型：REFERENCE（除了int、long和double之外的引用类型）、INT_VALUE、LONG_VALUE和DOUBLE_VALUE
</span><span class="c1"></span>    <span class="kd">abstract</span> <span class="n">StreamShape</span> <span class="nf">getSourceShape</span><span class="o">();</span>

    <span class="c1">// 获取合并流和流操作的标志，合并的标志包括流的数据源标志、中间操作标志和终结操作标志
</span><span class="c1"></span>    <span class="c1">// 从实现上看是当前流管道节点合并前面所有节点和自身节点标志的所有标志
</span><span class="c1"></span>    <span class="kd">abstract</span> <span class="kt">int</span> <span class="nf">getStreamAndOpFlags</span><span class="o">();</span>

    <span class="c1">// 如果当前的流管道节点的合并标志集合支持SIZED，则调用Spliterator.getExactSizeIfKnown()返回数据源中的准确元素数量，否则返回-1
</span><span class="c1"></span>    <span class="kd">abstract</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="kt">long</span> <span class="nf">exactOutputSizeIfKnown</span><span class="o">(</span><span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="n">spliterator</span><span class="o">);</span>

    <span class="c1">// 相当于调用下面的方法组合：copyInto(wrapSink(sink), spliterator)
</span><span class="c1"></span>    <span class="kd">abstract</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">,</span> <span class="n">S</span> <span class="kd">extends</span> <span class="n">Sink</span><span class="o">&lt;</span><span class="n">P_OUT</span><span class="o">&gt;&gt;</span> <span class="n">S</span> <span class="nf">wrapAndCopyInto</span><span class="o">(</span><span class="n">S</span> <span class="n">sink</span><span class="o">,</span> <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="n">spliterator</span><span class="o">);</span>

    <span class="c1">// 发送所有来自Spliterator中的元素到Sink中，如果支持SHORT_CIRCUIT标志，则会调用copyIntoWithCancel
</span><span class="c1"></span>    <span class="kd">abstract</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">copyInto</span><span class="o">(</span><span class="n">Sink</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="n">wrappedSink</span><span class="o">,</span> <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="n">spliterator</span><span class="o">);</span>

    <span class="c1">// 发送所有来自Spliterator中的元素到Sink中，Sink处理完每个元素后会检查Sink#cancellationRequested()方法的状态去判断是否中断推送元素的操作
</span><span class="c1"></span>    <span class="kd">abstract</span> <span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="kt">boolean</span> <span class="nf">copyIntoWithCancel</span><span class="o">(</span><span class="n">Sink</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="n">wrappedSink</span><span class="o">,</span> <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="n">spliterator</span><span class="o">);</span>

    <span class="c1">// 创建接收元素类型为P_IN的Sink实例，实现PipelineHelper中描述的所有中间操作，用这个Sink去包装传入的Sink实例（传入的Sink实例的元素类型为PipelineHelper的输出类型P_OUT）
</span><span class="c1"></span>    <span class="kd">abstract</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="n">Sink</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="nf">wrapSink</span><span class="o">(</span><span class="n">Sink</span><span class="o">&lt;</span><span class="n">P_OUT</span><span class="o">&gt;</span> <span class="n">sink</span><span class="o">);</span>

    <span class="c1">// 包装传入的spliterator，从源码来看，在Stream链的头节点调用会直接返回传入的实例，如果在非头节点调用会委托到StreamSpliterators.WrappingSpliterator()方法进行包装
</span><span class="c1"></span>    <span class="c1">// 这个方法在源码中没有API注释
</span><span class="c1"></span>    <span class="kd">abstract</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">P_OUT</span><span class="o">&gt;</span> <span class="nf">wrapSpliterator</span><span class="o">(</span><span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="n">spliterator</span><span class="o">);</span>

    <span class="c1">// 构造一个兼容当前Stream元素&#34;形状&#34;的Node.Builder实例
</span><span class="c1"></span>    <span class="c1">// 从源码来看直接委托到Nodes.builder()方法
</span><span class="c1"></span>    <span class="kd">abstract</span> <span class="n">Node</span><span class="o">.</span><span class="na">Builder</span><span class="o">&lt;</span><span class="n">P_OUT</span><span class="o">&gt;</span> <span class="nf">makeNodeBuilder</span><span class="o">(</span><span class="kt">long</span> <span class="n">exactSizeIfKnown</span><span class="o">,</span>
                                                 <span class="n">IntFunction</span><span class="o">&lt;</span><span class="n">P_OUT</span><span class="o">[]&gt;</span> <span class="n">generator</span><span class="o">);</span>

    <span class="c1">// Stream流水线所有阶段(节点)应用于数据源Spliterator，输出的元素作为结果收集起来转化为Node实例
</span><span class="c1"></span>    <span class="c1">// 此方法应用于toArray()方法的计算，本质上是一个终结操作
</span><span class="c1"></span>    <span class="kd">abstract</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">P_OUT</span><span class="o">&gt;</span> <span class="nf">evaluate</span><span class="o">(</span><span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="n">spliterator</span><span class="o">,</span>
                                        <span class="kt">boolean</span> <span class="n">flatten</span><span class="o">,</span>
                                        <span class="n">IntFunction</span><span class="o">&lt;</span><span class="n">P_OUT</span><span class="o">[]&gt;</span> <span class="n">generator</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Note one thing (repeat 3 times).</p>
<ul>
<li>The synchronous stream is referred to here as a stream of synchronous processing|execution, and the &ldquo;parallel stream&rdquo; is referred to as a stream of concurrent processing|execution, because the parallel stream is ambiguous and is actually only concurrent execution, not parallel execution</li>
<li>The synchronous stream is referred to here as a stream of synchronous processing|execution, and the &ldquo;parallel stream&rdquo; is referred to as a stream of concurrent processing|execution, because the parallel stream is ambiguous and is actually only concurrent execution, not parallel execution</li>
<li>The synchronous stream is referred to here as a stream of synchronous processing|execution, and the &ldquo;parallel stream&rdquo; is referred to as a stream of concurrent processing|execution, because the parallel stream is ambiguous and is actually only concurrent execution, not parallel execution</li>
</ul>
<h3 id="sink-and-reference-type-chains">Sink and reference type chains</h3>
<p>The interface Sink exists in several methods of PipelineHelper, which was not analyzed in the previous section and will be expanded in this subsection. This is similar to a multi-layer wrapper programming model, simplified as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">WrapperApp</span> <span class="o">{</span>

    <span class="kd">interface</span> <span class="nc">Wrapper</span> <span class="o">{</span>

        <span class="kt">void</span> <span class="nf">doAction</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">AtomicInteger</span> <span class="n">counter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicInteger</span><span class="o">(</span><span class="n">0</span><span class="o">);</span>
        <span class="n">Wrapper</span> <span class="n">first</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">&#34;wrapper [depth =&gt; %d] invoke\n&#34;</span><span class="o">,</span> <span class="n">counter</span><span class="o">.</span><span class="na">incrementAndGet</span><span class="o">());</span>
        <span class="n">Wrapper</span> <span class="n">second</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">first</span><span class="o">.</span><span class="na">doAction</span><span class="o">();</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">&#34;wrapper [depth =&gt; %d] invoke\n&#34;</span><span class="o">,</span> <span class="n">counter</span><span class="o">.</span><span class="na">incrementAndGet</span><span class="o">());</span>
        <span class="o">};</span>
        <span class="n">second</span><span class="o">.</span><span class="na">doAction</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 控制台输出
</span><span class="c1"></span><span class="n">wrapper</span> <span class="o">[</span><span class="n">depth</span> <span class="o">=&gt;</span> <span class="n">1</span><span class="o">]</span> <span class="n">invoke</span>
<span class="n">wrapper</span> <span class="o">[</span><span class="n">depth</span> <span class="o">=&gt;</span> <span class="n">2</span><span class="o">]</span> <span class="n">invoke</span>
</code></pre></td></tr></table>
</div>
</div><p>The above example is a bit abrupt, and two different Sink implementations can be achieved without sensory integration, citing another example as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Sink</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">Consumer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="k">default</span> <span class="kt">void</span> <span class="nf">begin</span><span class="o">(</span><span class="kt">long</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>

    <span class="o">}</span>

    <span class="k">default</span> <span class="kt">void</span> <span class="nf">end</span><span class="o">()</span> <span class="o">{</span>

    <span class="o">}</span>

    <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">ChainedReference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">OUT</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="n">Sink</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>

        <span class="kd">protected</span> <span class="kd">final</span> <span class="n">Sink</span><span class="o">&lt;</span><span class="n">OUT</span><span class="o">&gt;</span> <span class="n">downstream</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">ChainedReference</span><span class="o">(</span><span class="n">Sink</span><span class="o">&lt;</span><span class="n">OUT</span><span class="o">&gt;</span> <span class="n">downstream</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">downstream</span> <span class="o">=</span> <span class="n">downstream</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="nd">@SuppressWarnings</span><span class="o">({</span><span class="s">&#34;unchecked&#34;</span><span class="o">,</span> <span class="s">&#34;rawtypes&#34;</span><span class="o">})</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReferenceChain</span><span class="o">&lt;</span><span class="n">OUT</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="cm">/**
</span><span class="cm">     * sink chain
</span><span class="cm">     */</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Supplier</span><span class="o">&lt;</span><span class="n">Sink</span><span class="o">&lt;?&gt;&gt;&gt;</span> <span class="n">sinkBuilders</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>

    <span class="cm">/**
</span><span class="cm">     * current sink
</span><span class="cm">     */</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">AtomicReference</span><span class="o">&lt;</span><span class="n">Sink</span><span class="o">&gt;</span> <span class="n">sinkReference</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicReference</span><span class="o">&lt;&gt;();</span>

    <span class="kd">public</span> <span class="n">ReferenceChain</span><span class="o">&lt;</span><span class="n">OUT</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="nf">filter</span><span class="o">(</span><span class="n">Predicate</span><span class="o">&lt;</span><span class="n">OUT</span><span class="o">&gt;</span> <span class="n">predicate</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//filter
</span><span class="c1"></span>        <span class="n">sinkBuilders</span><span class="o">.</span><span class="na">add</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">Sink</span><span class="o">&lt;</span><span class="n">OUT</span><span class="o">&gt;</span> <span class="n">prevSink</span> <span class="o">=</span> <span class="o">(</span><span class="n">Sink</span><span class="o">&lt;</span><span class="n">OUT</span><span class="o">&gt;)</span> <span class="n">sinkReference</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
            <span class="n">Sink</span><span class="o">.</span><span class="na">ChainedReference</span><span class="o">&lt;</span><span class="n">OUT</span><span class="o">,</span> <span class="n">OUT</span><span class="o">&gt;</span> <span class="n">currentSink</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Sink</span><span class="o">.</span><span class="na">ChainedReference</span><span class="o">&lt;&gt;(</span><span class="n">prevSink</span><span class="o">)</span> <span class="o">{</span>

                <span class="nd">@Override</span>
                <span class="kd">public</span> <span class="kt">void</span> <span class="nf">accept</span><span class="o">(</span><span class="n">OUT</span> <span class="n">out</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">predicate</span><span class="o">.</span><span class="na">test</span><span class="o">(</span><span class="n">out</span><span class="o">))</span> <span class="o">{</span>
                        <span class="n">downstream</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">out</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">};</span>
            <span class="n">sinkReference</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">currentSink</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">currentSink</span><span class="o">;</span>
        <span class="o">});</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">ReferenceChain</span><span class="o">&lt;</span><span class="n">OUT</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="nf">map</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;</span><span class="n">OUT</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="n">function</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// map
</span><span class="c1"></span>        <span class="n">sinkBuilders</span><span class="o">.</span><span class="na">add</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">Sink</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="n">prevSink</span> <span class="o">=</span> <span class="o">(</span><span class="n">Sink</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;)</span> <span class="n">sinkReference</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
            <span class="n">Sink</span><span class="o">.</span><span class="na">ChainedReference</span><span class="o">&lt;</span><span class="n">OUT</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="n">currentSink</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Sink</span><span class="o">.</span><span class="na">ChainedReference</span><span class="o">&lt;&gt;(</span><span class="n">prevSink</span><span class="o">)</span> <span class="o">{</span>

                <span class="nd">@Override</span>
                <span class="kd">public</span> <span class="kt">void</span> <span class="nf">accept</span><span class="o">(</span><span class="n">OUT</span> <span class="n">in</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">downstream</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">function</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">in</span><span class="o">));</span>
                <span class="o">}</span>
            <span class="o">};</span>
            <span class="n">sinkReference</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">currentSink</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">currentSink</span><span class="o">;</span>
        <span class="o">});</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">forEachPrint</span><span class="o">(</span><span class="n">Collection</span><span class="o">&lt;</span><span class="n">OUT</span><span class="o">&gt;</span> <span class="n">collection</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">forEachPrint</span><span class="o">(</span><span class="n">collection</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">forEachPrint</span><span class="o">(</span><span class="n">Collection</span><span class="o">&lt;</span><span class="n">OUT</span><span class="o">&gt;</span> <span class="n">collection</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">reverse</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">OUT</span><span class="o">&gt;</span> <span class="n">spliterator</span> <span class="o">=</span> <span class="n">collection</span><span class="o">.</span><span class="na">spliterator</span><span class="o">();</span>
        <span class="c1">// 这个是类似于terminal op
</span><span class="c1"></span>        <span class="n">Sink</span><span class="o">&lt;</span><span class="n">OUT</span><span class="o">&gt;</span> <span class="n">sink</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">;</span>
        <span class="n">sinkReference</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">sink</span><span class="o">);</span>
        <span class="n">Sink</span><span class="o">&lt;</span><span class="n">OUT</span><span class="o">&gt;</span> <span class="n">stage</span> <span class="o">=</span> <span class="n">sink</span><span class="o">;</span>
        <span class="c1">// 反向包装 -&gt; 正向遍历
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">reverse</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">sinkBuilders</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">Supplier</span><span class="o">&lt;</span><span class="n">Sink</span><span class="o">&lt;?&gt;&gt;</span> <span class="n">supplier</span> <span class="o">=</span> <span class="n">sinkBuilders</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                <span class="n">stage</span> <span class="o">=</span> <span class="o">(</span><span class="n">Sink</span><span class="o">&lt;</span><span class="n">OUT</span><span class="o">&gt;)</span> <span class="n">supplier</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="c1">// 正向包装 -&gt; 反向遍历
</span><span class="c1"></span>            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">sinkBuilders</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
                <span class="n">Supplier</span><span class="o">&lt;</span><span class="n">Sink</span><span class="o">&lt;?&gt;&gt;</span> <span class="n">supplier</span> <span class="o">=</span> <span class="n">sinkBuilders</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                <span class="n">stage</span> <span class="o">=</span> <span class="o">(</span><span class="n">Sink</span><span class="o">&lt;</span><span class="n">OUT</span><span class="o">&gt;)</span> <span class="n">supplier</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">Sink</span><span class="o">&lt;</span><span class="n">OUT</span><span class="o">&gt;</span> <span class="n">finalStage</span> <span class="o">=</span> <span class="n">stage</span><span class="o">;</span>
        <span class="n">spliterator</span><span class="o">.</span><span class="na">forEachRemaining</span><span class="o">(</span><span class="n">finalStage</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">2</span><span class="o">);</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">3</span><span class="o">);</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">12</span><span class="o">);</span>
        <span class="n">ReferenceChain</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">chain</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ReferenceChain</span><span class="o">&lt;&gt;();</span>
        <span class="c1">// filter -&gt; map -&gt; for each
</span><span class="c1"></span>        <span class="n">chain</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">item</span> <span class="o">-&gt;</span> <span class="n">item</span> <span class="o">&gt;</span> <span class="n">10</span><span class="o">)</span>
                <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">item</span> <span class="o">-&gt;</span> <span class="n">item</span> <span class="o">*</span> <span class="n">2</span><span class="o">)</span>
                <span class="o">.</span><span class="na">forEachPrint</span><span class="o">(</span><span class="n">list</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 输出结果
</span><span class="c1"></span><span class="n">24</span>
</code></pre></td></tr></table>
</div>
</div><p>The process of execution is as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/07/6bb6be22c58947c59e679f67169ec06d.png" alt=""></p>
<p>The central tenet of the multi-layer wrapper programming model is that</p>
<ul>
<li>the vast majority of operations can be converted to the implementation of java.util.function.Consumer, that is, the implementation of accept(T t) method to complete the processing of incoming elements</li>
<li>The Sink processed first is always the Sink processed later as an input, in its own processing methods to determine and call back the incoming Sink processing method callback, that is, when building a reference chain, you need to build from back to front, the logic of this way of implementation can refer to AbstractPipeline#wrapSink(), for example.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 目标顺序：filter -&gt; map
</span><span class="c1"></span><span class="n">Sink</span> <span class="n">mapSink</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Sink</span><span class="o">(</span><span class="n">inputSink</span><span class="o">){</span>

    <span class="kd">private</span> <span class="n">Function</span> <span class="n">mapper</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">accept</span><span class="o">(</span><span class="n">E</span> <span class="n">ele</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">inputSink</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">mapper</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">ele</span><span class="o">))</span>
    <span class="o">}</span>

<span class="o">}</span>
<span class="n">Sink</span> <span class="n">filterSink</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Sink</span><span class="o">(</span><span class="n">mapSink</span><span class="o">){</span>

    <span class="kd">private</span> <span class="n">Predicate</span> <span class="n">predicate</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">accept</span><span class="o">(</span><span class="n">E</span> <span class="n">ele</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">predicate</span><span class="o">.</span><span class="na">test</span><span class="o">(</span><span class="n">ele</span><span class="o">)){</span>
            <span class="n">mapSink</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">ele</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>From the above point, we know that, in general, the final termination operation is applied to the first Sink of the reference chain</li>
</ul>
<p>The above code is not made up by the author and can be found in the source code of java.util.stream.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 继承自Consumer，主要是继承函数式接口方法void accept(T t)
</span><span class="c1"></span><span class="kd">interface</span> <span class="nc">Sink</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">Consumer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    
    <span class="c1">// 重置当前Sink的状态（为了接收一个新的数据集），传入的size是推送到downstream的准确数据量，无法评估数据量则传入-1
</span><span class="c1"></span>    <span class="k">default</span> <span class="kt">void</span> <span class="nf">begin</span><span class="o">(</span><span class="kt">long</span> <span class="n">size</span><span class="o">)</span> <span class="o">{}</span>

    <span class="c1">// 
</span><span class="c1"></span>    <span class="k">default</span> <span class="kt">void</span> <span class="nf">end</span><span class="o">()</span> <span class="o">{}</span>

    <span class="c1">// 返回true的时候表示当前的Sink不会接收数据
</span><span class="c1"></span>    <span class="k">default</span> <span class="kt">boolean</span> <span class="nf">cancellationRequested</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 特化方法，接受一个int类型的值
</span><span class="c1"></span>    <span class="k">default</span> <span class="kt">void</span> <span class="nf">accept</span><span class="o">(</span><span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="o">(</span><span class="s">&#34;called wrong accept method&#34;</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 特化方法，接受一个long类型的值
</span><span class="c1"></span>    <span class="k">default</span> <span class="kt">void</span> <span class="nf">accept</span><span class="o">(</span><span class="kt">long</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="o">(</span><span class="s">&#34;called wrong accept method&#34;</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 特化方法，接受一个double类型的值
</span><span class="c1"></span>    <span class="k">default</span> <span class="kt">void</span> <span class="nf">accept</span><span class="o">(</span><span class="kt">double</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="o">(</span><span class="s">&#34;called wrong accept method&#34;</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="c1">// 引用类型链，准确来说是Sink链
</span><span class="c1"></span>    <span class="kd">abstract</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">ChainedReference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">E_OUT</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="n">Sink</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
        
        <span class="c1">// 下一个Sink
</span><span class="c1"></span>        <span class="kd">protected</span> <span class="kd">final</span> <span class="n">Sink</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">E_OUT</span><span class="o">&gt;</span> <span class="n">downstream</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">ChainedReference</span><span class="o">(</span><span class="n">Sink</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">E_OUT</span><span class="o">&gt;</span> <span class="n">downstream</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">downstream</span> <span class="o">=</span> <span class="n">Objects</span><span class="o">.</span><span class="na">requireNonNull</span><span class="o">(</span><span class="n">downstream</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">begin</span><span class="o">(</span><span class="kt">long</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">downstream</span><span class="o">.</span><span class="na">begin</span><span class="o">(</span><span class="n">size</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">end</span><span class="o">()</span> <span class="o">{</span>
            <span class="n">downstream</span><span class="o">.</span><span class="na">end</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">cancellationRequested</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">downstream</span><span class="o">.</span><span class="na">cancellationRequested</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">// 暂时忽略Int、Long、Double的特化类型场景
</span><span class="c1"></span><span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>If you have used RxJava or Project-Reactor, Sink is more like Subscriber, multiple Subscribers form a ChainedReference (Sink Chain, which can be understood as a composite Subscriber), while Terminal Op is similar to Publisher, only when the Subscriber subscribes to the Publisher, the data will be processed, here is the application of Reactive programming model.</p>
<h3 id="implementation-of-abstractpipeline-and-referencepipeline">Implementation of AbstractPipeline and ReferencePipeline</h3>
<p>AbstractPipeline and ReferencePipeline are both abstract classes. AbstractPipeline is used to build the data structure of Pipeline and provide some Shape-related abstract methods for ReferencePipeline to implement, while ReferencePipeline is the base type of Pipeline in Stream. From the source code, the head node and operation node of Stream chain (pipeline) structure are subclasses of ReferencePipeline. First look at the member variables and constructors of AbstractPipeline.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">AbstractPipeline</span><span class="o">&lt;</span><span class="n">E_IN</span><span class="o">,</span> <span class="n">E_OUT</span><span class="o">,</span> <span class="n">S</span> <span class="kd">extends</span> <span class="n">BaseStream</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">,</span> <span class="n">S</span><span class="o">&gt;&gt;</span>
        <span class="kd">extends</span> <span class="n">PipelineHelper</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="n">BaseStream</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">,</span> <span class="n">S</span><span class="o">&gt;</span> <span class="o">{</span>
    
    <span class="c1">// 流管道链式结构的头节点（只有当前的AbstractPipeline引用是头节点，此变量才会被赋值，非头节点为NULL）
</span><span class="c1"></span>    <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">&#34;rawtypes&#34;</span><span class="o">)</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">AbstractPipeline</span> <span class="n">sourceStage</span><span class="o">;</span>
    
    <span class="c1">// 流管道链式结构的upstream，也就是上一个节点，如果是头节点此引用为NULL
</span><span class="c1"></span>    <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">&#34;rawtypes&#34;</span><span class="o">)</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">AbstractPipeline</span> <span class="n">previousStage</span><span class="o">;</span>
    
    <span class="c1">// 合并数据源的标志和操作标志的掩码
</span><span class="c1"></span>    <span class="kd">protected</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">sourceOrOpFlags</span><span class="o">;</span>
    
    <span class="c1">// 流管道链式结构的下一个节点，如果是头节点此引用为NULL
</span><span class="c1"></span>    <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">&#34;rawtypes&#34;</span><span class="o">)</span>
    <span class="kd">private</span> <span class="n">AbstractPipeline</span> <span class="n">nextStage</span><span class="o">;</span>
    
    <span class="c1">// 流的深度
</span><span class="c1"></span>    <span class="c1">// 串行执行的流中，表示当前流管道实例中中间操作节点的个数（除去头节点和终结操作）
</span><span class="c1"></span>    <span class="c1">// 并发执行的流中，表示当前流管道实例中中间操作节点和前一个有状态操作节点之间的节点个数
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">depth</span><span class="o">;</span>
     
    <span class="c1">// 合并了所有数据源的标志、操作标志和当前的节点(AbstractPipeline)实例的标志，也就是当前的节点可以基于此属性得知所有支持的标志
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">combinedFlags</span><span class="o">;</span>
    
    <span class="c1">// 数据源的Spliterator实例
</span><span class="c1"></span>    <span class="kd">private</span> <span class="n">Spliterator</span><span class="o">&lt;?&gt;</span> <span class="n">sourceSpliterator</span><span class="o">;</span>
    
    <span class="c1">// 数据源的Spliterator实例封装的Supplier实例
</span><span class="c1"></span>    <span class="kd">private</span> <span class="n">Supplier</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">Spliterator</span><span class="o">&lt;?&gt;&gt;</span> <span class="n">sourceSupplier</span><span class="o">;</span>
    
    <span class="c1">// 标记当前的流节点是否被连接或者消费掉，不能重复连接或者重复消费
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">linkedOrConsumed</span><span class="o">;</span>

    <span class="c1">// 标记当前的流管道链式结构中是否存在有状态的操作节点，这个属性只会在头节点中有效
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">sourceAnyStateful</span><span class="o">;</span>
    
    <span class="c1">// 数据源关闭动作，这个属性只会在头节点中有效，由sourceStage持有
</span><span class="c1"></span>    <span class="kd">private</span> <span class="n">Runnable</span> <span class="n">sourceCloseAction</span><span class="o">;</span>
    
    <span class="c1">// 标记当前流是否并发执行
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">parallel</span><span class="o">;</span>

    <span class="c1">// 流管道结构头节点的父构造方法，使用数据源的Spliterator实例封装的Supplier实例
</span><span class="c1"></span>    <span class="n">AbstractPipeline</span><span class="o">(</span><span class="n">Supplier</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">Spliterator</span><span class="o">&lt;?&gt;&gt;</span> <span class="n">source</span><span class="o">,</span>
                     <span class="kt">int</span> <span class="n">sourceFlags</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">parallel</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 头节点的前驱节点置为NULL
</span><span class="c1"></span>        <span class="k">this</span><span class="o">.</span><span class="na">previousStage</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">sourceSupplier</span> <span class="o">=</span> <span class="n">source</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">sourceStage</span> <span class="o">=</span> <span class="k">this</span><span class="o">;</span>
        <span class="c1">// 合并传入的源标志和流标志的掩码
</span><span class="c1"></span>        <span class="k">this</span><span class="o">.</span><span class="na">sourceOrOpFlags</span> <span class="o">=</span> <span class="n">sourceFlags</span> <span class="o">&amp;</span> <span class="n">StreamOpFlag</span><span class="o">.</span><span class="na">STREAM_MASK</span><span class="o">;</span>
        <span class="c1">// The following is an optimization of:
</span><span class="c1"></span>        <span class="c1">// StreamOpFlag.combineOpFlags(sourceOrOpFlags, StreamOpFlag.INITIAL_OPS_VALUE);
</span><span class="c1"></span>        <span class="c1">// 初始化合并标志集合为sourceOrOpFlags和所有流操作标志的初始化值
</span><span class="c1"></span>        <span class="k">this</span><span class="o">.</span><span class="na">combinedFlags</span> <span class="o">=</span> <span class="o">(~(</span><span class="n">sourceOrOpFlags</span> <span class="o">&lt;&lt;</span> <span class="n">1</span><span class="o">))</span> <span class="o">&amp;</span> <span class="n">StreamOpFlag</span><span class="o">.</span><span class="na">INITIAL_OPS_VALUE</span><span class="o">;</span>
        <span class="c1">// 深度设置为0
</span><span class="c1"></span>        <span class="k">this</span><span class="o">.</span><span class="na">depth</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">parallel</span> <span class="o">=</span> <span class="n">parallel</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 流管道结构头节点的父构造方法，使用数据源的Spliterator实例
</span><span class="c1"></span>    <span class="n">AbstractPipeline</span><span class="o">(</span><span class="n">Spliterator</span><span class="o">&lt;?&gt;</span> <span class="n">source</span><span class="o">,</span>
                     <span class="kt">int</span> <span class="n">sourceFlags</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">parallel</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 头节点的前驱节点置为NULL
</span><span class="c1"></span>        <span class="k">this</span><span class="o">.</span><span class="na">previousStage</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">sourceSpliterator</span> <span class="o">=</span> <span class="n">source</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">sourceStage</span> <span class="o">=</span> <span class="k">this</span><span class="o">;</span>
        <span class="c1">// 合并传入的源标志和流标志的掩码
</span><span class="c1"></span>        <span class="k">this</span><span class="o">.</span><span class="na">sourceOrOpFlags</span> <span class="o">=</span> <span class="n">sourceFlags</span> <span class="o">&amp;</span> <span class="n">StreamOpFlag</span><span class="o">.</span><span class="na">STREAM_MASK</span><span class="o">;</span>
        <span class="c1">// The following is an optimization of:
</span><span class="c1"></span>        <span class="c1">// StreamOpFlag.combineOpFlags(sourceOrOpFlags, StreamOpFlag.INITIAL_OPS_VALUE);
</span><span class="c1"></span>        <span class="c1">// 初始化合并标志集合为sourceOrOpFlags和所有流操作标志的初始化值
</span><span class="c1"></span>        <span class="k">this</span><span class="o">.</span><span class="na">combinedFlags</span> <span class="o">=</span> <span class="o">(~(</span><span class="n">sourceOrOpFlags</span> <span class="o">&lt;&lt;</span> <span class="n">1</span><span class="o">))</span> <span class="o">&amp;</span> <span class="n">StreamOpFlag</span><span class="o">.</span><span class="na">INITIAL_OPS_VALUE</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">depth</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">parallel</span> <span class="o">=</span> <span class="n">parallel</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="c1">// 流管道结构中间操作节点的父构造方法
</span><span class="c1"></span>    <span class="n">AbstractPipeline</span><span class="o">(</span><span class="n">AbstractPipeline</span><span class="o">&lt;?,</span> <span class="n">E_IN</span><span class="o">,</span> <span class="o">?&gt;</span> <span class="n">previousStage</span><span class="o">,</span> <span class="kt">int</span> <span class="n">opFlags</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">previousStage</span><span class="o">.</span><span class="na">linkedOrConsumed</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="o">(</span><span class="n">MSG_STREAM_LINKED</span><span class="o">);</span>
        <span class="n">previousStage</span><span class="o">.</span><span class="na">linkedOrConsumed</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="c1">// 设置前驱节点的后继节点引用为当前的AbstractPipeline实例
</span><span class="c1"></span>        <span class="n">previousStage</span><span class="o">.</span><span class="na">nextStage</span> <span class="o">=</span> <span class="k">this</span><span class="o">;</span>
        <span class="c1">// 设置前驱节点引用为传入的前驱节点实例
</span><span class="c1"></span>        <span class="k">this</span><span class="o">.</span><span class="na">previousStage</span> <span class="o">=</span> <span class="n">previousStage</span><span class="o">;</span>
        <span class="c1">// 合并传入的中间操作标志和流操作标志的掩码
</span><span class="c1"></span>        <span class="k">this</span><span class="o">.</span><span class="na">sourceOrOpFlags</span> <span class="o">=</span> <span class="n">opFlags</span> <span class="o">&amp;</span> <span class="n">StreamOpFlag</span><span class="o">.</span><span class="na">OP_MASK</span><span class="o">;</span>
        <span class="c1">// 合并标志集合为传入的标志和前驱节点的标志集合
</span><span class="c1"></span>        <span class="k">this</span><span class="o">.</span><span class="na">combinedFlags</span> <span class="o">=</span> <span class="n">StreamOpFlag</span><span class="o">.</span><span class="na">combineOpFlags</span><span class="o">(</span><span class="n">opFlags</span><span class="o">,</span> <span class="n">previousStage</span><span class="o">.</span><span class="na">combinedFlags</span><span class="o">);</span>
        <span class="c1">// 赋值sourceStage为前驱节点的sourceStage
</span><span class="c1"></span>        <span class="k">this</span><span class="o">.</span><span class="na">sourceStage</span> <span class="o">=</span> <span class="n">previousStage</span><span class="o">.</span><span class="na">sourceStage</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">opIsStateful</span><span class="o">())</span>
            <span class="c1">// 标记当前的流存在有状态操作
</span><span class="c1"></span>            <span class="n">sourceStage</span><span class="o">.</span><span class="na">sourceAnyStateful</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="c1">// 深度设置为前驱节点深度加1
</span><span class="c1"></span>        <span class="k">this</span><span class="o">.</span><span class="na">depth</span> <span class="o">=</span> <span class="n">previousStage</span><span class="o">.</span><span class="na">depth</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 省略其他方法
</span><span class="c1"></span><span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>At this point, the data structure of the flow pipeline can be seen.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/07/5e8dcaa3b39d4ed1b36c25f69c3c7461.png" alt=""></p>
<p>Terminal Op is not involved in the construction of the pipeline chain structure. Moving on to the Terminal evaluation methods in AbstractPipeline.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">AbstractPipeline</span><span class="o">&lt;</span><span class="n">E_IN</span><span class="o">,</span> <span class="n">E_OUT</span><span class="o">,</span> <span class="n">S</span> <span class="kd">extends</span> <span class="n">BaseStream</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">,</span> <span class="n">S</span><span class="o">&gt;&gt;</span>
        <span class="kd">extends</span> <span class="n">PipelineHelper</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="n">BaseStream</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">,</span> <span class="n">S</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="c1">// 省略其他方法
</span><span class="c1"></span>    
    <span class="c1">// 基于终结操作进行求值，这个是Stream执行的常用核心方法，常用于collect()这类终结操作
</span><span class="c1"></span>    <span class="kd">final</span> <span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="n">R</span> <span class="nf">evaluate</span><span class="o">(</span><span class="n">TerminalOp</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="n">terminalOp</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">assert</span> <span class="n">getOutputShape</span><span class="o">()</span> <span class="o">==</span> <span class="n">terminalOp</span><span class="o">.</span><span class="na">inputShape</span><span class="o">();</span>
        <span class="c1">// 判断linkedOrConsumed，以防多次终结求值，也就是每个终结操作只能执行一次
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">linkedOrConsumed</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="o">(</span><span class="n">MSG_STREAM_LINKED</span><span class="o">);</span>
        <span class="n">linkedOrConsumed</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        
        <span class="c1">// 如果当前流支持并发执行，则委托到TerminalOp.evaluateParallel()，如果当前流只支持同步执行，则委托到TerminalOp.evaluateSequential()
</span><span class="c1"></span>        <span class="c1">// 这里注意传入到TerminalOp中的方法参数分别是this(PipelineHelper类型)和数据源Spliterator
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">isParallel</span><span class="o">()</span>
               <span class="o">?</span> <span class="n">terminalOp</span><span class="o">.</span><span class="na">evaluateParallel</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">sourceSpliterator</span><span class="o">(</span><span class="n">terminalOp</span><span class="o">.</span><span class="na">getOpFlags</span><span class="o">()))</span>
               <span class="o">:</span> <span class="n">terminalOp</span><span class="o">.</span><span class="na">evaluateSequential</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">sourceSpliterator</span><span class="o">(</span><span class="n">terminalOp</span><span class="o">.</span><span class="na">getOpFlags</span><span class="o">()));</span>
    <span class="o">}</span>

    <span class="c1">// 基于当前的流实例转换为最终的Node实例，传入的IntFunction用于创建数组实例
</span><span class="c1"></span>    <span class="c1">// 此终结方法一般用于toArray()这类终结操作
</span><span class="c1"></span>    <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">&#34;unchecked&#34;</span><span class="o">)</span>
    <span class="kd">final</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">&gt;</span> <span class="nf">evaluateToArrayNode</span><span class="o">(</span><span class="n">IntFunction</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">[]&gt;</span> <span class="n">generator</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">linkedOrConsumed</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="o">(</span><span class="n">MSG_STREAM_LINKED</span><span class="o">);</span>
        <span class="n">linkedOrConsumed</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

        <span class="c1">// If the last intermediate operation is stateful then
</span><span class="c1"></span>        <span class="c1">// evaluate directly to avoid an extra collection step
</span><span class="c1"></span>        <span class="c1">// 当前流支持并发执行，并且最后一个中间操作是有状态，则委托到opEvaluateParallel()，否则委托到evaluate()，这两个都是AbstractPipeline中的方法
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">isParallel</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">previousStage</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">opIsStateful</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// Set the depth of this, last, pipeline stage to zero to slice the
</span><span class="c1"></span>            <span class="c1">// pipeline such that this operation will not be included in the
</span><span class="c1"></span>            <span class="c1">// upstream slice and upstream operations will not be included
</span><span class="c1"></span>            <span class="c1">// in this slice
</span><span class="c1"></span>            <span class="n">depth</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
            <span class="k">return</span> <span class="n">opEvaluateParallel</span><span class="o">(</span><span class="n">previousStage</span><span class="o">,</span> <span class="n">previousStage</span><span class="o">.</span><span class="na">sourceSpliterator</span><span class="o">(</span><span class="n">0</span><span class="o">),</span> <span class="n">generator</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">evaluate</span><span class="o">(</span><span class="n">sourceSpliterator</span><span class="o">(</span><span class="n">0</span><span class="o">),</span> <span class="kc">true</span><span class="o">,</span> <span class="n">generator</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// 这个方法比较简单，就是获取当前流的数据源所在的Spliterator，并且确保流已经消费，一般用于forEach()这类终结操作
</span><span class="c1"></span>    <span class="kd">final</span> <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">&gt;</span> <span class="nf">sourceStageSpliterator</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span> <span class="o">!=</span> <span class="n">sourceStage</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="o">();</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">linkedOrConsumed</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="o">(</span><span class="n">MSG_STREAM_LINKED</span><span class="o">);</span>
        <span class="n">linkedOrConsumed</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">sourceStage</span><span class="o">.</span><span class="na">sourceSpliterator</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">&#34;unchecked&#34;</span><span class="o">)</span>
            <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="n">sourceStage</span><span class="o">.</span><span class="na">sourceSpliterator</span><span class="o">;</span>
            <span class="n">sourceStage</span><span class="o">.</span><span class="na">sourceSpliterator</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="k">return</span> <span class="n">s</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">sourceStage</span><span class="o">.</span><span class="na">sourceSupplier</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">&#34;unchecked&#34;</span><span class="o">)</span>
            <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="o">(</span><span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">&gt;)</span> <span class="n">sourceStage</span><span class="o">.</span><span class="na">sourceSupplier</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
            <span class="n">sourceStage</span><span class="o">.</span><span class="na">sourceSupplier</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="k">return</span> <span class="n">s</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="o">(</span><span class="n">MSG_CONSUMED</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">// 省略其他方法  
</span><span class="c1"></span><span class="o">}</span>

</code></pre></td></tr></table>
</div>
</div><p>The methods of BaseStream are implemented in AbstractPipeline.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">AbstractPipeline</span><span class="o">&lt;</span><span class="n">E_IN</span><span class="o">,</span> <span class="n">E_OUT</span><span class="o">,</span> <span class="n">S</span> <span class="kd">extends</span> <span class="n">BaseStream</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">,</span> <span class="n">S</span><span class="o">&gt;&gt;</span>
        <span class="kd">extends</span> <span class="n">PipelineHelper</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="n">BaseStream</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">,</span> <span class="n">S</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="c1">// 省略其他方法
</span><span class="c1"></span>    
    <span class="c1">// 设置头节点的parallel属性为false，返回自身实例，表示当前的流是同步执行的
</span><span class="c1"></span>    <span class="nd">@Override</span>
    <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">&#34;unchecked&#34;</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="n">S</span> <span class="nf">sequential</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">sourceStage</span><span class="o">.</span><span class="na">parallel</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">S</span><span class="o">)</span> <span class="k">this</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="c1">// 设置头节点的parallel属性为true，返回自身实例，表示当前的流是并发执行的
</span><span class="c1"></span>    <span class="nd">@Override</span>
    <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">&#34;unchecked&#34;</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="n">S</span> <span class="nf">parallel</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">sourceStage</span><span class="o">.</span><span class="na">parallel</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">S</span><span class="o">)</span> <span class="k">this</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="c1">// 流关闭操作，设置linkedOrConsumed为true，数据源的Spliterator相关引用置为NULL，置空并且回调sourceCloseAction钩子实例
</span><span class="c1"></span>    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">close</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">linkedOrConsumed</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="n">sourceSupplier</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="n">sourceSpliterator</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">sourceStage</span><span class="o">.</span><span class="na">sourceCloseAction</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">Runnable</span> <span class="n">closeAction</span> <span class="o">=</span> <span class="n">sourceStage</span><span class="o">.</span><span class="na">sourceCloseAction</span><span class="o">;</span>
            <span class="n">sourceStage</span><span class="o">.</span><span class="na">sourceCloseAction</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="n">closeAction</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="c1">// 返回一个添加了close处理器的Stream实例，close处理器会在下面的close方法中回调
</span><span class="c1"></span>    <span class="c1">// 如果本来持有的引用sourceStage.sourceCloseAction非空，会使用传入的closeHandler与sourceStage.sourceCloseAction进行合并
</span><span class="c1"></span>    <span class="nd">@Override</span>
    <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">&#34;unchecked&#34;</span><span class="o">)</span>
    <span class="kd">public</span> <span class="n">S</span> <span class="nf">onClose</span><span class="o">(</span><span class="n">Runnable</span> <span class="n">closeHandler</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">linkedOrConsumed</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="o">(</span><span class="n">MSG_STREAM_LINKED</span><span class="o">);</span>
        <span class="n">Objects</span><span class="o">.</span><span class="na">requireNonNull</span><span class="o">(</span><span class="n">closeHandler</span><span class="o">);</span>
        <span class="n">Runnable</span> <span class="n">existingHandler</span> <span class="o">=</span> <span class="n">sourceStage</span><span class="o">.</span><span class="na">sourceCloseAction</span><span class="o">;</span>
        <span class="n">sourceStage</span><span class="o">.</span><span class="na">sourceCloseAction</span> <span class="o">=</span>
                <span class="o">(</span><span class="n">existingHandler</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                <span class="o">?</span> <span class="n">closeHandler</span>
                <span class="o">:</span> <span class="n">Streams</span><span class="o">.</span><span class="na">composeWithExceptions</span><span class="o">(</span><span class="n">existingHandler</span><span class="o">,</span> <span class="n">closeHandler</span><span class="o">);</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">S</span><span class="o">)</span> <span class="k">this</span><span class="o">;</span>
    <span class="o">}</span>
 
    <span class="c1">// Primitive specialization use co-variant overrides, hence is not final
</span><span class="c1"></span>    <span class="c1">// 返回当前流实例中所有元素的Spliterator实例
</span><span class="c1"></span>    <span class="nd">@Override</span>
    <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">&#34;unchecked&#34;</span><span class="o">)</span>
    <span class="kd">public</span> <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">&gt;</span> <span class="nf">spliterator</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">linkedOrConsumed</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="o">(</span><span class="n">MSG_STREAM_LINKED</span><span class="o">);</span>
        <span class="c1">// 标记当前节点被链接或者消费
</span><span class="c1"></span>        <span class="n">linkedOrConsumed</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="c1">// 如果当前节点为头节点，那么返回sourceStage.sourceSpliterator或者延时加载的sourceStage.sourceSupplier(延时加载封装由lazySpliterator实现)
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="k">this</span> <span class="o">==</span> <span class="n">sourceStage</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">sourceStage</span><span class="o">.</span><span class="na">sourceSpliterator</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">&#34;unchecked&#34;</span><span class="o">)</span>
                <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="o">(</span><span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">&gt;)</span> <span class="n">sourceStage</span><span class="o">.</span><span class="na">sourceSpliterator</span><span class="o">;</span>
                <span class="n">sourceStage</span><span class="o">.</span><span class="na">sourceSpliterator</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="k">return</span> <span class="n">s</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">sourceStage</span><span class="o">.</span><span class="na">sourceSupplier</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">&#34;unchecked&#34;</span><span class="o">)</span>
                <span class="n">Supplier</span><span class="o">&lt;</span><span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">&gt;&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="o">(</span><span class="n">Supplier</span><span class="o">&lt;</span><span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">&gt;&gt;)</span> <span class="n">sourceStage</span><span class="o">.</span><span class="na">sourceSupplier</span><span class="o">;</span>
                <span class="n">sourceStage</span><span class="o">.</span><span class="na">sourceSupplier</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="k">return</span> <span class="n">lazySpliterator</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="o">(</span><span class="n">MSG_CONSUMED</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="c1">// 如果当前节点不是头节点，重新对sourceSpliterator进行包装，包装后的实例为WrappingSpliterator
</span><span class="c1"></span>            <span class="k">return</span> <span class="n">wrap</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="n">sourceSpliterator</span><span class="o">(</span><span class="n">0</span><span class="o">),</span> <span class="n">isParallel</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="c1">// 当前流实例是否并发执行，从头节点的parallel属性进行判断
</span><span class="c1"></span>    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">isParallel</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">sourceStage</span><span class="o">.</span><span class="na">parallel</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 从当前combinedFlags中获取数据源标志和所有流中间操作标志的集合
</span><span class="c1"></span>    <span class="kd">final</span> <span class="kt">int</span> <span class="nf">getStreamFlags</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">StreamOpFlag</span><span class="o">.</span><span class="na">toStreamFlags</span><span class="o">(</span><span class="n">combinedFlags</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**
</span><span class="cm">     * Get the source spliterator for this pipeline stage.  For a sequential or
</span><span class="cm">     * stateless parallel pipeline, this is the source spliterator.  For a
</span><span class="cm">     * stateful parallel pipeline, this is a spliterator describing the results
</span><span class="cm">     * of all computations up to and including the most recent stateful
</span><span class="cm">     * operation.
</span><span class="cm">     */</span>
    <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">&#34;unchecked&#34;</span><span class="o">)</span>
    <span class="kd">private</span> <span class="n">Spliterator</span><span class="o">&lt;?&gt;</span> <span class="n">sourceSpliterator</span><span class="o">(</span><span class="kt">int</span> <span class="n">terminalFlags</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 从sourceStage.sourceSpliterator或者sourceStage.sourceSupplier中获取当前流实例中的Spliterator实例，确保必定存在，否则抛出IllegalStateException
</span><span class="c1"></span>        <span class="n">Spliterator</span><span class="o">&lt;?&gt;</span> <span class="n">spliterator</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">sourceStage</span><span class="o">.</span><span class="na">sourceSpliterator</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">spliterator</span> <span class="o">=</span> <span class="n">sourceStage</span><span class="o">.</span><span class="na">sourceSpliterator</span><span class="o">;</span>
            <span class="n">sourceStage</span><span class="o">.</span><span class="na">sourceSpliterator</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">sourceStage</span><span class="o">.</span><span class="na">sourceSupplier</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">spliterator</span> <span class="o">=</span> <span class="o">(</span><span class="n">Spliterator</span><span class="o">&lt;?&gt;)</span> <span class="n">sourceStage</span><span class="o">.</span><span class="na">sourceSupplier</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
            <span class="n">sourceStage</span><span class="o">.</span><span class="na">sourceSupplier</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="o">(</span><span class="n">MSG_CONSUMED</span><span class="o">);</span>
        <span class="o">}</span>
        
        <span class="c1">// 下面这段逻辑是对于并发执行并且存在有状态操作的节点，那么需要重新计算节点的深度和节点的合并标志集合
</span><span class="c1"></span>        <span class="c1">// 这里只提一下计算过程，从头节点的后继节点开始遍历到当前节点，如果被遍历的节点时有状态的，那么对depth、combinedFlags和spliterator会进行重新计算
</span><span class="c1"></span>        <span class="c1">// depth一旦出现有状态节点就会重置为0，然后从1重新开始增加
</span><span class="c1"></span>        <span class="c1">// combinedFlags会重新合并sourceOrOpFlags、SHORT_CIRCUIT(如果sourceOrOpFlags支持)和Spliterator.SIZED
</span><span class="c1"></span>        <span class="c1">// spliterator简单来看就是从并发执行的toArray()=&gt;Array数组=&gt;Spliterator实例
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">isParallel</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">sourceStage</span><span class="o">.</span><span class="na">sourceAnyStateful</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Adapt the source spliterator, evaluating each stateful op
</span><span class="c1"></span>            <span class="c1">// in the pipeline up to and including this pipeline stage.
</span><span class="c1"></span>            <span class="c1">// The depth and flags of each pipeline stage are adjusted accordingly.
</span><span class="c1"></span>            <span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">&#34;rawtypes&#34;</span><span class="o">)</span> <span class="n">AbstractPipeline</span> <span class="n">u</span> <span class="o">=</span> <span class="n">sourceStage</span><span class="o">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">sourceStage</span><span class="o">.</span><span class="na">nextStage</span><span class="o">,</span> <span class="n">e</span> <span class="o">=</span> <span class="k">this</span><span class="o">;</span>
                 <span class="n">u</span> <span class="o">!=</span> <span class="n">e</span><span class="o">;</span>
                 <span class="n">u</span> <span class="o">=</span> <span class="n">p</span><span class="o">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">nextStage</span><span class="o">)</span> <span class="o">{</span>

                <span class="kt">int</span> <span class="n">thisOpFlags</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">sourceOrOpFlags</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">opIsStateful</span><span class="o">())</span> <span class="o">{</span>
                    <span class="n">depth</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>

                    <span class="k">if</span> <span class="o">(</span><span class="n">StreamOpFlag</span><span class="o">.</span><span class="na">SHORT_CIRCUIT</span><span class="o">.</span><span class="na">isKnown</span><span class="o">(</span><span class="n">thisOpFlags</span><span class="o">))</span> <span class="o">{</span>
                        <span class="c1">// Clear the short circuit flag for next pipeline stage
</span><span class="c1"></span>                        <span class="c1">// This stage encapsulates short-circuiting, the next
</span><span class="c1"></span>                        <span class="c1">// stage may not have any short-circuit operations, and
</span><span class="c1"></span>                        <span class="c1">// if so spliterator.forEachRemaining should be used
</span><span class="c1"></span>                        <span class="c1">// for traversal
</span><span class="c1"></span>                        <span class="n">thisOpFlags</span> <span class="o">=</span> <span class="n">thisOpFlags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">StreamOpFlag</span><span class="o">.</span><span class="na">IS_SHORT_CIRCUIT</span><span class="o">;</span>
                    <span class="o">}</span>

                    <span class="n">spliterator</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">opEvaluateParallelLazy</span><span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="n">spliterator</span><span class="o">);</span>

                    <span class="c1">// Inject or clear SIZED on the source pipeline stage
</span><span class="c1"></span>                    <span class="c1">// based on the stage&#39;s spliterator
</span><span class="c1"></span>                    <span class="n">thisOpFlags</span> <span class="o">=</span> <span class="n">spliterator</span><span class="o">.</span><span class="na">hasCharacteristics</span><span class="o">(</span><span class="n">Spliterator</span><span class="o">.</span><span class="na">SIZED</span><span class="o">)</span>
                            <span class="o">?</span> <span class="o">(</span><span class="n">thisOpFlags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">StreamOpFlag</span><span class="o">.</span><span class="na">NOT_SIZED</span><span class="o">)</span> <span class="o">|</span> <span class="n">StreamOpFlag</span><span class="o">.</span><span class="na">IS_SIZED</span>
                            <span class="o">:</span> <span class="o">(</span><span class="n">thisOpFlags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">StreamOpFlag</span><span class="o">.</span><span class="na">IS_SIZED</span><span class="o">)</span> <span class="o">|</span> <span class="n">StreamOpFlag</span><span class="o">.</span><span class="na">NOT_SIZED</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="n">p</span><span class="o">.</span><span class="na">depth</span> <span class="o">=</span> <span class="n">depth</span><span class="o">++;</span>
                <span class="n">p</span><span class="o">.</span><span class="na">combinedFlags</span> <span class="o">=</span> <span class="n">StreamOpFlag</span><span class="o">.</span><span class="na">combineOpFlags</span><span class="o">(</span><span class="n">thisOpFlags</span><span class="o">,</span> <span class="n">u</span><span class="o">.</span><span class="na">combinedFlags</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// 如果传入的terminalFlags标志不为0，则当前节点的combinedFlags会合并terminalFlags
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">terminalFlags</span> <span class="o">!=</span> <span class="n">0</span><span class="o">)</span>  <span class="o">{</span>
            <span class="c1">// Apply flags from the terminal operation to last pipeline stage
</span><span class="c1"></span>            <span class="n">combinedFlags</span> <span class="o">=</span> <span class="n">StreamOpFlag</span><span class="o">.</span><span class="na">combineOpFlags</span><span class="o">(</span><span class="n">terminalFlags</span><span class="o">,</span> <span class="n">combinedFlags</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">spliterator</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 省略其他方法
</span><span class="c1"></span><span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The methods of PipelineHelper are implemented in AbstractPipeline.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">AbstractPipeline</span><span class="o">&lt;</span><span class="n">E_IN</span><span class="o">,</span> <span class="n">E_OUT</span><span class="o">,</span> <span class="n">S</span> <span class="kd">extends</span> <span class="n">BaseStream</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">,</span> <span class="n">S</span><span class="o">&gt;&gt;</span>
        <span class="kd">extends</span> <span class="n">PipelineHelper</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="n">BaseStream</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">,</span> <span class="n">S</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="c1">// 省略其他方法
</span><span class="c1"></span>    
    <span class="c1">// 获取数据源元素的类型，这里的类型包括引用、int、double和float
</span><span class="c1"></span>    <span class="c1">// 其实实现上就是获取depth&lt;=0的第一个节点的输出类型
</span><span class="c1"></span>    <span class="nd">@Override</span> 
    <span class="kd">final</span> <span class="n">StreamShape</span> <span class="nf">getSourceShape</span><span class="o">()</span> <span class="o">{</span>
        <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">&#34;rawtypes&#34;</span><span class="o">)</span>
        <span class="n">AbstractPipeline</span> <span class="n">p</span> <span class="o">=</span> <span class="n">AbstractPipeline</span><span class="o">.</span><span class="na">this</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">depth</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">previousStage</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="na">getOutputShape</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="c1">// 基于当前节点的标志集合判断和返回流中待处理的元素数量，无法获取则返回-1
</span><span class="c1"></span>    <span class="nd">@Override</span>
    <span class="kd">final</span> <span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="kt">long</span> <span class="nf">exactOutputSizeIfKnown</span><span class="o">(</span><span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="n">spliterator</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">StreamOpFlag</span><span class="o">.</span><span class="na">SIZED</span><span class="o">.</span><span class="na">isKnown</span><span class="o">(</span><span class="n">getStreamAndOpFlags</span><span class="o">())</span> <span class="o">?</span> <span class="n">spliterator</span><span class="o">.</span><span class="na">getExactSizeIfKnown</span><span class="o">()</span> <span class="o">:</span> <span class="o">-</span><span class="n">1</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="c1">// 通过流管道链式结构构建元素引用链，再遍历元素引用链
</span><span class="c1"></span>    <span class="nd">@Override</span>
    <span class="kd">final</span> <span class="o">&lt;</span><span class="n">P_IN</span><span class="o">,</span> <span class="n">S</span> <span class="kd">extends</span> <span class="n">Sink</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">&gt;&gt;</span> <span class="n">S</span> <span class="nf">wrapAndCopyInto</span><span class="o">(</span><span class="n">S</span> <span class="n">sink</span><span class="o">,</span> <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="n">spliterator</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">copyInto</span><span class="o">(</span><span class="n">wrapSink</span><span class="o">(</span><span class="n">Objects</span><span class="o">.</span><span class="na">requireNonNull</span><span class="o">(</span><span class="n">sink</span><span class="o">)),</span> <span class="n">spliterator</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">sink</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="c1">// 遍历元素引用链
</span><span class="c1"></span>    <span class="nd">@Override</span>
    <span class="kd">final</span> <span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">copyInto</span><span class="o">(</span><span class="n">Sink</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="n">wrappedSink</span><span class="o">,</span> <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="n">spliterator</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Objects</span><span class="o">.</span><span class="na">requireNonNull</span><span class="o">(</span><span class="n">wrappedSink</span><span class="o">);</span>
        <span class="c1">// 当前节点不支持SHORT_CIRCUIT(短路)特性，则直接遍历元素引用链，不支持短路跳出
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(!</span><span class="n">StreamOpFlag</span><span class="o">.</span><span class="na">SHORT_CIRCUIT</span><span class="o">.</span><span class="na">isKnown</span><span class="o">(</span><span class="n">getStreamAndOpFlags</span><span class="o">()))</span> <span class="o">{</span>
            <span class="n">wrappedSink</span><span class="o">.</span><span class="na">begin</span><span class="o">(</span><span class="n">spliterator</span><span class="o">.</span><span class="na">getExactSizeIfKnown</span><span class="o">());</span>
            <span class="n">spliterator</span><span class="o">.</span><span class="na">forEachRemaining</span><span class="o">(</span><span class="n">wrappedSink</span><span class="o">);</span>
            <span class="n">wrappedSink</span><span class="o">.</span><span class="na">end</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="c1">// 支持短路(中途取消)遍历元素引用链
</span><span class="c1"></span>            <span class="n">copyIntoWithCancel</span><span class="o">(</span><span class="n">wrappedSink</span><span class="o">,</span> <span class="n">spliterator</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="c1">// 支持短路(中途取消)遍历元素引用链
</span><span class="c1"></span>    <span class="nd">@Override</span>
    <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">&#34;unchecked&#34;</span><span class="o">)</span>
    <span class="kd">final</span> <span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="kt">boolean</span> <span class="nf">copyIntoWithCancel</span><span class="o">(</span><span class="n">Sink</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="n">wrappedSink</span><span class="o">,</span> <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="n">spliterator</span><span class="o">)</span> <span class="o">{</span>
        <span class="nd">@SuppressWarnings</span><span class="o">({</span><span class="s">&#34;rawtypes&#34;</span><span class="o">,</span><span class="s">&#34;unchecked&#34;</span><span class="o">})</span>
        <span class="n">AbstractPipeline</span> <span class="n">p</span> <span class="o">=</span> <span class="n">AbstractPipeline</span><span class="o">.</span><span class="na">this</span><span class="o">;</span>
        <span class="c1">// 基于当前节点，获取流管道链式结构中第最后一个depth=0的前驱节点
</span><span class="c1"></span>        <span class="k">while</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">depth</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">previousStage</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">wrappedSink</span><span class="o">.</span><span class="na">begin</span><span class="o">(</span><span class="n">spliterator</span><span class="o">.</span><span class="na">getExactSizeIfKnown</span><span class="o">());</span>
        <span class="c1">// 委托到forEachWithCancel()进行遍历
</span><span class="c1"></span>        <span class="kt">boolean</span> <span class="n">cancelled</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">forEachWithCancel</span><span class="o">(</span><span class="n">spliterator</span><span class="o">,</span> <span class="n">wrappedSink</span><span class="o">);</span>
        <span class="n">wrappedSink</span><span class="o">.</span><span class="na">end</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">cancelled</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="c1">// 返回当前节点的标志集合
</span><span class="c1"></span>    <span class="nd">@Override</span>
    <span class="kd">final</span> <span class="kt">int</span> <span class="nf">getStreamAndOpFlags</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">combinedFlags</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="c1">// 当前节点标志集合中是否支持ORDERED
</span><span class="c1"></span>    <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">isOrdered</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">StreamOpFlag</span><span class="o">.</span><span class="na">ORDERED</span><span class="o">.</span><span class="na">isKnown</span><span class="o">(</span><span class="n">combinedFlags</span><span class="o">);</span>
    <span class="o">}</span>
     
    <span class="c1">// 构建元素引用链，生成一个多重包装的Sink(WrapSink)，这里的逻辑可以看前面的分析章节
</span><span class="c1"></span>    <span class="nd">@Override</span>
    <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">&#34;unchecked&#34;</span><span class="o">)</span>
    <span class="kd">final</span> <span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="n">Sink</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="nf">wrapSink</span><span class="o">(</span><span class="n">Sink</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">&gt;</span> <span class="n">sink</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Objects</span><span class="o">.</span><span class="na">requireNonNull</span><span class="o">(</span><span class="n">sink</span><span class="o">);</span>
        <span class="c1">// 这里遍历的时候，总是从当前节点向前驱节点遍历，也就是传入的sink实例总是包裹在最里面一层执行
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span> <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">&#34;rawtypes&#34;</span><span class="o">)</span> <span class="n">AbstractPipeline</span> <span class="n">p</span><span class="o">=</span><span class="n">AbstractPipeline</span><span class="o">.</span><span class="na">this</span><span class="o">;</span> <span class="n">p</span><span class="o">.</span><span class="na">depth</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">;</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="na">previousStage</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">sink</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">opWrapSink</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">previousStage</span><span class="o">.</span><span class="na">combinedFlags</span><span class="o">,</span> <span class="n">sink</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="o">(</span><span class="n">Sink</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;)</span> <span class="n">sink</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="c1">// 包装数据源的Spliterator，如果depth=0，则直接返回sourceSpliterator，否则返回的是延迟加载的WrappingSpliterator
</span><span class="c1"></span>    <span class="nd">@Override</span>
    <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">&#34;unchecked&#34;</span><span class="o">)</span>
    <span class="kd">final</span> <span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">&gt;</span> <span class="nf">wrapSpliterator</span><span class="o">(</span><span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="n">sourceSpliterator</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">depth</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="o">(</span><span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">&gt;)</span> <span class="n">sourceSpliterator</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">wrap</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="n">sourceSpliterator</span><span class="o">,</span> <span class="n">isParallel</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="c1">// 计算Node实例，这个方法用于toArray()方法系列，是一个终结操作，下面会另开章节详细分析
</span><span class="c1"></span>    <span class="nd">@Override</span>
    <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">&#34;unchecked&#34;</span><span class="o">)</span>
    <span class="kd">final</span> <span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">&gt;</span> <span class="nf">evaluate</span><span class="o">(</span><span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="n">spliterator</span><span class="o">,</span>
                                      <span class="kt">boolean</span> <span class="n">flatten</span><span class="o">,</span>
                                      <span class="n">IntFunction</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">[]&gt;</span> <span class="n">generator</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">isParallel</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// @@@ Optimize if op of this pipeline stage is a stateful op
</span><span class="c1"></span>            <span class="k">return</span> <span class="n">evaluateToNode</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">spliterator</span><span class="o">,</span> <span class="n">flatten</span><span class="o">,</span> <span class="n">generator</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="n">Node</span><span class="o">.</span><span class="na">Builder</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">&gt;</span> <span class="n">nb</span> <span class="o">=</span> <span class="n">makeNodeBuilder</span><span class="o">(</span>
                    <span class="n">exactOutputSizeIfKnown</span><span class="o">(</span><span class="n">spliterator</span><span class="o">),</span> <span class="n">generator</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">wrapAndCopyInto</span><span class="o">(</span><span class="n">nb</span><span class="o">,</span> <span class="n">spliterator</span><span class="o">).</span><span class="na">build</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// 省略其他方法    
</span><span class="c1"></span><span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The remaining abstract methods in AbstractPipeline to be implemented by subclasses such as XXYYZZPipeline.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">AbstractPipeline</span><span class="o">&lt;</span><span class="n">E_IN</span><span class="o">,</span> <span class="n">E_OUT</span><span class="o">,</span> <span class="n">S</span> <span class="kd">extends</span> <span class="n">BaseStream</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">,</span> <span class="n">S</span><span class="o">&gt;&gt;</span>
        <span class="kd">extends</span> <span class="n">PipelineHelper</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="n">BaseStream</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">,</span> <span class="n">S</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="c1">// 省略其他方法
</span><span class="c1"></span>
    <span class="c1">// 获取当前流的输出&#34;形状&#34;，REFERENCE、INT_VALUE、LONG_VALUE或者DOUBLE_VALUE
</span><span class="c1"></span>    <span class="kd">abstract</span> <span class="n">StreamShape</span> <span class="nf">getOutputShape</span><span class="o">();</span>

    <span class="c1">// 收集当前流的所有输出元素，转化为一个适配当前流输出&#34;形状&#34;的Node实例
</span><span class="c1"></span>    <span class="kd">abstract</span> <span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">&gt;</span> <span class="nf">evaluateToNode</span><span class="o">(</span><span class="n">PipelineHelper</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">&gt;</span> <span class="n">helper</span><span class="o">,</span>
                                               <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="n">spliterator</span><span class="o">,</span>
                                               <span class="kt">boolean</span> <span class="n">flattenTree</span><span class="o">,</span>
                                               <span class="n">IntFunction</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">[]&gt;</span> <span class="n">generator</span><span class="o">);</span>
    
    <span class="c1">// 包装Spliterator为WrappingSpliterator实例
</span><span class="c1"></span>    <span class="kd">abstract</span> <span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">&gt;</span> <span class="nf">wrap</span><span class="o">(</span><span class="n">PipelineHelper</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">&gt;</span> <span class="n">ph</span><span class="o">,</span>
                                            <span class="n">Supplier</span><span class="o">&lt;</span><span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;&gt;</span> <span class="n">supplier</span><span class="o">,</span>
                                            <span class="kt">boolean</span> <span class="n">isParallel</span><span class="o">);</span>
    
    <span class="c1">// 包装Spliterator为DelegatingSpliterator实例
</span><span class="c1"></span>    <span class="kd">abstract</span> <span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">&gt;</span> <span class="nf">wrap</span><span class="o">(</span><span class="n">PipelineHelper</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">&gt;</span> <span class="n">ph</span><span class="o">,</span>
                                            <span class="n">Supplier</span><span class="o">&lt;</span><span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;&gt;</span> <span class="n">supplier</span><span class="o">,</span>
                                            <span class="kt">boolean</span> <span class="n">isParallel</span><span class="o">);</span>
    <span class="c1">// 基于Sink遍历Spliterator中的元素，支持取消操作，简单理解就是支持cancel的tryAdvance方法
</span><span class="c1"></span>    <span class="kd">abstract</span> <span class="kt">boolean</span> <span class="nf">forEachWithCancel</span><span class="o">(</span><span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">&gt;</span> <span class="n">spliterator</span><span class="o">,</span> <span class="n">Sink</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">&gt;</span> <span class="n">sink</span><span class="o">);</span>

    <span class="c1">// 返回Node的建造器实例，用于toArray方法系列
</span><span class="c1"></span>    <span class="kd">abstract</span> <span class="n">Node</span><span class="o">.</span><span class="na">Builder</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">&gt;</span> <span class="nf">makeNodeBuilder</span><span class="o">(</span><span class="kt">long</span> <span class="n">exactSizeIfKnown</span><span class="o">,</span>
                                                 <span class="n">IntFunction</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">[]&gt;</span> <span class="n">generator</span><span class="o">);</span>
    
    <span class="c1">// 判断当前的操作(节点)是否有状态，如果是有状态的操作，必须覆盖opEvaluateParallel方法
</span><span class="c1"></span>    <span class="kd">abstract</span> <span class="kt">boolean</span> <span class="nf">opIsStateful</span><span class="o">();</span>
    
    <span class="c1">// 当前操作生成的结果会作为传入的Sink实例的入参，这是一个包装Sink的过程，通俗理解就是之前提到的元素引用链添加一个新的链节点，这个方法算是流执行的一个核心方法
</span><span class="c1"></span>    <span class="kd">abstract</span> <span class="n">Sink</span><span class="o">&lt;</span><span class="n">E_IN</span><span class="o">&gt;</span> <span class="nf">opWrapSink</span><span class="o">(</span><span class="kt">int</span> <span class="n">flags</span><span class="o">,</span> <span class="n">Sink</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">&gt;</span> <span class="n">sink</span><span class="o">);</span>    
    
    <span class="c1">// 并发执行的操作节点求值
</span><span class="c1"></span>    <span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">&gt;</span> <span class="nf">opEvaluateParallel</span><span class="o">(</span><span class="n">PipelineHelper</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">&gt;</span> <span class="n">helper</span><span class="o">,</span>
                                          <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="n">spliterator</span><span class="o">,</span>
                                          <span class="n">IntFunction</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">[]&gt;</span> <span class="n">generator</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">UnsupportedOperationException</span><span class="o">(</span><span class="s">&#34;Parallel evaluation is not supported&#34;</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 并发执行的操作节点惰性求值
</span><span class="c1"></span>    <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">&#34;unchecked&#34;</span><span class="o">)</span>
    <span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">&gt;</span> <span class="nf">opEvaluateParallelLazy</span><span class="o">(</span><span class="n">PipelineHelper</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">&gt;</span> <span class="n">helper</span><span class="o">,</span>
                                                     <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="n">spliterator</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">opEvaluateParallel</span><span class="o">(</span><span class="n">helper</span><span class="o">,</span> <span class="n">spliterator</span><span class="o">,</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">E_OUT</span><span class="o">[])</span> <span class="k">new</span> <span class="n">Object</span><span class="o">[</span><span class="n">i</span><span class="o">]).</span><span class="na">spliterator</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="c1">// 省略其他方法
</span><span class="c1"></span><span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The abstract method opWrapSink() mentioned here is actually the method of adding a chain node to the element reference chain, and its implementation logic is shown in the subclasses, and only part of the source code of the non-specialized subclass ReferencePipeline is considered here.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">ReferencePipeline</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">,</span> <span class="n">P_OUT</span><span class="o">&gt;</span>
        <span class="kd">extends</span> <span class="n">AbstractPipeline</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">,</span> <span class="n">P_OUT</span><span class="o">,</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">P_OUT</span><span class="o">&gt;&gt;</span>
        <span class="kd">implements</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">P_OUT</span><span class="o">&gt;</span>  <span class="o">{</span>

    <span class="c1">// 构造函数，用于头节点，传入基于Supplier封装的Spliterator实例作为数据源，数据源的标志集合和是否支持并发执行的判断标记
</span><span class="c1"></span>    <span class="n">ReferencePipeline</span><span class="o">(</span><span class="n">Supplier</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">Spliterator</span><span class="o">&lt;?&gt;&gt;</span> <span class="n">source</span><span class="o">,</span>
                      <span class="kt">int</span> <span class="n">sourceFlags</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">parallel</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">source</span><span class="o">,</span> <span class="n">sourceFlags</span><span class="o">,</span> <span class="n">parallel</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 构造函数，用于头节点，传入Spliterator实例作为数据源，数据源的标志集合和是否支持并发执行的判断标记
</span><span class="c1"></span>    <span class="n">ReferencePipeline</span><span class="o">(</span><span class="n">Spliterator</span><span class="o">&lt;?&gt;</span> <span class="n">source</span><span class="o">,</span>
                      <span class="kt">int</span> <span class="n">sourceFlags</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">parallel</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">source</span><span class="o">,</span> <span class="n">sourceFlags</span><span class="o">,</span> <span class="n">parallel</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 构造函数，用于中间节点，传入上一个流管道节点的实例(前驱节点)和当前操作节点支持的标志集合
</span><span class="c1"></span>    <span class="n">ReferencePipeline</span><span class="o">(</span><span class="n">AbstractPipeline</span><span class="o">&lt;?,</span> <span class="n">P_IN</span><span class="o">,</span> <span class="o">?&gt;</span> <span class="n">upstream</span><span class="o">,</span> <span class="kt">int</span> <span class="n">opFlags</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">upstream</span><span class="o">,</span> <span class="n">opFlags</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="c1">// 这里流的输出&#34;形状&#34;固定为REFERENCE
</span><span class="c1"></span>    <span class="nd">@Override</span>
    <span class="kd">final</span> <span class="n">StreamShape</span> <span class="nf">getOutputShape</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">StreamShape</span><span class="o">.</span><span class="na">REFERENCE</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="c1">// 转换当前流实例为Node实例，应用于toArray方法，后面详细分析终结操作的时候再展开
</span><span class="c1"></span>    <span class="nd">@Override</span>
    <span class="kd">final</span> <span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">P_OUT</span><span class="o">&gt;</span> <span class="nf">evaluateToNode</span><span class="o">(</span><span class="n">PipelineHelper</span><span class="o">&lt;</span><span class="n">P_OUT</span><span class="o">&gt;</span> <span class="n">helper</span><span class="o">,</span>
                                        <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="n">spliterator</span><span class="o">,</span>
                                        <span class="kt">boolean</span> <span class="n">flattenTree</span><span class="o">,</span>
                                        <span class="n">IntFunction</span><span class="o">&lt;</span><span class="n">P_OUT</span><span class="o">[]&gt;</span> <span class="n">generator</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">Nodes</span><span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">helper</span><span class="o">,</span> <span class="n">spliterator</span><span class="o">,</span> <span class="n">flattenTree</span><span class="o">,</span> <span class="n">generator</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="c1">// 包装Spliterator=&gt;WrappingSpliterator
</span><span class="c1"></span>    <span class="nd">@Override</span>
    <span class="kd">final</span> <span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">P_OUT</span><span class="o">&gt;</span> <span class="nf">wrap</span><span class="o">(</span><span class="n">PipelineHelper</span><span class="o">&lt;</span><span class="n">P_OUT</span><span class="o">&gt;</span> <span class="n">ph</span><span class="o">,</span>
                                     <span class="n">Supplier</span><span class="o">&lt;</span><span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;&gt;</span> <span class="n">supplier</span><span class="o">,</span>
                                     <span class="kt">boolean</span> <span class="n">isParallel</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">StreamSpliterators</span><span class="o">.</span><span class="na">WrappingSpliterator</span><span class="o">&lt;&gt;(</span><span class="n">ph</span><span class="o">,</span> <span class="n">supplier</span><span class="o">,</span> <span class="n">isParallel</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="c1">// 包装Spliterator=&gt;DelegatingSpliterator，实现惰性加载
</span><span class="c1"></span>    <span class="nd">@Override</span>
    <span class="kd">final</span> <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">P_OUT</span><span class="o">&gt;</span> <span class="nf">lazySpliterator</span><span class="o">(</span><span class="n">Supplier</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">P_OUT</span><span class="o">&gt;&gt;</span> <span class="n">supplier</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">StreamSpliterators</span><span class="o">.</span><span class="na">DelegatingSpliterator</span><span class="o">&lt;&gt;(</span><span class="n">supplier</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="c1">// 遍历Spliterator中的元素，基于传入的Sink实例进行处理，支持Cancel操作
</span><span class="c1"></span>    <span class="nd">@Override</span>
    <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">forEachWithCancel</span><span class="o">(</span><span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">P_OUT</span><span class="o">&gt;</span> <span class="n">spliterator</span><span class="o">,</span> <span class="n">Sink</span><span class="o">&lt;</span><span class="n">P_OUT</span><span class="o">&gt;</span> <span class="n">sink</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">boolean</span> <span class="n">cancelled</span><span class="o">;</span>
        <span class="k">do</span> <span class="o">{</span> <span class="o">}</span> <span class="k">while</span> <span class="o">(!(</span><span class="n">cancelled</span> <span class="o">=</span> <span class="n">sink</span><span class="o">.</span><span class="na">cancellationRequested</span><span class="o">())</span> <span class="o">&amp;&amp;</span> <span class="n">spliterator</span><span class="o">.</span><span class="na">tryAdvance</span><span class="o">(</span><span class="n">sink</span><span class="o">));</span>
        <span class="k">return</span> <span class="n">cancelled</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="c1">// 构造Node建造器实例
</span><span class="c1"></span>    <span class="nd">@Override</span>
    <span class="kd">final</span> <span class="n">Node</span><span class="o">.</span><span class="na">Builder</span><span class="o">&lt;</span><span class="n">P_OUT</span><span class="o">&gt;</span> <span class="nf">makeNodeBuilder</span><span class="o">(</span><span class="kt">long</span> <span class="n">exactSizeIfKnown</span><span class="o">,</span> <span class="n">IntFunction</span><span class="o">&lt;</span><span class="n">P_OUT</span><span class="o">[]&gt;</span> <span class="n">generator</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">Nodes</span><span class="o">.</span><span class="na">builder</span><span class="o">(</span><span class="n">exactSizeIfKnown</span><span class="o">,</span> <span class="n">generator</span><span class="o">);</span>
    <span class="o">}</span>
 
    <span class="c1">// 基于当前流的Spliterator生成迭代器实例
</span><span class="c1"></span>    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="n">Iterator</span><span class="o">&lt;</span><span class="n">P_OUT</span><span class="o">&gt;</span> <span class="nf">iterator</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">Spliterators</span><span class="o">.</span><span class="na">iterator</span><span class="o">(</span><span class="n">spliterator</span><span class="o">());</span>
    <span class="o">}</span>
    
    <span class="c1">// 省略其他OP的代码
</span><span class="c1"></span>    
    <span class="c1">// 流管道结构的头节点
</span><span class="c1"></span>    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Head</span><span class="o">&lt;</span><span class="n">E_IN</span><span class="o">,</span> <span class="n">E_OUT</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">ReferencePipeline</span><span class="o">&lt;</span><span class="n">E_IN</span><span class="o">,</span> <span class="n">E_OUT</span><span class="o">&gt;</span> <span class="o">{</span>
        
        <span class="c1">// 构造函数，用于头节点，传入基于Supplier封装的Spliterator实例作为数据源，数据源的标志集合和是否支持并发执行的判断标记
</span><span class="c1"></span>        <span class="n">Head</span><span class="o">(</span><span class="n">Supplier</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">Spliterator</span><span class="o">&lt;?&gt;&gt;</span> <span class="n">source</span><span class="o">,</span>
             <span class="kt">int</span> <span class="n">sourceFlags</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">parallel</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">super</span><span class="o">(</span><span class="n">source</span><span class="o">,</span> <span class="n">sourceFlags</span><span class="o">,</span> <span class="n">parallel</span><span class="o">);</span>
        <span class="o">}</span>
        
        <span class="c1">// 构造函数，用于头节点，传入Spliterator实例作为数据源，数据源的标志集合和是否支持并发执行的判断标记
</span><span class="c1"></span>        <span class="n">Head</span><span class="o">(</span><span class="n">Spliterator</span><span class="o">&lt;?&gt;</span> <span class="n">source</span><span class="o">,</span>
             <span class="kt">int</span> <span class="n">sourceFlags</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">parallel</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">super</span><span class="o">(</span><span class="n">source</span><span class="o">,</span> <span class="n">sourceFlags</span><span class="o">,</span> <span class="n">parallel</span><span class="o">);</span>
        <span class="o">}</span>
        
        <span class="c1">// 不支持判断是否状态操作
</span><span class="c1"></span>        <span class="nd">@Override</span>
        <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">opIsStateful</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">UnsupportedOperationException</span><span class="o">();</span>
        <span class="o">}</span>
        
        <span class="c1">// 不支持包装Sink实例
</span><span class="c1"></span>        <span class="nd">@Override</span>
        <span class="kd">final</span> <span class="n">Sink</span><span class="o">&lt;</span><span class="n">E_IN</span><span class="o">&gt;</span> <span class="nf">opWrapSink</span><span class="o">(</span><span class="kt">int</span> <span class="n">flags</span><span class="o">,</span> <span class="n">Sink</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">&gt;</span> <span class="n">sink</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">UnsupportedOperationException</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="c1">// 区分同步异步执行forEach，同步则简单理解为调用Spliterator.forEachRemaining，异步则调用终结操作forEach
</span><span class="c1"></span>        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">forEach</span><span class="o">(</span><span class="n">Consumer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">E_OUT</span><span class="o">&gt;</span> <span class="n">action</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">isParallel</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">sourceStageSpliterator</span><span class="o">().</span><span class="na">forEachRemaining</span><span class="o">(</span><span class="n">action</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="kd">super</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">action</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="c1">// 区分同步异步执行forEachOrdered，同步则简单理解为调用Spliterator.forEachRemaining，异步则调用终结操作forEachOrdered
</span><span class="c1"></span>        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">forEachOrdered</span><span class="o">(</span><span class="n">Consumer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">E_OUT</span><span class="o">&gt;</span> <span class="n">action</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">isParallel</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">sourceStageSpliterator</span><span class="o">().</span><span class="na">forEachRemaining</span><span class="o">(</span><span class="n">action</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="kd">super</span><span class="o">.</span><span class="na">forEachOrdered</span><span class="o">(</span><span class="n">action</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="c1">// 无状态操作节点的父类
</span><span class="c1"></span>    <span class="kd">abstract</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">StatelessOp</span><span class="o">&lt;</span><span class="n">E_IN</span><span class="o">,</span> <span class="n">E_OUT</span><span class="o">&gt;</span>
            <span class="kd">extends</span> <span class="n">ReferencePipeline</span><span class="o">&lt;</span><span class="n">E_IN</span><span class="o">,</span> <span class="n">E_OUT</span><span class="o">&gt;</span> <span class="o">{</span>
        
        <span class="c1">// 基于上一个节点引用、输入元素&#34;形状&#34;和当前节点支持的标志集合创建StatelessOp实例
</span><span class="c1"></span>        <span class="n">StatelessOp</span><span class="o">(</span><span class="n">AbstractPipeline</span><span class="o">&lt;?,</span> <span class="n">E_IN</span><span class="o">,</span> <span class="o">?&gt;</span> <span class="n">upstream</span><span class="o">,</span>
                    <span class="n">StreamShape</span> <span class="n">inputShape</span><span class="o">,</span>
                    <span class="kt">int</span> <span class="n">opFlags</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">super</span><span class="o">(</span><span class="n">upstream</span><span class="o">,</span> <span class="n">opFlags</span><span class="o">);</span>
            <span class="k">assert</span> <span class="n">upstream</span><span class="o">.</span><span class="na">getOutputShape</span><span class="o">()</span> <span class="o">==</span> <span class="n">inputShape</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="c1">// 操作状态标记设置为无状态
</span><span class="c1"></span>        <span class="nd">@Override</span>
        <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">opIsStateful</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// 有状态操作节点的父类
</span><span class="c1"></span>    <span class="kd">abstract</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">StatefulOp</span><span class="o">&lt;</span><span class="n">E_IN</span><span class="o">,</span> <span class="n">E_OUT</span><span class="o">&gt;</span>
            <span class="kd">extends</span> <span class="n">ReferencePipeline</span><span class="o">&lt;</span><span class="n">E_IN</span><span class="o">,</span> <span class="n">E_OUT</span><span class="o">&gt;</span> <span class="o">{</span>

        <span class="c1">// 基于上一个节点引用、输入元素&#34;形状&#34;和当前节点支持的标志集合创建StatefulOp实例
</span><span class="c1"></span>        <span class="n">StatefulOp</span><span class="o">(</span><span class="n">AbstractPipeline</span><span class="o">&lt;?,</span> <span class="n">E_IN</span><span class="o">,</span> <span class="o">?&gt;</span> <span class="n">upstream</span><span class="o">,</span>
                   <span class="n">StreamShape</span> <span class="n">inputShape</span><span class="o">,</span>
                   <span class="kt">int</span> <span class="n">opFlags</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">super</span><span class="o">(</span><span class="n">upstream</span><span class="o">,</span> <span class="n">opFlags</span><span class="o">);</span>
            <span class="k">assert</span> <span class="n">upstream</span><span class="o">.</span><span class="na">getOutputShape</span><span class="o">()</span> <span class="o">==</span> <span class="n">inputShape</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="c1">// 操作状态标记设置为有状态
</span><span class="c1"></span>        <span class="nd">@Override</span>
        <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">opIsStateful</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="c1">// 前面也提到，节点操作异步求值的方法在无状态节点下必须覆盖，这里重新把这个方法抽象，子类必须实现
</span><span class="c1"></span>        <span class="nd">@Override</span>
        <span class="kd">abstract</span> <span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">&gt;</span> <span class="nf">opEvaluateParallel</span><span class="o">(</span><span class="n">PipelineHelper</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">&gt;</span> <span class="n">helper</span><span class="o">,</span>
                                                       <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="n">spliterator</span><span class="o">,</span>
                                                       <span class="n">IntFunction</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">[]&gt;</span> <span class="n">generator</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span> 

</code></pre></td></tr></table>
</div>
</div><p>Here is a heavy focus on the implementation of the wrapSink method in the ReferencePipeline.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">final</span> <span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="n">Sink</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="nf">wrapSink</span><span class="o">(</span><span class="n">Sink</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">&gt;</span> <span class="n">sink</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Objects</span><span class="o">.</span><span class="na">requireNonNull</span><span class="o">(</span><span class="n">sink</span><span class="o">);</span>

    <span class="k">for</span> <span class="o">(</span> <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">&#34;rawtypes&#34;</span><span class="o">)</span> <span class="n">AbstractPipeline</span> <span class="n">p</span><span class="o">=</span><span class="n">AbstractPipeline</span><span class="o">.</span><span class="na">this</span><span class="o">;</span> <span class="n">p</span><span class="o">.</span><span class="na">depth</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">;</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="na">previousStage</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">sink</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">opWrapSink</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">previousStage</span><span class="o">.</span><span class="na">combinedFlags</span><span class="o">,</span> <span class="n">sink</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="o">(</span><span class="n">Sink</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;)</span> <span class="n">sink</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The input is a Sink instance, and the return value is also a Sink instance. The for loop inside is based on the current AbstractPipeline node traversing forward until the node with depth 0 jumps out of the loop, and depth 0 means that the node must be the head node, that is, the loop is traversing the current node to the successor node of the head node, and Sink is Sink is &ldquo;forward wrapped&rdquo;, that is, the node Sink at the back of the chain will always be used as an input to the opWrapSink() method of its predecessor node. When the stream value calculation is executed synchronously, the Sink of the predecessor node will call its accept through the downstream reference after processing the elements (actually, the Sink of the predecessor node ) will call its accept() to pass in the element or the result of the processed element to activate the next Sink, and so on. In addition, the three internal classes of ReferencePipeline, Head, StatelessOp and StatefulOp, are the node classes of the stream, where only Head is a non-abstract class representing the head node of the stream pipeline structure (or bidirectional chain table structure). StatelessOp (stateless operations) and StatefulOp (stateful operations) subclasses constitute the operation nodes or end operations of the stream pipeline structure. In ignoring the premise of whether there is a state operation to see ReferencePipeline, it is only the carrier of the stream data structure, the apparent bi-directional chain table structure seen in the stream value calculation process does not directly traverse each node for value, but first transformed into a multi-layer packaging Sink, which is the latter element reference chain mentioned by the author in the previous sentence of the analysis Sink element processing and delivery, correctly speaking, should be a Sink stack or Sink wrapper, its implementation can be analogous to the real-life onion, or the programming model of the AOP programming model. A more graphic description is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">Head<span class="o">(</span>Spliterator<span class="o">)</span> -&gt; Op<span class="o">(</span>filter<span class="o">)</span> -&gt; Op<span class="o">(</span>map<span class="o">)</span> -&gt; Op<span class="o">(</span>sorted<span class="o">)</span> -&gt; Terminal Op<span class="o">(</span>forEach<span class="o">)</span>

↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
forEach ele in Spliterator: 
    Sink<span class="o">[</span>filter<span class="o">](</span>ele<span class="o">){</span>
        <span class="k">if</span> filter <span class="nv">process</span> <span class="o">==</span> true: 
            Sink<span class="o">[</span>map<span class="o">](</span>ele<span class="o">){</span>
                <span class="nv">ele</span> <span class="o">=</span> mapper<span class="o">(</span>ele<span class="o">)</span>
                Sink<span class="o">[</span>sorted<span class="o">](</span>ele<span class="o">){</span>

                    var array 

                    begin: 
          
                    accept<span class="o">(</span>ele<span class="o">)</span>:
                      add ele to array

                    end:
                      sort ele in array                      
                <span class="o">}</span>
            <span class="o">}</span>
    <span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The termination operation forEach is by far the simplest implementation in the analyzed source code, and the implementation details of each termination operation will be analyzed in detail below.</p>
<h2 id="source-code-implementation-of-stream-intermediate-operations">Source code implementation of stream intermediate operations</h2>
<p>Due to the limitation of space, only a part of the intermediate Op can be analyzed here. The intermediate operations of streams are basically defined by the BaseStream interface and implemented in the ReferencePipeline, here we select the more commonly used filter, map and sorted for analysis. Let&rsquo;s look at filter first.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">ReferencePipeline</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">,</span> <span class="n">P_OUT</span><span class="o">&gt;</span>
        <span class="kd">extends</span> <span class="n">AbstractPipeline</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">,</span> <span class="n">P_OUT</span><span class="o">,</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">P_OUT</span><span class="o">&gt;&gt;</span>
        <span class="kd">implements</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">P_OUT</span><span class="o">&gt;</span>  <span class="o">{</span>
    
    <span class="c1">// 暂时省略其他代码
</span><span class="c1"></span>
    <span class="c1">// filter操作，泛型参数Predicate类型接受一个任意类型(这里考虑到泛型擦除)的元素，输出布尔值，它是一个无状态操作
</span><span class="c1"></span>    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">P_OUT</span><span class="o">&gt;</span> <span class="nf">filter</span><span class="o">(</span><span class="n">Predicate</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">P_OUT</span><span class="o">&gt;</span> <span class="n">predicate</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Objects</span><span class="o">.</span><span class="na">requireNonNull</span><span class="o">(</span><span class="n">predicate</span><span class="o">);</span>
        <span class="c1">// 这里注意到，StatelessOp的第一个参数是指upstream，也就是理解为上一个节点，这里使用了this，意味着upstream为当前的ReferencePipeline实例，元素&#34;形状&#34;为引用类型，操作标志位不支持SIZED
</span><span class="c1"></span>        <span class="c1">// 在AbstractPipeline，previousStage指向了this，当前的节点就是StatelessOp[filter]实例，那么前驱节点this的后继节点引用nextStage就指向了StatelessOp[filter]实例
</span><span class="c1"></span>        <span class="c1">// 也就是StatelessOp[filter].previousStage = this; this.nextStage = StatelessOp[filter];  ===&gt; 也就是这个看起来简单的new StatelessOp()其实已经把自身加入到管道中
</span><span class="c1"></span>        <span class="k">return</span> <span class="k">new</span> <span class="n">StatelessOp</span><span class="o">&lt;</span><span class="n">P_OUT</span><span class="o">,</span> <span class="n">P_OUT</span><span class="o">&gt;(</span><span class="k">this</span><span class="o">,</span> <span class="n">StreamShape</span><span class="o">.</span><span class="na">REFERENCE</span><span class="o">,</span>
                                     <span class="n">StreamOpFlag</span><span class="o">.</span><span class="na">NOT_SIZED</span><span class="o">)</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="n">Sink</span><span class="o">&lt;</span><span class="n">P_OUT</span><span class="o">&gt;</span> <span class="nf">opWrapSink</span><span class="o">(</span><span class="kt">int</span> <span class="n">flags</span><span class="o">,</span> <span class="n">Sink</span><span class="o">&lt;</span><span class="n">P_OUT</span><span class="o">&gt;</span> <span class="n">sink</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="k">new</span> <span class="n">Sink</span><span class="o">.</span><span class="na">ChainedReference</span><span class="o">&lt;</span><span class="n">P_OUT</span><span class="o">,</span> <span class="n">P_OUT</span><span class="o">&gt;(</span><span class="n">sink</span><span class="o">)</span> <span class="o">{</span>
                    <span class="nd">@Override</span>
                    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">begin</span><span class="o">(</span><span class="kt">long</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
                        <span class="c1">// 这里通知下一个节点的Sink.begin()，由于filter方法不感知元素数量，所以传值-1
</span><span class="c1"></span>                        <span class="n">downstream</span><span class="o">.</span><span class="na">begin</span><span class="o">(-</span><span class="n">1</span><span class="o">);</span>
                    <span class="o">}</span>

                    <span class="nd">@Override</span>
                    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">accept</span><span class="o">(</span><span class="n">P_OUT</span> <span class="n">u</span><span class="o">)</span> <span class="o">{</span>
                        <span class="c1">// 基于输入的Predicate实例判断当前处理元素是否符合判断，只有判断结果为true才会把元素原封不动直接传递到下一个Sink
</span><span class="c1"></span>                        <span class="k">if</span> <span class="o">(</span><span class="n">predicate</span><span class="o">.</span><span class="na">test</span><span class="o">(</span><span class="n">u</span><span class="o">))</span>
                            <span class="n">downstream</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">u</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">};</span>
            <span class="o">}</span>
        <span class="o">};</span>
    <span class="o">}</span>

    <span class="c1">// 暂时省略其他代码
</span><span class="c1"></span><span class="o">}</span>

</code></pre></td></tr></table>
</div>
</div><p>Next is Map.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">ReferencePipeline</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">,</span> <span class="n">P_OUT</span><span class="o">&gt;</span>
        <span class="kd">extends</span> <span class="n">AbstractPipeline</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">,</span> <span class="n">P_OUT</span><span class="o">,</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">P_OUT</span><span class="o">&gt;&gt;</span>
        <span class="kd">implements</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">P_OUT</span><span class="o">&gt;</span>  <span class="o">{</span>
    
    <span class="c1">// 暂时省略其他代码
</span><span class="c1"></span>    
    <span class="c1">// map操作，基于传入的Function实例做映射转换(P_OUT-&gt;R)，它是一个无状态操作
</span><span class="c1"></span>    <span class="nd">@Override</span>
    <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">&#34;unchecked&#34;</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="nf">map</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">P_OUT</span><span class="o">,</span> <span class="o">?</span> <span class="kd">extends</span> <span class="n">R</span><span class="o">&gt;</span> <span class="n">mapper</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Objects</span><span class="o">.</span><span class="na">requireNonNull</span><span class="o">(</span><span class="n">mapper</span><span class="o">);</span>
        <span class="c1">// upstream为当前的ReferencePipeline实例，元素&#34;形状&#34;为引用类型，操作标志位不支持SORTED和DISTINCT
</span><span class="c1"></span>        <span class="k">return</span> <span class="k">new</span> <span class="n">StatelessOp</span><span class="o">&lt;</span><span class="n">P_OUT</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;(</span><span class="k">this</span><span class="o">,</span> <span class="n">StreamShape</span><span class="o">.</span><span class="na">REFERENCE</span><span class="o">,</span>
                                     <span class="n">StreamOpFlag</span><span class="o">.</span><span class="na">NOT_SORTED</span> <span class="o">|</span> <span class="n">StreamOpFlag</span><span class="o">.</span><span class="na">NOT_DISTINCT</span><span class="o">)</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="n">Sink</span><span class="o">&lt;</span><span class="n">P_OUT</span><span class="o">&gt;</span> <span class="nf">opWrapSink</span><span class="o">(</span><span class="kt">int</span> <span class="n">flags</span><span class="o">,</span> <span class="n">Sink</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="n">sink</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="k">new</span> <span class="n">Sink</span><span class="o">.</span><span class="na">ChainedReference</span><span class="o">&lt;</span><span class="n">P_OUT</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;(</span><span class="n">sink</span><span class="o">)</span> <span class="o">{</span>
                    <span class="nd">@Override</span>
                    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">accept</span><span class="o">(</span><span class="n">P_OUT</span> <span class="n">u</span><span class="o">)</span> <span class="o">{</span>
                        <span class="c1">// 基于传入的Function实例转换元素后把转换结果传递到下一个Sink
</span><span class="c1"></span>                        <span class="n">downstream</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">mapper</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">u</span><span class="o">));</span>
                    <span class="o">}</span>
                <span class="o">};</span>
            <span class="o">}</span>
        <span class="o">};</span>
    <span class="o">}</span>

    <span class="c1">// 暂时省略其他代码
</span><span class="c1"></span><span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Then comes sorted, which is a relatively complex operation.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">ReferencePipeline</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">,</span> <span class="n">P_OUT</span><span class="o">&gt;</span>
        <span class="kd">extends</span> <span class="n">AbstractPipeline</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">,</span> <span class="n">P_OUT</span><span class="o">,</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">P_OUT</span><span class="o">&gt;&gt;</span>
        <span class="kd">implements</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">P_OUT</span><span class="o">&gt;</span>  <span class="o">{</span>
    
    <span class="c1">// 暂时省略其他代码
</span><span class="c1"></span>    
    <span class="c1">// sorted操作，基于传入的Comparator实例对处理的元素进行排序，从源码中看，它是一个有状态操作
</span><span class="c1"></span>    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">P_OUT</span><span class="o">&gt;</span> <span class="nf">sorted</span><span class="o">(</span><span class="n">Comparator</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">P_OUT</span><span class="o">&gt;</span> <span class="n">comparator</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">SortedOps</span><span class="o">.</span><span class="na">makeRef</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">comparator</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 暂时省略其他代码
</span><span class="c1"></span><span class="o">}</span>

<span class="c1">// SortedOps工具类
</span><span class="c1"></span><span class="kd">final</span> <span class="kd">class</span> <span class="nc">SortedOps</span> <span class="o">{</span>

    <span class="c1">// 暂时省略其他代码
</span><span class="c1"></span>
    <span class="c1">// 构建排序操作的链节点
</span><span class="c1"></span>    <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">makeRef</span><span class="o">(</span><span class="n">AbstractPipeline</span><span class="o">&lt;?,</span> <span class="n">T</span><span class="o">,</span> <span class="o">?&gt;</span> <span class="n">upstream</span><span class="o">,</span>
                                <span class="n">Comparator</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">comparator</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">OfRef</span><span class="o">&lt;&gt;(</span><span class="n">upstream</span><span class="o">,</span> <span class="n">comparator</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="c1">// 有状态的排序操作节点
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">OfRef</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">ReferencePipeline</span><span class="o">.</span><span class="na">StatefulOp</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
        
        <span class="c1">// 是否自然排序，不定义Comparator实例的时候为true，否则为false
</span><span class="c1"></span>        <span class="kd">private</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="n">isNaturalSort</span><span class="o">;</span>
        <span class="c1">// 用于排序的Comparator实例
</span><span class="c1"></span>        <span class="kd">private</span> <span class="kd">final</span> <span class="n">Comparator</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">comparator</span><span class="o">;</span>

        <span class="c1">// 自然排序情况下的构造方法，元素&#34;形状&#34;为引用类型，操作标志位不支持ORDERED和SORTED
</span><span class="c1"></span>        <span class="n">OfRef</span><span class="o">(</span><span class="n">AbstractPipeline</span><span class="o">&lt;?,</span> <span class="n">T</span><span class="o">,</span> <span class="o">?&gt;</span> <span class="n">upstream</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">super</span><span class="o">(</span><span class="n">upstream</span><span class="o">,</span> <span class="n">StreamShape</span><span class="o">.</span><span class="na">REFERENCE</span><span class="o">,</span>
                  <span class="n">StreamOpFlag</span><span class="o">.</span><span class="na">IS_ORDERED</span> <span class="o">|</span> <span class="n">StreamOpFlag</span><span class="o">.</span><span class="na">IS_SORTED</span><span class="o">);</span>
            <span class="k">this</span><span class="o">.</span><span class="na">isNaturalSort</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="c1">// Comparator实例赋值为Comparator.naturalOrder()，本质是基于Object中的equals或者子类覆盖Object中的equals方法进行元素排序
</span><span class="c1"></span>            <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">&#34;unchecked&#34;</span><span class="o">)</span>
            <span class="n">Comparator</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">comp</span> <span class="o">=</span> <span class="o">(</span><span class="n">Comparator</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;)</span> <span class="n">Comparator</span><span class="o">.</span><span class="na">naturalOrder</span><span class="o">();</span>
            <span class="k">this</span><span class="o">.</span><span class="na">comparator</span> <span class="o">=</span> <span class="n">comp</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 非自然排序情况下的构造方法，需要传入Comparator实例，元素&#34;形状&#34;为引用类型，操作标志位不支持ORDERED和SORTED
</span><span class="c1"></span>        <span class="n">OfRef</span><span class="o">(</span><span class="n">AbstractPipeline</span><span class="o">&lt;?,</span> <span class="n">T</span><span class="o">,</span> <span class="o">?&gt;</span> <span class="n">upstream</span><span class="o">,</span> <span class="n">Comparator</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">comparator</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">super</span><span class="o">(</span><span class="n">upstream</span><span class="o">,</span> <span class="n">StreamShape</span><span class="o">.</span><span class="na">REFERENCE</span><span class="o">,</span>
                  <span class="n">StreamOpFlag</span><span class="o">.</span><span class="na">IS_ORDERED</span> <span class="o">|</span> <span class="n">StreamOpFlag</span><span class="o">.</span><span class="na">NOT_SORTED</span><span class="o">);</span>
            <span class="k">this</span><span class="o">.</span><span class="na">isNaturalSort</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">comparator</span> <span class="o">=</span> <span class="n">Objects</span><span class="o">.</span><span class="na">requireNonNull</span><span class="o">(</span><span class="n">comparator</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="n">Sink</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">opWrapSink</span><span class="o">(</span><span class="kt">int</span> <span class="n">flags</span><span class="o">,</span> <span class="n">Sink</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">sink</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">Objects</span><span class="o">.</span><span class="na">requireNonNull</span><span class="o">(</span><span class="n">sink</span><span class="o">);</span>

            <span class="c1">// If the input is already naturally sorted and this operation
</span><span class="c1"></span>            <span class="c1">// also naturally sorted then this is a no-op
</span><span class="c1"></span>            <span class="c1">// 流中的所有元素本身已经按照自然顺序排序，并且没有定义Comparator实例，则不需要进行排序，所以no op就行
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">StreamOpFlag</span><span class="o">.</span><span class="na">SORTED</span><span class="o">.</span><span class="na">isKnown</span><span class="o">(</span><span class="n">flags</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">isNaturalSort</span><span class="o">)</span>
                <span class="k">return</span> <span class="n">sink</span><span class="o">;</span>
            <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">StreamOpFlag</span><span class="o">.</span><span class="na">SIZED</span><span class="o">.</span><span class="na">isKnown</span><span class="o">(</span><span class="n">flags</span><span class="o">))</span>
                <span class="c1">// 知道要处理的元素的确切数量，使用数组进行排序
</span><span class="c1"></span>                <span class="k">return</span> <span class="k">new</span> <span class="n">SizedRefSortingSink</span><span class="o">&lt;&gt;(</span><span class="n">sink</span><span class="o">,</span> <span class="n">comparator</span><span class="o">);</span>
            <span class="k">else</span>
                <span class="c1">// 不知道要处理的元素的确切数量，使用ArrayList进行排序
</span><span class="c1"></span>                <span class="k">return</span> <span class="k">new</span> <span class="n">RefSortingSink</span><span class="o">&lt;&gt;(</span><span class="n">sink</span><span class="o">,</span> <span class="n">comparator</span><span class="o">);</span>
        <span class="o">}</span>
        
        <span class="c1">// 这里是并行执行流中toArray方法的实现，暂不分析
</span><span class="c1"></span>        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">opEvaluateParallel</span><span class="o">(</span><span class="n">PipelineHelper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">helper</span><span class="o">,</span>
                                                 <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="n">spliterator</span><span class="o">,</span>
                                                 <span class="n">IntFunction</span><span class="o">&lt;</span><span class="n">T</span><span class="o">[]&gt;</span> <span class="n">generator</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// If the input is already naturally sorted and this operation
</span><span class="c1"></span>            <span class="c1">// naturally sorts then collect the output
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">StreamOpFlag</span><span class="o">.</span><span class="na">SORTED</span><span class="o">.</span><span class="na">isKnown</span><span class="o">(</span><span class="n">helper</span><span class="o">.</span><span class="na">getStreamAndOpFlags</span><span class="o">())</span> <span class="o">&amp;&amp;</span> <span class="n">isNaturalSort</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">helper</span><span class="o">.</span><span class="na">evaluate</span><span class="o">(</span><span class="n">spliterator</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="n">generator</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// @@@ Weak two-pass parallel implementation; parallel collect, parallel sort
</span><span class="c1"></span>                <span class="n">T</span><span class="o">[]</span> <span class="n">flattenedData</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="na">evaluate</span><span class="o">(</span><span class="n">spliterator</span><span class="o">,</span> <span class="kc">true</span><span class="o">,</span> <span class="n">generator</span><span class="o">).</span><span class="na">asArray</span><span class="o">(</span><span class="n">generator</span><span class="o">);</span>
                <span class="n">Arrays</span><span class="o">.</span><span class="na">parallelSort</span><span class="o">(</span><span class="n">flattenedData</span><span class="o">,</span> <span class="n">comparator</span><span class="o">);</span>
                <span class="k">return</span> <span class="n">Nodes</span><span class="o">.</span><span class="na">node</span><span class="o">(</span><span class="n">flattenedData</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// 这里考虑到篇幅太长，SizedRefSortingSink和RefSortingSink的源码不复杂，只展开RefSortingSink进行分析
</span><span class="c1"></span>
    <span class="c1">// 无法确认待处理元素确切数量时候用于元素排序的Sink实现
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">RefSortingSink</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">AbstractRefSortingSink</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>

        <span class="c1">// 临时ArrayList实例
</span><span class="c1"></span>        <span class="kd">private</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">;</span>
        
        <span class="c1">// 构造函数，需要的参数为下一个Sink引用和Comparator实例
</span><span class="c1"></span>        <span class="n">RefSortingSink</span><span class="o">(</span><span class="n">Sink</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">sink</span><span class="o">,</span> <span class="n">Comparator</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">comparator</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">super</span><span class="o">(</span><span class="n">sink</span><span class="o">,</span> <span class="n">comparator</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">begin</span><span class="o">(</span><span class="kt">long</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">Nodes</span><span class="o">.</span><span class="na">MAX_ARRAY_SIZE</span><span class="o">)</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="n">Nodes</span><span class="o">.</span><span class="na">BAD_SIZE</span><span class="o">);</span>
            <span class="c1">// 基于传入的size是否大于0，大于等于0用于作为initialCapacity构建ArrayList，小于0则构建默认initialCapacity的ArrayList，赋值到临时变量list
</span><span class="c1"></span>            <span class="n">list</span> <span class="o">=</span> <span class="o">(</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">0</span><span class="o">)</span> <span class="o">?</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;((</span><span class="kt">int</span><span class="o">)</span> <span class="n">size</span><span class="o">)</span> <span class="o">:</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">end</span><span class="o">()</span> <span class="o">{</span>
            <span class="c1">// 临时的ArrayList实例基于Comparator实例进行潘旭
</span><span class="c1"></span>            <span class="n">list</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">comparator</span><span class="o">);</span>
            <span class="c1">// 下一个Sink节点的激活，区分是否支持取消操作
</span><span class="c1"></span>            <span class="n">downstream</span><span class="o">.</span><span class="na">begin</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">cancellationRequestedCalled</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">list</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">downstream</span><span class="o">::</span><span class="n">accept</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="k">for</span> <span class="o">(</span><span class="n">T</span> <span class="n">t</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">downstream</span><span class="o">.</span><span class="na">cancellationRequested</span><span class="o">())</span> <span class="k">break</span><span class="o">;</span>
                    <span class="n">downstream</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="n">downstream</span><span class="o">.</span><span class="na">end</span><span class="o">();</span>
            <span class="c1">// 激活下一个Sink完成后，临时的ArrayList实例置为NULL，便于GC回收
</span><span class="c1"></span>            <span class="n">list</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">accept</span><span class="o">(</span><span class="n">T</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 当前Sink处理元素直接添加到临时的ArrayList实例
</span><span class="c1"></span>            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>    

    <span class="c1">// 暂时省略其他代码
</span><span class="c1"></span><span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The sorted operation has a distinctive feature: a normal Sink will activate the next Sink reference in the accept() method after processing its own logic, but it only does the accumulation of elements (element enrichment) in the accept() method, the final sorting operation in the end() method and the two element traversal methods that mimic Spliterator to downstream to push the elements to be processed. The schematic diagram is as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/08/4a035daca475449f896dbc7b51e3c36e.png" alt=""></p>
<p>The implementation logic for the other intermediate operations is roughly the same.</p>
<h2 id="source-code-implementation-of-synchronous-execution-of-stream-termination-operations">Source code implementation of synchronous execution of stream termination operations</h2>
<p>Due to the limitation of space, only a part of the Terminal Op can be selected here for analysis, and for simplicity, only the scenario of synchronous execution is analyzed, and the most typical and complex froEach() and collect() are selected here, as well as the more unique toArray() method. First look at the implementation of the froEach() method.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">ReferencePipeline</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">,</span> <span class="n">P_OUT</span><span class="o">&gt;</span>
        <span class="kd">extends</span> <span class="n">AbstractPipeline</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">,</span> <span class="n">P_OUT</span><span class="o">,</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">P_OUT</span><span class="o">&gt;&gt;</span>
        <span class="kd">implements</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">P_OUT</span><span class="o">&gt;</span>  <span class="o">{</span>
    
    <span class="c1">// 暂时省略其他代码
</span><span class="c1"></span>    
    <span class="c1">// 遍历元素
</span><span class="c1"></span>    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">forEach</span><span class="o">(</span><span class="n">Consumer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">P_OUT</span><span class="o">&gt;</span> <span class="n">action</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">evaluate</span><span class="o">(</span><span class="n">ForEachOps</span><span class="o">.</span><span class="na">makeRef</span><span class="o">(</span><span class="n">action</span><span class="o">,</span> <span class="kc">false</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="c1">// 暂时省略其他代码
</span><span class="c1"></span>
    <span class="c1">// 基于终结操作的求值方法
</span><span class="c1"></span>    <span class="kd">final</span> <span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="n">R</span> <span class="nf">evaluate</span><span class="o">(</span><span class="n">TerminalOp</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="n">terminalOp</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">assert</span> <span class="n">getOutputShape</span><span class="o">()</span> <span class="o">==</span> <span class="n">terminalOp</span><span class="o">.</span><span class="na">inputShape</span><span class="o">();</span>
        <span class="c1">// 确保只会执行一次，linkedOrConsumed是流管道结构最后一个节点的属性
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">linkedOrConsumed</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="o">(</span><span class="n">MSG_STREAM_LINKED</span><span class="o">);</span>
        <span class="n">linkedOrConsumed</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="c1">// 这里暂且只分析同步执行的流的终结操作，终结操作节点的标志会合并到流最后一个节点的combinedFlags中，执行的关键就是evaluateSequential方法
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">isParallel</span><span class="o">()</span>
               <span class="o">?</span> <span class="n">terminalOp</span><span class="o">.</span><span class="na">evaluateParallel</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">sourceSpliterator</span><span class="o">(</span><span class="n">terminalOp</span><span class="o">.</span><span class="na">getOpFlags</span><span class="o">()))</span>
               <span class="o">:</span> <span class="n">terminalOp</span><span class="o">.</span><span class="na">evaluateSequential</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">sourceSpliterator</span><span class="o">(</span><span class="n">terminalOp</span><span class="o">.</span><span class="na">getOpFlags</span><span class="o">()));</span>
    <span class="o">}</span>

    <span class="c1">// 暂时省略其他代码  
</span><span class="c1"></span><span class="o">}</span>

<span class="c1">// ForEachOps类，TerminalOp接口的定义比较简单，这里不展开
</span><span class="c1"></span><span class="kd">final</span> <span class="kd">class</span> <span class="nc">ForEachOps</span> <span class="o">{</span>
    
    <span class="c1">// 暂时省略其他代码
</span><span class="c1"></span>
    <span class="c1">// 构造变量元素的终结操作实例，传入的元素是T类型，结果是Void类型(返回NULL，或者说是没有返回值，毕竟是一个元素遍历过程)
</span><span class="c1"></span>    <span class="c1">// 参数为一个Consumer接口实例和一个标记是否顺序处理元素的布尔值
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">TerminalOp</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">Void</span><span class="o">&gt;</span> <span class="nf">makeRef</span><span class="o">(</span><span class="n">Consumer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">action</span><span class="o">,</span>
                                                  <span class="kt">boolean</span> <span class="n">ordered</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Objects</span><span class="o">.</span><span class="na">requireNonNull</span><span class="o">(</span><span class="n">action</span><span class="o">);</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">ForEachOp</span><span class="o">.</span><span class="na">OfRef</span><span class="o">&lt;&gt;(</span><span class="n">action</span><span class="o">,</span> <span class="n">ordered</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 遍历元素操作的终结操作实现，同时它是一个适配器，适配TerminalSink(Sink)接口
</span><span class="c1"></span>    <span class="kd">abstract</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">ForEachOp</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
            <span class="kd">implements</span> <span class="n">TerminalOp</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">Void</span><span class="o">&gt;,</span> <span class="n">TerminalSink</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">Void</span><span class="o">&gt;</span> <span class="o">{</span>

        <span class="c1">// 标记是否顺序处理元素
</span><span class="c1"></span>        <span class="kd">private</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="n">ordered</span><span class="o">;</span>

        <span class="kd">protected</span> <span class="nf">ForEachOp</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">ordered</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">ordered</span> <span class="o">=</span> <span class="n">ordered</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// TerminalOp
</span><span class="c1"></span>        
        <span class="c1">// 终结操作节点的标志集合，如果ordered为true则返回0，否则返回StreamOpFlag.NOT_ORDERED，表示不支持顺序处理元素
</span><span class="c1"></span>        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getOpFlags</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">ordered</span> <span class="o">?</span> <span class="n">0</span> <span class="o">:</span> <span class="n">StreamOpFlag</span><span class="o">.</span><span class="na">NOT_ORDERED</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 同步遍历和处理元素
</span><span class="c1"></span>        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="n">Void</span> <span class="nf">evaluateSequential</span><span class="o">(</span><span class="n">PipelineHelper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">helper</span><span class="o">,</span>
                                           <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="n">spliterator</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 以当前的ForEachOp实例作为最后一个Sink添加到Sink链(也就是前面经常说的元素引用链)，然后对Sink链进行遍历
</span><span class="c1"></span>            <span class="k">return</span> <span class="n">helper</span><span class="o">.</span><span class="na">wrapAndCopyInto</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">spliterator</span><span class="o">).</span><span class="na">get</span><span class="o">();</span>
        <span class="o">}</span>
        
        <span class="c1">// 并发遍历和处理元素，这里暂不分析
</span><span class="c1"></span>        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="n">Void</span> <span class="nf">evaluateParallel</span><span class="o">(</span><span class="n">PipelineHelper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">helper</span><span class="o">,</span>
                                         <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="n">spliterator</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">ordered</span><span class="o">)</span>
                <span class="k">new</span> <span class="n">ForEachOrderedTask</span><span class="o">&lt;&gt;(</span><span class="n">helper</span><span class="o">,</span> <span class="n">spliterator</span><span class="o">,</span> <span class="k">this</span><span class="o">).</span><span class="na">invoke</span><span class="o">();</span>
            <span class="k">else</span>
                <span class="k">new</span> <span class="n">ForEachTask</span><span class="o">&lt;&gt;(</span><span class="n">helper</span><span class="o">,</span> <span class="n">spliterator</span><span class="o">,</span> <span class="n">helper</span><span class="o">.</span><span class="na">wrapSink</span><span class="o">(</span><span class="k">this</span><span class="o">)).</span><span class="na">invoke</span><span class="o">();</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// TerminalSink
</span><span class="c1"></span>         
        <span class="c1">// 实现TerminalSink的方法，实际上TerminalSink继承接口Supplier，这里是实现了Supplier接口的get()方法，由于PipelineHelper.wrapAndCopyInto()方法会返回最后一个Sink的引用，这里其实就是evaluateSequential()中的返回值
</span><span class="c1"></span>        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="n">Void</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// ForEachOp的静态内部类，引用类型的ForEachOp的最终实现，依赖入参遍历元素处理的最后一步回调Consumer实例
</span><span class="c1"></span>        <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">OfRef</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">ForEachOp</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>

            <span class="c1">// 最后的遍历回调的Consumer句柄
</span><span class="c1"></span>            <span class="kd">final</span> <span class="n">Consumer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">consumer</span><span class="o">;</span>

            <span class="n">OfRef</span><span class="o">(</span><span class="n">Consumer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">consumer</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">ordered</span><span class="o">)</span> <span class="o">{</span>
                <span class="kd">super</span><span class="o">(</span><span class="n">ordered</span><span class="o">);</span>
                <span class="k">this</span><span class="o">.</span><span class="na">consumer</span> <span class="o">=</span> <span class="n">consumer</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">accept</span><span class="o">(</span><span class="n">T</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 遍历元素回调操作
</span><span class="c1"></span>                <span class="n">consumer</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>forEach terminal operation implementation, itself this operation will not form part of the chain structure of the stream, that is, it is not a subclass instance of AbstractPipeline, but to build a callback Consumer instance operation of a Sink instance (TerminalSink to be exact) instance, here for the time being called forEach terminal sink, add the forEach terminal sink to the end of the Sink chain through the wrapSink() method of the last operation node of the stream, traverse the elements through the copyInto() method of the last operation node of the stream, and follow the set of copyInto() methods, as long as the multi-layer wrapped Sink method always activates the downstream premise when calling back its implementation method, the order of execution is the order of operation nodes defined by the stream chain structure, and the Consumer instance added at the end of the forEach must be the last one called back.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/08/108ac9e7df8d46c9a75ed132f04d1f04.png" alt=""></p>
<p>Moving on to the analysis of the implementation of the collect() method, let&rsquo;s first look at the definition of the Collector interface.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="c1">// T：需要进行reduce操作的输入元素类型
</span><span class="c1">// A：reduce操作中可变累加对象的类型，可以简单理解为累加操作中，累加到Container&lt;A&gt;中的可变对象类型
</span><span class="c1">// R：reduce操作结果类型
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Collector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">A</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="o">{</span>
    
    <span class="c1">// 注释中称为Container，用于承载最终结果的可变容器，而此方法的Supplier实例持有的是创建Container实例的get()方法实现，后面称为Supplier
</span><span class="c1"></span>    <span class="c1">// 也就是一般使用如：Supplier&lt;Container&gt; supplier = () -&gt; new Container();
</span><span class="c1"></span>    <span class="n">Supplier</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="nf">supplier</span><span class="o">();</span>

    <span class="c1">// Accumulator，翻译为累加器，用于处理值并且把处理结果传递(累加)到Container中，后面称为Accumulator
</span><span class="c1"></span>    <span class="n">BiConsumer</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="nf">accumulator</span><span class="o">();</span>
    
    <span class="c1">// Combiner，翻译为合并器，真实泛型类型为BinaryOperator&lt;A,A,A&gt;，BiFunction的子类，接收两个部分的结果并且合并为一个结果，后面称为Combiner
</span><span class="c1"></span>    <span class="c1">// 这个方法可以把一个参数的状态转移到另一个参数，然后返回更新状态后的参数，例如：(arg1, arg2) -&gt; {arg2.state = arg1.state; return arg2;}
</span><span class="c1"></span>    <span class="c1">// 可以把一个参数的状态转移到另一个参数，然后返回一个新的容器，例如：(arg1, arg2) -&gt; {arg2.state = arg1.state; return new Container(arg2);}
</span><span class="c1"></span>    <span class="n">BinaryOperator</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="nf">combiner</span><span class="o">();</span>
    
    <span class="c1">// Finisher，直接翻译感觉意义不合理，实际上就是做最后一步转换工作的处理器，后面称为Finisher
</span><span class="c1"></span>    <span class="n">Function</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="nf">finisher</span><span class="o">();</span>
    
    <span class="c1">// Collector支持的特性集合，见枚举Characteristics
</span><span class="c1"></span>    <span class="n">Set</span><span class="o">&lt;</span><span class="n">Characteristics</span><span class="o">&gt;</span> <span class="nf">characteristics</span><span class="o">();</span>

    <span class="c1">// 这里忽略两个Collector的静态工厂方法，因为并不常用
</span><span class="c1"></span>
    <span class="kd">enum</span> <span class="n">Characteristics</span> <span class="o">{</span>
        
        <span class="c1">// 标记Collector支持并发执行，一般和并发容器相关
</span><span class="c1"></span>        <span class="n">CONCURRENT</span><span class="o">,</span>
        
        <span class="c1">// 标记Collector处理元素时候无序
</span><span class="c1"></span>        <span class="n">UNORDERED</span><span class="o">,</span>
       
        <span class="c1">// 标记Collector的输入和输出元素是同类型，也就是Finisher在实现上R -&gt; A可以等效于A -&gt; R，unchecked cast会成功(也就是类型强转可以成功)
</span><span class="c1"></span>        <span class="c1">// 在这种场景下，对于Container来说其实类型强制转换也是等效的，也就是Supplier&lt;A&gt;和Supplier&lt;R&gt;得出的Container是同一种类型的Container
</span><span class="c1"></span>        <span class="n">IDENTITY_FINISH</span>
    <span class="o">}</span>    
<span class="o">}</span>

<span class="c1">// Collector的实现Collectors.CollectorImpl
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Collectors</span> <span class="o">{</span>
    
    <span class="c1">// 这一大堆常量就是预设的多种特性组合，CH_NOID比较特殊，是空集合，也就是Collector三种特性都不支持
</span><span class="c1"></span>    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">Collector</span><span class="o">.</span><span class="na">Characteristics</span><span class="o">&gt;</span> <span class="n">CH_CONCURRENT_ID</span>
            <span class="o">=</span> <span class="n">Collections</span><span class="o">.</span><span class="na">unmodifiableSet</span><span class="o">(</span><span class="n">EnumSet</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">Collector</span><span class="o">.</span><span class="na">Characteristics</span><span class="o">.</span><span class="na">CONCURRENT</span><span class="o">,</span>
                                                     <span class="n">Collector</span><span class="o">.</span><span class="na">Characteristics</span><span class="o">.</span><span class="na">UNORDERED</span><span class="o">,</span>
                                                     <span class="n">Collector</span><span class="o">.</span><span class="na">Characteristics</span><span class="o">.</span><span class="na">IDENTITY_FINISH</span><span class="o">));</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">Collector</span><span class="o">.</span><span class="na">Characteristics</span><span class="o">&gt;</span> <span class="n">CH_CONCURRENT_NOID</span>
            <span class="o">=</span> <span class="n">Collections</span><span class="o">.</span><span class="na">unmodifiableSet</span><span class="o">(</span><span class="n">EnumSet</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">Collector</span><span class="o">.</span><span class="na">Characteristics</span><span class="o">.</span><span class="na">CONCURRENT</span><span class="o">,</span>
                                                     <span class="n">Collector</span><span class="o">.</span><span class="na">Characteristics</span><span class="o">.</span><span class="na">UNORDERED</span><span class="o">));</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">Collector</span><span class="o">.</span><span class="na">Characteristics</span><span class="o">&gt;</span> <span class="n">CH_ID</span>
            <span class="o">=</span> <span class="n">Collections</span><span class="o">.</span><span class="na">unmodifiableSet</span><span class="o">(</span><span class="n">EnumSet</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">Collector</span><span class="o">.</span><span class="na">Characteristics</span><span class="o">.</span><span class="na">IDENTITY_FINISH</span><span class="o">));</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">Collector</span><span class="o">.</span><span class="na">Characteristics</span><span class="o">&gt;</span> <span class="n">CH_UNORDERED_ID</span>
            <span class="o">=</span> <span class="n">Collections</span><span class="o">.</span><span class="na">unmodifiableSet</span><span class="o">(</span><span class="n">EnumSet</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">Collector</span><span class="o">.</span><span class="na">Characteristics</span><span class="o">.</span><span class="na">UNORDERED</span><span class="o">,</span>
                                                     <span class="n">Collector</span><span class="o">.</span><span class="na">Characteristics</span><span class="o">.</span><span class="na">IDENTITY_FINISH</span><span class="o">));</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">Collector</span><span class="o">.</span><span class="na">Characteristics</span><span class="o">&gt;</span> <span class="n">CH_NOID</span> <span class="o">=</span> <span class="n">Collections</span><span class="o">.</span><span class="na">emptySet</span><span class="o">();</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">Collector</span><span class="o">.</span><span class="na">Characteristics</span><span class="o">&gt;</span> <span class="n">CH_UNORDERED_NOID</span>
            <span class="o">=</span> <span class="n">Collections</span><span class="o">.</span><span class="na">unmodifiableSet</span><span class="o">(</span><span class="n">EnumSet</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">Collector</span><span class="o">.</span><span class="na">Characteristics</span><span class="o">.</span><span class="na">UNORDERED</span><span class="o">));</span>

    <span class="kd">private</span> <span class="nf">Collectors</span><span class="o">()</span> <span class="o">{</span> <span class="o">}</span>

    <span class="c1">// 省略大量代码
</span><span class="c1"></span>
    <span class="c1">// 静态类，Collector的实现，实现其实就是Supplier、Accumulator、Combiner、Finisher和Characteristics集合的成员属性承载
</span><span class="c1"></span>    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">CollectorImpl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">A</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="n">Collector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">A</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="kd">final</span> <span class="n">Supplier</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">supplier</span><span class="o">;</span>
        <span class="kd">private</span> <span class="kd">final</span> <span class="n">BiConsumer</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">accumulator</span><span class="o">;</span>
        <span class="kd">private</span> <span class="kd">final</span> <span class="n">BinaryOperator</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">combiner</span><span class="o">;</span>
        <span class="kd">private</span> <span class="kd">final</span> <span class="n">Function</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="n">finisher</span><span class="o">;</span>
        <span class="kd">private</span> <span class="kd">final</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">Characteristics</span><span class="o">&gt;</span> <span class="n">characteristics</span><span class="o">;</span>

        <span class="n">CollectorImpl</span><span class="o">(</span><span class="n">Supplier</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">supplier</span><span class="o">,</span>
                      <span class="n">BiConsumer</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">accumulator</span><span class="o">,</span>
                      <span class="n">BinaryOperator</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">combiner</span><span class="o">,</span>
                      <span class="n">Function</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span><span class="n">R</span><span class="o">&gt;</span> <span class="n">finisher</span><span class="o">,</span>
                      <span class="n">Set</span><span class="o">&lt;</span><span class="n">Characteristics</span><span class="o">&gt;</span> <span class="n">characteristics</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">supplier</span> <span class="o">=</span> <span class="n">supplier</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">accumulator</span> <span class="o">=</span> <span class="n">accumulator</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">combiner</span> <span class="o">=</span> <span class="n">combiner</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">finisher</span> <span class="o">=</span> <span class="n">finisher</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">characteristics</span> <span class="o">=</span> <span class="n">characteristics</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="n">CollectorImpl</span><span class="o">(</span><span class="n">Supplier</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">supplier</span><span class="o">,</span>
                      <span class="n">BiConsumer</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">accumulator</span><span class="o">,</span>
                      <span class="n">BinaryOperator</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">combiner</span><span class="o">,</span>
                      <span class="n">Set</span><span class="o">&lt;</span><span class="n">Characteristics</span><span class="o">&gt;</span> <span class="n">characteristics</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">(</span><span class="n">supplier</span><span class="o">,</span> <span class="n">accumulator</span><span class="o">,</span> <span class="n">combiner</span><span class="o">,</span> <span class="n">castingIdentity</span><span class="o">(),</span> <span class="n">characteristics</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="n">BiConsumer</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="nf">accumulator</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">accumulator</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="n">Supplier</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="nf">supplier</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">supplier</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="n">BinaryOperator</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="nf">combiner</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">combiner</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="n">Function</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="nf">finisher</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">finisher</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">Characteristics</span><span class="o">&gt;</span> <span class="nf">characteristics</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">characteristics</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// 省略大量代码
</span><span class="c1"></span>
    <span class="c1">// IDENTITY_FINISH特性下，Finisher的实现，也就是之前提到的A-&gt;R和R-&gt;A等效，可以强转
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">I</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="n">Function</span><span class="o">&lt;</span><span class="n">I</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="nf">castingIdentity</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">R</span><span class="o">)</span> <span class="n">i</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 省略大量代码
</span><span class="c1"></span><span class="o">}</span>

</code></pre></td></tr></table>
</div>
</div><p>The execution portal for the collect() method is in the ReferencePipeline.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="c1">// ReferencePipeline
</span><span class="c1"></span><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">ReferencePipeline</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">,</span> <span class="n">P_OUT</span><span class="o">&gt;</span>
        <span class="kd">extends</span> <span class="n">AbstractPipeline</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">,</span> <span class="n">P_OUT</span><span class="o">,</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">P_OUT</span><span class="o">&gt;&gt;</span>
        <span class="kd">implements</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">P_OUT</span><span class="o">&gt;</span>  <span class="o">{</span>
    
    <span class="c1">// 暂时省略其他代码
</span><span class="c1"></span>
    <span class="c1">// 基于Collector实例进行求值
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kd">final</span> <span class="o">&lt;</span><span class="n">R</span><span class="o">,</span> <span class="n">A</span><span class="o">&gt;</span> <span class="n">R</span> <span class="nf">collect</span><span class="o">(</span><span class="n">Collector</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">P_OUT</span><span class="o">,</span> <span class="n">A</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="n">collector</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">A</span> <span class="n">container</span><span class="o">;</span>
        <span class="c1">// 并发求值场景暂不考虑
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">isParallel</span><span class="o">()</span>
                <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">collector</span><span class="o">.</span><span class="na">characteristics</span><span class="o">().</span><span class="na">contains</span><span class="o">(</span><span class="n">Collector</span><span class="o">.</span><span class="na">Characteristics</span><span class="o">.</span><span class="na">CONCURRENT</span><span class="o">))</span>
                <span class="o">&amp;&amp;</span> <span class="o">(!</span><span class="n">isOrdered</span><span class="o">()</span> <span class="o">||</span> <span class="n">collector</span><span class="o">.</span><span class="na">characteristics</span><span class="o">().</span><span class="na">contains</span><span class="o">(</span><span class="n">Collector</span><span class="o">.</span><span class="na">Characteristics</span><span class="o">.</span><span class="na">UNORDERED</span><span class="o">)))</span> <span class="o">{</span>
            <span class="n">container</span> <span class="o">=</span> <span class="n">collector</span><span class="o">.</span><span class="na">supplier</span><span class="o">().</span><span class="na">get</span><span class="o">();</span>
            <span class="n">BiConsumer</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="o">?</span> <span class="kd">super</span> <span class="n">P_OUT</span><span class="o">&gt;</span> <span class="n">accumulator</span> <span class="o">=</span> <span class="n">collector</span><span class="o">.</span><span class="na">accumulator</span><span class="o">();</span>
            <span class="n">forEach</span><span class="o">(</span><span class="n">u</span> <span class="o">-&gt;</span> <span class="n">accumulator</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">container</span><span class="o">,</span> <span class="n">u</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="c1">// 这里就是同步执行场景下的求值过程，这里可以看出其实所有Collector的求值都是Reduce操作
</span><span class="c1"></span>            <span class="n">container</span> <span class="o">=</span> <span class="n">evaluate</span><span class="o">(</span><span class="n">ReduceOps</span><span class="o">.</span><span class="na">makeRef</span><span class="o">(</span><span class="n">collector</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="c1">// 如果Collector的Finisher输入类型和输出类型相同，所以Supplier&lt;A&gt;和Supplier&lt;R&gt;得出的Container是同一种类型的Container，可以直接类型转换，否则就要调用Collector中的Finisher进行最后一步处理
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">collector</span><span class="o">.</span><span class="na">characteristics</span><span class="o">().</span><span class="na">contains</span><span class="o">(</span><span class="n">Collector</span><span class="o">.</span><span class="na">Characteristics</span><span class="o">.</span><span class="na">IDENTITY_FINISH</span><span class="o">)</span>
                <span class="o">?</span> <span class="o">(</span><span class="n">R</span><span class="o">)</span> <span class="n">container</span>
                <span class="o">:</span> <span class="n">collector</span><span class="o">.</span><span class="na">finisher</span><span class="o">().</span><span class="na">apply</span><span class="o">(</span><span class="n">container</span><span class="o">);</span>
    <span class="o">}</span>

     <span class="c1">// 暂时省略其他代码
</span><span class="c1"></span><span class="o">}</span>

<span class="c1">// ReduceOps
</span><span class="c1"></span><span class="kd">final</span> <span class="kd">class</span> <span class="nc">ReduceOps</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nf">ReduceOps</span><span class="o">()</span> <span class="o">{</span> <span class="o">}</span>

    <span class="c1">// 暂时省略其他代码
</span><span class="c1"></span>    
    <span class="c1">// 引用类型Reduce操作创建TerminalOp实例
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">I</span><span class="o">&gt;</span> <span class="n">TerminalOp</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">I</span><span class="o">&gt;</span>
    <span class="nf">makeRef</span><span class="o">(</span><span class="n">Collector</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">,</span> <span class="n">I</span><span class="o">,</span> <span class="o">?&gt;</span> <span class="n">collector</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Supplier
</span><span class="c1"></span>        <span class="n">Supplier</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span> <span class="n">supplier</span> <span class="o">=</span> <span class="n">Objects</span><span class="o">.</span><span class="na">requireNonNull</span><span class="o">(</span><span class="n">collector</span><span class="o">).</span><span class="na">supplier</span><span class="o">();</span>
        <span class="c1">// Accumulator
</span><span class="c1"></span>        <span class="n">BiConsumer</span><span class="o">&lt;</span><span class="n">I</span><span class="o">,</span> <span class="o">?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">accumulator</span> <span class="o">=</span> <span class="n">collector</span><span class="o">.</span><span class="na">accumulator</span><span class="o">();</span>
        <span class="c1">// Combiner
</span><span class="c1"></span>        <span class="n">BinaryOperator</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span> <span class="n">combiner</span> <span class="o">=</span> <span class="n">collector</span><span class="o">.</span><span class="na">combiner</span><span class="o">();</span>

        <span class="c1">// 这里注意一点，ReducingSink是方法makeRef中的内部类，作用域只在方法内，它是封装为TerminalOp最终转化为Sink链中最后一个Sink实例的类型
</span><span class="c1"></span>        <span class="kd">class</span> <span class="nc">ReducingSink</span> <span class="kd">extends</span> <span class="n">Box</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span>
                <span class="kd">implements</span> <span class="n">AccumulatingSink</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">I</span><span class="o">,</span> <span class="n">ReducingSink</span><span class="o">&gt;</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">begin</span><span class="o">(</span><span class="kt">long</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 这里把从Supplier创建的新Container实例存放在父类Box的状态属性中
</span><span class="c1"></span>                <span class="n">state</span> <span class="o">=</span> <span class="n">supplier</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
            <span class="o">}</span>

            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">accept</span><span class="o">(</span><span class="n">T</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 处理元素，Accumulator处理状态(容器实例)和元素，这里可以想象，如果state为一个ArrayList实例，这里的accept()实现可能为add(ele)操作
</span><span class="c1"></span>                <span class="n">accumulator</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">state</span><span class="o">,</span> <span class="n">t</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">combine</span><span class="o">(</span><span class="n">ReducingSink</span> <span class="n">other</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Combiner合并两个状态(容器实例)
</span><span class="c1"></span>                <span class="n">state</span> <span class="o">=</span> <span class="n">combiner</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">state</span><span class="o">,</span> <span class="n">other</span><span class="o">.</span><span class="na">state</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">ReduceOp</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">I</span><span class="o">,</span> <span class="n">ReducingSink</span><span class="o">&gt;(</span><span class="n">StreamShape</span><span class="o">.</span><span class="na">REFERENCE</span><span class="o">)</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="n">ReducingSink</span> <span class="nf">makeSink</span><span class="o">()</span> <span class="o">{</span>
                <span class="k">return</span> <span class="k">new</span> <span class="n">ReducingSink</span><span class="o">();</span>
            <span class="o">}</span>

            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getOpFlags</span><span class="o">()</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">collector</span><span class="o">.</span><span class="na">characteristics</span><span class="o">().</span><span class="na">contains</span><span class="o">(</span><span class="n">Collector</span><span class="o">.</span><span class="na">Characteristics</span><span class="o">.</span><span class="na">UNORDERED</span><span class="o">)</span>
                       <span class="o">?</span> <span class="n">StreamOpFlag</span><span class="o">.</span><span class="na">NOT_ORDERED</span>
                       <span class="o">:</span> <span class="n">0</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">};</span>
    <span class="o">}</span>

    <span class="c1">// 暂时省略其他代码
</span><span class="c1"></span>
    <span class="c1">// 继承自接口TerminalSink，主要添加了combine()抽象方法，用于合并元素
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">interface</span> <span class="nc">AccumulatingSink</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">R</span><span class="o">,</span> <span class="n">K</span> <span class="kd">extends</span> <span class="n">AccumulatingSink</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">R</span><span class="o">,</span> <span class="n">K</span><span class="o">&gt;&gt;</span>
            <span class="kd">extends</span> <span class="n">TerminalSink</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="kt">void</span> <span class="nf">combine</span><span class="o">(</span><span class="n">K</span> <span class="n">other</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="c1">// 状态盒，用于持有和获取状态，状态属性的修饰符为default，包内的类实例都能修改
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">abstract</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Box</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="n">U</span> <span class="n">state</span><span class="o">;</span>

        <span class="n">Box</span><span class="o">()</span> <span class="o">{}</span> <span class="c1">// Avoid creation of special accessor
</span><span class="c1"></span>
        <span class="kd">public</span> <span class="n">U</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">state</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// ReduceOp的最终实现，这个就是Reduce操作终结操作的实现
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">abstract</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">ReduceOp</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">R</span><span class="o">,</span> <span class="n">S</span> <span class="kd">extends</span> <span class="n">AccumulatingSink</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">R</span><span class="o">,</span> <span class="n">S</span><span class="o">&gt;&gt;</span>
            <span class="kd">implements</span> <span class="n">TerminalOp</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="o">{</span>

        <span class="c1">// 流输入元素&#34;形状&#34;
</span><span class="c1"></span>        <span class="kd">private</span> <span class="kd">final</span> <span class="n">StreamShape</span> <span class="n">inputShape</span><span class="o">;</span>

        <span class="n">ReduceOp</span><span class="o">(</span><span class="n">StreamShape</span> <span class="n">shape</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">inputShape</span> <span class="o">=</span> <span class="n">shape</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="c1">// 抽象方法，让子类生成终结操作的Sink
</span><span class="c1"></span>        <span class="kd">public</span> <span class="kd">abstract</span> <span class="n">S</span> <span class="nf">makeSink</span><span class="o">();</span>
        
        <span class="c1">// 获取流输入元素&#34;形状&#34;
</span><span class="c1"></span>        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="n">StreamShape</span> <span class="nf">inputShape</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">inputShape</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="c1">// 同步执行求值，还是相似的思路，使用wrapAndCopyInto()进行Sink链构建和元素遍历
</span><span class="c1"></span>        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="n">R</span> <span class="nf">evaluateSequential</span><span class="o">(</span><span class="n">PipelineHelper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">helper</span><span class="o">,</span>
                                           <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="n">spliterator</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 以当前的ReduceOp实例的makeSink()返回的Sink实例作为最后一个Sink添加到Sink链(也就是前面经常说的元素引用链)，然后对Sink链进行遍历
</span><span class="c1"></span>            <span class="c1">// 这里向上一步一步推演思考，最终get()方法执行完毕拿到的结果就是ReducingSink父类Box中的state变量，也就是容器实例
</span><span class="c1"></span>            <span class="k">return</span> <span class="n">helper</span><span class="o">.</span><span class="na">wrapAndCopyInto</span><span class="o">(</span><span class="n">makeSink</span><span class="o">(),</span> <span class="n">spliterator</span><span class="o">).</span><span class="na">get</span><span class="o">();</span>
        <span class="o">}</span> 
        
        <span class="c1">// 异步执行求值，暂时忽略
</span><span class="c1"></span>        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="n">R</span> <span class="nf">evaluateParallel</span><span class="o">(</span><span class="n">PipelineHelper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">helper</span><span class="o">,</span>
                                         <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="n">spliterator</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="n">ReduceTask</span><span class="o">&lt;&gt;(</span><span class="k">this</span><span class="o">,</span> <span class="n">helper</span><span class="o">,</span> <span class="n">spliterator</span><span class="o">).</span><span class="na">invoke</span><span class="o">().</span><span class="na">get</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// 暂时省略其他代码
</span><span class="c1"></span><span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Then look at the static factory method of Collector to see how some common Collector instances are built, for example, look at Collectors.toList().</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="c1">// Supplier =&gt; () -&gt; new ArrayList&lt;T&gt;();  // 初始化ArrayList
</span><span class="c1">// Accumulator =&gt; (list,number) -&gt; list.add(number);  // 往ArrayList中添加元素
</span><span class="c1">// Combiner =&gt;  (left, right) -&gt; { left.addAll(right); return left;}  // 合并ArrayList
</span><span class="c1">// Finisher =&gt; X -&gt; X;  // 输入什么就返回什么，这里实际返回的是ArrayList
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="n">Collector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="o">?,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="nf">toList</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">CollectorImpl</span><span class="o">&lt;&gt;((</span><span class="n">Supplier</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;)</span> <span class="n">ArrayList</span><span class="o">::</span><span class="k">new</span><span class="o">,</span> <span class="n">List</span><span class="o">::</span><span class="n">add</span><span class="o">,</span>
                                <span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="n">left</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">right</span><span class="o">);</span> <span class="k">return</span> <span class="n">left</span><span class="o">;</span> <span class="o">},</span>
                                <span class="n">CH_ID</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Draw the process as a flow chart as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/08/acc3b98f810c47f78448ac57f54e0d48.png" alt=""></p>
<p>Even more colloquially, the execution of a Terminal Op like Collector can be represented in pseudo-code (still using Collectors.toList() as an example).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="o">[</span><span class="n">begin</span><span class="o">]</span>
<span class="n">Supplier</span> <span class="n">supplier</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;();</span>
<span class="n">Container</span> <span class="n">container</span> <span class="o">=</span> <span class="n">supplier</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
<span class="n">Box</span><span class="o">.</span><span class="na">state</span> <span class="o">=</span> <span class="n">container</span><span class="o">;</span>

<span class="o">[</span><span class="n">accept</span><span class="o">]</span>
<span class="n">Box</span><span class="o">.</span><span class="na">state</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">element</span><span class="o">);</span>

<span class="o">[</span><span class="n">end</span><span class="o">]</span>
<span class="k">return</span> <span class="n">supplier</span><span class="o">.</span><span class="na">get</span><span class="o">();</span> <span class="o">(=&gt;</span> <span class="k">return</span> <span class="n">Box</span><span class="o">.</span><span class="na">state</span><span class="o">);</span>

<span class="err">↓↓↓↓↓↓↓↓↓</span><span class="n">甚至更加通俗的过程如下</span><span class="err">↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span>

<span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">container</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;();</span>
<span class="nl">loop:</span>
  <span class="n">container</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">element</span><span class="o">)</span>
<span class="k">return</span> <span class="n">container</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><p>That is, although the engineered code looks complex, the final implementation is simple: initialize the ArrayList instance held by the state property, traversing the processing of elements when the elements are added to the state, and finally return to the state. finally look at the method implementation of toArray () (the following method code is not posted in accordance with the actual location, the author put the fragmented code blocks together to facilitate analysis).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span><span class="lnt">222
</span><span class="lnt">223
</span><span class="lnt">224
</span><span class="lnt">225
</span><span class="lnt">226
</span><span class="lnt">227
</span><span class="lnt">228
</span><span class="lnt">229
</span><span class="lnt">230
</span><span class="lnt">231
</span><span class="lnt">232
</span><span class="lnt">233
</span><span class="lnt">234
</span><span class="lnt">235
</span><span class="lnt">236
</span><span class="lnt">237
</span><span class="lnt">238
</span><span class="lnt">239
</span><span class="lnt">240
</span><span class="lnt">241
</span><span class="lnt">242
</span><span class="lnt">243
</span><span class="lnt">244
</span><span class="lnt">245
</span><span class="lnt">246
</span><span class="lnt">247
</span><span class="lnt">248
</span><span class="lnt">249
</span><span class="lnt">250
</span><span class="lnt">251
</span><span class="lnt">252
</span><span class="lnt">253
</span><span class="lnt">254
</span><span class="lnt">255
</span><span class="lnt">256
</span><span class="lnt">257
</span><span class="lnt">258
</span><span class="lnt">259
</span><span class="lnt">260
</span><span class="lnt">261
</span><span class="lnt">262
</span><span class="lnt">263
</span><span class="lnt">264
</span><span class="lnt">265
</span><span class="lnt">266
</span><span class="lnt">267
</span><span class="lnt">268
</span><span class="lnt">269
</span><span class="lnt">270
</span><span class="lnt">271
</span><span class="lnt">272
</span><span class="lnt">273
</span><span class="lnt">274
</span><span class="lnt">275
</span><span class="lnt">276
</span><span class="lnt">277
</span><span class="lnt">278
</span><span class="lnt">279
</span><span class="lnt">280
</span><span class="lnt">281
</span><span class="lnt">282
</span><span class="lnt">283
</span><span class="lnt">284
</span><span class="lnt">285
</span><span class="lnt">286
</span><span class="lnt">287
</span><span class="lnt">288
</span><span class="lnt">289
</span><span class="lnt">290
</span><span class="lnt">291
</span><span class="lnt">292
</span><span class="lnt">293
</span><span class="lnt">294
</span><span class="lnt">295
</span><span class="lnt">296
</span><span class="lnt">297
</span><span class="lnt">298
</span><span class="lnt">299
</span><span class="lnt">300
</span><span class="lnt">301
</span><span class="lnt">302
</span><span class="lnt">303
</span><span class="lnt">304
</span><span class="lnt">305
</span><span class="lnt">306
</span><span class="lnt">307
</span><span class="lnt">308
</span><span class="lnt">309
</span><span class="lnt">310
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">ReferencePipeline</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">,</span> <span class="n">P_OUT</span><span class="o">&gt;</span>
        <span class="kd">extends</span> <span class="n">AbstractPipeline</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">,</span> <span class="n">P_OUT</span><span class="o">,</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">P_OUT</span><span class="o">&gt;&gt;</span>
        <span class="kd">implements</span> <span class="n">Stream</span><span class="o">&lt;</span><span class="n">P_OUT</span><span class="o">&gt;</span>  <span class="o">{</span>

    <span class="c1">// 暂时省略其他代码
</span><span class="c1"></span>    
    <span class="c1">// 流的所有元素转换为数组，这里的IntFunction有一种比较特殊的用法，就是用于创建数组实例
</span><span class="c1"></span>    <span class="c1">// 例如IntFunction&lt;String[]&gt; f = String::new; String[] arry = f.apply(2);  相当于String[] arry = new String[2];
</span><span class="c1"></span>    <span class="nd">@Override</span>
    <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">&#34;unchecked&#34;</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">A</span><span class="o">[]</span> <span class="nf">toArray</span><span class="o">(</span><span class="n">IntFunction</span><span class="o">&lt;</span><span class="n">A</span><span class="o">[]&gt;</span> <span class="n">generator</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="c1">// 这里主动擦除了IntFunction的类型，只要保证求值的过程是正确，最终可以做类型强转
</span><span class="c1"></span>        <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">&#34;rawtypes&#34;</span><span class="o">)</span>
        <span class="n">IntFunction</span> <span class="n">rawGenerator</span> <span class="o">=</span> <span class="o">(</span><span class="n">IntFunction</span><span class="o">)</span> <span class="n">generator</span><span class="o">;</span>
        <span class="c1">// 委托到evaluateToArrayNode()方法进行计算
</span><span class="c1"></span>        <span class="k">return</span> <span class="o">(</span><span class="n">A</span><span class="o">[])</span> <span class="n">Nodes</span><span class="o">.</span><span class="na">flatten</span><span class="o">(</span><span class="n">evaluateToArrayNode</span><span class="o">(</span><span class="n">rawGenerator</span><span class="o">),</span> <span class="n">rawGenerator</span><span class="o">)</span>
                              <span class="o">.</span><span class="na">asArray</span><span class="o">(</span><span class="n">rawGenerator</span><span class="o">);</span>
    <span class="o">}</span>    
    
    <span class="c1">// 流的所有元素转换为Object数组
</span><span class="c1"></span>    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="n">Object</span><span class="o">[]</span> <span class="nf">toArray</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">toArray</span><span class="o">(</span><span class="n">Object</span><span class="o">[]::</span><span class="k">new</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 流元素求值转换为ArrayNode
</span><span class="c1"></span>    <span class="kd">final</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">&gt;</span> <span class="nf">evaluateToArrayNode</span><span class="o">(</span><span class="n">IntFunction</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">[]&gt;</span> <span class="n">generator</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 确保不会处理多次
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">linkedOrConsumed</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="o">(</span><span class="n">MSG_STREAM_LINKED</span><span class="o">);</span>
        <span class="n">linkedOrConsumed</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="c1">// 并发执行暂时跳过
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">isParallel</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">previousStage</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">opIsStateful</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">depth</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
            <span class="k">return</span> <span class="n">opEvaluateParallel</span><span class="o">(</span><span class="n">previousStage</span><span class="o">,</span> <span class="n">previousStage</span><span class="o">.</span><span class="na">sourceSpliterator</span><span class="o">(</span><span class="n">0</span><span class="o">),</span> <span class="n">generator</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">evaluate</span><span class="o">(</span><span class="n">sourceSpliterator</span><span class="o">(</span><span class="n">0</span><span class="o">),</span> <span class="kc">true</span><span class="o">,</span> <span class="n">generator</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="c1">// 最终的转换Node的方法
</span><span class="c1"></span>    <span class="kd">final</span> <span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">&gt;</span> <span class="nf">evaluate</span><span class="o">(</span><span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">P_IN</span><span class="o">&gt;</span> <span class="n">spliterator</span><span class="o">,</span>
                                      <span class="kt">boolean</span> <span class="n">flatten</span><span class="o">,</span>
                                      <span class="n">IntFunction</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">[]&gt;</span> <span class="n">generator</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 并发执行暂时跳过
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">isParallel</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// @@@ Optimize if op of this pipeline stage is a stateful op
</span><span class="c1"></span>            <span class="k">return</span> <span class="n">evaluateToNode</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">spliterator</span><span class="o">,</span> <span class="n">flatten</span><span class="o">,</span> <span class="n">generator</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="c1">// 兜兜转换还是回到了wrapAndCopyInto()方法，遍历Sink链，所以基本可以得知Node.Builder是Sink的一个实现
</span><span class="c1"></span>            <span class="n">Node</span><span class="o">.</span><span class="na">Builder</span><span class="o">&lt;</span><span class="n">E_OUT</span><span class="o">&gt;</span> <span class="n">nb</span> <span class="o">=</span> <span class="n">makeNodeBuilder</span><span class="o">(</span>
                    <span class="n">exactOutputSizeIfKnown</span><span class="o">(</span><span class="n">spliterator</span><span class="o">),</span> <span class="n">generator</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">wrapAndCopyInto</span><span class="o">(</span><span class="n">nb</span><span class="o">,</span> <span class="n">spliterator</span><span class="o">).</span><span class="na">build</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="c1">// 获取Node的建造器实例
</span><span class="c1"></span>    <span class="kd">final</span> <span class="n">Node</span><span class="o">.</span><span class="na">Builder</span><span class="o">&lt;</span><span class="n">P_OUT</span><span class="o">&gt;</span> <span class="nf">makeNodeBuilder</span><span class="o">(</span><span class="kt">long</span> <span class="n">exactSizeIfKnown</span><span class="o">,</span> <span class="n">IntFunction</span><span class="o">&lt;</span><span class="n">P_OUT</span><span class="o">[]&gt;</span> <span class="n">generator</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">Nodes</span><span class="o">.</span><span class="na">builder</span><span class="o">(</span><span class="n">exactSizeIfKnown</span><span class="o">,</span> <span class="n">generator</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 暂时省略其他代码
</span><span class="c1"></span><span class="o">}</span>

<span class="c1">// Node接口定义
</span><span class="c1"></span><span class="kd">interface</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    
    <span class="c1">// 获取待处理的元素封装成的Spliterator实例
</span><span class="c1"></span>    <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">spliterator</span><span class="o">();</span>
    
    <span class="c1">// 遍历当前Node实例中所有待处理的元素，回调到Consumer实例中
</span><span class="c1"></span>    <span class="kt">void</span> <span class="nf">forEach</span><span class="o">(</span><span class="n">Consumer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">consumer</span><span class="o">);</span>

    <span class="c1">// 获取当前Node实例的所有子Node的个数
</span><span class="c1"></span>    <span class="k">default</span> <span class="kt">int</span> <span class="nf">getChildCount</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 获取当前Node实例的子Node实例，入参i是子Node的索引
</span><span class="c1"></span>    <span class="k">default</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">getChild</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">IndexOutOfBoundsException</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="c1">// 分割当前Node实例的一个部分，生成一个新的sub Node，类似于ArrayList中的subList方法
</span><span class="c1"></span>    <span class="k">default</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">truncate</span><span class="o">(</span><span class="kt">long</span> <span class="n">from</span><span class="o">,</span> <span class="kt">long</span> <span class="n">to</span><span class="o">,</span> <span class="n">IntFunction</span><span class="o">&lt;</span><span class="n">T</span><span class="o">[]&gt;</span> <span class="n">generator</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">from</span> <span class="o">==</span> <span class="n">0</span> <span class="o">&amp;&amp;</span> <span class="n">to</span> <span class="o">==</span> <span class="n">count</span><span class="o">())</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
        <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">spliterator</span> <span class="o">=</span> <span class="n">spliterator</span><span class="o">();</span>
        <span class="kt">long</span> <span class="n">size</span> <span class="o">=</span> <span class="n">to</span> <span class="o">-</span> <span class="n">from</span><span class="o">;</span>
        <span class="n">Node</span><span class="o">.</span><span class="na">Builder</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">nodeBuilder</span> <span class="o">=</span> <span class="n">Nodes</span><span class="o">.</span><span class="na">builder</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">generator</span><span class="o">);</span>
        <span class="n">nodeBuilder</span><span class="o">.</span><span class="na">begin</span><span class="o">(</span><span class="n">size</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">from</span> <span class="o">&amp;&amp;</span> <span class="n">spliterator</span><span class="o">.</span><span class="na">tryAdvance</span><span class="o">(</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="o">});</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span> <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">to</span> <span class="o">==</span> <span class="n">count</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">spliterator</span><span class="o">.</span><span class="na">forEachRemaining</span><span class="o">(</span><span class="n">nodeBuilder</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="o">&amp;&amp;</span> <span class="n">spliterator</span><span class="o">.</span><span class="na">tryAdvance</span><span class="o">(</span><span class="n">nodeBuilder</span><span class="o">);</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span> <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">nodeBuilder</span><span class="o">.</span><span class="na">end</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">nodeBuilder</span><span class="o">.</span><span class="na">build</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="c1">// 创建一个包含当前Node实例所有元素的元素数组视图
</span><span class="c1"></span>    <span class="n">T</span><span class="o">[]</span> <span class="nf">asArray</span><span class="o">(</span><span class="n">IntFunction</span><span class="o">&lt;</span><span class="n">T</span><span class="o">[]&gt;</span> <span class="n">generator</span><span class="o">);</span>
    
    <span class="c1">//
</span><span class="c1"></span>    <span class="kt">void</span> <span class="nf">copyInto</span><span class="o">(</span><span class="n">T</span><span class="o">[]</span> <span class="n">array</span><span class="o">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="o">);</span>
    
    <span class="c1">// 返回Node实例基于Stream的元素&#34;形状&#34;
</span><span class="c1"></span>    <span class="k">default</span> <span class="n">StreamShape</span> <span class="nf">getShape</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">StreamShape</span><span class="o">.</span><span class="na">REFERENCE</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 获取当前Node实例包含的元素个数
</span><span class="c1"></span>    <span class="kt">long</span> <span class="nf">count</span><span class="o">();</span>

<span class="c1">// Node建造器，注意这个Node.Builder接口是继承自Sink，那么其子类实现都可以添加到Sink链中作为一个节点(终结节点)
</span><span class="c1"></span><span class="kd">interface</span> <span class="nc">Builder</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">Sink</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>

        <span class="c1">// 创建Node实例
</span><span class="c1"></span>        <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">build</span><span class="o">();</span>

        <span class="c1">// 基于Integer元素类型的特化类型Node.Builder
</span><span class="c1"></span>        <span class="kd">interface</span> <span class="nc">OfInt</span> <span class="kd">extends</span> <span class="n">Node</span><span class="o">.</span><span class="na">Builder</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;,</span> <span class="n">Sink</span><span class="o">.</span><span class="na">OfInt</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="n">Node</span><span class="o">.</span><span class="na">OfInt</span> <span class="nf">build</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="c1">// 基于Long元素类型的特化类型Node.Builder
</span><span class="c1"></span>        <span class="kd">interface</span> <span class="nc">OfLong</span> <span class="kd">extends</span> <span class="n">Node</span><span class="o">.</span><span class="na">Builder</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;,</span> <span class="n">Sink</span><span class="o">.</span><span class="na">OfLong</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="n">Node</span><span class="o">.</span><span class="na">OfLong</span> <span class="nf">build</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="c1">// 基于Double元素类型的特化类型Node.Builder
</span><span class="c1"></span>        <span class="kd">interface</span> <span class="nc">OfDouble</span> <span class="kd">extends</span> <span class="n">Node</span><span class="o">.</span><span class="na">Builder</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">&gt;,</span> <span class="n">Sink</span><span class="o">.</span><span class="na">OfDouble</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="n">Node</span><span class="o">.</span><span class="na">OfDouble</span> <span class="nf">build</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

     <span class="c1">// 暂时省略其他代码
</span><span class="c1"></span><span class="o">}</span>


<span class="c1">// 这里下面的方法来源于Nodes类
</span><span class="c1"></span><span class="kd">final</span> <span class="kd">class</span> <span class="nc">Nodes</span> <span class="o">{</span>

    <span class="c1">// 暂时省略其他代码
</span><span class="c1"></span>   
    <span class="c1">// Node扁平化处理，如果传入的Node实例存在子Node实例，则使用fork-join对Node进行分割和并发计算，结果添加到IntFunction生成的数组中，如果不存在子Node，直接返回传入的Node实例
</span><span class="c1"></span>    <span class="c1">// 关于并发计算部分暂时不分析
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">flatten</span><span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">node</span><span class="o">,</span> <span class="n">IntFunction</span><span class="o">&lt;</span><span class="n">T</span><span class="o">[]&gt;</span> <span class="n">generator</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">getChildCount</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">long</span> <span class="n">size</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">count</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">MAX_ARRAY_SIZE</span><span class="o">)</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="n">BAD_SIZE</span><span class="o">);</span>
            <span class="n">T</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="n">generator</span><span class="o">.</span><span class="na">apply</span><span class="o">((</span><span class="kt">int</span><span class="o">)</span> <span class="n">size</span><span class="o">);</span>
            <span class="k">new</span> <span class="n">ToArrayTask</span><span class="o">.</span><span class="na">OfRef</span><span class="o">&lt;&gt;(</span><span class="n">node</span><span class="o">,</span> <span class="n">array</span><span class="o">,</span> <span class="n">0</span><span class="o">).</span><span class="na">invoke</span><span class="o">();</span>
            <span class="k">return</span> <span class="n">node</span><span class="o">(</span><span class="n">array</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="c1">// 创建Node的建造器实例
</span><span class="c1"></span>    <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">.</span><span class="na">Builder</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">builder</span><span class="o">(</span><span class="kt">long</span> <span class="n">exactSizeIfKnown</span><span class="o">,</span> <span class="n">IntFunction</span><span class="o">&lt;</span><span class="n">T</span><span class="o">[]&gt;</span> <span class="n">generator</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 当知道待处理元素的准确数量并且小于允许创建的数组的最大长度MAX_ARRAY_SIZE(Integer.MAX_VALUE - 8)，使用FixedNodeBuilder(固定长度数组Node建造器)，否则使用SpinedNodeBuilder实例
</span><span class="c1"></span>        <span class="k">return</span> <span class="o">(</span><span class="n">exactSizeIfKnown</span> <span class="o">&gt;=</span> <span class="n">0</span> <span class="o">&amp;&amp;</span> <span class="n">exactSizeIfKnown</span> <span class="o">&lt;</span> <span class="n">MAX_ARRAY_SIZE</span><span class="o">)</span>
               <span class="o">?</span> <span class="k">new</span> <span class="n">FixedNodeBuilder</span><span class="o">&lt;&gt;(</span><span class="n">exactSizeIfKnown</span><span class="o">,</span> <span class="n">generator</span><span class="o">)</span>
               <span class="o">:</span> <span class="n">builder</span><span class="o">();</span>
    <span class="o">}</span> 

    <span class="c1">// 创建Node的建造器实例，使用SpinedNodeBuilder的实例，此SpinedNode支持元素添加，但是不支持元素移除
</span><span class="c1"></span>    <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Node</span><span class="o">.</span><span class="na">Builder</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">builder</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">SpinedNodeBuilder</span><span class="o">&lt;&gt;();</span>
    <span class="o">}</span>
    
    <span class="c1">// 固定长度固定长度数组Node实现(也就是最终的Node实现是一个ArrayNode，最终的容器为一个T类型元素的数组T[])
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">FixedNodeBuilder</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
            <span class="kd">extends</span> <span class="n">ArrayNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
            <span class="kd">implements</span> <span class="n">Node</span><span class="o">.</span><span class="na">Builder</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>

        <span class="c1">// 基于size(元素个数，或者说创建数组的长度)和数组创建方法IntFunction构建FixedNodeBuilder实例
</span><span class="c1"></span>        <span class="n">FixedNodeBuilder</span><span class="o">(</span><span class="kt">long</span> <span class="n">size</span><span class="o">,</span> <span class="n">IntFunction</span><span class="o">&lt;</span><span class="n">T</span><span class="o">[]&gt;</span> <span class="n">generator</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">super</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">generator</span><span class="o">);</span>
            <span class="k">assert</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="n">MAX_ARRAY_SIZE</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="c1">// 返回当前FixedNodeBuilder实例，判断数组元素计数值curSize必须大于等于实际数组容器中元素的个数
</span><span class="c1"></span>        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">build</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">curSize</span> <span class="o">&lt;</span> <span class="n">array</span><span class="o">.</span><span class="na">length</span><span class="o">)</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">&#34;Current size %d is less than fixed size %d&#34;</span><span class="o">,</span>
                                                              <span class="n">curSize</span><span class="o">,</span> <span class="n">array</span><span class="o">.</span><span class="na">length</span><span class="o">));</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="c1">// Sink的begin方法回调，传入的size必须和数组长度相等，因为后面的accept()方法会执行size此
</span><span class="c1"></span>        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">begin</span><span class="o">(</span><span class="kt">long</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">size</span> <span class="o">!=</span> <span class="n">array</span><span class="o">.</span><span class="na">length</span><span class="o">)</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">&#34;Begin size %d is not equal to fixed size %d&#34;</span><span class="o">,</span>
                                                            <span class="n">size</span><span class="o">,</span> <span class="n">array</span><span class="o">.</span><span class="na">length</span><span class="o">));</span>
            <span class="c1">// 重置数组元素计数值为0
</span><span class="c1"></span>            <span class="n">curSize</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="c1">// Sink的accept方法回调，当数组元素计数值小于数组长度，直接向数组下标curSize++添加传入的元素
</span><span class="c1"></span>        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">accept</span><span class="o">(</span><span class="n">T</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">curSize</span> <span class="o">&lt;</span> <span class="n">array</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">array</span><span class="o">[</span><span class="n">curSize</span><span class="o">++]</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">&#34;Accept exceeded fixed size of %d&#34;</span><span class="o">,</span>
                                                              <span class="n">array</span><span class="o">.</span><span class="na">length</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="c1">// Sink的end方法回调，再次判断数组元素计数值curSize必须大于等于实际数组容器中元素的个数
</span><span class="c1"></span>        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">end</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">curSize</span> <span class="o">&lt;</span> <span class="n">array</span><span class="o">.</span><span class="na">length</span><span class="o">)</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">&#34;End size %d is less than fixed size %d&#34;</span><span class="o">,</span>
                                                              <span class="n">curSize</span><span class="o">,</span> <span class="n">array</span><span class="o">.</span><span class="na">length</span><span class="o">));</span>
        <span class="o">}</span>
        
        <span class="c1">// 返回FixedNodeBuilder当前信息，当前处理的下标和当前数组中所有的元素
</span><span class="c1"></span>        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">&#34;FixedNodeBuilder[%d][%s]&#34;</span><span class="o">,</span>
                                 <span class="n">array</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">curSize</span><span class="o">,</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">array</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// Node实现，容器为一个固定长度的数组
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">ArrayNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>

        <span class="c1">// 数组容器
</span><span class="c1"></span>        <span class="kd">final</span> <span class="n">T</span><span class="o">[]</span> <span class="n">array</span><span class="o">;</span>

        <span class="c1">// 数组容器中当前元素的个数，这个值是一个固定值，或者在FixedNodeBuilder的accept()方法回调中递增
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">curSize</span><span class="o">;</span>
        
        <span class="c1">// 基于size和数组创建的工厂IntFunction构建ArrayNode实例
</span><span class="c1"></span>        <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">&#34;unchecked&#34;</span><span class="o">)</span>
        <span class="n">ArrayNode</span><span class="o">(</span><span class="kt">long</span> <span class="n">size</span><span class="o">,</span> <span class="n">IntFunction</span><span class="o">&lt;</span><span class="n">T</span><span class="o">[]&gt;</span> <span class="n">generator</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">MAX_ARRAY_SIZE</span><span class="o">)</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="n">BAD_SIZE</span><span class="o">);</span>
            <span class="c1">// 创建szie长度的数组容器
</span><span class="c1"></span>            <span class="k">this</span><span class="o">.</span><span class="na">array</span> <span class="o">=</span> <span class="n">generator</span><span class="o">.</span><span class="na">apply</span><span class="o">((</span><span class="kt">int</span><span class="o">)</span> <span class="n">size</span><span class="o">);</span>
            <span class="k">this</span><span class="o">.</span><span class="na">curSize</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="c1">// 这个方法是基于一个现成的数组创建ArrayNode实例，直接改变数组的引用为array，元素个数curSize置为输入参数长度
</span><span class="c1"></span>        <span class="n">ArrayNode</span><span class="o">(</span><span class="n">T</span><span class="o">[]</span> <span class="n">array</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">array</span> <span class="o">=</span> <span class="n">array</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">curSize</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Node - 接下来是Node接口的实现
</span><span class="c1"></span>        
        <span class="c1">// 基于数组实例，起始索引0和结束索引curSize构造一个全新的Spliterator实例
</span><span class="c1"></span>        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">spliterator</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">spliterator</span><span class="o">(</span><span class="n">array</span><span class="o">,</span> <span class="n">0</span><span class="o">,</span> <span class="n">curSize</span><span class="o">);</span>
        <span class="o">}</span>
        
        <span class="c1">// 拷贝array中的元素到外部传入的dest数组中
</span><span class="c1"></span>        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">copyInto</span><span class="o">(</span><span class="n">T</span><span class="o">[]</span> <span class="n">dest</span><span class="o">,</span> <span class="kt">int</span> <span class="n">destOffset</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">array</span><span class="o">,</span> <span class="n">0</span><span class="o">,</span> <span class="n">dest</span><span class="o">,</span> <span class="n">destOffset</span><span class="o">,</span> <span class="n">curSize</span><span class="o">);</span>
        <span class="o">}</span>
        
        <span class="c1">// 返回元素数组视图，这里直接返回array引用
</span><span class="c1"></span>        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="n">T</span><span class="o">[]</span> <span class="nf">asArray</span><span class="o">(</span><span class="n">IntFunction</span><span class="o">&lt;</span><span class="n">T</span><span class="o">[]&gt;</span> <span class="n">generator</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">array</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="n">curSize</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">array</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="c1">// 获取array中的元素个数
</span><span class="c1"></span>        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">long</span> <span class="nf">count</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">curSize</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="c1">// 遍历array，每个元素回调Consumer实例
</span><span class="c1"></span>        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">forEach</span><span class="o">(</span><span class="n">Consumer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">consumer</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">curSize</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">consumer</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// 返回ArrayNode当前信息，当前处理的下标和当前数组中所有的元素
</span><span class="c1"></span>        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">&#34;ArrayNode[%d][%s]&#34;</span><span class="o">,</span>
                                 <span class="n">array</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">curSize</span><span class="o">,</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">array</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// 暂时省略其他代码
</span><span class="c1"></span><span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>In fact, the final implementation of Node is in many cases Nodes.SpinedNodeBuilder, because SpinedNodeBuilder is a heavy implementation of the array expansion and Spliterator based on the array partitioning method, the source code is relatively complex (especially the spliterator() method). relatively complex (especially the spliterator () method), here to pick part of the analysis, as SpinedNodeBuilder most of the methods are used in the parent class SpinedBuffer implementation, here you can directly analyze the SpinedBuffer.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="c1">// SpinedBuffer的当前数组在超过了元素数量阈值之后，会拆分为多个数组块，存储到spine中，而curChunk引用指向的是当前处理的数组块
</span><span class="c1"></span><span class="kd">class</span> <span class="nc">SpinedBuffer</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span>
        <span class="kd">extends</span> <span class="n">AbstractSpinedBuffer</span>
        <span class="kd">implements</span> <span class="n">Consumer</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;,</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="c1">// 暂时省略其他代码
</span><span class="c1"></span>    
    <span class="c1">// 当前的数组块
</span><span class="c1"></span>    <span class="kd">protected</span> <span class="n">E</span><span class="o">[]</span> <span class="n">curChunk</span><span class="o">;</span>
    
    <span class="c1">// 所有数组块
</span><span class="c1"></span>    <span class="kd">protected</span> <span class="n">E</span><span class="o">[][]</span> <span class="n">spine</span><span class="o">;</span>
    
    <span class="c1">// 构造函数，指定初始化容量
</span><span class="c1"></span>    <span class="n">SpinedBuffer</span><span class="o">(</span><span class="kt">int</span> <span class="n">initialCapacity</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">initialCapacity</span><span class="o">);</span>
        <span class="n">curChunk</span> <span class="o">=</span> <span class="o">(</span><span class="n">E</span><span class="o">[])</span> <span class="k">new</span> <span class="n">Object</span><span class="o">[</span><span class="n">1</span> <span class="o">&lt;&lt;</span> <span class="n">initialChunkPower</span><span class="o">];</span>
    <span class="o">}</span>

     <span class="c1">// 构造函数，指定默认初始化容量
</span><span class="c1"></span>    <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">&#34;unchecked&#34;</span><span class="o">)</span>
    <span class="n">SpinedBuffer</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">();</span>
        <span class="n">curChunk</span> <span class="o">=</span> <span class="o">(</span><span class="n">E</span><span class="o">[])</span> <span class="k">new</span> <span class="n">Object</span><span class="o">[</span><span class="n">1</span> <span class="o">&lt;&lt;</span> <span class="n">initialChunkPower</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="c1">// 拷贝当前SpinedBuffer中的数组元素到传入的数组实例
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">copyInto</span><span class="o">(</span><span class="n">E</span><span class="o">[]</span> <span class="n">array</span><span class="o">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 计算最终的offset，区分单个chunk和多个chunk的情况
</span><span class="c1"></span>        <span class="kt">long</span> <span class="n">finalOffset</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">count</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">finalOffset</span> <span class="o">&gt;</span> <span class="n">array</span><span class="o">.</span><span class="na">length</span> <span class="o">||</span> <span class="n">finalOffset</span> <span class="o">&lt;</span> <span class="n">offset</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">IndexOutOfBoundsException</span><span class="o">(</span><span class="s">&#34;does not fit&#34;</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">// 单个chunk的情况，由curChunk最接拷贝
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">spineIndex</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span>
            <span class="n">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">curChunk</span><span class="o">,</span> <span class="n">0</span><span class="o">,</span> <span class="n">array</span><span class="o">,</span> <span class="n">offset</span><span class="o">,</span> <span class="n">elementIndex</span><span class="o">);</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="c1">// 多个chunk的情况，由遍历spine并且对每个chunk进行拷贝
</span><span class="c1"></span>            <span class="c1">// full chunks
</span><span class="c1"></span>            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">spineIndex</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">spine</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">0</span><span class="o">,</span> <span class="n">array</span><span class="o">,</span> <span class="n">offset</span><span class="o">,</span> <span class="n">spine</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">length</span><span class="o">);</span>
                <span class="n">offset</span> <span class="o">+=</span> <span class="n">spine</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">elementIndex</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span>
                <span class="n">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">curChunk</span><span class="o">,</span> <span class="n">0</span><span class="o">,</span> <span class="n">array</span><span class="o">,</span> <span class="n">offset</span><span class="o">,</span> <span class="n">elementIndex</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="c1">// 返回数组元素视图，基于IntFunction构建数组实例，使用copyInto()方法进行元素拷贝
</span><span class="c1"></span>    <span class="kd">public</span> <span class="n">E</span><span class="o">[]</span> <span class="nf">asArray</span><span class="o">(</span><span class="n">IntFunction</span><span class="o">&lt;</span><span class="n">E</span><span class="o">[]&gt;</span> <span class="n">arrayFactory</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">size</span> <span class="o">=</span> <span class="n">count</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">Nodes</span><span class="o">.</span><span class="na">MAX_ARRAY_SIZE</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="n">Nodes</span><span class="o">.</span><span class="na">BAD_SIZE</span><span class="o">);</span>
        <span class="n">E</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="n">arrayFactory</span><span class="o">.</span><span class="na">apply</span><span class="o">((</span><span class="kt">int</span><span class="o">)</span> <span class="n">size</span><span class="o">);</span>
        <span class="n">copyInto</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">0</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="c1">// 清空SpinedBuffer，清空分块元素和所有引用
</span><span class="c1"></span>    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">clear</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">spine</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">curChunk</span> <span class="o">=</span> <span class="n">spine</span><span class="o">[</span><span class="n">0</span><span class="o">];</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">curChunk</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
                <span class="n">curChunk</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="n">spine</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="n">priorElementCount</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">elementIndex</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
                <span class="n">curChunk</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">elementIndex</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="n">spineIndex</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
    <span class="o">}</span>
      
    <span class="c1">// 遍历元素回调Consumer，分别遍历spine和curChunk
</span><span class="c1"></span>    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">forEach</span><span class="o">(</span><span class="n">Consumer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">E</span><span class="o">&gt;</span> <span class="n">consumer</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// completed chunks, if any
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">spineIndex</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span>
            <span class="k">for</span> <span class="o">(</span><span class="n">E</span> <span class="n">t</span> <span class="o">:</span> <span class="n">spine</span><span class="o">[</span><span class="n">j</span><span class="o">])</span>
                <span class="n">consumer</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>

        <span class="c1">// current chunk
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">elementIndex</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
            <span class="n">consumer</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">curChunk</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
    <span class="o">}</span>
    
    <span class="c1">// Consumer的accept实现，最终会作为Sink接口的accept方法调用
</span><span class="c1"></span>    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">accept</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 如果当前分块(第一个)的元素已经满了，就初始化spine，然后元素添加到spine[0]中
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">elementIndex</span> <span class="o">==</span> <span class="n">curChunk</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">inflateSpine</span><span class="o">();</span>
            <span class="c1">// 然后元素添加到spine[0]中的元素已经满了，就新增spine[n]，把元素放进spine[n]中
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">spineIndex</span><span class="o">+</span><span class="n">1</span> <span class="o">&gt;=</span> <span class="n">spine</span><span class="o">.</span><span class="na">length</span> <span class="o">||</span> <span class="n">spine</span><span class="o">[</span><span class="n">spineIndex</span><span class="o">+</span><span class="n">1</span><span class="o">]</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                <span class="n">increaseCapacity</span><span class="o">();</span>
            <span class="n">elementIndex</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
            <span class="o">++</span><span class="n">spineIndex</span><span class="o">;</span>
            <span class="c1">// 当前的chunk更新为最新的chunk，就是spine中的最新一个chunk
</span><span class="c1"></span>            <span class="n">curChunk</span> <span class="o">=</span> <span class="n">spine</span><span class="o">[</span><span class="n">spineIndex</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="c1">// 当前的curChunk添加元素
</span><span class="c1"></span>        <span class="n">curChunk</span><span class="o">[</span><span class="n">elementIndex</span><span class="o">++]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 暂时省略其他代码
</span><span class="c1"></span><span class="o">}</span>

</code></pre></td></tr></table>
</div>
</div><p>The source code has been basically analyzed, and the following is still translated into a flow chart using an example.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/08/5189d9db783140fe956232442ceec3a9.png" alt=""></p>
<h2 id="source-code-implementation-of-stream-concurrent-execution">Source code implementation of stream concurrent execution</h2>
<p>If the stream instance calls parallel(), the annotation mentions that it will return a variant that performs the stream asynchronously. In fact, no variant is constructed, but only sourceStage.parallel is marked as true, and the basic process of asynchronous solving is that the process of constructing the stream pipeline structure is the same as that of synchronous solving, and after constructing the Sink chain Spliterator will use a specific algorithm based on trySplit() to perform self-partitioning, the self-partitioning algorithm is determined by the specific subclass, for example ArrayList uses the dichotomy method, after the partitioning is completed each Spliterator holds a small portion of all the elements, then each Spliterator as sourceSpliterator in the fork-join thread pool to execute the Sink chain, get the results of multiple parts in the current call thread aggregation, to get the final result. The techniques used here are thread closure and fork-join, and since the concurrency of different Terminal Op&rsquo;s is similar, we only analyze the implementation of forEach concurrent execution here. First, we show a simple example of using a fork-join thread pool.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MapReduceApp</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 数组中每个元素*2，再求和
</span><span class="c1"></span>        <span class="n">Integer</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MapReducer</span><span class="o">&lt;&gt;(</span><span class="k">new</span> <span class="n">Integer</span><span class="o">[]{</span><span class="n">1</span><span class="o">,</span> <span class="n">2</span><span class="o">,</span> <span class="n">3</span><span class="o">,</span> <span class="n">4</span><span class="o">},</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">2</span><span class="o">,</span> <span class="n">Integer</span><span class="o">::</span><span class="n">sum</span><span class="o">).</span><span class="na">invoke</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">interface</span> <span class="nc">Mapper</span><span class="o">&lt;</span><span class="n">S</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>

        <span class="n">T</span> <span class="nf">apply</span><span class="o">(</span><span class="n">S</span> <span class="n">source</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">interface</span> <span class="nc">Reducer</span><span class="o">&lt;</span><span class="n">S</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>

        <span class="n">T</span> <span class="nf">apply</span><span class="o">(</span><span class="n">S</span> <span class="n">first</span><span class="o">,</span> <span class="n">S</span> <span class="n">second</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">MapReducer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">CountedCompleter</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>

        <span class="kd">final</span> <span class="n">T</span><span class="o">[]</span> <span class="n">array</span><span class="o">;</span>

        <span class="kd">final</span> <span class="n">Mapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">mapper</span><span class="o">;</span>

        <span class="kd">final</span> <span class="n">Reducer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">reducer</span><span class="o">;</span>

        <span class="kd">final</span> <span class="kt">int</span> <span class="n">lo</span><span class="o">,</span> <span class="n">hi</span><span class="o">;</span>

        <span class="n">MapReducer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">sibling</span><span class="o">;</span>

        <span class="n">T</span> <span class="n">result</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">MapReducer</span><span class="o">(</span><span class="n">T</span><span class="o">[]</span> <span class="n">array</span><span class="o">,</span>
                          <span class="n">Mapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">mapper</span><span class="o">,</span>
                          <span class="n">Reducer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">reducer</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">array</span> <span class="o">=</span> <span class="n">array</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">mapper</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">reducer</span> <span class="o">=</span> <span class="n">reducer</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">lo</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">hi</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="nf">MapReducer</span><span class="o">(</span><span class="n">CountedCompleter</span><span class="o">&lt;?&gt;</span> <span class="n">p</span><span class="o">,</span>
                          <span class="n">T</span><span class="o">[]</span> <span class="n">array</span><span class="o">,</span>
                          <span class="n">Mapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">mapper</span><span class="o">,</span>
                          <span class="n">Reducer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">reducer</span><span class="o">,</span>
                          <span class="kt">int</span> <span class="n">lo</span><span class="o">,</span>
                          <span class="kt">int</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">super</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
            <span class="k">this</span><span class="o">.</span><span class="na">array</span> <span class="o">=</span> <span class="n">array</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">mapper</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">reducer</span> <span class="o">=</span> <span class="n">reducer</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">lo</span> <span class="o">=</span> <span class="n">lo</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">hi</span> <span class="o">=</span> <span class="n">hi</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">compute</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">hi</span> <span class="o">-</span> <span class="n">lo</span> <span class="o">&gt;=</span> <span class="n">2</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">lo</span> <span class="o">+</span> <span class="n">hi</span><span class="o">)</span> <span class="o">&gt;&gt;</span> <span class="n">1</span><span class="o">;</span>
                <span class="n">MapReducer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">left</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MapReducer</span><span class="o">&lt;&gt;(</span><span class="k">this</span><span class="o">,</span> <span class="n">array</span><span class="o">,</span> <span class="n">mapper</span><span class="o">,</span> <span class="n">reducer</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">mid</span><span class="o">);</span>
                <span class="n">MapReducer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">right</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MapReducer</span><span class="o">&lt;&gt;(</span><span class="k">this</span><span class="o">,</span> <span class="n">array</span><span class="o">,</span> <span class="n">mapper</span><span class="o">,</span> <span class="n">reducer</span><span class="o">,</span> <span class="n">mid</span><span class="o">,</span> <span class="n">hi</span><span class="o">);</span>
                <span class="n">left</span><span class="o">.</span><span class="na">sibling</span> <span class="o">=</span> <span class="n">right</span><span class="o">;</span>
                <span class="n">right</span><span class="o">.</span><span class="na">sibling</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span>
                <span class="c1">// 创建子任务父任务的pending计数器加1
</span><span class="c1"></span>                <span class="n">setPendingCount</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
                <span class="c1">// 提交右子任务
</span><span class="c1"></span>                <span class="n">right</span><span class="o">.</span><span class="na">fork</span><span class="o">();</span>
                <span class="c1">// 在当前线程计算左子任务
</span><span class="c1"></span>                <span class="n">left</span><span class="o">.</span><span class="na">compute</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">hi</span> <span class="o">&gt;</span> <span class="n">lo</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="n">lo</span><span class="o">]);</span>
                <span class="o">}</span>
                <span class="c1">// 叶子节点完成，尝试合并其他兄弟节点的结果，会调用onCompletion方法
</span><span class="c1"></span>                <span class="n">tryComplete</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="n">T</span> <span class="nf">getRawResult</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">&#34;unchecked&#34;</span><span class="o">)</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onCompletion</span><span class="o">(</span><span class="n">CountedCompleter</span><span class="o">&lt;?&gt;</span> <span class="n">caller</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">caller</span> <span class="o">!=</span> <span class="k">this</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">MapReducer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">child</span> <span class="o">=</span> <span class="o">(</span><span class="n">MapReducer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;)</span> <span class="n">caller</span><span class="o">;</span>
                <span class="n">MapReducer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">sib</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="na">sibling</span><span class="o">;</span>
                <span class="c1">// 合并子任务结果，只有两个子任务
</span><span class="c1"></span>                <span class="k">if</span> <span class="o">(</span><span class="n">Objects</span><span class="o">.</span><span class="na">isNull</span><span class="o">(</span><span class="n">sib</span><span class="o">)</span> <span class="o">||</span> <span class="n">Objects</span><span class="o">.</span><span class="na">isNull</span><span class="o">(</span><span class="n">sib</span><span class="o">.</span><span class="na">result</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="na">result</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">reducer</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">child</span><span class="o">.</span><span class="na">result</span><span class="o">,</span> <span class="n">sib</span><span class="o">.</span><span class="na">result</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></td></tr></table>
</div>
</div><p>Here a simple MapReduce application is written using fork-join. The main method runs the process of mapping all the elements in the array [1,2,3,4] to i -&gt; i * 2 first, and then reducing (summation), the code also simply uses the dichotomy to split the original array. When the final task contains only one element, i.e. lo &lt; hi and hi - lo == 1, Mapper&rsquo;s method will be called based on a single element to notify tryComplete() of completion, and the task completion will eventually notify the onCompletion() method, in which the Reducer is the aggregation operation of the result. The process is similar for concurrent value seeking in streams, where ForEachOp eventually calls ForEachOrderedTask or ForEachTask, and here ForEachTask is selected for analysis.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">abstract</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">ForEachOp</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
        <span class="kd">implements</span> <span class="n">TerminalOp</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">Void</span><span class="o">&gt;,</span> <span class="n">TerminalSink</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">Void</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="c1">// 暂时省略其他代码
</span><span class="c1"></span>    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="n">Void</span> <span class="nf">evaluateParallel</span><span class="o">(</span><span class="n">PipelineHelper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">helper</span><span class="o">,</span>
                                        <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="n">spliterator</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">ordered</span><span class="o">)</span>
            <span class="k">new</span> <span class="n">ForEachOrderedTask</span><span class="o">&lt;&gt;(</span><span class="n">helper</span><span class="o">,</span> <span class="n">spliterator</span><span class="o">,</span> <span class="k">this</span><span class="o">).</span><span class="na">invoke</span><span class="o">();</span>
        <span class="k">else</span>
            <span class="c1">// 最终是调用ForEachTask的invoke方法，invoke会阻塞到所有fork任务执行完，获取最终的结果
</span><span class="c1"></span>            <span class="k">new</span> <span class="n">ForEachTask</span><span class="o">&lt;&gt;(</span><span class="n">helper</span><span class="o">,</span> <span class="n">spliterator</span><span class="o">,</span> <span class="n">helper</span><span class="o">.</span><span class="na">wrapSink</span><span class="o">(</span><span class="k">this</span><span class="o">)).</span><span class="na">invoke</span><span class="o">();</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// 暂时省略其他代码
</span><span class="c1"></span><span class="o">}</span>

<span class="c1">// ForEachOps类
</span><span class="c1"></span><span class="kd">final</span> <span class="kd">class</span> <span class="nc">ForEachOps</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nf">ForEachOps</span><span class="o">()</span> <span class="o">{</span> <span class="o">}</span>
    
    <span class="c1">// forEach的fork-join任务实现，没有覆盖getRawResult()方法，最终只会返回NULL
</span><span class="c1"></span>    <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">ForEachTask</span><span class="o">&lt;</span><span class="n">S</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">CountedCompleter</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span> <span class="o">{</span>

        <span class="c1">// Spliterator实例，如果是父任务则代表所有待处理的元素，如果是子任务则是一个分割后的新Spliterator实例
</span><span class="c1"></span>        <span class="kd">private</span> <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="n">spliterator</span><span class="o">;</span>

        <span class="c1">// Sink链实例
</span><span class="c1"></span>        <span class="kd">private</span> <span class="kd">final</span> <span class="n">Sink</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="n">sink</span><span class="o">;</span>

        <span class="c1">// 流管道引用
</span><span class="c1"></span>        <span class="kd">private</span> <span class="kd">final</span> <span class="n">PipelineHelper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">helper</span><span class="o">;</span>

        <span class="c1">// 目标数量，其实是每个任务处理元素数量的建议值
</span><span class="c1"></span>        <span class="kd">private</span> <span class="kt">long</span> <span class="n">targetSize</span><span class="o">;</span>
        
        <span class="c1">// 这个构造器是提供给父(根)任务
</span><span class="c1"></span>        <span class="n">ForEachTask</span><span class="o">(</span><span class="n">PipelineHelper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">helper</span><span class="o">,</span>
                    <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="n">spliterator</span><span class="o">,</span>
                    <span class="n">Sink</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="n">sink</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">super</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
            <span class="k">this</span><span class="o">.</span><span class="na">sink</span> <span class="o">=</span> <span class="n">sink</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">helper</span> <span class="o">=</span> <span class="n">helper</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">spliterator</span> <span class="o">=</span> <span class="n">spliterator</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">targetSize</span> <span class="o">=</span> <span class="n">0L</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="c1">// 这个构造器是提供给子任务，所以需要父任务的引用和一个分割后的新Spliterator实例作为参数
</span><span class="c1"></span>        <span class="n">ForEachTask</span><span class="o">(</span><span class="n">ForEachTask</span><span class="o">&lt;</span><span class="n">S</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">parent</span><span class="o">,</span> <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="n">spliterator</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">super</span><span class="o">(</span><span class="n">parent</span><span class="o">);</span>
            <span class="k">this</span><span class="o">.</span><span class="na">spliterator</span> <span class="o">=</span> <span class="n">spliterator</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">sink</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="na">sink</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">targetSize</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="na">targetSize</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">helper</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="na">helper</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Similar to AbstractTask but doesn&#39;t need to track child tasks
</span><span class="c1"></span>        <span class="c1">// 实现compute方法，用于分割Spliterator成多个子任务，这里不需要跟踪所有子任务
</span><span class="c1"></span>        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">compute</span><span class="o">()</span> <span class="o">{</span>
            <span class="c1">// 神奇的赋值，相当于Spliterator&lt;S&gt; rightSplit = spliterator; Spliterator&lt;S&gt; leftSplit;
</span><span class="c1"></span>            <span class="c1">// rightSplit总是指向当前的spliterator实例
</span><span class="c1"></span>            <span class="n">Spliterator</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="n">rightSplit</span> <span class="o">=</span> <span class="n">spliterator</span><span class="o">,</span> <span class="n">leftSplit</span><span class="o">;</span>
            <span class="c1">// 这里也是神奇的赋值，相当于long sizeEstimate = rightSplit.estimateSize(); long sizeThreshold;
</span><span class="c1"></span>            <span class="kt">long</span> <span class="n">sizeEstimate</span> <span class="o">=</span> <span class="n">rightSplit</span><span class="o">.</span><span class="na">estimateSize</span><span class="o">(),</span> <span class="n">sizeThreshold</span><span class="o">;</span>
            <span class="c1">// sizeThreshold赋值为targetSize
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">((</span><span class="n">sizeThreshold</span> <span class="o">=</span> <span class="n">targetSize</span><span class="o">)</span> <span class="o">==</span> <span class="n">0L</span><span class="o">)</span>
                <span class="c1">// 基于Spliterator分割后的右分支实例的元素数量重新赋值sizeThreshold和targetSize
</span><span class="c1"></span>                <span class="c1">// 计算方式是待处理元素数量/(fork-join线程池并行度&lt;&lt;2)或者1(当前一个计算方式结果为0的时候)
</span><span class="c1"></span>                <span class="n">targetSize</span> <span class="o">=</span> <span class="n">sizeThreshold</span> <span class="o">=</span> <span class="n">AbstractTask</span><span class="o">.</span><span class="na">suggestTargetSize</span><span class="o">(</span><span class="n">sizeEstimate</span><span class="o">);</span>
            <span class="c1">// 当前的流是否支持SHORT_CIRCUIT，也就是短路特性
</span><span class="c1"></span>            <span class="kt">boolean</span> <span class="n">isShortCircuit</span> <span class="o">=</span> <span class="n">StreamOpFlag</span><span class="o">.</span><span class="na">SHORT_CIRCUIT</span><span class="o">.</span><span class="na">isKnown</span><span class="o">(</span><span class="n">helper</span><span class="o">.</span><span class="na">getStreamAndOpFlags</span><span class="o">());</span>
            <span class="c1">// 当前的任务是否fork右分支
</span><span class="c1"></span>            <span class="kt">boolean</span> <span class="n">forkRight</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="c1">// taskSink作为Sink的临时变量
</span><span class="c1"></span>            <span class="n">Sink</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="n">taskSink</span> <span class="o">=</span> <span class="n">sink</span><span class="o">;</span>
            <span class="c1">// 当前任务的临时变量
</span><span class="c1"></span>            <span class="n">ForEachTask</span><span class="o">&lt;</span><span class="n">S</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">task</span> <span class="o">=</span> <span class="k">this</span><span class="o">;</span>
            <span class="c1">// Spliterator分割和创建新的fork任务ForEachTask，前提是不支持短路或者Sink不支持取消
</span><span class="c1"></span>            <span class="k">while</span> <span class="o">(!</span><span class="n">isShortCircuit</span> <span class="o">||</span> <span class="o">!</span><span class="n">taskSink</span><span class="o">.</span><span class="na">cancellationRequested</span><span class="o">())</span> <span class="o">{</span>
                <span class="c1">// 当前的任务中的Spliterator(rightSplit)中的待处理元素小于等于每个任务应该处理的元素阈值或者再分割后得到NULL，则不需要再分割，直接基于rightSplit和Sink链执行循环处理元素
</span><span class="c1"></span>                <span class="k">if</span> <span class="o">(</span><span class="n">sizeEstimate</span> <span class="o">&lt;=</span> <span class="n">sizeThreshold</span> <span class="o">||</span> <span class="o">(</span><span class="n">leftSplit</span> <span class="o">=</span> <span class="n">rightSplit</span><span class="o">.</span><span class="na">trySplit</span><span class="o">())</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// 这里就是遍历rightSplit元素回调Sink链的操作
</span><span class="c1"></span>                    <span class="n">task</span><span class="o">.</span><span class="na">helper</span><span class="o">.</span><span class="na">copyInto</span><span class="o">(</span><span class="n">taskSink</span><span class="o">,</span> <span class="n">rightSplit</span><span class="o">);</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="c1">// rightSplit还能分割，则基于分割后的leftSplit和以当前任务作为父任务创建一个新的fork任务
</span><span class="c1"></span>                <span class="n">ForEachTask</span><span class="o">&lt;</span><span class="n">S</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">leftTask</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ForEachTask</span><span class="o">&lt;&gt;(</span><span class="n">task</span><span class="o">,</span> <span class="n">leftSplit</span><span class="o">);</span>
                <span class="c1">// 待处理子任务加1
</span><span class="c1"></span>                <span class="n">task</span><span class="o">.</span><span class="na">addToPendingCount</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
                <span class="c1">// 需要fork的任务实例临时变量
</span><span class="c1"></span>                <span class="n">ForEachTask</span><span class="o">&lt;</span><span class="n">S</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">taskToFork</span><span class="o">;</span>
                <span class="c1">// 因为rightSplit总是分割Spliterator后对应原来的Spliterator引用，而leftSplit总是trySplit()后生成的新的Spliterator
</span><span class="c1"></span>                <span class="c1">// 所以这里leftSplit也需要作为rightSplit进行分割，通俗来说就是周星驰007那把梅花间足发射的枪
</span><span class="c1"></span>                <span class="k">if</span> <span class="o">(</span><span class="n">forkRight</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// 这里交换leftSplit为rightSplit，所以forkRight设置为false，下一轮循环相当于fork left
</span><span class="c1"></span>                    <span class="n">forkRight</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                    <span class="n">rightSplit</span> <span class="o">=</span> <span class="n">leftSplit</span><span class="o">;</span>
                    <span class="n">taskToFork</span> <span class="o">=</span> <span class="n">task</span><span class="o">;</span>
                    <span class="c1">// 赋值下一轮的父Task为当前的fork task
</span><span class="c1"></span>                    <span class="n">task</span> <span class="o">=</span> <span class="n">leftTask</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">else</span> <span class="o">{</span>
                    <span class="n">forkRight</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                    <span class="n">taskToFork</span> <span class="o">=</span> <span class="n">leftTask</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="c1">// 添加fork任务到任务队列中
</span><span class="c1"></span>                <span class="n">taskToFork</span><span class="o">.</span><span class="na">fork</span><span class="o">();</span>
                <span class="c1">// 其实这里是更新剩余待分割的Spliterator中的所有元素数量到sizeEstimate
</span><span class="c1"></span>                <span class="n">sizeEstimate</span> <span class="o">=</span> <span class="n">rightSplit</span><span class="o">.</span><span class="na">estimateSize</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="c1">// 置空spliterator实例并且传播任务完成状态，等待所有任务执行完成
</span><span class="c1"></span>            <span class="n">task</span><span class="o">.</span><span class="na">spliterator</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="n">task</span><span class="o">.</span><span class="na">propagateCompletion</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></td></tr></table>
</div>
</div><p>The source code analysis above may seem difficult to understand, so here is a simple example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">2</span><span class="o">);</span>
    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">3</span><span class="o">);</span>
    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">4</span><span class="o">);</span>
    <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">parallel</span><span class="o">().</span><span class="na">forEach</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>This code is finally converted into ForEachTask in the evaluation of the targetSize = sizeThreshold == 1, the current calling thread will participate in the calculation, will perform 3 forks, that is, a total of 4 processing process instances (that is, the original Spliterator instance will eventually split out of 3 brand new Spliterator instances, plus itself a 4 Spliterator instances), each processing process instances only deal with 1 element, the corresponding flow chart is as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/08/547596e9210a42dbbd10d2da27f3a957.png" alt=""></p>
<p>The final result is obtained by calling CountedCompleter.invoke() method, this method will block until all subtasks are processed, of course, forEach end operation does not need to return value, so there is no getRawResult() method, here just to block until all tasks are executed before lifting the calling thread This is just to block until all tasks are executed before releasing the calling thread from the blocking state.</p>
<h2 id="state-operation-and-short-circuit-operation">State operation and short-circuit operation</h2>
<p>Stream can be divided into stateless operations and stateful operations according to whether the intermediate operations have state or not, and into non-short-circuit operations and short-circuit operations according to whether the end operations support the short-circuit feature. The understanding is as follows.</p>
<ul>
<li>Stateless operation: After the current operation node finishes processing the element, the result is passed directly to the next operation node if the preconditions are met, that is, there is no state inside the operation and no need to save state, such as filter, map, etc.</li>
<li>Stateful operations: when processing elements, depending on the internal state of the node to accumulate elements, when processing a new element, in fact, you can sense the history of all the elements processed, this &ldquo;state&rdquo; is actually more like the concept of the buffer, such as sort, limit and other operations, to sort operations, for example, is generally to add all the elements to be processed to a container such as ArrayList, and then sort all the elements, and then re-simulate Spliterator to push the elements to the next node</li>
<li>Non-short-circuiting (terminating) operations: terminating operations cannot interrupt processing early and return based on short-circuiting conditions when processing elements, i.e., all elements must be processed, such as forEach</li>
<li>Short-circuit (end) operation: the end operation allows the processing of elements based on the short-circuit condition in advance to interrupt the processing and return, but the final implementation is possible to traverse all the elements, but in the processing method based on the preceding short-circuit condition to skip the actual processing, such as anyMatch (in fact, anyMatch will traverse all the elements, but in the hit the short-circuit condition (actually anyMatch will traverse all the elements, but when the short-circuit condition is hit, the element will call back the Sink.accept() method to skip the actual processing based on the stop short-circuit flag)</li>
</ul>
<p>Without expanding the source code here for analysis, just show a summary table of frequently seen Stream operations as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/08/744a2c23b5f644a78cd04ee14eaa9149.png" alt=""></p>
<p>Two other points to note here.</p>
<ul>
<li>From the source code, some of the intermediate operations also support short-circuiting, such as slice and while-related operations</li>
<li>From the source code findFirst and findAny are supported and judged by StreamOpFlag.SHORT_CIRCUIT, while match-related end operations are short-circuited by the internal temporary state stop and value.</li>
</ul>
<h2 id="summary">Summary</h2>
<p>Before and after writing more than 100,000 words, in fact, only a relatively shallow introduction to the basic implementation of Stream, the author believes that many did not analyze the implementation of intermediate and final operations, especially the concurrent implementation of the final operation is very complex, multi-threaded environment requires some imagination and multiple DEBUG positioning execution location and deduce the process of implementation. A brief summary.</p>
<ul>
<li>The Stream implementation in the JDK is refined and highly engineered code</li>
<li>Although the carrier of Stream is AbstractPipeline, the pipeline structure, but only its shape, the actual value of the operation will be transformed into a multi-layer wrapped Sink structure, that is, the previous article has been said Sink chain, from the programming model, the application of the Reactor programming model</li>
<li>The inherent execution structure supported by Stream must be Head(Source Spliterator) -&gt; Op -&gt; Op &hellip; -&gt; Terminal Op form, which is a limitation, there is no way to do as LINQ can be flexible to achieve similar memory view functionality</li>
<li>Stream currently supports concurrent value solution is for Source Spliterator to split, encapsulate Terminal Op and fixed Sink chain construction of ForkJoinTask for concurrent computation, the calling thread and fork-join thread pool in the work thread can participate in the value process, the author believes that this part is the most complex implementation of Stream in addition to those sign collection bit operation</li>
<li>Stream implementation is a breakthrough, some people have said that this feature is a &ldquo;premature child&rdquo;, here I hope that the JDK can be in the contradiction spiral forward and development</li>
</ul>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/java/">java</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2021-10/heapbytebuffer-notes/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Notes on using HeapByteBuffer for in-heap memory</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2021-10/yarn-and-npm/">
            <span class="next-text nav-default">Talking about package managers yarn and npm</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
