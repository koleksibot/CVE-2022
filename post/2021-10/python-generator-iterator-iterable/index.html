<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Python Iterators and Generators - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="We all know that in Python we can for loop to iterate through a list, tuple or range object. So what is the underlying principle? In understanding Python&amp;rsquo;s data structures, containers (container), iterable objects (iterator), iterators (iterator), generators (generator), lists/sets/dictionary comprehensions (list, set, dict comprehension), and many other concepts are mixed together to make beginners confused. The relationship between them. container A container is a data structure that organizes multiple" /><meta name="keywords" content="Python, Iterators, Generators" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2021-10/python-generator-iterator-iterable/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Python Iterators and Generators" />
<meta property="og:description" content="We all know that in Python we can for loop to iterate through a list, tuple or range object. So what is the underlying principle? In understanding Python&rsquo;s data structures, containers (container), iterable objects (iterator), iterators (iterator), generators (generator), lists/sets/dictionary comprehensions (list, set, dict comprehension), and many other concepts are mixed together to make beginners confused. The relationship between them. container A container is a data structure that organizes multiple" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2021-10/python-generator-iterator-iterable/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-10-20T15:12:43+08:00" />
<meta property="article:modified_time" content="2021-10-20T15:12:43+08:00" />

<meta itemprop="name" content="Python Iterators and Generators">
<meta itemprop="description" content="We all know that in Python we can for loop to iterate through a list, tuple or range object. So what is the underlying principle? In understanding Python&rsquo;s data structures, containers (container), iterable objects (iterator), iterators (iterator), generators (generator), lists/sets/dictionary comprehensions (list, set, dict comprehension), and many other concepts are mixed together to make beginners confused. The relationship between them. container A container is a data structure that organizes multiple"><meta itemprop="datePublished" content="2021-10-20T15:12:43+08:00" />
<meta itemprop="dateModified" content="2021-10-20T15:12:43+08:00" />
<meta itemprop="wordCount" content="3509">
<meta itemprop="keywords" content="python," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Python Iterators and Generators"/>
<meta name="twitter:description" content="We all know that in Python we can for loop to iterate through a list, tuple or range object. So what is the underlying principle? In understanding Python&rsquo;s data structures, containers (container), iterable objects (iterator), iterators (iterator), generators (generator), lists/sets/dictionary comprehensions (list, set, dict comprehension), and many other concepts are mixed together to make beginners confused. The relationship between them. container A container is a data structure that organizes multiple"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Python Iterators and Generators</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-10-20 15:12:43 </span>
        <div class="post-category">
            <a href="/categories/skills/"> skills </a>
            </div>
          <span class="more-meta"> 3509 words </span>
          <span class="more-meta"> 8 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#container">container</a></li>
        <li><a href="#iterable">iterable</a></li>
        <li><a href="#iterator">iterator</a></li>
        <li><a href="#generator">generator</a>
          <ul>
            <li><a href="#generator-function">generator function</a></li>
            <li><a href="#generator-expression">generator expression</a></li>
            <li><a href="#example-of-generator-usage">Example of generator usage</a></li>
            <li><a href="#generator-performance">generator performance</a></li>
            <li><a href="#advanced-generator-methods">Advanced Generator Methods</a></li>
            <li><a href="#creating-data-pipelines-using-generators">Creating data pipelines using generators</a></li>
          </ul>
        </li>
        <li><a href="#for-loop-working-mechanism">for loop working mechanism</a></li>
        <li><a href="#generator-functions-in-the-standard-library">Generator functions in the standard library</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>We all know that in Python we can for loop to iterate through a list, tuple or range object. So what is the underlying principle?</p>
<p>In understanding Python&rsquo;s data structures, containers (container), iterable objects (iterator), iterators (iterator), generators (generator), lists/sets/dictionary comprehensions (list, set, dict comprehension), and many other concepts are mixed together to make beginners confused. The relationship between them.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/20/ebed8cee289a4403a773e2323f5d2f42.png" alt=""></p>
<h2 id="container">container</h2>
<p>A container is a data structure that organizes multiple elements together. The elements in a container can be obtained iteratively one by one, and you can use the in, not in keywords to determine whether an element is contained in the container. Usually this type of data structure stores all elements in memory (there are some exceptions where not all elements are in memory, such as iterator and generator objects) In Python, common container objects are.</p>
<ul>
<li>list, deque, &hellip;.</li>
<li>set, frozensets, &hellip;.</li>
<li>dict, defaultdict, OrderedDict, Counter, &hellip;.</li>
<li>tuple, namedtuple, &hellip;</li>
<li>str</li>
</ul>
<p>From a technical point of view, when it can be used to ask whether an element is contained in it, then the object can be considered a container, for example, lists, collections, and tuples are all container objects. Generally containers are iterable objects, but not all containers are iterable.</p>
<h2 id="iterable">iterable</h2>
<p>For any object in Python that defines a <code>__iter__</code> method that returns an iterator, or a <code>__getitem__</code> method that supports subscript indexing, the object is iterable. In Python, all containers, such as lists, tuples, dictionaries, collections, etc., are iterable.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/20/d6d4529650e7466ab8c79dfbb09103d0.png" alt=""></p>
<p>Method for determining whether an object is iterable.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>


<span class="k">def</span> <span class="nf">iterable_test_1</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">iterable_test_2</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="nb">iter</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>


<span class="k">def</span> <span class="nf">iterable_test_3</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&#34;__main__&#34;</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">iterable_test_1</span><span class="p">(</span><span class="s2">&#34;Hello World!&#34;</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">iterable_test_2</span><span class="p">(</span><span class="s2">&#34;Hello World!&#34;</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">iterable_test_3</span><span class="p">(</span><span class="s2">&#34;Hello World!&#34;</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">iterable_test_1</span><span class="p">(</span><span class="mi">123</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">iterable_test_2</span><span class="p">(</span><span class="mi">123</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">iterable_test_3</span><span class="p">(</span><span class="mi">123</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>In practical applications it is recommended to use isinstance() to make the determination.</p>
<h2 id="iterator">iterator</h2>
<p>Iterators refer to tools that iterate over values; iteration is an iterative process; each iteration is based on the result of the previous one; iterators provide a generic and index-independent way of iterating over values.</p>
<p>Iterators should implement not only the <code>__iter__</code> method, but also the <code>__next__</code> method.</p>
<ul>
<li><code>__iter__</code>: returns the iterator itself self.</li>
<li><code>__next__</code>: returns the next available element of the iterator, throwing a StopIteration exception when there is no element at the end.</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/20/709cc25c52d64830b213bce3c8fa776b.png" alt=""></p>
<p>Characteristics of iterators.</p>
<ul>
<li>An iterator must be an iterable object because the <code>__iter__</code> method is implemented.</li>
<li>The <code>__iter__</code> method of an iterator returns itself, does not produce a new iterator object, and can only be iterated over once. If you want to iterate again you need to rebuild the iterator.</li>
<li>Iterators are inert computations that return values only when called, and wait for the next call when not called. This saves a lot of memory space.</li>
</ul>
<p>Iterator protocol: The object must provide a next method, the execution of which either returns the next item in the iteration or raises a StopIteration exception to terminate the iteration (it can only go backwards not forwards).</p>
<p>Pros.</p>
<ul>
<li>Provides a generic and index-independent way of iterating over values</li>
<li>Only one value exists in memory at the same time, which is more memory-efficient</li>
</ul>
<p>Disadvantages.</p>
<ul>
<li>Not as flexible as indexed fetching (can&rsquo;t fetch a specified value and can only go backwards)</li>
<li>Unable to predict the length of the iterator</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/20/0862dab12b6b4a12851e4fb62f67d99e.png" alt=""></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="c1"># 创建一个迭代器类</span>
<span class="k">class</span> <span class="nc">Fib</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prev</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">curr</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">curr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">curr</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prev</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="mi">500</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span>
        <span class="k">return</span> <span class="n">value</span>
<span class="nb">print</span><span class="p">(</span><span class="n">Fib</span><span class="p">())</span>

<span class="c1"># 根据可迭代对象创建一个迭代器</span>
<span class="n">lst</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">res</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

<span class="c1"># 判断可迭代对象是否为迭代器</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterator</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">Iterator</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">Iterator</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="generator">generator</h2>
<p>A generator is both iterable and iterative, and there are two ways to define a generator.</p>
<ul>
<li>generator function</li>
<li>generator expression</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/20/27b173a8242e43ab946c97cca915e4ff.png" alt=""></p>
<h3 id="generator-function">generator function</h3>
<p>If a function definition contains the yield keyword, the entire function is a generator function. During the execution of a generator function, each time it encounters a yield, the function pauses and saves all the current run information, returns the value of the yield, and continues from the current position the next time the next() method is executed.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="k">def</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">counter</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">a</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
        <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>


<span class="n">f</span> <span class="o">=</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;----&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Generator functions look and behave like regular functions, but have one defining feature. Instead of return, generator functions use the Python yield keyword. yield indicates where to send the value back to the caller, and unlike return, you don&rsquo;t exit the function afterwards. Instead, it remembers the state of the function. Thus, when next() is called on a generator object (explicitly or implicitly in a for loop), the value is generated again.</p>
<h3 id="generator-expression">generator expression</h3>
<p>A generator expression is a generator version of a list pushdown that looks like a list derivative, but it returns a generator object instead of a list object. A generator expression is computed on demand (or inert), computing values when needed and returning an iterator, while a list parser returns values immediately, returning a list of iterable objects. In terms of memory footprint, generator expressions are more memory-efficient.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="n">nums_squared_lc</span> <span class="o">=</span> <span class="p">[</span><span class="n">num</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
<span class="n">nums_squared_gc</span> <span class="o">=</span> <span class="p">(</span><span class="n">num</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&#34;__main__&#34;</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">nums_squared_lc</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">nums_squared_gc</span><span class="p">)</span>
<span class="c1"># 输出</span>
<span class="c1"># [0, 1, 4, 9, 16]</span>
<span class="c1"># &lt;generator object &lt;genexpr&gt; at 0x0000022D4FD5EDC8&gt;</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="example-of-generator-usage">Example of generator usage</h3>
<h4 id="example-1-reading-large-files">Example 1: Reading large files</h4>
<p>A common use case for generators is working with data streams or large files, such as CSV files. Now, what if you want to count the number of rows in a CSV file? The following code gives some ideas.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="n">csv_gen</span> <span class="o">=</span> <span class="n">csv_reader</span><span class="p">(</span><span class="s2">&#34;some_csv.txt&#34;</span><span class="p">)</span>
<span class="n">row_count</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">csv_gen</span><span class="p">:</span>
    <span class="n">row_count</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Row count is </span><span class="si">{</span><span class="n">row_count</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>You may want csv_gen to be a list. To populate this list, csv_reader() opens a file and loads its contents into csv_gen. The program then iterates through the list and increments row_count for each line.</p>
<p>This is a reasonable logic, but does this design still work if the file is very large? What if the file is larger than the available memory? Let&rsquo;s assume for a moment that csv_reader() simply opens the file and reads it into an array.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="k">def</span> <span class="nf">csv_reader</span><span class="p">(</span><span class="n">file_name</span><span class="p">):</span>
    <span class="n">file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&#34;</span><span class="se">\n</span><span class="s2">&#34;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>
</code></pre></td></tr></table>
</div>
</div><p>This function opens a given file and adds each line as a separate element to the list using file.read(), with.split(). When executed you may get the following output.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s2">&#34;ex1_naive.py&#34;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">22</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
    <span class="n">main</span><span class="p">()</span>
  <span class="n">File</span> <span class="s2">&#34;ex1_naive.py&#34;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">13</span><span class="p">,</span> <span class="ow">in</span> <span class="n">main</span>
    <span class="n">csv_gen</span> <span class="o">=</span> <span class="n">csv_reader</span><span class="p">(</span><span class="s2">&#34;file.txt&#34;</span><span class="p">)</span>
  <span class="n">File</span> <span class="s2">&#34;ex1_naive.py&#34;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">6</span><span class="p">,</span> <span class="ow">in</span> <span class="n">csv_reader</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&#34;</span><span class="se">\n</span><span class="s2">&#34;</span><span class="p">)</span>
<span class="ne">MemoryError</span>
</code></pre></td></tr></table>
</div>
</div><p>In this case, open() returns a generator object and you can iterate over it lazily line by line. However, file.read().split() loads all the contents into memory at once, leading to MemoryError. so, how to handle these huge data files? Look at redefining csv_reader().</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="k">def</span> <span class="nf">csv_reader</span><span class="p">(</span><span class="n">file_name</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="s2">&#34;r&#34;</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">row</span>
</code></pre></td></tr></table>
</div>
</div><p>In this version, you open the file, iterate over it, and produce a single line. This code should produce the following output, with no memory errors. What&rsquo;s happening here? You&rsquo;ve actually turned csv_reader() into a generator function. Open a file, iterate over each line, and produce each line instead of returning it.</p>
<p>You can also define generator expressions whose syntax is very similar to list derivatives. This makes it possible to use generators without calling the function.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="n">csv_gen</span> <span class="o">=</span> <span class="p">(</span><span class="n">row</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="example-2-generating-an-infinite-sequence">Example 2: Generating an infinite sequence</h4>
<p>To get a finite sequence in Python, you range() can be called in the context of a list and evaluate it.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="n">a</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>However, generating an infinite sequence requires the use of a generator, since your computer&rsquo;s memory is limited.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="k">def</span> <span class="nf">infinite_sequence</span><span class="p">():</span>
    <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">num</span>
        <span class="n">num</span> <span class="o">+=</span> <span class="mi">1</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&#34;__main__&#34;</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">infinite_sequence</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&#34; &#34;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>The program will execute consistently until you stop it manually. In addition to using a for loop, you can also next() to call the generator object directly. This is particularly useful for testing generators in the console: the</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="n">gen</span> <span class="o">=</span> <span class="n">infinite_sequence</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">gen</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="example-3-back-to-text-detection">Example 3: Back to text detection</h4>
<p>You can use infinite sequences in many ways, but one practical use for them is to construct an echo detector. An echo detector will find all letters or sequences that are an echo. That is, forward and backward to be able to read the same word or number, for example 121. First, define your numeric echo detector.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="k">def</span> <span class="nf">infinite_sequence</span><span class="p">():</span>
    <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">num</span>
        <span class="n">num</span> <span class="o">+=</span> <span class="mi">1</span>


<span class="k">def</span> <span class="nf">is_palindrome</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="c1"># Skip single-digit inputs</span>
    <span class="k">if</span> <span class="n">num</span> <span class="o">//</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">num</span>
    <span class="n">reversed_num</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">while</span> <span class="n">temp</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">reversed_num</span> <span class="o">=</span> <span class="p">(</span><span class="n">reversed_num</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">temp</span> <span class="o">%</span> <span class="mi">10</span><span class="p">)</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span> <span class="o">//</span> <span class="mi">10</span>

    <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="n">reversed_num</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">num</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&#34;__main__&#34;</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">infinite_sequence</span><span class="p">():</span>
        <span class="n">pal</span> <span class="o">=</span> <span class="n">is_palindrome</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pal</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Don&rsquo;t worry too much about understanding the underlying math in this code. This function takes an input number, inverts it, and checks to see if the inverted number is the same as the original number. The only numbers printed to the console are those that are the same forward or backward.</p>
<h3 id="generator-performance">generator performance</h3>
<p>You learned earlier that generators are a great way to optimize memory. While the infinite sequence generator is an extreme example of this optimization, let&rsquo;s zoom in on the number-squared example you just saw and examine the size of the resulting object. You can do this by calling sys.getsizeof().</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="n">nums_squared_lc</span> <span class="o">=</span> <span class="p">[</span><span class="n">num</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10000</span><span class="p">)]</span>
<span class="n">nums_squared_gc</span> <span class="o">=</span> <span class="p">(</span><span class="n">num</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10000</span><span class="p">))</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&#34;__main__&#34;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">sys</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">getsizeof</span><span class="p">(</span><span class="n">nums_squared_lc</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">getsizeof</span><span class="p">(</span><span class="n">nums_squared_gc</span><span class="p">))</span>
<span class="c1"># 输出</span>
<span class="c1"># 87624</span>
<span class="c1"># 120</span>
</code></pre></td></tr></table>
</div>
</div><p>In this case, you get a list of 87624 bytes from the list derivation, while the generator object has only 120. This means that the list is more than 700 times larger than the generator object! However, there is one thing to remember. If the list is smaller than the available memory of the running machine, then the list derivation will compute faster than the equivalent generator expression:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="kn">import</span> <span class="nn">cProfile</span>
<span class="nb">print</span><span class="p">(</span><span class="n">cProfile</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="s1">&#39;sum([i * 2 for i in range(10000)])&#39;</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">cProfile</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="s1">&#39;sum((i * 2 for i in range(10000)))&#39;</span><span class="p">))</span>
<span class="c1"># 输出</span>
<span class="c1">#          5 function calls in 0.001 seconds</span>
<span class="c1">#</span>
<span class="c1">#    Ordered by: standard name</span>
<span class="c1">#</span>
<span class="c1">#    ncalls  tottime  percall  cumtime  percall filename:lineno(function)</span>
<span class="c1">#         1    0.001    0.001    0.001    0.001 &lt;string&gt;:1(&lt;listcomp&gt;)</span>
<span class="c1">#         1    0.000    0.000    0.001    0.001 &lt;string&gt;:1(&lt;module&gt;)</span>
<span class="c1">#         1    0.000    0.000    0.001    0.001 {built-in method builtins.exec}</span>
<span class="c1">#         1    0.000    0.000    0.000    0.000 {built-in method builtins.sum}</span>
<span class="c1">#         1    0.000    0.000    0.000    0.000 {method &#39;disable&#39; of &#39;_lsprof.Profiler&#39; objects}</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># None</span>
<span class="c1">#          10005 function calls in 0.002 seconds</span>
<span class="c1">#</span>
<span class="c1">#    Ordered by: standard name</span>
<span class="c1">#</span>
<span class="c1">#    ncalls  tottime  percall  cumtime  percall filename:lineno(function)</span>
<span class="c1">#     10001    0.001    0.000    0.001    0.000 &lt;string&gt;:1(&lt;genexpr&gt;)</span>
<span class="c1">#         1    0.000    0.000    0.002    0.002 &lt;string&gt;:1(&lt;module&gt;)</span>
<span class="c1">#         1    0.000    0.000    0.002    0.002 {built-in method builtins.exec}</span>
<span class="c1">#         1    0.001    0.001    0.002    0.002 {built-in method builtins.sum}</span>
<span class="c1">#         1    0.000    0.000    0.000    0.000 {method &#39;disable&#39; of &#39;_lsprof.Profiler&#39; objects}</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># None</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="advanced-generator-methods">Advanced Generator Methods</h3>
<p>You have seen the most common uses and constructs of generators, but there are a few more tricks to introduce. In addition to yield, the following methods are available for generator objects.</p>
<ul>
<li>.send()</li>
<li>.throw()</li>
<li>.close()</li>
</ul>
<h4 id="how-to-use-send">How to use .send()</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="k">def</span> <span class="nf">infinite_palindromes</span><span class="p">():</span>
    <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">is_palindrome</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="k">yield</span> <span class="n">num</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">num</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">num</span> <span class="o">+=</span> <span class="mi">1</span>


<span class="k">def</span> <span class="nf">is_palindrome</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="c1"># Skip single-digit inputs</span>
    <span class="k">if</span> <span class="n">num</span> <span class="o">//</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">num</span>
    <span class="n">reversed_num</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">while</span> <span class="n">temp</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">reversed_num</span> <span class="o">=</span> <span class="p">(</span><span class="n">reversed_num</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">temp</span> <span class="o">%</span> <span class="mi">10</span><span class="p">)</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span> <span class="o">//</span> <span class="mi">10</span>

    <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="n">reversed_num</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&#34;__main__&#34;</span><span class="p">:</span>
    <span class="n">pal_gen</span> <span class="o">=</span> <span class="n">infinite_palindromes</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pal_gen</span><span class="p">:</span>
        <span class="n">digits</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="n">pal_gen</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="n">digits</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>This program will print numeric palindromes as before, but with a few tweaks. When a palindrome is encountered, your new program will add a number and start searching for the next one from there.</p>
<ul>
<li>infinite_palindromes() in i = (yield num), check if i is not None, which may happen if next() is called on a generator object.</li>
<li>send(), will execute 10 ** digits to i, update num</li>
</ul>
<p>What you are creating here is a coroutine (concatenation), or a generator function that can pass data. These are useful for building data pipelines.</p>
<h4 id="how-to-use-throw">How to use .throw()</h4>
<p>.throw() allows you to use generators to throw exceptions. In the following example, this code will throw a ValueError when digits=5 is thrown.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&#34;__main__&#34;</span><span class="p">:</span>
    <span class="n">pal_gen</span> <span class="o">=</span> <span class="n">infinite_palindromes</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pal_gen</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">digits</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">digits</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">pal_gen</span><span class="o">.</span><span class="n">throw</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s2">&#34;We don&#39;t like large palindromes&#34;</span><span class="p">))</span>
        <span class="n">pal_gen</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="n">digits</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>.throw() is useful in any area where you may need to catch an exception.</p>
<h4 id="how-to-use-close">How to use .close()</h4>
<p>As the name implies, .close() allows you to stop the generator. This is particularly handy when controlling an infinite sequence generator.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&#34;__main__&#34;</span><span class="p">:</span>
    <span class="n">pal_gen</span> <span class="o">=</span> <span class="n">infinite_palindromes</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pal_gen</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">digits</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">digits</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">pal_gen</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">pal_gen</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="n">digits</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>.close() is that it raises StopIteration an exception to indicate the end of the finite iterator.</p>
<h3 id="creating-data-pipelines-using-generators">Creating data pipelines using generators</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="n">file_name</span> <span class="o">=</span> <span class="s2">&#34;techcrunch.csv&#34;</span>
<span class="n">lines</span> <span class="o">=</span> <span class="p">(</span><span class="n">line</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">))</span>
<span class="n">list_line</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&#34;,&#34;</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">)</span>
<span class="n">cols</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">list_line</span><span class="p">)</span>
<span class="n">company_dicts</span> <span class="o">=</span> <span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">cols</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span> <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">list_line</span><span class="p">)</span>
<span class="n">funding</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">company_dict</span><span class="p">[</span><span class="s2">&#34;raisedAmt&#34;</span><span class="p">])</span> <span class="k">for</span> <span class="n">company_dict</span> <span class="ow">in</span> <span class="n">company_dicts</span> <span class="k">if</span> <span class="n">company_dict</span><span class="p">[</span><span class="s2">&#34;round&#34;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&#34;a&#34;</span><span class="p">)</span>
<span class="n">total_series_a</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">funding</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Total series A fundraising: $</span><span class="si">{</span><span class="n">total_series_a</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="for-loop-working-mechanism">for loop working mechanism</h2>
<p>After introducing iterable objects and iterators, let&rsquo;s further summarize the working mechanism of for loops in iterable objects and iterators.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/20/38f367b84a8c4b43a343648914e3c922.png" alt=""></p>
<p><strong>Iterable objects</strong> in the for loop work mechanism.</p>
<ul>
<li>first determine whether the object is an iterable object (equivalent to determining whether there is an iter or getitem method), if not iterable then throw a TypeError exception. If the object is iterable then the <code>__iter__</code> method is called and an iterator is returned.</li>
<li>Keep calling the <code>__next__</code> method of the iterator, returning one value from the iterator at a time, in order.</li>
<li>Throws an exception StopIteration when there are no elements at the end of the iteration. this exception is handled by Python itself and is not exposed to the developer.</li>
</ul>
<p><strong>Iterator</strong> in for loop working mechanism.</p>
<ul>
<li>Call the <code>__iter__</code> method, which returns its own self, i.e., the iterator.</li>
<li>Keep calling the iterator&rsquo;s next() method, returning one value from the iterator at a time, in order.</li>
<li>Throws an exception StopIteration when there are no elements at the end of the iteration.</li>
</ul>
<p>In Python, for loops are compatible with two mechanisms.</p>
<ul>
<li>If the object defines <code>__iter__</code>, an iterator is returned.</li>
<li>If the object does not define <code>__iter__</code> but implements <code>__getitem__</code>, it will iterate over subscripts instead.</li>
</ul>
<p>When the for loop finds no <code>__iter__</code> but <code>__getitem__</code>, it will read the corresponding subscripts in order, starting from 0 until an IndexError occurs. iter() method also handles this case, returning a subscripted iterator object instead when <code>__iter__</code> is not present.</p>
<h2 id="generator-functions-in-the-standard-library">Generator functions in the standard library</h2>
<p>Generator functions for filtering.</p>
<table>
<thead>
<tr>
<th>Module</th>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>itertools</td>
<td>compress(it, selector_it)</td>
<td>Processes two iterable objects in parallel. If the element in selector_it is true, output the corresponding element in it</td>
</tr>
<tr>
<td>itertools</td>
<td>dropwhile(predicate, it)</td>
<td>Passes the elements of the iterable object it to predicate, skips elements where predicate(item) is true, stops when predicate(item) is false, and outputs all remaining (unskipped) elements (no further checking)</td>
</tr>
<tr>
<td>Built-in</td>
<td>filter(predicate, it)</td>
<td>Pass each element of it to predicate, and if predicate(item) returns true, output the corresponding element</td>
</tr>
<tr>
<td>itertools</td>
<td>filterfalse(predicate, it)</td>
<td>Similar to the filter function, but predicate(item) returns the corresponding element when it returns a false value</td>
</tr>
<tr>
<td>itertools</td>
<td>takewhile(predicate, it)</td>
<td>predicate(item) produces the corresponding element when it returns the true value, and then stops immediately without further checking</td>
</tr>
<tr>
<td>itertools</td>
<td>islice(it, stop) or islice(it, start, stop, step=1)</td>
<td>produces a slice of it, similar to s[:stop] or s[start:stop:step, except that it can be any iterable object and implements an inert operation</td>
</tr>
</tbody>
</table>
<p>Generator functions for mapping.</p>
<table>
<thead>
<tr>
<th>Module</th>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>itertools</td>
<td>accumulate(it, [func])</td>
<td>The cumulative sum of the outputs. If func is provided, the first two elements of it are passed to func, then the result of the calculation is passed to func along with the next element, and so on, yielding the result</td>
</tr>
<tr>
<td>Built-in</td>
<td>enumerate(it, start=0)</td>
<td>yields a tuple of two elements, with the structure (index, item). where index is counted from start and item is obtained from it</td>
</tr>
<tr>
<td>Built-in</td>
<td>map(func, it1, [it2, …, itN])</td>
<td>Pass each element of it to func to produce the result; if you pass in N iterables, func must be able to accept N arguments and process each iterable in parallel</td>
</tr>
</tbody>
</table>
<p>Generator function for merging multiple iterable objects.</p>
<table>
<thead>
<tr>
<th>Module</th>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>itertools</td>
<td>chain(it1, …, itN)</td>
<td>Output all the elements in it1, then all the elements in it2, and so on, seamlessly</td>
</tr>
<tr>
<td>itertools</td>
<td>chain.from_iterable(it)</td>
<td>Produce the elements of each iterable object generated by it, one after the other seamlessly; the elements in it should be iterable objects (i.e. it is an iterable object with nested iterables)</td>
</tr>
<tr>
<td>itertools</td>
<td>product(it1, …, itN, repeat=1)</td>
<td>Computes the Cartesian product. Takes the elements from each of the input iterables and combines them into a tuple of N elements, the same effect as a nested for loop. repeat specifies how many times to repeat the input iterables</td>
</tr>
<tr>
<td>Built-in</td>
<td>zip(it1, …, itN)</td>
<td>The elements are fetched from each of the input iterable objects in parallel, resulting in a tuple of N elements. As soon as any of these iterable objects reaches the end, it simply stops</td>
</tr>
<tr>
<td>itertools</td>
<td>zip_longest(it1, …, itN, fillvalue=None)</td>
<td>The elements are fetched from each of the input iterable objects in parallel, producing a tuple of N elements, and stopping only when the longest iterable object is reached. The missing values are filled with fillvalue</td>
</tr>
</tbody>
</table>
<p>Generator functions for rearranging elements.</p>
<table>
<thead>
<tr>
<th>Module</th>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>itertools</td>
<td>groupby(it, key=None)</td>
<td>Produces an element consisting of two elements of the form (key, group), where key is the grouping criterion and group is the generator used to produce the elements in the group</td>
</tr>
<tr>
<td>Built-in</td>
<td>reversed(seq)</td>
<td>Output the elements of seq in reverse order, from back to front; seq must be a sequence or an object that implements the <code>__reversed__</code> special method</td>
</tr>
<tr>
<td>itertools</td>
<td>tee(it, n=2)</td>
<td>produces a tuple of n generators, each of which can independently produce the elements of the input iterable object</td>
</tr>
</tbody>
</table>
<p>Functions that read an iterator and return a single value.</p>
<table>
<thead>
<tr>
<th>Module</th>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Built-in</td>
<td>all(it)</td>
<td>True if all elements in it are true, False otherwise; all([]) returns True</td>
</tr>
<tr>
<td>Built-in</td>
<td>any(it)</td>
<td>True if it has an element that is true, otherwise False; any([]) returns False</td>
</tr>
<tr>
<td>Built-in</td>
<td>max(it, [key=], [default=])</td>
<td>Returns the element with the largest value in it; key is the sorting function, the same as in sorted; if the iterable object is empty, returns default</td>
</tr>
<tr>
<td>Built-in</td>
<td>min(it, [key=], [default=])</td>
<td>Returns the element with the smallest value in it; key is the sorting function; if the iterable object is empty, returns default</td>
</tr>
<tr>
<td>functools</td>
<td>reduce(func, it, [initial])</td>
<td>Pass the first two elements to func, then pass the result of the computation and the third element to func, and so on, returning the final result. If initial is provided, pass it as the first element into</td>
</tr>
<tr>
<td>Built-in</td>
<td>sum(it, start=0)</td>
<td>The sum of all elements in it, and if an optional start is provided, it will be added as well</td>
</tr>
</tbody>
</table>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/python/">python</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2021-10/python-import/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">In-depth learning of the Python import mechanism</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2021-10/lvs/">
            <span class="next-text nav-default">Load Balancing Technology for LVS</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
