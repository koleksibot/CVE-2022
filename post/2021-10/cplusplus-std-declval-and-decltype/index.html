<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Understand declval and decltype - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="std::declval and decltype About decltype decltype(expr) is a new keyword added to C&#43;&#43;11 to type out entities or expressions.
1 2 3 4 5 6  #include &amp;lt;iostream&amp;gt;int main() { int i = 33; decltype(i) j = i * 2; std::cout &amp;lt;&amp;lt; j; }   It is simple and needs no additional explanation.
But how can something so simple require such a big thing as a new keyword? It&amp;rsquo;s metaprogramming!" /><meta name="keywords" content="declval, decltype" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2021-10/cplusplus-std-declval-and-decltype/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Understand declval and decltype" />
<meta property="og:description" content="std::declval and decltype About decltype decltype(expr) is a new keyword added to C&#43;&#43;11 to type out entities or expressions.
1 2 3 4 5 6  #include &lt;iostream&gt;int main() { int i = 33; decltype(i) j = i * 2; std::cout &lt;&lt; j; }   It is simple and needs no additional explanation.
But how can something so simple require such a big thing as a new keyword? It&rsquo;s metaprogramming!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2021-10/cplusplus-std-declval-and-decltype/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-10-21T22:20:27+08:00" />
<meta property="article:modified_time" content="2021-10-21T22:20:27+08:00" />

<meta itemprop="name" content="Understand declval and decltype">
<meta itemprop="description" content="std::declval and decltype About decltype decltype(expr) is a new keyword added to C&#43;&#43;11 to type out entities or expressions.
1 2 3 4 5 6  #include &lt;iostream&gt;int main() { int i = 33; decltype(i) j = i * 2; std::cout &lt;&lt; j; }   It is simple and needs no additional explanation.
But how can something so simple require such a big thing as a new keyword? It&rsquo;s metaprogramming!"><meta itemprop="datePublished" content="2021-10-21T22:20:27+08:00" />
<meta itemprop="dateModified" content="2021-10-21T22:20:27+08:00" />
<meta itemprop="wordCount" content="1856">
<meta itemprop="keywords" content="c&#43;&#43;," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Understand declval and decltype"/>
<meta name="twitter:description" content="std::declval and decltype About decltype decltype(expr) is a new keyword added to C&#43;&#43;11 to type out entities or expressions.
1 2 3 4 5 6  #include &lt;iostream&gt;int main() { int i = 33; decltype(i) j = i * 2; std::cout &lt;&lt; j; }   It is simple and needs no additional explanation.
But how can something so simple require such a big thing as a new keyword? It&rsquo;s metaprogramming!"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Understand declval and decltype</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-10-21 22:20:27 </span>
        <div class="post-category">
            <a href="/categories/skills/"> skills </a>
            </div>
          <span class="more-meta"> 1856 words </span>
          <span class="more-meta"> 9 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#stddeclval-and-decltype">std::declval and decltype</a>
          <ul>
            <li><a href="#about-decltype">About decltype</a></li>
            <li><a href="#about-stddeclval">About std::declval</a></li>
            <li><a href="#refs">Refs</a></li>
          </ul>
        </li>
        <li><a href="#tricks">Tricks</a>
          <ul>
            <li><a href="#use-a-common-abstract-class-as-the-base-class">Use a common abstract class as the base class</a></li>
            <li><a href="#how-to-put-a-pure-virtual-class-in-a-container">How to put a pure virtual class in a container</a></li>
            <li><a href="#runtime-polymorphism">Runtime Polymorphism</a></li>
          </ul>
        </li>
        <li><a href="#postscript">Postscript</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="stddeclval-and-decltype">std::declval and decltype</h2>
<h3 id="about-decltype">About decltype</h3>
<p><code>decltype(expr)</code> is a new keyword added to C++11 to type out entities or expressions.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">33</span><span class="p">;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">j</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>It is simple and needs no additional explanation.</p>
<p>But how can something so simple require such a big thing as a new keyword? It&rsquo;s metaprogramming! In the world of metaprogramming, a long string of template class declarations is crippling, and writing them repeatedly is even more tedious. For example, a runtime debug log output.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/21/223e3785f20f41ee9c9b4e2995bf4365.png" alt=""></p>
<p>It&rsquo;s not the longest name I can remember, just the one reference that I can intercept most easily. There are plenty of examples like this.</p>
<p>Here&rsquo;s a slightly rewritten example to illustrate the usefulness of decltype.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="nf">test_state_meta</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">machine_t</span><span class="o">&lt;</span><span class="n">my_state</span><span class="p">,</span> <span class="kt">void</span><span class="p">,</span> <span class="n">payload_t</span><span class="o">&lt;</span><span class="n">my_state</span><span class="o">&gt;&gt;</span> <span class="n">m</span><span class="p">;</span>
  <span class="k">using</span> <span class="n">M</span> <span class="o">=</span> <span class="k">decltype</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
  <span class="c1">// equals to: using M = machine_t&lt;my_state, void, payload_t&lt;my_state&gt;&gt;;
</span><span class="c1"></span>
  <span class="c1">// @formatter:off
</span><span class="c1"></span>  <span class="c1">// states
</span><span class="c1"></span>  <span class="n">m</span><span class="p">.</span><span class="n">state</span><span class="p">().</span><span class="n">set</span><span class="p">(</span><span class="n">my_state</span><span class="o">::</span><span class="n">Initial</span><span class="p">).</span><span class="n">as_initial</span><span class="p">().</span><span class="n">build</span><span class="p">();</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Obviously, <code>using M = decltype(m)</code> is more concise, especially when <code>machine_t&lt;my_state, void, payload_t&lt;my_state&gt;&gt;</code> may be a super-long string with a super-long definition of template arguments, the value of decltype becomes more obvious.</p>
<p>In metaprogramming, especially in cases where large class systems are tangled with each other, there are many times when the power of decltype and auto-derivation may not be available, because we may not be able to predict what the specific type will be in a specific scenario.</p>
<h4 id="standardized-coding-style">Standardized coding style</h4>
<p>In addition, making good use of decltype and using can contribute to the standardization and effortlessness of your code.</p>
<p>When writing a class, we should make more use of the type aliasing capabilities provided by using, which of course may also involve the use of decltype.</p>
<p>The advantage of using is that the compiler can be explicitly prompted to do the relevant type derivation in advance, and if there is a mistake, it can be fixed at a set of using statements, rather than having to go through a bunch of code paragraphs to figure out why the wrong type was used.</p>
<p>Using the wrong type can lead to a huge pile of code that has to be rewritten.</p>
<p>Using using can also help you reduce the number of code paragraphs you have to change. For example, if <code>using Container=std::list&lt;T&gt;</code> is changed to <code>using Container=std::vector&lt;T&gt;</code>, your already written code paragraphs and even the <code>Container _container</code> declaration can be changed without a single change, just by recompiling.</p>
<p>This section does not give reference examples, because that would take away from the main point. And the timing is not good enough to tell you about it.</p>
<h3 id="about-stddeclval">About std::declval</h3>
<p><a href="https://en.cppreference.com/w/cpp/utility/declval"> <code>std::declval&lt;T&gt;()</code> </a> is not much to say, it returns a right-valued reference of type T.</p>
<p>But <a href="https://en.cppreference.com/w/cpp/utility/declval">cppref</a> is really confusing, what does declval really do? It is used to return a fake instance of a T object with a right-valued reference. In other words, it is equivalent to the compile-time state of objref as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="n">T</span> <span class="n">obj</span><span class="p">{};</span>
<span class="n">T</span> <span class="o">&amp;</span><span class="n">objref</span> <span class="o">=</span> <span class="n">obj</span><span class="p">{};</span>
</code></pre></td></tr></table>
</div>
</div><p>First, it is lexically and semantically equivalent to objref, which is an instance value of object T and has the type T&amp;&amp;; second, it is only used in non-valued situations; and third, it doesn&rsquo;t really exist. What it means, in human terms, is that at compile time, you need a value object, but you don&rsquo;t want it to be compiled as a binary entity, so you construct one virtually with declval, as if you had a temporary object on which you could apply operations, such as calling member functions, but since it is virtual, there is no such temporary object, so I call it pseudo-instances.</p>
<p>We often don&rsquo;t really need the pseudo-instance directly from the declval, but more from the pseudo-instance to get the corresponding type description, i.e., T. So in general, declval is often surrounded by decltype computation, and trying to get T is the real goal: the declval is the only one we need.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">namespace</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="nc">base_t</span> <span class="p">{</span> <span class="k">virtual</span> <span class="o">~</span><span class="n">base_t</span><span class="p">(){}</span> <span class="p">};</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="nc">Base</span> <span class="o">:</span> <span class="k">public</span> <span class="n">base_t</span> <span class="p">{</span>
      <span class="k">virtual</span> <span class="n">T</span> <span class="nf">t</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">};</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="nc">A</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
      <span class="o">~</span><span class="n">A</span><span class="p">(){}</span>
      <span class="k">virtual</span> <span class="n">T</span> <span class="nf">t</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;A&#34;</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="k">return</span> <span class="n">T</span><span class="p">{};</span> <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">().</span><span class="n">t</span><span class="p">())</span> <span class="n">a</span><span class="p">{};</span> <span class="c1">// = int a;
</span><span class="c1"></span>  <span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">Base</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">().</span><span class="n">t</span><span class="p">())</span> <span class="n">b</span><span class="p">{};</span> <span class="c1">// = int b;
</span><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;,&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>As you can see, the pseudo-instance of A<code>&lt;int&gt;</code> can &ldquo;call&rdquo; A&rsquo;s member function t(), and then with the help of decltype we can get the return type of t() and use it to declare a specific variable a. Since the return type of t() is T, this variable declaration in the main() function statement in the main() function is actually equivalent to int a{};.</p>
<p>This example is meant to help you understand what declval actually means; the example itself is rather meaningless.</p>
<h4 id="the-power-of-declval">The power of declval</h4>
<p>The core power of <code>declval(expr)</code> is clear from the example above: it doesn&rsquo;t really evaluate expr. So you don&rsquo;t have to generate any temporary objects at expr, and no real computation occurs because the expression is complex. This is very useful for complex environments with metaprogramming.</p>
<p>The following page from a ppt also shows a use case where the expression does not have to be evaluated but only type.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/10/21/445d5b05f2144e31b4400226aa12f655.png" alt=""></p>
<p>But not only that, further power is derived from the undeclval of declval.</p>
<h5 id="no-default-constructor">No default constructor</h5>
<p>If a class does not define a default constructor, it can be troublesome in a metaprogramming environment. For example, the following decltype will not pass compilation.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">struct</span> <span class="nc">A</span><span class="p">{</span>
  <span class="n">A</span><span class="p">()</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
  <span class="kt">int</span> <span class="nf">t</span><span class="p">(){</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
  <span class="k">decltype</span><span class="p">(</span><span class="n">A</span><span class="p">().</span><span class="n">t</span><span class="p">())</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// BAD
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>because A() is not present.</p>
<p>But by using declval instead, you can get around the problem:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
  <span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">().</span><span class="n">t</span><span class="p">())</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// OK
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h5 id="pure-virtual-class">Pure Virtual Class</h5>
<p>Sometimes metaprogramming on purely virtual base classes can be tricky, and it may be possible to bypass the problem of purely virtual base classes not being instantiated with the help of declval.</p>
<p>There is a corresponding reference in the first example <code>decltype(std::declval&lt;Base&lt;int&gt;&gt;().t()) b{}; // = int b;</code> .</p>
<h3 id="refs">Refs</h3>
<ul>
<li><a href="https://hackingcpp.com/cpp/lang/type_deduction.html">C++ Type Deduction Introduction - hacking C++</a></li>
<li><a href="https://en.cppreference.com/w/cpp/utility/declval">std::declval - cppreference.com</a></li>
<li><a href="https://en.cppreference.com/w/cpp/language/decltype">decltype specifier - cppreference.com</a></li>
</ul>
<h2 id="tricks">Tricks</h2>
<p>The above code involves some of the usual method, the following is a brief background, but also contains a little association extension.</p>
<h3 id="use-a-common-abstract-class-as-the-base-class">Use a common abstract class as the base class</h3>
<p>The system design of template classes may lead to bloat problems if the base class has a lot of code and data. One solution is to take a common base class and build templated base classes on top of it</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">struct</span> <span class="nc">base</span> <span class="p">{</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">base_t</span><span class="p">(){}</span>
  
  <span class="kt">void</span> <span class="nf">operation</span><span class="p">()</span> <span class="p">{</span> <span class="n">do_sth</span><span class="p">();</span> <span class="p">}</span>
  
  <span class="k">protected</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">do_sth</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="nc">base_t</span><span class="o">:</span> <span class="k">public</span> <span class="n">base</span><span class="p">{</span>
    <span class="k">protected</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">another</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">C</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span>
  <span class="k">struct</span> <span class="nc">vec_style</span><span class="o">:</span> <span class="k">public</span> <span class="n">base_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">protected</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">do_sth</span><span class="p">()</span> <span class="k">override</span> <span class="p">{}</span>
    <span class="kt">void</span> <span class="nf">another</span><span class="p">()</span> <span class="k">override</span> <span class="p">{}</span>
    
    <span class="k">private</span><span class="o">:</span>
    <span class="n">C</span> <span class="n">_container</span><span class="p">{};</span>
  <span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>This is written in such a way that generic logic (that doesn&rsquo;t have to be generalized) can be abstracted out into base and avoids being left in base_t to bloat with generic instantiation.</p>
<h3 id="how-to-put-a-pure-virtual-class-in-a-container">How to put a pure virtual class in a container</h3>
<p>By the way, we also talk about the containerization of pure virtual classes, abstract classes, and so on.</p>
<p>For class system design, we encourage pure virtualization of base classes, but such pure virtual base classes cannot be put into containers such as std::vector.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">namespace</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="nc">base</span> <span class="p">{};</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="nc">base_t</span> <span class="o">:</span> <span class="k">public</span> <span class="n">base</span> <span class="p">{</span>
      <span class="k">virtual</span> <span class="o">~</span><span class="n">base_t</span><span class="p">(){}</span>
      <span class="k">virtual</span> <span class="n">T</span> <span class="nf">t</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">};</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="nc">A</span> <span class="o">:</span> <span class="k">public</span> <span class="n">base_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
      <span class="n">A</span><span class="p">(){}</span>
      <span class="n">A</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">t_</span><span class="p">)</span><span class="o">:</span> <span class="n">_t</span><span class="p">(</span><span class="n">t_</span><span class="p">)</span> <span class="p">{}</span>
      <span class="o">~</span><span class="n">A</span><span class="p">(){}</span>
      <span class="n">T</span> <span class="n">_t</span><span class="p">{};</span>
      <span class="k">virtual</span> <span class="n">T</span> <span class="nf">t</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">_t</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="k">return</span> <span class="n">_t</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">vec</span><span class="p">;</span> <span class="c1">// BAD
</span><span class="c1"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>What to do?</p>
<p>It doesn&rsquo;t make sense to use declval here, you should use smart pointers to decorate the abstract base class with.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">base_t</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&gt;</span> <span class="n">vec</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
  <span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>Since we declare a non-generic base class base for the generic class base_t, it is also possible to use the <code>std::vector&lt;base&gt;</code> approach, but this requires you to extract all virtual interfaces into base, which would always leave some of the generic interfaces unextracted, so there is a chance that this approach will not work.</p>
</blockquote>
<p>If you find virtual functions and their overloading so painful that you can&rsquo;t stand them, you can consider CRTP, which is a very powerful compile-time polymorphism capability in the template class inheritance system.</p>
<p>In addition, it is possible to abandon the base class abstraction scheme and design the class system with the so-called runtime polymorphic trick.</p>
<h3 id="runtime-polymorphism">Runtime Polymorphism</h3>
<p>This is a <a href="https://sean-parent.stlab.cc/papers-and-presentations/#better-code-runtime-polymorphism">runtime polymorphism</a> coding technique provided by Sean Parent.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">class</span> <span class="nc">Animal</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">struct</span> <span class="nc">Interface</span> <span class="p">{</span>
    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">toString</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Interface</span><span class="p">()</span>                 <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="p">};</span>
  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Interface</span><span class="o">&gt;</span> <span class="n">_p</span><span class="p">;</span>

 <span class="k">public</span><span class="o">:</span>
  <span class="n">Animal</span><span class="p">(</span><span class="n">Interface</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="o">:</span> <span class="n">_p</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">toString</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_p</span><span class="o">-&gt;</span><span class="n">toString</span><span class="p">();</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Bird</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Animal</span><span class="o">::</span><span class="n">Interface</span> <span class="p">{</span>
 <span class="k">private</span><span class="o">:</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">_name</span><span class="p">;</span>
  <span class="kt">bool</span>        <span class="n">_canFly</span><span class="p">;</span>

 <span class="k">public</span><span class="o">:</span>
  <span class="n">Bird</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">canFly</span> <span class="o">=</span> <span class="nb">true</span><span class="p">)</span> <span class="o">:</span> <span class="n">_name</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">_canFly</span><span class="p">(</span><span class="n">canFly</span><span class="p">)</span> <span class="p">{}</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">toString</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&#34;I am a bird&#34;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Insect</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Animal</span><span class="o">::</span><span class="n">Interface</span> <span class="p">{</span>
 <span class="k">private</span><span class="o">:</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">_name</span><span class="p">;</span>
  <span class="kt">int</span>         <span class="n">_numberOfLegs</span><span class="p">;</span>

 <span class="k">public</span><span class="o">:</span>
  <span class="n">Insect</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">numberOfLegs</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">_name</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">_numberOfLegs</span><span class="p">(</span><span class="n">numberOfLegs</span><span class="p">)</span> <span class="p">{}</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">toString</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&#34;I am an insect.&#34;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Animal</span><span class="o">&gt;</span> <span class="n">creatures</span><span class="p">;</span>

  <span class="n">creatures</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="k">new</span> <span class="n">Bird</span><span class="p">(</span><span class="s">&#34;duck&#34;</span><span class="p">,</span> <span class="nb">true</span><span class="p">));</span>
  <span class="n">creatures</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="k">new</span> <span class="n">Bird</span><span class="p">(</span><span class="s">&#34;penguin&#34;</span><span class="p">,</span> <span class="nb">false</span><span class="p">));</span>
  <span class="n">creatures</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="k">new</span> <span class="n">Insect</span><span class="p">(</span><span class="s">&#34;spider&#34;</span><span class="p">,</span> <span class="mi">8</span><span class="p">));</span>
  <span class="n">creatures</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="k">new</span> <span class="n">Insect</span><span class="p">(</span><span class="s">&#34;centipede&#34;</span><span class="p">,</span> <span class="mi">44</span><span class="p">));</span>

  <span class="c1">// now iterate through the creatures and call their toString()
</span><span class="c1"></span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">creatures</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">creatures</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">toString</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Animal::Interface is the abstract base class used for the class system, it is purely imaginary but does not affect the valid compilation and working of <code>std::vector&lt;Animal&gt;</code>. Animal uses a simple transfer technique to map the interface of Animal::Interface ( Such as toString()), which is a bit like Pimpl Trick, but with a slight difference.</p>
<h2 id="postscript">Postscript</h2>
<p>In a nutshell, declval is specifically for situations where concrete objects cannot be instantiated.</p>
<p><code>std::declval&lt;T&gt;()</code> is also typically used for compile-time testing and other purposes, so we&rsquo;ll explore that next time we have time, it&rsquo;s too big a topic.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/c&#43;&#43;/">c&#43;&#43;</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2021-10/pytho-if-name-main/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">If __name__ == &#39;__main__&#39; in Python</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2021-10/python-with/">
            <span class="next-text nav-default">In-depth understanding of Python with statements</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
