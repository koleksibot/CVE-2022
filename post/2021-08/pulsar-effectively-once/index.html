<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Pulsar characteristics explained [Effectively once] - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="https://www.splunk.com/en_us/blog/it/effectively-once-semantics-in-apache-pulsar.html
 The article by pulsar describes in detail how Effectively once is supported, so I will not repeat it in this article, but will just summarise the conclusions described in the article below. The source code will be parsed later.
In order to implement Effectively once, pulsar supports it in two ways.
 Effectively-once publishing: ensuring that messages are sent only once Effectively-once consumer: ensuring that messages are consumed only once  Effectively-once publishing pulsar supports the guarantee that only one copy of a message will be stored in pulsar in the event of extreme conditions such as broker failure, producer failure, network failure, etc." /><meta name="keywords" content="Pulsar" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2021-08/pulsar-effectively-once/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Pulsar characteristics explained [Effectively once]" />
<meta property="og:description" content="https://www.splunk.com/en_us/blog/it/effectively-once-semantics-in-apache-pulsar.html
 The article by pulsar describes in detail how Effectively once is supported, so I will not repeat it in this article, but will just summarise the conclusions described in the article below. The source code will be parsed later.
In order to implement Effectively once, pulsar supports it in two ways.
 Effectively-once publishing: ensuring that messages are sent only once Effectively-once consumer: ensuring that messages are consumed only once  Effectively-once publishing pulsar supports the guarantee that only one copy of a message will be stored in pulsar in the event of extreme conditions such as broker failure, producer failure, network failure, etc." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2021-08/pulsar-effectively-once/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-08-29T18:52:55+08:00" />
<meta property="article:modified_time" content="2021-08-29T18:52:55+08:00" />

<meta itemprop="name" content="Pulsar characteristics explained [Effectively once]">
<meta itemprop="description" content="https://www.splunk.com/en_us/blog/it/effectively-once-semantics-in-apache-pulsar.html
 The article by pulsar describes in detail how Effectively once is supported, so I will not repeat it in this article, but will just summarise the conclusions described in the article below. The source code will be parsed later.
In order to implement Effectively once, pulsar supports it in two ways.
 Effectively-once publishing: ensuring that messages are sent only once Effectively-once consumer: ensuring that messages are consumed only once  Effectively-once publishing pulsar supports the guarantee that only one copy of a message will be stored in pulsar in the event of extreme conditions such as broker failure, producer failure, network failure, etc."><meta itemprop="datePublished" content="2021-08-29T18:52:55+08:00" />
<meta itemprop="dateModified" content="2021-08-29T18:52:55+08:00" />
<meta itemprop="wordCount" content="2108">
<meta itemprop="keywords" content="pulsar," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Pulsar characteristics explained [Effectively once]"/>
<meta name="twitter:description" content="https://www.splunk.com/en_us/blog/it/effectively-once-semantics-in-apache-pulsar.html
 The article by pulsar describes in detail how Effectively once is supported, so I will not repeat it in this article, but will just summarise the conclusions described in the article below. The source code will be parsed later.
In order to implement Effectively once, pulsar supports it in two ways.
 Effectively-once publishing: ensuring that messages are sent only once Effectively-once consumer: ensuring that messages are consumed only once  Effectively-once publishing pulsar supports the guarantee that only one copy of a message will be stored in pulsar in the event of extreme conditions such as broker failure, producer failure, network failure, etc."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Pulsar characteristics explained [Effectively once]</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-08-29 18:52:55 </span>
        <div class="post-category">
            <a href="/categories/skills/"> skills </a>
            </div>
          <span class="more-meta"> 2108 words </span>
          <span class="more-meta"> 10 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#effectively-once-publishing">Effectively-once publishing</a></li>
        <li><a href="#effectively-once-consumer">Effectively-once consumer</a></li>
        <li><a href="#message-deduplication-source-code-analysis">Message Deduplication source code analysis</a>
          <ul>
            <li><a href="#how-can-i-tell-if-a-message-is-a-duplicate">How can I tell if a message is a duplicate?</a></li>
            <li><a href="#how-is-the-messagededuplication-state-persisted">How is the MessageDeduplication state persisted?</a></li>
          </ul>
        </li>
        <li><a href="#summary">Summary</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <blockquote>
<p><a href="https://www.splunk.com/en_us/blog/it/effectively-once-semantics-in-apache-pulsar.html">https://www.splunk.com/en_us/blog/it/effectively-once-semantics-in-apache-pulsar.html</a></p>
</blockquote>
<p>The article by pulsar describes in detail how Effectively once is supported, so I will not repeat it in this article, but will just summarise the conclusions described in the article below. The source code will be parsed later.</p>
<p>In order to implement Effectively once, pulsar supports it in two ways.</p>
<ol>
<li>Effectively-once publishing: ensuring that messages are sent only once</li>
<li>Effectively-once consumer: ensuring that messages are consumed only once</li>
</ol>
<h2 id="effectively-once-publishing">Effectively-once publishing</h2>
<p>pulsar supports the guarantee that only one copy of a message will be stored in pulsar in the event of extreme conditions such as broker failure, producer failure, network failure, etc. It relies heavily on the <strong>message deduplication</strong> feature in pulsar, which provides switches to control whether or not <strong>message deduplication</strong> is activated, from namespaces, to topics and other dimensions.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">pulsar-admin namespaces set-deduplication <span class="nv">$MY_NAMESPACE</span> --enable
</code></pre></td></tr></table>
</div>
</div><p>The reliable delivery of messages to pulsar is functionally accomplished by: constant retry on the producer side + <strong>message deduplication</strong> on the broker side.</p>
<p>So the producer also needs to set up a constant retry configuration. This is achieved by the following configuration</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">ProducerConfiguration</span> <span class="n">conf</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ProducerConfiguration</span><span class="o">();</span>
<span class="n">conf</span><span class="o">.</span><span class="na">setProducerName</span><span class="o">(</span><span class="s">&#34;my-producer&#34;</span><span class="o">);</span>
<span class="n">conf</span><span class="o">.</span><span class="na">setSendTimeout</span><span class="o">(</span><span class="n">0</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">);</span>
<span class="n">Producer</span> <span class="n">producer</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="na">createProducer</span><span class="o">(</span><span class="n">TOPIC_NAME</span><span class="o">,</span> <span class="n">conf</span><span class="o">);</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>message deduplication</strong> The implementation principle relies on the broker side maintaining a highSequenceId for each producer, the sequenceId is incremental and can be controlled by the user. Each time a message arrives at the broker, it is determined whether it is a duplicate message based on whether it is less than the current highSequenceId.</p>
<p>A more detailed source code explanation of <strong>message deduplication</strong> will follow, so I won&rsquo;t go into too much detail here, but rather describe a limitation of this design. (Readers can see the limitations of this feature after reading the more detailed source code explanation)</p>
<blockquote>
<p>Effectively-once publishing in practice only makes sense when the messages are coming from a replayable source as opposed to a non-replayable source (for example online HTTP requests). For non-replayable sources, there’s no way to re-send the previous pending messages after a crash.</p>
</blockquote>
<p>pulsar uses the sequenceId design for higher performance <strong>message deduplication</strong>, with two limitations.</p>
<ol>
<li>it cannot determine <strong>non-replayable source</strong> deduplication: for example, http requests, each of which is stateless and random, cannot be associated with a sequenceId.</li>
<li>only determine whether the most recent message is a duplicate: pulsar was originally designed to cope with the various failures of the producer and broker when passing to achieve a precise production of a message, and not to solve the business message idempotent. So if your scenario is that you have a history of messages that could be delivered repeatedly, and then want pulsar to de-duplicate messages based on some custom id (idmpotentId), then pulsar does not support this.</li>
</ol>
<p>In summary, pulsar&rsquo;s implementation of <strong>message deduplication</strong> using sequenceId is very high performance (only one loss of hash and judgement), and snapshots and persistence are performed asynchronously. To support both of these features, pulsar would have to maintain messageId&rsquo;s for all messages over time, and would have to be designed to determine them efficiently.</p>
<h2 id="effectively-once-consumer">Effectively-once consumer</h2>
<p>pulsar only supports two consumption modes, subscribe and reader.</p>
<p>In subscribe mode, pulsar saves the consumer&rsquo;s consumption loci and casts the next message according to the latest loci, and the user can explicitly and actively ack the loci after consuming the message.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">Consumer</span> <span class="n">consumer</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">MY_TOPIC</span><span class="o">,</span> <span class="n">MY_SUBSCRIPTION_NAME</span><span class="o">);</span>

<span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Message</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">consumer</span><span class="o">.</span><span class="na">receive</span><span class="o">();</span>
    <span class="c1">// Process the message...
</span><span class="c1"></span>    <span class="n">consumer</span><span class="o">.</span><span class="na">acknowledge</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>For the subscribe mode, there are several possible cases of repeated consumption:</p>
<ol>
<li>broker failure: When the broker fails, the user may consume the data and process it, but not succeed in the ack, then the broker will recast the message when it recovers.</li>
<li>consumer failure: Like broker failure, the message is consumed and processed, but the consumer is down before the ack, then the broker will also re-cast the message.</li>
<li>network failure: network timeouts etc. will also cause the consumer to fail in submitting the ack, and the broker will re-cast the message.</li>
<li>Duplicate data consumption (special): As described in the limitations of the <strong>Effectively-once publishing</strong> conclusion, it is possible that the pulsar itself stores duplicate data, and then even without the above three failures, the business side consumes duplicate data.</li>
</ol>
<p>The first three of these faults can be solved by using pulsar&rsquo;s reader mode + relying on external storage for the current offset. However, to achieve idempotency in the face of inherently duplicate data, one must use a store that stores all message ids to do so.</p>
<p>With reader mode, the user can actively specify that the pull starts with a certain message, and the user simply saves the bits consumed at the moment, for example by storing the lastMessageId and business state changes in a single transaction to be committed.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">MessageId</span> <span class="n">lastMessageId</span> <span class="o">=</span> <span class="n">recoverLastMessageIdFromDB</span><span class="o">();</span>
<span class="n">Reader</span> <span class="n">reader</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="na">createReader</span><span class="o">(</span><span class="n">MY_TOPIC</span><span class="o">,</span> <span class="n">lastMessageId</span><span class="o">,</span>
                                    <span class="k">new</span> <span class="n">ReaderConfiguration</span><span class="o">());</span>

<span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Message</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="na">readNext</span><span class="o">();</span>
    <span class="kt">byte</span><span class="o">[]</span> <span class="n">msgId</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="na">getMessageId</span><span class="o">().</span><span class="na">toByteArray</span><span class="o">();</span>

    <span class="c1">// Process the message and store msgId atomically
</span><span class="c1"></span><span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>To sum up, in order to achieve a complete consumer accurate one-time consumption, if the producer side can not guarantee that the messages sent without duplicate messages, the consumer side needs to use a large idempotent persistent state storage to achieve, of course, this idempotent state can be configured according to the business scenario of a certain elimination mechanism.</p>
<h2 id="message-deduplication-source-code-analysis">Message Deduplication source code analysis</h2>
<p>As described in <strong>Effectively-once publishing</strong> above, we know that pulsar uses the maxSequenceId of the maintained producer to guarantee the de-duplication of messages when a producer retries. Here is a brief parsing of the source code.</p>
<p>All the message de-duplication logic is implemented in the MessageDeduplication class, and each PersistentTopic object holds a MessageDeduplication object.</p>
<h3 id="how-can-i-tell-if-a-message-is-a-duplicate">How can I tell if a message is a duplicate?</h3>
<p>It relies heavily on two set judgements:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="nd">@VisibleForTesting</span>
<span class="kd">final</span> <span class="n">ConcurrentOpenHashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">highestSequencedPushed</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConcurrentOpenHashMap</span><span class="o">&lt;&gt;(</span><span class="n">16</span><span class="o">,</span> <span class="n">1</span><span class="o">);</span>
<span class="kd">final</span> <span class="n">ConcurrentOpenHashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">highestSequencedPersisted</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConcurrentOpenHashMap</span><span class="o">&lt;&gt;(</span><span class="n">16</span><span class="o">,</span> <span class="n">1</span><span class="o">);</span>
</code></pre></td></tr></table>
</div>
</div><p>These two collections store the produceName corresponding to the largest seuenceId, one is persistent and one is non-persistent. The daily judgement is made by non-persistent judgement (high speed) and a thread in the background periodically takes snapshots, ultimately determining whether the message is a duplicate or not relying mainly on persistent.</p>
<p>PersistentTopic will first call MessageDeduplication#isDuplication when it receives a message to write to determine if it is a duplicate message. The logic for this is simple and is shown below with the code omitted.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="n">MessageDupStatus</span> <span class="nf">isDuplicate</span><span class="o">(</span><span class="n">PublishContext</span> <span class="n">publishContext</span><span class="o">,</span> <span class="n">ByteBuf</span> <span class="n">headersAndPayload</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Synchronize the get() and subsequent put() on the map. This would only be relevant if the producer
</span><span class="c1"></span>    <span class="c1">// disconnects and re-connects very quickly. At that point the call can be coming from a different thread
</span><span class="c1"></span>    <span class="kd">synchronized</span> <span class="o">(</span><span class="n">highestSequencedPushed</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Long</span> <span class="n">lastSequenceIdPushed</span> <span class="o">=</span> <span class="n">highestSequencedPushed</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">producerName</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">lastSequenceIdPushed</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">sequenceId</span> <span class="o">&lt;=</span> <span class="n">lastSequenceIdPushed</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">log</span><span class="o">.</span><span class="na">isDebugEnabled</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">log</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">&#34;[{}] Message identified as duplicated producer={} seq-id={} -- highest-seq-id={}&#34;</span><span class="o">,</span>
                        <span class="n">topic</span><span class="o">.</span><span class="na">getName</span><span class="o">(),</span> <span class="n">producerName</span><span class="o">,</span> <span class="n">sequenceId</span><span class="o">,</span> <span class="n">lastSequenceIdPushed</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="c1">// Also need to check sequence ids that has been persisted.
</span><span class="c1"></span>            <span class="c1">// If current message&#39;s seq id is smaller or equals to the
</span><span class="c1"></span>            <span class="c1">// lastSequenceIdPersisted than its definitely a dup
</span><span class="c1"></span>            <span class="c1">// If current message&#39;s seq id is between lastSequenceIdPersisted and
</span><span class="c1"></span>            <span class="c1">// lastSequenceIdPushed, then we cannot be sure whether the message is a dup or not
</span><span class="c1"></span>            <span class="c1">// we should return an error to the producer for the latter case so that it can retry at a future time
</span><span class="c1"></span>            <span class="n">Long</span> <span class="n">lastSequenceIdPersisted</span> <span class="o">=</span> <span class="n">highestSequencedPersisted</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">producerName</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">lastSequenceIdPersisted</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">sequenceId</span> <span class="o">&lt;=</span> <span class="n">lastSequenceIdPersisted</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">MessageDupStatus</span><span class="o">.</span><span class="na">Dup</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">MessageDupStatus</span><span class="o">.</span><span class="na">Unknown</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">highestSequencedPushed</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">producerName</span><span class="o">,</span> <span class="n">highestSequenceId</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">MessageDupStatus</span><span class="o">.</span><span class="na">NotDup</span><span class="o">;</span>
<span class="o">}</span>      
</code></pre></td></tr></table>
</div>
</div><p>It can be seen that there are three states returned.</p>
<ul>
<li>MessageDupStatus.NotDup(non-duplicate message): If the sequenceId of the message sent by the producer is <strong>greater</strong> than the highSequenceId of the <strong>memory</strong> maintained by PersistentTopic, the message must be a duplicate.</li>
<li>MessageDupStatus.Dup(duplicate message): if sequenceId &lt; highSequenceId, and sequenceId &lt; highPersistentSequenceId, then it must be a duplicate message. persistentTopic will return confirmation that it is a duplicate message.</li>
<li>MessageDupStatus.Unknown: If sequenceId &lt; highSequenceId and sequenceId &gt; highPersistentSequenceId, then it is an unknown status; PersistentTopic will throw DupUnknownException to make the producer side retry</li>
</ul>
<p>The Unknown state occurs because the highPersistentSequenceId set and the highSequenceId set are not maintained at the same point in time.</p>
<ul>
<li>highSequenceId: The highSequenceId collection is updated each time the result is determined to be NotDup (before the message is persisted).</li>
<li>highPersistentSequenceId: The highPersistentSequenceId collection is updated after the message is actually written to bk (after the message is persisted).</li>
</ul>
<p>The original intention of this design is because the execution of pulsar is asynchronous, after the current message is judged, if the message has not been written to bk successfully, the next message comes again, for high concurrency processing, this should not wait for the previous message to be written before doing the judgment of that message, so there is a collection of memory and a collection of persistence.</p>
<p>In most cases where a bk can be written to are successful, highSequenceId and highPersistentSequenceId are able to be consistent, so the Unknown state does not occur. In the event of a write bk exception, the highPersistentSequenceId will not be updated and the Unknown state will occur, and the PersistentTopic will call MessageDeduplication# when it receives the Unknown and Dup. resetHighestSequenceIdPushed() method to overwrite the highSequenceId collection with highPersistentSequenceId to keep the two collections consistent.</p>
<h3 id="how-is-the-messagededuplication-state-persisted">How is the MessageDeduplication state persisted?</h3>
<p>Each broker in pulsar is stateless and if a broker hangs, the topic responsible for that broker is scheduled to run on another available broker. The main state to be persisted in MessageDeduplication is the highestSequencedPersisted collection.</p>
<p>The broker starts a timed thread to call the MessageDeduplication#takeSnapshot method to persist the state snapshot based on the user&rsquo;s configuration at startup. The state is written to the bk, using the ManagedCursor&rsquo;s properties metadata store.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kt">void</span> <span class="nf">takeSnapshot</span><span class="o">(</span><span class="n">PositionImpl</span> <span class="n">position</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">log</span><span class="o">.</span><span class="na">isDebugEnabled</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">log</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">&#34;[{}] Taking snapshot of sequence ids map&#34;</span><span class="o">,</span> <span class="n">topic</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span> <span class="n">snapshot</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeMap</span><span class="o">&lt;&gt;();</span>
    <span class="n">highestSequencedPersisted</span><span class="o">.</span><span class="na">forEach</span><span class="o">((</span><span class="n">producerName</span><span class="o">,</span> <span class="n">sequenceId</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">snapshot</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">maxNumberOfProducers</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">snapshot</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">producerName</span><span class="o">,</span> <span class="n">sequenceId</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">});</span>

    <span class="n">managedCursor</span><span class="o">.</span><span class="na">asyncMarkDelete</span><span class="o">(</span><span class="n">position</span><span class="o">,</span> <span class="n">snapshot</span><span class="o">,</span> <span class="k">new</span> <span class="n">MarkDeleteCallback</span><span class="o">()</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">markDeleteComplete</span><span class="o">(</span><span class="n">Object</span> <span class="n">ctx</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">log</span><span class="o">.</span><span class="na">isDebugEnabled</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">log</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">&#34;[{}] Stored new deduplication snapshot at {}&#34;</span><span class="o">,</span> <span class="n">topic</span><span class="o">.</span><span class="na">getName</span><span class="o">(),</span> <span class="n">position</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">lastSnapshotTimestamp</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">markDeleteFailed</span><span class="o">(</span><span class="n">ManagedLedgerException</span> <span class="n">exception</span><span class="o">,</span> <span class="n">Object</span> <span class="n">ctx</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">log</span><span class="o">.</span><span class="na">warn</span><span class="o">(</span><span class="s">&#34;[{}] Failed to store new deduplication snapshot at {}&#34;</span><span class="o">,</span> <span class="n">topic</span><span class="o">.</span><span class="na">getName</span><span class="o">(),</span> <span class="n">position</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">},</span> <span class="kc">null</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>So the question is, since state is persisted asynchronously, how does pulsar ensure that unpersisted state can be restored correctly after drifting?</p>
<p>When the broker starts, it will first read the latest state stored in the cursor, then it will start from the position corresponding to that state, re-consume it to the latest position of the ledger, and then come to guarantee the recovery to the latest sequenceId of each producer under that topic. replayCursor method</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="n">CompletableFuture</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span> <span class="nf">recoverSequenceIdsMap</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// Load the sequence ids from the snapshot in the cursor properties
</span><span class="c1"></span>    <span class="n">managedCursor</span><span class="o">.</span><span class="na">getProperties</span><span class="o">().</span><span class="na">forEach</span><span class="o">((</span><span class="n">k</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="n">highestSequencedPushed</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">v</span><span class="o">);</span>
        <span class="n">highestSequencedPersisted</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">v</span><span class="o">);</span>
    <span class="o">});</span>

    <span class="c1">// Replay all the entries and apply all the sequence ids updates
</span><span class="c1"></span>    <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&#34;[{}] Replaying {} entries for deduplication&#34;</span><span class="o">,</span> <span class="n">topic</span><span class="o">.</span><span class="na">getName</span><span class="o">(),</span> <span class="n">managedCursor</span><span class="o">.</span><span class="na">getNumberOfEntries</span><span class="o">());</span>
    <span class="n">CompletableFuture</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CompletableFuture</span><span class="o">&lt;&gt;();</span>
    <span class="n">replayCursor</span><span class="o">(</span><span class="n">future</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">future</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="summary">Summary</h2>
<p>Pulsar&rsquo;s implementation of the Effectively once semantics requires the user to work with external storage, Pulsar just provides the api and the best solution. On the producer side, Pulsar implements producer de-duplication by maintaining the relationship between the producer&rsquo;s corresponding highSequenceId, which can solve producer idempotency for producers with traceability. If the guarantee of Effectively once semantics is needed, a suitable solution needs to be made according to the specific business scenario.</p>
<p>Business scenario 1: Producer with traceability</p>
<p>For example, the data on the producer side is read from a file and the sequenceId can be used to guarantee producer idempotency. Then you can use the producer message deduplication + consumer reader pattern, so that the consumer side only needs to rely on external storage of the lastMessageId consumed at the moment.</p>
<p>Business scenario 2: Producers that are not traceable</p>
<p>For example, if the data on the producer side is sent from an http request, then pulsar producer message deduplication cannot be used, so the consumer side needs to rely on external storage to store all messageId&rsquo;s (of business properties), thus realising the Effectively once semantics.</p>
<hr>
<p>Reference <code>https://shibd.github.io/pulsar-effectively-once/</code></p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/pulsar/">pulsar</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2021-08/kompute/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">General purpose GPU computing framework Kompute joins LF AI &amp; Data as a new sandbox project</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2021-08/firefox-92-fully-ship-webrender/">
            <span class="next-text nav-default">Mozilla plans to enable WebRender in Firefox across all platforms</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
