<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>About Redisson Lock - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="I wrote an article about the red lock implementation in Redis a long, long time ago, but in a production environment, the distributed lock component used in my projects has always been Redisson, a Java-based Redis client framework written with features of In-Memory Data Grid Redisson is a Java-based Redis client framework (Redis Java Client) with features of In-Memory Data Grid, which extends the basic data types of Redis with" /><meta name="keywords" content="Redisson,Redis,Lock" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2021-08/about-redisson-lock/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="About Redisson Lock" />
<meta property="og:description" content="I wrote an article about the red lock implementation in Redis a long, long time ago, but in a production environment, the distributed lock component used in my projects has always been Redisson, a Java-based Redis client framework written with features of In-Memory Data Grid Redisson is a Java-based Redis client framework (Redis Java Client) with features of In-Memory Data Grid, which extends the basic data types of Redis with" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2021-08/about-redisson-lock/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-08-09T12:27:06+08:00" />
<meta property="article:modified_time" content="2021-08-09T12:27:06+08:00" />

<meta itemprop="name" content="About Redisson Lock">
<meta itemprop="description" content="I wrote an article about the red lock implementation in Redis a long, long time ago, but in a production environment, the distributed lock component used in my projects has always been Redisson, a Java-based Redis client framework written with features of In-Memory Data Grid Redisson is a Java-based Redis client framework (Redis Java Client) with features of In-Memory Data Grid, which extends the basic data types of Redis with"><meta itemprop="datePublished" content="2021-08-09T12:27:06+08:00" />
<meta itemprop="dateModified" content="2021-08-09T12:27:06+08:00" />
<meta itemprop="wordCount" content="11511">
<meta itemprop="keywords" content="redisson,redis," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="About Redisson Lock"/>
<meta name="twitter:description" content="I wrote an article about the red lock implementation in Redis a long, long time ago, but in a production environment, the distributed lock component used in my projects has always been Redisson, a Java-based Redis client framework written with features of In-Memory Data Grid Redisson is a Java-based Redis client framework (Redis Java Client) with features of In-Memory Data Grid, which extends the basic data types of Redis with"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">About Redisson Lock</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-08-09 12:27:06 </span>
        <div class="post-category">
            <a href="/categories/implementation-details/"> implementation-details </a>
            <a href="/categories/skills/"> skills </a>
            <a href="/categories/tools/"> tools </a>
            </div>
          <span class="more-meta"> 11511 words </span>
          <span class="more-meta"> 23 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#fundamentals">Fundamentals</a></li>
        <li><a href="#using-rlock-in-redisson">Using RLock in Redisson</a></li>
        <li><a href="#the-principle-of-rlock-implementation-in-redisson">The principle of RLock implementation in Redisson</a></li>
        <li><a href="#jedis-based-implementation-of-redisson-like-distributed-locking-capabilities">Jedis-based implementation of Redisson-like distributed locking capabilities</a></li>
        <li><a href="#summary">Summary</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>I wrote an article about the red lock implementation in Redis a long, long time ago, but in a production environment, the distributed lock component used in my projects has always been Redisson, a Java-based Redis client framework written with features of In-Memory Data Grid Redisson is a Java-based Redis client framework (Redis Java Client) with features of In-Memory Data Grid, which extends the basic data types of Redis with a variety of advanced data structures, as shown in the official introduction.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/08/09/fd0e17009345405d8ebc416b8f46f471.png" alt=" "></p>
<p>The R(ed) Lock implementation to be analyzed in this article is only one of the very small modules, other advanced features can be selected on demand. The following section will cover the basic principles, source code analysis, and Jedis-like implementation. The Redisson source code analyzed in this article is the main branch source code of the Redisson project around 2020-01, corresponding to version 3.14.1.</p>
<h2 id="fundamentals">Fundamentals</h2>
<p>The basics of red lock are actually &ldquo;out in the open&rdquo; on the Redis website&rsquo;s front page documentation (the link is <a href="https://redis.io/topics/distlock">https://redis.io/topics/distlock</a>).</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/08/09/c43d4cfef197489aa4d9cebd095cb471.png" alt=" "></p>
<p>Roughly speaking: distributed locks are a very useful primitive in many environments where different processes must operate in a mutually exclusive manner using shared resources. This attempts to provide a more speciﬁc algorithm to implement distributed locks for Redis. We propose an algorithm called Redlock, which implements DLM (guessing that it stands for Distributed Lock Manager), which we believe is more secure than the normal single-instance approach.</p>
<p>Three core features of the algorithm (three minimum guarantees).</p>
<ul>
<li>Safety property: Mutual exclusion. At any given moment, only one client can hold a lock.</li>
<li>Liveness property A: Deadlock free. Eventually it is always possible to acquire a lock, even if the client that locked a resource crashes or gets partitioned.</li>
<li>Liveness property B: Fault tolerance. As long as the majority of Redis nodes are up, clients are able to acquire and release locks.</li>
</ul>
<p>The documentation also points out that the current implementation of the algorithm for failover still has obvious problems with competing conditions (described, I believe, under the Redis master-slave architecture):.</p>
<ul>
<li>Client A acquires the lock in the Redis master node (assuming the locked resource is X)</li>
<li>Redis master node crashes before it can synchronize the KEY to the Redis slave node</li>
<li>Redis slave node is promoted to master node due to failure</li>
<li>At this point, Client B succeeds in acquiring the lock for resource X (the problem is that the lock for resource X has already been acquired by Client A earlier, so that there is a concurrency problem)</li>
</ul>
<p>The implementation of the algorithm is simple, and the locking command under a single Redis instance is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">SET <span class="nv">$resource_name</span> <span class="nv">$random_value</span> NX PX <span class="nv">$ttl</span>
</code></pre></td></tr></table>
</div>
</div><p><code>Nx</code> and <code>PX</code> here are enhanced parameters for the <code>SET</code> command, which since Redis version <code>2.6.12</code> has provided the optional compound operator.</p>
<ul>
<li>EX: set the timeout time in seconds</li>
<li>PX: Set the timeout time in milliseconds</li>
<li>NX: abbreviation of IF NOT EXIST, K-V will be set only if KEY does not exist, set successfully to return 1, otherwise return 0</li>
<li>XX: abbreviation of IF EXIST, K-V will be set only if KEY exists, successful setting returns 1, otherwise returns 0</li>
</ul>
<p>The unlock command under a single Redis instance is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># KEYS[1] = $resource_name</span>
<span class="c1"># ARGV[1] = $random_value</span>
<span class="k">if</span> redis.call<span class="o">(</span><span class="s2">&#34;get&#34;</span>,KEYS<span class="o">[</span>1<span class="o">])</span> <span class="o">==</span> ARGV<span class="o">[</span>1<span class="o">]</span> <span class="k">then</span>
    <span class="k">return</span> redis.call<span class="o">(</span><span class="s2">&#34;del&#34;</span>,KEYS<span class="o">[</span>1<span class="o">])</span>
<span class="k">else</span>
    <span class="k">return</span> <span class="m">0</span>
end
</code></pre></td></tr></table>
</div>
</div><h2 id="using-rlock-in-redisson">Using RLock in Redisson</h2>
<p>To use <code>RLock</code>, you need to first instantiate <code>Redisson</code>, which has been adapted to Redis' Sentinel, Cluster, Normal Master-Slave, and Standalone modes, because I have only installed standalone Redis locally, so here is a demonstration using the standalone mode configuration. Instantiating <code>RedissonClient</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">static</span> <span class="n">RedissonClient</span> <span class="n">REDISSON</span><span class="o">;</span>

<span class="nd">@BeforeClass</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">beforeClass</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
    <span class="n">Config</span> <span class="n">config</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Config</span><span class="o">();</span>
    <span class="c1">// Standalone
</span><span class="c1"></span>    <span class="n">config</span><span class="o">.</span><span class="na">useSingleServer</span><span class="o">()</span>
            <span class="o">.</span><span class="na">setTimeout</span><span class="o">(</span><span class="n">10000</span><span class="o">)</span>
            <span class="o">.</span><span class="na">setAddress</span><span class="o">(</span><span class="s">&#34;redis://127.0.0.1:6379&#34;</span><span class="o">);</span>
    <span class="n">REDISSON</span> <span class="o">=</span> <span class="n">Redisson</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="n">config</span><span class="o">);</span>
<span class="c1">//        // Master-Slave
</span><span class="c1">//        config.useMasterSlaveServers()
</span><span class="c1">//                .setMasterAddress(&#34;主节点连接地址&#34;)
</span><span class="c1">//                .setSlaveAddresses(Sets.newHashSet(&#34;从节点连接地址&#34;));
</span><span class="c1">//        REDISSON = Redisson.create(config);
</span><span class="c1">//        // Sentinel
</span><span class="c1">//        config.useSentinelServers()
</span><span class="c1">//                .setMasterName(&#34;Master名称&#34;)
</span><span class="c1">//                .addSentinelAddress(new String[]{&#34;哨兵连接地址&#34;});
</span><span class="c1">//        REDISSON = Redisson.create(config);
</span><span class="c1">//        // Cluster
</span><span class="c1">//        config.useClusterServers()
</span><span class="c1">//                .addNodeAddress(new String[]{&#34;集群节点连接地址&#34;});
</span><span class="c1">//        REDISSON = Redisson.create(config);
</span><span class="c1"></span><span class="o">}</span>

</code></pre></td></tr></table>
</div>
</div><p>Locking and unlocking.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">testLockAndUnLock</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
    <span class="n">String</span> <span class="n">resourceName</span> <span class="o">=</span> <span class="s">&#34;resource:x&#34;</span><span class="o">;</span>
    <span class="n">RLock</span> <span class="n">lock</span> <span class="o">=</span> <span class="n">REDISSON</span><span class="o">.</span><span class="na">getLock</span><span class="o">(</span><span class="n">resourceName</span><span class="o">);</span>
    <span class="n">Thread</span> <span class="n">threadA</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
            <span class="n">process</span><span class="o">(</span><span class="n">resourceName</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">&#34;线程%s释放资源%s的锁&#34;</span><span class="o">,</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">(),</span> <span class="n">resourceName</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">},</span> <span class="s">&#34;threadA&#34;</span><span class="o">);</span>
    <span class="n">Thread</span> <span class="n">threadB</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
            <span class="n">process</span><span class="o">(</span><span class="n">resourceName</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">&#34;线程%s释放资源%s的锁&#34;</span><span class="o">,</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">(),</span> <span class="n">resourceName</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">},</span> <span class="s">&#34;threadB&#34;</span><span class="o">);</span>
    <span class="n">threadA</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="n">threadB</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">Long</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">process</span><span class="o">(</span><span class="n">String</span> <span class="n">resourceName</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">String</span> <span class="n">threadName</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">();</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">&#34;线程%s获取到资源%s的锁&#34;</span><span class="o">,</span> <span class="n">threadName</span><span class="o">,</span> <span class="n">resourceName</span><span class="o">));</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">1000</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">ignore</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 某次执行的输出结果
</span><span class="c1"></span><span class="nl">线程threadB获取到资源resource:</span><span class="n">x的锁</span>
<span class="nl">线程threadB释放资源resource:</span><span class="n">x的锁</span>
<span class="nl">线程threadA获取到资源resource:</span><span class="n">x的锁</span>
<span class="nl">线程threadA释放资源resource:</span><span class="n">x的锁</span>
</code></pre></td></tr></table>
</div>
</div><p>More often than not, we choose APIs with a wait time period and a maximum lock holding time.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">testTryLockAndUnLock</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
    <span class="n">String</span> <span class="n">resourceName</span> <span class="o">=</span> <span class="s">&#34;resource:x&#34;</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">waitTime</span> <span class="o">=</span> <span class="n">500</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">leaseTime</span> <span class="o">=</span> <span class="n">1000</span><span class="o">;</span>
    <span class="n">Thread</span> <span class="n">threadA</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="n">process</span><span class="o">(</span><span class="n">resourceName</span><span class="o">,</span> <span class="n">waitTime</span><span class="o">,</span> <span class="n">leaseTime</span><span class="o">);</span>
    <span class="o">},</span> <span class="s">&#34;threadA&#34;</span><span class="o">);</span>
    <span class="n">Thread</span> <span class="n">threadB</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="n">process</span><span class="o">(</span><span class="n">resourceName</span><span class="o">,</span> <span class="n">waitTime</span><span class="o">,</span> <span class="n">leaseTime</span><span class="o">);</span>
    <span class="o">},</span> <span class="s">&#34;threadB&#34;</span><span class="o">);</span>
    <span class="n">threadA</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="n">threadB</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">Long</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">process</span><span class="o">(</span><span class="n">String</span> <span class="n">resourceName</span><span class="o">,</span> <span class="kt">int</span> <span class="n">waitTime</span><span class="o">,</span> <span class="kt">int</span> <span class="n">leaseTime</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">RLock</span> <span class="n">lock</span> <span class="o">=</span> <span class="n">REDISSON</span><span class="o">.</span><span class="na">getLock</span><span class="o">(</span><span class="n">resourceName</span><span class="o">);</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">threadName</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">();</span>
        <span class="kt">boolean</span> <span class="n">tryLock</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="na">tryLock</span><span class="o">(</span><span class="n">waitTime</span><span class="o">,</span> <span class="n">leaseTime</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">tryLock</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">&#34;线程%s获取到资源%s的锁&#34;</span><span class="o">,</span> <span class="n">threadName</span><span class="o">,</span> <span class="n">resourceName</span><span class="o">));</span>
                <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">800</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
                <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">&#34;线程%s释放资源%s的锁&#34;</span><span class="o">,</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">(),</span> <span class="n">resourceName</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">&#34;线程%s获取资源%s的锁失败,等待时间:%d ms&#34;</span><span class="o">,</span> <span class="n">threadName</span><span class="o">,</span> <span class="n">resourceName</span><span class="o">,</span> <span class="n">waitTime</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">interrupt</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// 某次执行的输出结果
</span><span class="c1"></span><span class="nl">线程threadA获取到资源resource:</span><span class="n">x的锁</span>
<span class="nl">线程threadB获取资源resource:</span><span class="n">x的锁失败</span><span class="o">,</span><span class="n">等待时间</span><span class="o">:</span><span class="n">500</span> <span class="n">ms</span>
<span class="nl">线程threadA释放资源resource:</span><span class="n">x的锁</span>
</code></pre></td></tr></table>
</div>
</div><p>To make it easier to use, you can refer to the programmatic transactions in spring-tx for a light wrapper like this.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="nd">@RequiredArgsConstructor</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">RedissonLockProvider</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="n">RedissonClient</span> <span class="n">redissonClient</span><span class="o">;</span>

    <span class="kd">public</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="nf">executeInLock</span><span class="o">(</span><span class="n">String</span> <span class="n">resourceName</span><span class="o">,</span> <span class="n">LockAction</span> <span class="n">lockAction</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">RLock</span> <span class="n">lock</span> <span class="o">=</span> <span class="n">redissonClient</span><span class="o">.</span><span class="na">getLock</span><span class="o">(</span><span class="n">resourceName</span><span class="o">);</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
            <span class="n">lockAction</span><span class="o">.</span><span class="na">onAcquire</span><span class="o">(</span><span class="n">resourceName</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">lockAction</span><span class="o">.</span><span class="na">doInLock</span><span class="o">(</span><span class="n">resourceName</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
            <span class="n">lockAction</span><span class="o">.</span><span class="na">onExit</span><span class="o">(</span><span class="n">resourceName</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="nf">executeInLock</span><span class="o">(</span><span class="n">String</span> <span class="n">resourceName</span><span class="o">,</span> <span class="kt">int</span> <span class="n">waitTime</span><span class="o">,</span> <span class="kt">int</span> <span class="n">leaseTime</span><span class="o">,</span> <span class="n">LockAction</span> <span class="n">lockAction</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
        <span class="n">RLock</span> <span class="n">lock</span> <span class="o">=</span> <span class="n">redissonClient</span><span class="o">.</span><span class="na">getLock</span><span class="o">(</span><span class="n">resourceName</span><span class="o">);</span>
        <span class="kt">boolean</span> <span class="n">tryLock</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="na">tryLock</span><span class="o">(</span><span class="n">waitTime</span><span class="o">,</span> <span class="n">leaseTime</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">tryLock</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">lockAction</span><span class="o">.</span><span class="na">onAcquire</span><span class="o">(</span><span class="n">resourceName</span><span class="o">);</span>
                <span class="k">return</span> <span class="n">lockAction</span><span class="o">.</span><span class="na">doInLock</span><span class="o">(</span><span class="n">resourceName</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
                <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
                <span class="n">lockAction</span><span class="o">.</span><span class="na">onExit</span><span class="o">(</span><span class="n">resourceName</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">executeInLockWithoutResult</span><span class="o">(</span><span class="n">String</span> <span class="n">resourceName</span><span class="o">,</span> <span class="kt">int</span> <span class="n">waitTime</span><span class="o">,</span> <span class="kt">int</span> <span class="n">leaseTime</span><span class="o">,</span> <span class="n">LockActionWithoutResult</span> <span class="n">lockAction</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
        <span class="n">RLock</span> <span class="n">lock</span> <span class="o">=</span> <span class="n">redissonClient</span><span class="o">.</span><span class="na">getLock</span><span class="o">(</span><span class="n">resourceName</span><span class="o">);</span>
        <span class="kt">boolean</span> <span class="n">tryLock</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="na">tryLock</span><span class="o">(</span><span class="n">waitTime</span><span class="o">,</span> <span class="n">leaseTime</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">tryLock</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">lockAction</span><span class="o">.</span><span class="na">onAcquire</span><span class="o">(</span><span class="n">resourceName</span><span class="o">);</span>
                <span class="n">lockAction</span><span class="o">.</span><span class="na">doInLock</span><span class="o">(</span><span class="n">resourceName</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
                <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
                <span class="n">lockAction</span><span class="o">.</span><span class="na">onExit</span><span class="o">(</span><span class="n">resourceName</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">executeInLockWithoutResult</span><span class="o">(</span><span class="n">String</span> <span class="n">resourceName</span><span class="o">,</span> <span class="n">LockActionWithoutResult</span> <span class="n">lockAction</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">RLock</span> <span class="n">lock</span> <span class="o">=</span> <span class="n">redissonClient</span><span class="o">.</span><span class="na">getLock</span><span class="o">(</span><span class="n">resourceName</span><span class="o">);</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
            <span class="n">lockAction</span><span class="o">.</span><span class="na">onAcquire</span><span class="o">(</span><span class="n">resourceName</span><span class="o">);</span>
            <span class="n">lockAction</span><span class="o">.</span><span class="na">doInLock</span><span class="o">(</span><span class="n">resourceName</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
            <span class="n">lockAction</span><span class="o">.</span><span class="na">onExit</span><span class="o">(</span><span class="n">resourceName</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="nd">@FunctionalInterface</span>
<span class="kd">interface</span> <span class="nc">LockAction</span> <span class="o">{</span>

    <span class="k">default</span> <span class="kt">void</span> <span class="nf">onAcquire</span><span class="o">(</span><span class="n">String</span> <span class="n">resourceName</span><span class="o">)</span> <span class="o">{</span>

    <span class="o">}</span>

    <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="nf">doInLock</span><span class="o">(</span><span class="n">String</span> <span class="n">resourceName</span><span class="o">);</span>

    <span class="k">default</span> <span class="kt">void</span> <span class="nf">onExit</span><span class="o">(</span><span class="n">String</span> <span class="n">resourceName</span><span class="o">)</span> <span class="o">{</span>

    <span class="o">}</span>
<span class="o">}</span>

<span class="nd">@FunctionalInterface</span>
<span class="kd">interface</span> <span class="nc">LockActionWithoutResult</span> <span class="o">{</span>

    <span class="k">default</span> <span class="kt">void</span> <span class="nf">onAcquire</span><span class="o">(</span><span class="n">String</span> <span class="n">resourceName</span><span class="o">)</span> <span class="o">{</span>

    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">doInLock</span><span class="o">(</span><span class="n">String</span> <span class="n">resourceName</span><span class="o">);</span>

    <span class="k">default</span> <span class="kt">void</span> <span class="nf">onExit</span><span class="o">(</span><span class="n">String</span> <span class="n">resourceName</span><span class="o">)</span> <span class="o">{</span>

    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Using RedissonLockProvider (for information only).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">testRedissonLockProvider</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
    <span class="n">RedissonLockProvider</span> <span class="n">provider</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RedissonLockProvider</span><span class="o">(</span><span class="n">REDISSON</span><span class="o">);</span>
    <span class="n">String</span> <span class="n">resourceName</span> <span class="o">=</span> <span class="s">&#34;resource:x&#34;</span><span class="o">;</span>
    <span class="n">Thread</span> <span class="n">threadA</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="n">provider</span><span class="o">.</span><span class="na">executeInLockWithoutResult</span><span class="o">(</span><span class="n">resourceName</span><span class="o">,</span> <span class="k">new</span> <span class="n">LockActionWithoutResult</span><span class="o">()</span> <span class="o">{</span>

            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onAcquire</span><span class="o">(</span><span class="n">String</span> <span class="n">resourceName</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">&#34;线程%s获取到资源%s的锁&#34;</span><span class="o">,</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">(),</span> <span class="n">resourceName</span><span class="o">));</span>
            <span class="o">}</span>

            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">doInLock</span><span class="o">(</span><span class="n">String</span> <span class="n">resourceName</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">800</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">ignore</span><span class="o">)</span> <span class="o">{</span>

                <span class="o">}</span>
            <span class="o">}</span>

            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onExit</span><span class="o">(</span><span class="n">String</span> <span class="n">resourceName</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">&#34;线程%s释放资源%s的锁&#34;</span><span class="o">,</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">(),</span> <span class="n">resourceName</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">});</span>
    <span class="o">},</span> <span class="s">&#34;threadA&#34;</span><span class="o">);</span>
    <span class="n">Thread</span> <span class="n">threadB</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="n">provider</span><span class="o">.</span><span class="na">executeInLockWithoutResult</span><span class="o">(</span><span class="n">resourceName</span><span class="o">,</span> <span class="k">new</span> <span class="n">LockActionWithoutResult</span><span class="o">()</span> <span class="o">{</span>

            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onAcquire</span><span class="o">(</span><span class="n">String</span> <span class="n">resourceName</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">&#34;线程%s获取到资源%s的锁&#34;</span><span class="o">,</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">(),</span> <span class="n">resourceName</span><span class="o">));</span>
            <span class="o">}</span>

            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">doInLock</span><span class="o">(</span><span class="n">String</span> <span class="n">resourceName</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">800</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">ignore</span><span class="o">)</span> <span class="o">{</span>

                <span class="o">}</span>
            <span class="o">}</span>

            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onExit</span><span class="o">(</span><span class="n">String</span> <span class="n">resourceName</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">&#34;线程%s释放资源%s的锁&#34;</span><span class="o">,</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">(),</span> <span class="n">resourceName</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">});</span>
    <span class="o">},</span> <span class="s">&#34;threadB&#34;</span><span class="o">);</span>
    <span class="n">threadA</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="n">threadB</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">Long</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span>
<span class="o">}</span>
<span class="c1">// 某次执行结果
</span><span class="c1"></span><span class="nl">线程threadA获取到资源resource:</span><span class="n">x的锁</span>
<span class="nl">线程threadA释放资源resource:</span><span class="n">x的锁</span>
<span class="nl">线程threadB获取到资源resource:</span><span class="n">x的锁</span>
<span class="nl">线程threadB释放资源resource:</span><span class="n">x的锁</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="the-principle-of-rlock-implementation-in-redisson">The principle of RLock implementation in Redisson</h2>
<p>The implementation of RLock in Redisson is basically a reference to the Redis red lock algorithm, but with improvements to the original red lock algorithm, including the following features.</p>
<ul>
<li>Mutual Exclusion</li>
<li>Deadlock-free</li>
<li>Reentrant, similar to ReentrantLock, the same thread can repeatedly obtain the same resource lock (generally implemented using a counter), the reentrant feature of the lock is generally conducive to improving the utilization of resources</li>
<li>Renewal, this is a relatively avant-garde solution, that is, if a client to the resource X permanently locked, then not directly to the KEY survival period set to -1, but through a daemon thread every fixed period to extend the KEY expiration time, so as to achieve the premise of the daemon thread is not killed, to avoid the collapse of the client caused by the lock can not be released for a long time to occupy the resources of the problem</li>
<li>LockPubSub, which relies on org.redisson.pubsub, is used to subscribe and notify lock release events.</li>
<li>Not exactly refer to the red lock algorithm implementation, the data type chosen is HASH, with Lua script to complete the atomicity of multiple commands</li>
</ul>
<p>Renewal or extension of the KEY expiration time in Redisson using watch dog implementation, understanding for the renewal of the guard thread, the underlying reliance on Netty&rsquo;s time wheel HashedWheelTimer and task io.netty.util.Timeout implementation, commonly known as watchdog, the following will be analyzed in detail.</p>
<p>First look at the class diagram of RLock.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/08/09/493e2e8cdcc74578ae6030eb4b355660.png" alt=" "></p>
<blockquote>
<p>There is a point of confusion here, the annotation of RedissonRedLock (a subclass of RedissonMultiLock) mentions RedLock locking algorithm implementation for multiple locks. But intuitively, RedissonLock is the core of the locking system, and the implementation follows the red locking algorithm.</p>
</blockquote>
<p>RedissonLock is a direct implementation of RLock, which is also the core class of the distributed lock implementation, as seen in the source code Redisson#getLock() is a direct instantiation of RedissonLock</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Redisson</span> <span class="kd">implements</span> <span class="n">RedissonClient</span> <span class="o">{</span>
    
    <span class="c1">// ...... 省略其他代码
</span><span class="c1"></span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">RLock</span> <span class="nf">getLock</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">RedissonLock</span><span class="o">(</span><span class="n">connectionManager</span><span class="o">.</span><span class="na">getCommandExecutor</span><span class="o">(),</span> <span class="n">name</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// ...... 省略其他代码
</span><span class="c1"></span><span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The class inheritance diagram of RedissonLock is as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/08/09/800540f6a3744245a9608bf5990ee890.png" alt=" "></p>
<p>Several points of awareness are needed here.</p>
<ul>
<li>RedissonLock implements all the methods of the java.util.concurrent.locks.Lock interface except for the newCondition() method, which means that it can be seamlessly adapted to the Lock interface, which is a boon for users who are used to the Lock interface API.</li>
<li>RedissonLock basically all synchronous API depends on the implementation of the asynchronous API, that is, the implementation of RLock depends on the implementation of RLockAsync, the underlying dependency is Netty&rsquo;s io.netty.util.concurrent.Promise, see RedissonPromise, if developers who have used Future in JUC should be more familiar with Future#get(), which is similar here</li>
<li>The simple functions of the several parent classes on the right are described as follows.
<ul>
<li>RObjectAsync: The base interface for all Redisson objects, providing some asynchronous methods for memory measurement, object copying, moving, etc.</li>
<li>RObject: synchronous version of RObjectAsync</li>
<li>RExpirableAsync: provides asynchronous methods related to object TTL</li>
<li>RExpirable: synchronous version of RExpirableAsync</li>
<li>RedissonObject: directly implements the methods in the class RObject interface</li>
<li>RedissonExpirable: mainly implements the methods in the RExpirable interface</li>
</ul>
</li>
</ul>
<p>Moving on to the constructor and core properties of RedissonLock first.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 存放entryName -&gt; ExpirationEntry，用于获取当前entryName的线程重入计数器和续期任务
</span><span class="c1"></span><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">ConcurrentMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">ExpirationEntry</span><span class="o">&gt;</span> <span class="n">EXPIRATION_RENEWAL_MAP</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConcurrentHashMap</span><span class="o">&lt;&gt;();</span>

<span class="c1">// 内部的锁持有的最大时间，来源于参数Config#lockWatchdogTimeout，用于控制续期的周期
</span><span class="c1"></span><span class="kd">protected</span> <span class="kt">long</span> <span class="n">internalLockLeaseTime</span><span class="o">;</span>

<span class="c1">// ID，唯一标识，是一个UUID
</span><span class="c1"></span><span class="kd">final</span> <span class="n">String</span> <span class="n">id</span><span class="o">;</span>

<span class="c1">// 
</span><span class="c1"></span><span class="kd">final</span> <span class="n">String</span> <span class="n">entryName</span><span class="o">;</span>

<span class="c1">// 锁释放事件订阅发布相关
</span><span class="c1"></span><span class="kd">protected</span> <span class="kd">final</span> <span class="n">LockPubSub</span> <span class="n">pubSub</span><span class="o">;</span>

<span class="c1">// 命令异步执行器实例
</span><span class="c1"></span><span class="kd">final</span> <span class="n">CommandAsyncExecutor</span> <span class="n">commandExecutor</span><span class="o">;</span>

<span class="cm">/**
</span><span class="cm"> * CommandAsyncExecutor是命令的异步执行器，里面的方法是相对底层的面向通讯框架的方法，包括异步写、异步读和同步结果获取等
</span><span class="cm"> * name参数就是getLock()时候传入的参数，其实就是最终同步到Redis中的KEY
</span><span class="cm"> */</span>
<span class="kd">public</span> <span class="nf">RedissonLock</span><span class="o">(</span><span class="n">CommandAsyncExecutor</span> <span class="n">commandExecutor</span><span class="o">,</span> <span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">(</span><span class="n">commandExecutor</span><span class="o">,</span> <span class="n">name</span><span class="o">);</span>
    <span class="k">this</span><span class="o">.</span><span class="na">commandExecutor</span> <span class="o">=</span> <span class="n">commandExecutor</span><span class="o">;</span>
    <span class="c1">// 这里的ID为外部初始化的UUID实例，调用toString()
</span><span class="c1"></span>    <span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">commandExecutor</span><span class="o">.</span><span class="na">getConnectionManager</span><span class="o">().</span><span class="na">getId</span><span class="o">();</span>
    <span class="k">this</span><span class="o">.</span><span class="na">internalLockLeaseTime</span> <span class="o">=</span> <span class="n">commandExecutor</span><span class="o">.</span><span class="na">getConnectionManager</span><span class="o">().</span><span class="na">getCfg</span><span class="o">().</span><span class="na">getLockWatchdogTimeout</span><span class="o">();</span>
    <span class="c1">// 这里的entryName = uuid值 + : + 外部传进来的name(KEY)，如559cc9df-bad8-4f6c-86a4-ffa51b7f1c36:resource:x
</span><span class="c1"></span>    <span class="k">this</span><span class="o">.</span><span class="na">entryName</span> <span class="o">=</span> <span class="n">id</span> <span class="o">+</span> <span class="s">&#34;:&#34;</span> <span class="o">+</span> <span class="n">name</span><span class="o">;</span>
    <span class="c1">// 初始化LockPubSub实例，用于订阅和发布锁释放的事件
</span><span class="c1"></span>    <span class="k">this</span><span class="o">.</span><span class="na">pubSub</span> <span class="o">=</span> <span class="n">commandExecutor</span><span class="o">.</span><span class="na">getConnectionManager</span><span class="o">().</span><span class="na">getSubscribeService</span><span class="o">().</span><span class="na">getLockPubSub</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// RedissonLock内部类ExpirationEntry，存放着线程重入的计数器和续期的Timeout任务
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">ExpirationEntry</span> <span class="o">{</span>
    
    <span class="c1">// 线程ID -&gt; 线程重入的次数
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">threadIds</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedHashMap</span><span class="o">&lt;&gt;();</span>
    <span class="kd">private</span> <span class="kd">volatile</span> <span class="n">Timeout</span> <span class="n">timeout</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="nf">ExpirationEntry</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="c1">// 这个方法主要记录线程重入的计数
</span><span class="c1"></span>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addThreadId</span><span class="o">(</span><span class="kt">long</span> <span class="n">threadId</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Integer</span> <span class="n">counter</span> <span class="o">=</span> <span class="n">threadIds</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">threadId</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">counter</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">counter</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">counter</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="n">threadIds</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">threadId</span><span class="o">,</span> <span class="n">counter</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasNoThreads</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">threadIds</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">Long</span> <span class="nf">getFirstThreadId</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">threadIds</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">threadIds</span><span class="o">.</span><span class="na">keySet</span><span class="o">().</span><span class="na">iterator</span><span class="o">().</span><span class="na">next</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">removeThreadId</span><span class="o">(</span><span class="kt">long</span> <span class="n">threadId</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Integer</span> <span class="n">counter</span> <span class="o">=</span> <span class="n">threadIds</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">threadId</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">counter</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">counter</span><span class="o">--;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">counter</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">threadIds</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">threadId</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">threadIds</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">threadId</span><span class="o">,</span> <span class="n">counter</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setTimeout</span><span class="o">(</span><span class="n">Timeout</span> <span class="n">timeout</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">timeout</span> <span class="o">=</span> <span class="n">timeout</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="n">Timeout</span> <span class="nf">getTimeout</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">timeout</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Here you need to pay attention to the lockWatchdogTimeout parameter in the Config.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/08/09/6c887c618b55418a985cd91149eb3104.png" alt=" "></p>
<p>Here is a list of methods to get names in RedissonLock for later use when analyzing these names as KEY for K-V structures.</p>
<ul>
<li>id: generated by the UUID instance instantiated at the time of configuration instantiation, from the source code analysis of each connection method of Redisson instance has a unique UUID, ConnectionManager initialization will call UUID id = UUID.randomUUUID(), I think it can be interpreted as the Redisson instance in a After all, in general, an application should only apply one type of Redisson connection</li>
<li>getEntryName(): returns the UUID + : + $KEY, e.g. 559cc9df-bad8-4f6c-86a4-ffa51b7f1c36:resource:x</li>
<li>getName(): returns $KEY, e.g. resource:x</li>
<li>getChannelName(): returns redisson_lock__channel:{$KEY}, e.g. redisson_lock__channel:{resource:x}</li>
<li>getLockName(long threadId): returns the UUID + : + $threadId, e.g. 559cc9df-bad8-4f6c-86a4-ffa51b7f1c36:1</li>
</ul>
<p>Moving on to the locking method, the core implementation is mainly.</p>
<ul>
<li>private void lock(long leaseTime, TimeUnit unit, boolean interruptibly) throws InterruptedException: lock method system</li>
<li>public boolean tryLock(long waitTime, long leaseTime, TimeUnit unit) throws InterruptedException: tryLock method system</li>
</ul>
<p>Let&rsquo;s first look at the lock() method system, which contains only the maximum holding time of the lock.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm"> * 获取锁，不指定等待时间，只指定锁的最大持有时间
</span><span class="cm"> * 通过interruptibly参数配置支持中断
</span><span class="cm"> */</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">(</span><span class="kt">long</span> <span class="n">leaseTime</span><span class="o">,</span> <span class="n">TimeUnit</span> <span class="n">unit</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">interruptibly</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
    <span class="kt">long</span> <span class="n">threadId</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getId</span><span class="o">();</span>
    <span class="c1">// 尝试获取锁，返回的ttl为空代表获取锁成功，返回的ttl代表已经存在的KEY的剩余存活时间
</span><span class="c1"></span>    <span class="n">Long</span> <span class="n">ttl</span> <span class="o">=</span> <span class="n">tryAcquire</span><span class="o">(</span><span class="n">leaseTime</span><span class="o">,</span> <span class="n">unit</span><span class="o">,</span> <span class="n">threadId</span><span class="o">);</span>
    <span class="c1">// lock acquired
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">ttl</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// 订阅redisson_lock__channel:{$KEY}，其实本质的目的是为了客户端通过Redis的订阅发布，感知到解锁的事件
</span><span class="c1"></span>    <span class="c1">// 这个方法会在LockPubSub中注册一个entryName -&gt; RedissonLockEntry的哈希映射，RedissonLockEntry实例中存放着RPromise&lt;RedissonLockEntry&gt;结果，一个信号量形式的锁和订阅方法重入计数器
</span><span class="c1"></span>    <span class="c1">// 下面的死循环中的getEntry()或者RPromise&lt;RedissonLockEntry&gt;#getNow()就是从这个映射中获取的
</span><span class="c1"></span>    <span class="n">RFuture</span><span class="o">&lt;</span><span class="n">RedissonLockEntry</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="n">subscribe</span><span class="o">(</span><span class="n">threadId</span><span class="o">);</span>
    <span class="c1">// 同步订阅执行，获取注册订阅Channel的响应，区分是否支持中断
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">interruptibly</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">commandExecutor</span><span class="o">.</span><span class="na">syncSubscriptionInterrupted</span><span class="o">(</span><span class="n">future</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="n">commandExecutor</span><span class="o">.</span><span class="na">syncSubscription</span><span class="o">(</span><span class="n">future</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">// 走到下面的for循环说明返回的ttl不为空，也就是Redis已经存在对应的KEY，有其他客户端已经获取到锁，此客户端线程的调用需要阻塞等待获取锁
</span><span class="c1"></span>    <span class="k">try</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 死循环中尝试获取锁，这个是后面会分析的方法
</span><span class="c1"></span>            <span class="n">ttl</span> <span class="o">=</span> <span class="n">tryAcquire</span><span class="o">(</span><span class="n">leaseTime</span><span class="o">,</span> <span class="n">unit</span><span class="o">,</span> <span class="n">threadId</span><span class="o">);</span>
            <span class="c1">// 返回的ttl为空，说明获取到锁，跳出死循环，这个死循环或者抛出中断异常，或者获取到锁成功break跳出，没有其他方式
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">ttl</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// 这个ttl来源于等待存在的锁的KEY的存活时间，直接使用许可为0的信号量进行阻塞等待，下面的几个分支判断都是大同小异，只是有的支持超时时间，有的支持中断
</span><span class="c1"></span>            <span class="c1">// 有的是永久阻塞直到锁释放事件订阅LockPubSub的onMessage()方法回调激活getLatch().release()进行解锁才会往下走
</span><span class="c1"></span>            <span class="c1">// 这里可以学到一个特殊的技巧，Semaphore(0)，信号量的许可设置为0，首个调用acquire()的线程会被阻塞，直到其他线程调用此信号量的release()方法才会解除阻塞，类似于一个CountDownLatch(1)的效果
</span><span class="c1"></span>            <span class="k">if</span> <span class="o">(</span><span class="n">ttl</span> <span class="o">&gt;=</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="n">future</span><span class="o">.</span><span class="na">getNow</span><span class="o">().</span><span class="na">getLatch</span><span class="o">().</span><span class="na">tryAcquire</span><span class="o">(</span><span class="n">ttl</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">interruptibly</span><span class="o">)</span> <span class="o">{</span>
                        <span class="k">throw</span> <span class="n">e</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="n">future</span><span class="o">.</span><span class="na">getNow</span><span class="o">().</span><span class="na">getLatch</span><span class="o">().</span><span class="na">tryAcquire</span><span class="o">(</span><span class="n">ttl</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">interruptibly</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">future</span><span class="o">.</span><span class="na">getNow</span><span class="o">().</span><span class="na">getLatch</span><span class="o">().</span><span class="na">acquire</span><span class="o">();</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="n">future</span><span class="o">.</span><span class="na">getNow</span><span class="o">().</span><span class="na">getLatch</span><span class="o">().</span><span class="na">acquireUninterruptibly</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="c1">// 获取到锁或者抛出中断异常，退订redisson_lock__channel:{$KEY}，不再关注解锁事件
</span><span class="c1"></span>        <span class="n">unsubscribe</span><span class="o">(</span><span class="n">future</span><span class="o">,</span> <span class="n">threadId</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 这是一个异步转同步的方法，类似于FutureTask#get()，关键看调用的tryAcquireAsync()方法
</span><span class="c1"></span><span class="kd">private</span> <span class="n">Long</span> <span class="nf">tryAcquire</span><span class="o">(</span><span class="kt">long</span> <span class="n">leaseTime</span><span class="o">,</span> <span class="n">TimeUnit</span> <span class="n">unit</span><span class="o">,</span> <span class="kt">long</span> <span class="n">threadId</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">get</span><span class="o">(</span><span class="n">tryAcquireAsync</span><span class="o">(</span><span class="n">leaseTime</span><span class="o">,</span> <span class="n">unit</span><span class="o">,</span> <span class="n">threadId</span><span class="o">));</span>
<span class="o">}</span>

<span class="cm">/**
</span><span class="cm"> * 通过传入锁持有的最大时间和线程ID异步获取锁
</span><span class="cm"> */</span>
<span class="kd">private</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">RFuture</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="nf">tryAcquireAsync</span><span class="o">(</span><span class="kt">long</span> <span class="n">leaseTime</span><span class="o">,</span> <span class="n">TimeUnit</span> <span class="n">unit</span><span class="o">,</span> <span class="kt">long</span> <span class="n">threadId</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 锁持有最大时间不为-1，也就是明确锁的持有时间，不是永久持有的场景
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">leaseTime</span> <span class="o">!=</span> <span class="o">-</span><span class="n">1</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">tryLockInnerAsync</span><span class="o">(</span><span class="n">leaseTime</span><span class="o">,</span> <span class="n">unit</span><span class="o">,</span> <span class="n">threadId</span><span class="o">,</span> <span class="n">RedisCommands</span><span class="o">.</span><span class="na">EVAL_LONG</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">// 走到这里说明是leaseTime == -1，KEY不设置过期时间的分支，需要启动看门狗机制。尝试内部异步获取锁，注意这里的lockWatchdogTimeout是从配置中获取传进去，不是内部的internalLockLeaseTime属性，这里的默认值还是30000毫秒
</span><span class="c1"></span>    <span class="n">RFuture</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="n">ttlRemainingFuture</span> <span class="o">=</span> <span class="n">tryLockInnerAsync</span><span class="o">(</span><span class="n">commandExecutor</span><span class="o">.</span><span class="na">getConnectionManager</span><span class="o">().</span><span class="na">getCfg</span><span class="o">().</span><span class="na">getLockWatchdogTimeout</span><span class="o">(),</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">,</span> <span class="n">threadId</span><span class="o">,</span> <span class="n">RedisCommands</span><span class="o">.</span><span class="na">EVAL_LONG</span><span class="o">);</span>
    <span class="n">ttlRemainingFuture</span><span class="o">.</span><span class="na">onComplete</span><span class="o">((</span><span class="n">ttlRemaining</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="c1">// 执行异常场景直接返回
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 成功获取到锁的场景，需要基于线程ID启用看门狗，通过时间轮指定定时任务进行续期
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">ttlRemaining</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 定时调度进行续期操作
</span><span class="c1"></span>            <span class="n">scheduleExpirationRenewal</span><span class="o">(</span><span class="n">threadId</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">});</span>
    <span class="k">return</span> <span class="n">ttlRemainingFuture</span><span class="o">;</span>
<span class="o">}</span>

<span class="cm">/**
</span><span class="cm"> * 转换锁持有最大时间，通过参数进行加锁的LUA脚本调用 
</span><span class="cm"> * getName()就是传入的KEY，如resource:x getLockName()就是锁的名称，形式是：UUID + : + threadId，如559cc9df-bad8-4f6c-86a4-ffa51b7f1c36:1
</span><span class="cm"> * internalLockLeaseTime在leaseTime != -1的前提下使用的是原值，在leaseTime == -1的前提下，使用的是lockWatchdogTimeout
</span><span class="cm"> */</span>
<span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">RFuture</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">tryLockInnerAsync</span><span class="o">(</span><span class="kt">long</span> <span class="n">leaseTime</span><span class="o">,</span> <span class="n">TimeUnit</span> <span class="n">unit</span><span class="o">,</span> <span class="kt">long</span> <span class="n">threadId</span><span class="o">,</span> <span class="n">RedisStrictCommand</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">command</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 时间转换为毫秒，注意一点这里的internalLockLeaseTime是类内的属性，被重新赋值了
</span><span class="c1"></span>    <span class="n">internalLockLeaseTime</span> <span class="o">=</span> <span class="n">unit</span><span class="o">.</span><span class="na">toMillis</span><span class="o">(</span><span class="n">leaseTime</span><span class="o">);</span>
    <span class="c1">// 底层向Redis服务执行LUA脚本
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">commandExecutor</span><span class="o">.</span><span class="na">evalWriteAsync</span><span class="o">(</span><span class="n">getName</span><span class="o">(),</span> <span class="n">LongCodec</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">,</span> <span class="n">command</span><span class="o">,</span>
                <span class="s">&#34;if (redis.call(&#39;exists&#39;, KEYS[1]) == 0) then &#34;</span> <span class="o">+</span>
                    <span class="s">&#34;redis.call(&#39;hset&#39;, KEYS[1], ARGV[2], 1); &#34;</span> <span class="o">+</span>
                    <span class="s">&#34;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[1]); &#34;</span> <span class="o">+</span>
                    <span class="s">&#34;return nil; &#34;</span> <span class="o">+</span>
                <span class="s">&#34;end; &#34;</span> <span class="o">+</span>
                <span class="s">&#34;if (redis.call(&#39;hexists&#39;, KEYS[1], ARGV[2]) == 1) then &#34;</span> <span class="o">+</span>
                    <span class="s">&#34;redis.call(&#39;hincrby&#39;, KEYS[1], ARGV[2], 1); &#34;</span> <span class="o">+</span>
                    <span class="s">&#34;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[1]); &#34;</span> <span class="o">+</span>
                    <span class="s">&#34;return nil; &#34;</span> <span class="o">+</span>
                <span class="s">&#34;end; &#34;</span> <span class="o">+</span>
                <span class="s">&#34;return redis.call(&#39;pttl&#39;, KEYS[1]);&#34;</span><span class="o">,</span>
                <span class="n">Collections</span><span class="o">.&lt;</span><span class="n">Object</span><span class="o">&gt;</span><span class="n">singletonList</span><span class="o">(</span><span class="n">getName</span><span class="o">()),</span> <span class="n">internalLockLeaseTime</span><span class="o">,</span> <span class="n">getLockName</span><span class="o">(</span><span class="n">threadId</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>First, note the property internalLockLeaseTime, which is reassigned within the tryLockInnerAsync() method, and it is assigned to lockWatchdogTimeout if releaseTime == -1L. This detail is important and determines the scheduling of the renewal method (watchdog) later This detail is important and determines the frequency of scheduling of later renewal methods (watchdogs). Also, the releaseTime ! = -1L will not be renewed, i.e., the watchdog mechanism will not be activated.</p>
<p>Next, we need to carefully analyze the LUA script executed in tryLockInnerAsync(), which I have extracted and described through comments.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="c1">-- KEYS[1] == getName() --&gt; $KEY --&gt; resource:x</span>
<span class="c1">-- ARGV[1] == internalLockLeaseTime --&gt; 30000</span>
<span class="c1">-- ARGV[2] == getLockName(threadId) --&gt; 559cc9df-bad8-4f6c-86a4-ffa51b7f1c36:1</span>
<span class="c1">-- 第一段代码是判断锁定的资源KEY不存在的时候进行相应值的设置，代表资源没有被锁定，首次获取锁成功</span>
<span class="kr">if</span> <span class="p">(</span><span class="n">redis.call</span><span class="p">(</span><span class="s1">&#39;exists&#39;</span><span class="p">,</span> <span class="n">KEYS</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="kr">then</span>
    <span class="c1">-- 这里是设置调用次数，可以理解为延长KEY过期时间的调用次数</span>
    <span class="n">redis.call</span><span class="p">(</span><span class="s1">&#39;hset&#39;</span><span class="p">,</span> <span class="n">KEYS</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ARGV</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>
    <span class="c1">-- 设置KEY的过期时间</span>
    <span class="n">redis.call</span><span class="p">(</span><span class="s1">&#39;pexpire&#39;</span><span class="p">,</span> <span class="n">KEYS</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ARGV</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="kr">return</span> <span class="kc">nil</span><span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
<span class="c1">-- 第二段代码是判断HASH的field是否存在，如果存在说明是同一个线程重入的情况，这个时候需要延长KEY的TTL，并且HASH的field对应的value加1，记录延长ttl的次数</span>
<span class="kr">if</span> <span class="p">(</span><span class="n">redis.call</span><span class="p">(</span><span class="s1">&#39;hexists&#39;</span><span class="p">,</span> <span class="n">KEYS</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ARGV</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="kr">then</span>
    <span class="c1">-- 这里是增加调用次数，可以理解为增加延长KEY过期时间的调用次数</span>
    <span class="n">redis.call</span><span class="p">(</span><span class="s1">&#39;hincrby&#39;</span><span class="p">,</span> <span class="n">KEYS</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ARGV</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>
    <span class="c1">-- 延长KEY的过期时间</span>
    <span class="n">redis.call</span><span class="p">(</span><span class="s1">&#39;pexpire&#39;</span><span class="p">,</span> <span class="n">KEYS</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ARGV</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="kr">return</span> <span class="kc">nil</span><span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
<span class="c1">-- 第三段代码是兜底的，走到这里说明当前线程获取锁失败，锁已经被其他（进程中的）线程占有，返回当前KEY被占用资源的ttl，用来确定需要休眠的最大时间</span>
<span class="kr">return</span> <span class="n">redis.call</span><span class="p">(</span><span class="s1">&#39;pttl&#39;</span><span class="p">,</span> <span class="n">KEYS</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</code></pre></td></tr></table>
</div>
</div><p>Here is a diagram demonstrating the logic of the three pieces of code that appear in this Lua script.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/08/09/cce6688b343b45ddb7b47b401a921e6f.png" alt=" "></p>
<p>The remaining scheduleExpirationRenewal(threadId) method has not been analyzed, and the logic inside is the periodic renewal logic of the watchdog:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 基于线程ID定时调度和续期
</span><span class="c1"></span><span class="kd">private</span> <span class="kt">void</span> <span class="nf">scheduleExpirationRenewal</span><span class="o">(</span><span class="kt">long</span> <span class="n">threadId</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 如果需要的话新建一个ExpirationEntry记录线程重入计数，同时把续期的任务Timeout对象保存在属性中
</span><span class="c1"></span>    <span class="n">ExpirationEntry</span> <span class="n">entry</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ExpirationEntry</span><span class="o">();</span>
    <span class="n">ExpirationEntry</span> <span class="n">oldEntry</span> <span class="o">=</span> <span class="n">EXPIRATION_RENEWAL_MAP</span><span class="o">.</span><span class="na">putIfAbsent</span><span class="o">(</span><span class="n">getEntryName</span><span class="o">(),</span> <span class="n">entry</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">oldEntry</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 当前进行的当前线程重入加锁
</span><span class="c1"></span>        <span class="n">oldEntry</span><span class="o">.</span><span class="na">addThreadId</span><span class="o">(</span><span class="n">threadId</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="c1">// 当前进行的当前线程首次加锁
</span><span class="c1"></span>        <span class="n">entry</span><span class="o">.</span><span class="na">addThreadId</span><span class="o">(</span><span class="n">threadId</span><span class="o">);</span>
        <span class="c1">// 首次新建ExpirationEntry需要触发续期方法，记录续期的任务句柄
</span><span class="c1"></span>        <span class="n">renewExpiration</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 处理续期
</span><span class="c1"></span><span class="kd">private</span> <span class="kt">void</span> <span class="nf">renewExpiration</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// 根据entryName获取ExpirationEntry实例，如果为空，说明在cancelExpirationRenewal()方法已经被移除，一般是解锁的时候触发
</span><span class="c1"></span>    <span class="n">ExpirationEntry</span> <span class="n">ee</span> <span class="o">=</span> <span class="n">EXPIRATION_RENEWAL_MAP</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">getEntryName</span><span class="o">());</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">ee</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// 新建一个定时任务，这个就是看门狗的实现，io.netty.util.Timeout是Netty结合时间轮使用的定时任务实例
</span><span class="c1"></span>    <span class="n">Timeout</span> <span class="n">task</span> <span class="o">=</span> <span class="n">commandExecutor</span><span class="o">.</span><span class="na">getConnectionManager</span><span class="o">().</span><span class="na">newTimeout</span><span class="o">(</span><span class="k">new</span> <span class="n">TimerTask</span><span class="o">()</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">(</span><span class="n">Timeout</span> <span class="n">timeout</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
            <span class="c1">// 这里是重复外面的那个逻辑，
</span><span class="c1"></span>            <span class="n">ExpirationEntry</span> <span class="n">ent</span> <span class="o">=</span> <span class="n">EXPIRATION_RENEWAL_MAP</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">getEntryName</span><span class="o">());</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">ent</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">// 获取ExpirationEntry中首个线程ID，如果为空说明调用过cancelExpirationRenewal()方法清空持有的线程重入计数，一般是锁已经释放的场景
</span><span class="c1"></span>            <span class="n">Long</span> <span class="n">threadId</span> <span class="o">=</span> <span class="n">ent</span><span class="o">.</span><span class="na">getFirstThreadId</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">threadId</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">// 向Redis异步发送续期的命令
</span><span class="c1"></span>            <span class="n">RFuture</span><span class="o">&lt;</span><span class="n">Boolean</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="n">renewExpirationAsync</span><span class="o">(</span><span class="n">threadId</span><span class="o">);</span>
            <span class="n">future</span><span class="o">.</span><span class="na">onComplete</span><span class="o">((</span><span class="n">res</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
                <span class="c1">// 抛出异常，续期失败，只打印日志和直接终止任务
</span><span class="c1"></span>                <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">log</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">&#34;Can&#39;t update lock &#34;</span> <span class="o">+</span> <span class="n">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">&#34; expiration&#34;</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
                    <span class="k">return</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="c1">// 返回true证明续期成功，则递归调用续期方法（重新调度自己），续期失败说明对应的锁已经不存在，直接返回，不再递归
</span><span class="c1"></span>                <span class="k">if</span> <span class="o">(</span><span class="n">res</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// reschedule itself
</span><span class="c1"></span>                    <span class="n">renewExpiration</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">});</span>
        <span class="o">}</span>
    <span class="o">},</span> 
    <span class="c1">// 这里的执行频率为leaseTime转换为ms单位下的三分之一，由于leaseTime初始值为-1的情况下才会进入续期逻辑，那么这里的执行频率为lockWatchdogTimeout的三分之一
</span><span class="c1"></span>    <span class="n">internalLockLeaseTime</span> <span class="o">/</span> <span class="n">3</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">);</span> 
    
    <span class="c1">// ExpirationEntry实例持有调度任务实例
</span><span class="c1"></span>    <span class="n">ee</span><span class="o">.</span><span class="na">setTimeout</span><span class="o">(</span><span class="n">task</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 调用Redis，执行Lua脚本，进行异步续期
</span><span class="c1"></span><span class="kd">protected</span> <span class="n">RFuture</span><span class="o">&lt;</span><span class="n">Boolean</span><span class="o">&gt;</span> <span class="nf">renewExpirationAsync</span><span class="o">(</span><span class="kt">long</span> <span class="n">threadId</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">commandExecutor</span><span class="o">.</span><span class="na">evalWriteAsync</span><span class="o">(</span><span class="n">getName</span><span class="o">(),</span> <span class="n">LongCodec</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">,</span> <span class="n">RedisCommands</span><span class="o">.</span><span class="na">EVAL_BOOLEAN</span><span class="o">,</span>
            <span class="s">&#34;if (redis.call(&#39;hexists&#39;, KEYS[1], ARGV[2]) == 1) then &#34;</span> <span class="o">+</span>
                <span class="s">&#34;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[1]); &#34;</span> <span class="o">+</span>
                <span class="s">&#34;return 1; &#34;</span> <span class="o">+</span>
            <span class="s">&#34;end; &#34;</span> <span class="o">+</span>
            <span class="s">&#34;return 0;&#34;</span><span class="o">,</span>
        <span class="n">Collections</span><span class="o">.&lt;</span><span class="n">Object</span><span class="o">&gt;</span><span class="n">singletonList</span><span class="o">(</span><span class="n">getName</span><span class="o">()),</span> 
        <span class="c1">//  这里根据前面的分析，internalLockLeaseTime在leaseTime的值为-1的前提下，对应值为lockWatchdogTimeout
</span><span class="c1"></span>        <span class="n">internalLockLeaseTime</span><span class="o">,</span> <span class="n">getLockName</span><span class="o">(</span><span class="n">threadId</span><span class="o">));</span>  
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Based on the source code, it is inferred that the mechanism of renewal is determined by the entry reference to releaseTime.</p>
<ul>
<li>When the releaseTime == -1 (usually the lock() and lockInterruptibly() method calls), the scheduling period of the renewal task is lockWatchdogTimeout / 3 and the maximum holding time of the lock (KEY expiration time) is refreshed to lockWatchdogTimeout</li>
<li>When the releaseTime ! = -1 (usually such method calls as lock(long leaseTime, TimeUnit unit) and lockInterruptibly(long leaseTime, TimeUnit unit) specify that the leaseTime is not -1), the expiration time of the lock is set directly in this case as The input value is converted to a time unit of ms and no renewal mechanism is started</li>
</ul>
<p>The Lua script for extracting the renewal is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="c1">-- KEYS[1] == getName() --&gt; $KEY --&gt; resource:x</span>
<span class="c1">-- ARGV[1] == internalLockLeaseTime --&gt; 30000</span>
<span class="c1">-- ARGV[2] == getLockName(threadId) --&gt; 559cc9df-bad8-4f6c-86a4-ffa51b7f1c36:1</span>
<span class="kr">if</span> <span class="p">(</span><span class="n">redis.call</span><span class="p">(</span><span class="s1">&#39;hexists&#39;</span><span class="p">,</span> <span class="n">KEYS</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ARGV</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="kr">then</span>
    <span class="n">redis.call</span><span class="p">(</span><span class="s1">&#39;pexpire&#39;</span><span class="p">,</span> <span class="n">KEYS</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ARGV</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="kr">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
<span class="kr">return</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>So far, the locking and renewal logic without the waitTime parameter is basically analyzed, and the tryLock(long waitTime, long leaseTime, TimeUnit unit) implementation with the waitTime parameter is actually the same as the lock(long leaseTime, TimeUnit unit, boolean interruptibly) implementation with only the leaseTime parameter. leaseTime, TimeUnit unit, boolean interruptibly) implementation of the underlying call method is the same, the biggest difference is that after trying to obtain the lock operation based on the before and after the System.currentTimeMillis() calculate the time difference and waitTime to do a comparison, to decide the need to Blocking wait or direct timeout to get the lock failed to return, the logic to deal with blocking wait is the logic of the client itself, here do not do a detailed expansion, because the source code implementation is not very elegant (too much long currentTime = System.currentTimeMillis() code segment). Then spend some effort to analyze the implementation of unlocking, including the general case of unlock unlock() and forceUnlockAsync().</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="c1">//  一般情况下的解锁
</span><span class="c1"></span><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">unlock</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="n">get</span><span class="o">(</span><span class="n">unlockAsync</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getId</span><span class="o">()));</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">RedisException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// IllegalMonitorStateException一般是A线程加锁，B线程解锁，内部判断线程状态不一致抛出的
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getCause</span><span class="o">()</span> <span class="k">instanceof</span> <span class="n">IllegalMonitorStateException</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="o">(</span><span class="n">IllegalMonitorStateException</span><span class="o">)</span> <span class="n">e</span><span class="o">.</span><span class="na">getCause</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="n">e</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="nd">@Override</span>
<span class="kd">public</span> <span class="n">RFuture</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span> <span class="nf">unlockAsync</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// 获取当前调用解锁操作的线程ID
</span><span class="c1"></span>    <span class="kt">long</span> <span class="n">threadId</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getId</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">unlockAsync</span><span class="o">(</span><span class="n">threadId</span><span class="o">);</span>
<span class="o">}</span>

<span class="nd">@Override</span>
<span class="kd">public</span> <span class="n">RFuture</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span> <span class="nf">unlockAsync</span><span class="o">(</span><span class="kt">long</span> <span class="n">threadId</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 构建一个结果RedissonPromise
</span><span class="c1"></span>    <span class="n">RPromise</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RedissonPromise</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;();</span>
    <span class="c1">// 返回的RFuture如果持有的结果为true，说明解锁成功，返回NULL说明线程ID异常，加锁和解锁的客户端线程不是同一个线程
</span><span class="c1"></span>    <span class="n">RFuture</span><span class="o">&lt;</span><span class="n">Boolean</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="n">unlockInnerAsync</span><span class="o">(</span><span class="n">threadId</span><span class="o">);</span>
    <span class="n">future</span><span class="o">.</span><span class="na">onComplete</span><span class="o">((</span><span class="n">opStatus</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="c1">// 这是内部的异常，说明解锁异常，需要取消看门狗的续期任务
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">cancelExpirationRenewal</span><span class="o">(</span><span class="n">threadId</span><span class="o">);</span>
            <span class="n">result</span><span class="o">.</span><span class="na">tryFailure</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// 这种情况说明线程ID异常，加锁和解锁的客户端线程不是同一个线程，抛出IllegalMonitorStateException异常
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">opStatus</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">IllegalMonitorStateException</span> <span class="n">cause</span> <span class="o">=</span> <span class="k">new</span> <span class="n">IllegalMonitorStateException</span><span class="o">(</span><span class="s">&#34;attempt to unlock lock, not locked by current thread by node id: &#34;</span>
                    <span class="o">+</span> <span class="n">id</span> <span class="o">+</span> <span class="s">&#34; thread-id: &#34;</span> <span class="o">+</span> <span class="n">threadId</span><span class="o">);</span>
            <span class="n">result</span><span class="o">.</span><span class="na">tryFailure</span><span class="o">(</span><span class="n">cause</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// 走到这里说明正常解锁，取消看门狗的续期任务
</span><span class="c1"></span>        <span class="n">cancelExpirationRenewal</span><span class="o">(</span><span class="n">threadId</span><span class="o">);</span>
        <span class="n">result</span><span class="o">.</span><span class="na">trySuccess</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
    <span class="o">});</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 真正的内部解锁的方法，执行解锁的Lua脚本
</span><span class="c1"></span><span class="kd">protected</span> <span class="n">RFuture</span><span class="o">&lt;</span><span class="n">Boolean</span><span class="o">&gt;</span> <span class="nf">unlockInnerAsync</span><span class="o">(</span><span class="kt">long</span> <span class="n">threadId</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">commandExecutor</span><span class="o">.</span><span class="na">evalWriteAsync</span><span class="o">(</span><span class="n">getName</span><span class="o">(),</span> <span class="n">LongCodec</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">,</span> <span class="n">RedisCommands</span><span class="o">.</span><span class="na">EVAL_BOOLEAN</span><span class="o">,</span>
            <span class="s">&#34;if (redis.call(&#39;hexists&#39;, KEYS[1], ARGV[3]) == 0) then &#34;</span> <span class="o">+</span>
                <span class="s">&#34;return nil;&#34;</span> <span class="o">+</span>
            <span class="s">&#34;end; &#34;</span> <span class="o">+</span>
            <span class="s">&#34;local counter = redis.call(&#39;hincrby&#39;, KEYS[1], ARGV[3], -1); &#34;</span> <span class="o">+</span>
            <span class="s">&#34;if (counter &gt; 0) then &#34;</span> <span class="o">+</span>
                <span class="s">&#34;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[2]); &#34;</span> <span class="o">+</span>
                <span class="s">&#34;return 0; &#34;</span> <span class="o">+</span>
            <span class="s">&#34;else &#34;</span> <span class="o">+</span>
                <span class="s">&#34;redis.call(&#39;del&#39;, KEYS[1]); &#34;</span> <span class="o">+</span>
                <span class="s">&#34;redis.call(&#39;publish&#39;, KEYS[2], ARGV[1]); &#34;</span> <span class="o">+</span>
                <span class="s">&#34;return 1; &#34;</span><span class="o">+</span>
            <span class="s">&#34;end; &#34;</span> <span class="o">+</span>
            <span class="s">&#34;return nil;&#34;</span><span class="o">,</span>
            <span class="n">Arrays</span><span class="o">.&lt;</span><span class="n">Object</span><span class="o">&gt;</span><span class="n">asList</span><span class="o">(</span><span class="n">getName</span><span class="o">(),</span> <span class="n">getChannelName</span><span class="o">()),</span> <span class="n">LockPubSub</span><span class="o">.</span><span class="na">UNLOCK_MESSAGE</span><span class="o">,</span> <span class="n">internalLockLeaseTime</span><span class="o">,</span> <span class="n">getLockName</span><span class="o">(</span><span class="n">threadId</span><span class="o">));</span>
<span class="o">}</span>

<span class="c1">// 取消续期任务
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">cancelExpirationRenewal</span><span class="o">(</span><span class="n">Long</span> <span class="n">threadId</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 这里说明ExpirationEntry已经被移除，一般是基于同一个线程ID多次调用解锁方法导致的（并发解锁）
</span><span class="c1"></span>    <span class="n">ExpirationEntry</span> <span class="n">task</span> <span class="o">=</span> <span class="n">EXPIRATION_RENEWAL_MAP</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">getEntryName</span><span class="o">());</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">task</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// 传入的线程ID不为NULL，从ExpirationEntry中移除线程ID，如果持有的线程ID对应的线程重入计数不为0，会先递减到0，等于0的前提下才会进行删除
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">threadId</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">task</span><span class="o">.</span><span class="na">removeThreadId</span><span class="o">(</span><span class="n">threadId</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">// 这里threadId == null的情况是为了满足强制解锁的场景，强制解锁需要直接删除锁所在的KEY，不需要理会传入的线程ID（传入的线程ID直接为NULL）
</span><span class="c1"></span>    <span class="c1">// 后者task.hasNoThreads()是为了说明当前的锁没有被任何线程持有，对于单线程也确定在移除线程ID之后重入计数器已经为0，从ExpirationEntry中移除，这个时候获取ExpirationEntry的任务实例进行取消即可
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">threadId</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">task</span><span class="o">.</span><span class="na">hasNoThreads</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">Timeout</span> <span class="n">timeout</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="na">getTimeout</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">timeout</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">timeout</span><span class="o">.</span><span class="na">cancel</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="c1">// EntryName -&gt; ExpirationEntry映射中移除当前锁的相关实例ExpirationEntry
</span><span class="c1"></span>        <span class="n">EXPIRATION_RENEWAL_MAP</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">getEntryName</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 强制解锁
</span><span class="c1"></span><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">forceUnlock</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">get</span><span class="o">(</span><span class="n">forceUnlockAsync</span><span class="o">());</span>
<span class="o">}</span>

<span class="nd">@Override</span>
<span class="kd">public</span> <span class="n">RFuture</span><span class="o">&lt;</span><span class="n">Boolean</span><span class="o">&gt;</span> <span class="nf">forceUnlockAsync</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// 线程ID传入为NULL，取消当前的EntryName对应的续期任务
</span><span class="c1"></span>    <span class="n">cancelExpirationRenewal</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
    <span class="c1">// 执行Lua脚本强制删除锁所在的KEY并且发布解锁消息
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">commandExecutor</span><span class="o">.</span><span class="na">evalWriteAsync</span><span class="o">(</span><span class="n">getName</span><span class="o">(),</span> <span class="n">LongCodec</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">,</span> <span class="n">RedisCommands</span><span class="o">.</span><span class="na">EVAL_BOOLEAN</span><span class="o">,</span>
            <span class="s">&#34;if (redis.call(&#39;del&#39;, KEYS[1]) == 1) then &#34;</span>
            <span class="o">+</span> <span class="s">&#34;redis.call(&#39;publish&#39;, KEYS[2], ARGV[1]); &#34;</span>
            <span class="o">+</span> <span class="s">&#34;return 1 &#34;</span>
            <span class="o">+</span> <span class="s">&#34;else &#34;</span>
            <span class="o">+</span> <span class="s">&#34;return 0 &#34;</span>
            <span class="o">+</span> <span class="s">&#34;end&#34;</span><span class="o">,</span>
            <span class="n">Arrays</span><span class="o">.&lt;</span><span class="n">Object</span><span class="o">&gt;</span><span class="n">asList</span><span class="o">(</span><span class="n">getName</span><span class="o">(),</span> <span class="n">getChannelName</span><span class="o">()),</span> <span class="n">LockPubSub</span><span class="o">.</span><span class="na">UNLOCK_MESSAGE</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The Lua scripts for unlocking and forcing unlocking in general are listed here and analyzed as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="c1">-- unlockInnerAsync方法的lua脚本</span>
<span class="c1">-- KEYS[1] == getName() --&gt; $KEY --&gt; resource:x</span>
<span class="c1">-- KEYS[2] == getChannelName() --&gt; 订阅锁的Channel --&gt; redisson_lock__channel:{resource:x}</span>
<span class="c1">-- ARGV[1] == LockPubSub.UNLOCK_MESSAGE --&gt; 常量数值0</span>
<span class="c1">-- ARGV[2] == internalLockLeaseTime --&gt; 30000或者具体的锁最大持有时间</span>
<span class="c1">-- ARGV[3] == getLockName(threadId) --&gt; 559cc9df-bad8-4f6c-86a4-ffa51b7f1c36:1</span>
<span class="c1">-- 第一个IF分支判断如果锁所在的哈希的field不存在，说明当前线程ID未曾获取过对应的锁，返回NULL表示解锁失败</span>
<span class="kr">if</span> <span class="p">(</span><span class="n">redis.call</span><span class="p">(</span><span class="s1">&#39;hexists&#39;</span><span class="p">,</span> <span class="n">KEYS</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ARGV</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="kr">then</span>
    <span class="kr">return</span> <span class="kc">nil</span><span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
<span class="c1">-- 走到这里通过hincrby进行线程重入计数-1,返回计数值</span>
<span class="kd">local</span> <span class="n">counter</span> <span class="o">=</span> <span class="n">redis.call</span><span class="p">(</span><span class="s1">&#39;hincrby&#39;</span><span class="p">,</span> <span class="n">KEYS</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ARGV</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="c1">-- 计数值大于0，说明线程重入加锁，这个时候基于internalLockLeaseTime对锁所在KEY进行续期</span>
<span class="kr">if</span> <span class="p">(</span><span class="n">counter</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="kr">then</span>
    <span class="n">redis.call</span><span class="p">(</span><span class="s1">&#39;pexpire&#39;</span><span class="p">,</span> <span class="n">KEYS</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ARGV</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
    <span class="kr">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="kr">else</span>
    <span class="c1">-- 计数值小于或等于0，说明可以解锁，删除锁所在的KEY，并且向redisson_lock__channel:{$KEY}发布消息，内容是0（常量数值）</span>
    <span class="n">redis.call</span><span class="p">(</span><span class="s1">&#39;del&#39;</span><span class="p">,</span> <span class="n">KEYS</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="n">redis.call</span><span class="p">(</span><span class="s1">&#39;publish&#39;</span><span class="p">,</span> <span class="n">KEYS</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">ARGV</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="kr">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
<span class="c1">-- 最后的return nil;在IDEA中提示是不会到达的语句，估计这里是开发者笔误写上去的，前面的if-else都有返回语句，这里应该是不可达的</span>
<span class="kr">return</span> <span class="kc">nil</span><span class="p">;</span>

<span class="c1">-------------------------------------------------- 不怎么华丽的分割线 -------------------------------------------------</span>

<span class="c1">-- forceUnlockAsync方法的lua脚本</span>
<span class="c1">-- KEYS[1] == getName() --&gt; $KEY --&gt; resource:x</span>
<span class="c1">-- KEYS[2] == getChannelName() --&gt; 订阅锁的Channel --&gt; redisson_lock__channel:{resource:x}</span>
<span class="c1">-- ARGV[1] == LockPubSub.UNLOCK_MESSAGE --&gt; 常量数值0</span>
<span class="c1">-- 强制删除锁所在的KEY，如果删除成功向redisson_lock__channel:{$KEY}发布消息，内容是0（常量数值）</span>
<span class="kr">if</span> <span class="p">(</span><span class="n">redis.call</span><span class="p">(</span><span class="s1">&#39;del&#39;</span><span class="p">,</span> <span class="n">KEYS</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="kr">then</span>
    <span class="n">redis.call</span><span class="p">(</span><span class="s1">&#39;publish&#39;</span><span class="p">,</span> <span class="n">KEYS</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">ARGV</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="kr">return</span> <span class="mi">1</span>
<span class="kr">else</span>
    <span class="kr">return</span> <span class="mi">0</span>
<span class="kr">end</span>
</code></pre></td></tr></table>
</div>
</div><p>Other auxiliary methods are relatively simple, so here is a simple &ldquo;running account&rdquo; to record some.</p>
<ul>
<li>isLocked(): calls Redis&rsquo;s EXISTS $KEY command based on getName() to determine if the lock is applied.</li>
<li>isHeldByThread(long threadId) and isHeldByCurrentThread(): calls Redis' HEXISTS $KEY $LOCK_NAME command based on - getName() and getLockName(threadId) to determine if the corresponding field-value exists in the HASH, and if it does, the lock is held by the thread with the corresponding thread ID</li>
<li>getHoldCount(): calls Redis' HGET $KEY $LOCK_NAME command based on getName() and getLockName(threadId), which is used to get the number of threads holding a lock (the comment is called holds, which is actually the number of times the KEY of a lock has been renewed by the same thread)</li>
</ul>
<p>The subscription and publishing sections are designed to use a large number of Netty components related to the source code, which is not expanded in detail here, and the logic of this section is simply appended to this flowchart later. Finally, a more detailed diagram analyzes the Redisson locking and unlocking process.</p>
<ul>
<li>The locking process without the waitTime parameter.</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/08/09/b54162cd42544a5bb9162175d6db8425.png" alt=" "></p>
<ul>
<li>The locking process with the waitTime parameter (the process on the right side of the diagram remains essentially the same, mainly because the process on the left calculates the time interval at each step).</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/08/09/6355a1bd2fff40749a90c20f7725297b.png" alt=" "></p>
<ul>
<li>Unlocking process</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/08/09/2f5c8f8948dc406497d5e47022435e08.png" alt=" "></p>
<p>Assuming that two different threads X and Y of different processes go to compete for the lock on the resource RESOURCE, the possible flow is as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/08/09/b034da4aa11942de9942d0952adbb43c.png" alt=" "></p>
<p>A final overview of the HASH data types used to implement the red lock algorithm in Redisson.</p>
<ul>
<li>KEY represents the resource or lock, creation, existence judgment, extended life cycle and deletion operations are always performed for KEY</li>
<li>FIELD represents the lock name lockName(), but in fact it consists of the initialization UUID of the Redisson connection manager instance spliced with the client thread ID, which is strictly speaking the unique identification of the client thread that acquired the lock.</li>
<li>VALUE represents the amount of locks held by the client thread, which from the source code should be the number of times the KEY has been renewed</li>
</ul>
<h2 id="jedis-based-implementation-of-redisson-like-distributed-locking-capabilities">Jedis-based implementation of Redisson-like distributed locking capabilities</h2>
<p>The previous sections have analyzed in some detail the principles of distributed lock implementation in Redisson, and a similar implementation is done here using Jedis and multi-threading techniques. For simplicity, only a non-referenced lock() method (similar to the Redisson scenario where releaseTime == -1) and an unlock() method are implemented here. Define the interface RedLock.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">RedLock</span> <span class="o">{</span>

    <span class="kt">void</span> <span class="nf">lock</span><span class="o">(</span><span class="n">String</span> <span class="n">resource</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span><span class="o">;</span>

    <span class="kt">void</span> <span class="nf">unlock</span><span class="o">(</span><span class="n">String</span> <span class="n">resource</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>For the sake of simplicity, I have written all the implementation logic in the implementation class RedisRedLock.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span><span class="lnt">213
</span><span class="lnt">214
</span><span class="lnt">215
</span><span class="lnt">216
</span><span class="lnt">217
</span><span class="lnt">218
</span><span class="lnt">219
</span><span class="lnt">220
</span><span class="lnt">221
</span><span class="lnt">222
</span><span class="lnt">223
</span><span class="lnt">224
</span><span class="lnt">225
</span><span class="lnt">226
</span><span class="lnt">227
</span><span class="lnt">228
</span><span class="lnt">229
</span><span class="lnt">230
</span><span class="lnt">231
</span><span class="lnt">232
</span><span class="lnt">233
</span><span class="lnt">234
</span><span class="lnt">235
</span><span class="lnt">236
</span><span class="lnt">237
</span><span class="lnt">238
</span><span class="lnt">239
</span><span class="lnt">240
</span><span class="lnt">241
</span><span class="lnt">242
</span><span class="lnt">243
</span><span class="lnt">244
</span><span class="lnt">245
</span><span class="lnt">246
</span><span class="lnt">247
</span><span class="lnt">248
</span><span class="lnt">249
</span><span class="lnt">250
</span><span class="lnt">251
</span><span class="lnt">252
</span><span class="lnt">253
</span><span class="lnt">254
</span><span class="lnt">255
</span><span class="lnt">256
</span><span class="lnt">257
</span><span class="lnt">258
</span><span class="lnt">259
</span><span class="lnt">260
</span><span class="lnt">261
</span><span class="lnt">262
</span><span class="lnt">263
</span><span class="lnt">264
</span><span class="lnt">265
</span><span class="lnt">266
</span><span class="lnt">267
</span><span class="lnt">268
</span><span class="lnt">269
</span><span class="lnt">270
</span><span class="lnt">271
</span><span class="lnt">272
</span><span class="lnt">273
</span><span class="lnt">274
</span><span class="lnt">275
</span><span class="lnt">276
</span><span class="lnt">277
</span><span class="lnt">278
</span><span class="lnt">279
</span><span class="lnt">280
</span><span class="lnt">281
</span><span class="lnt">282
</span><span class="lnt">283
</span><span class="lnt">284
</span><span class="lnt">285
</span><span class="lnt">286
</span><span class="lnt">287
</span><span class="lnt">288
</span><span class="lnt">289
</span><span class="lnt">290
</span><span class="lnt">291
</span><span class="lnt">292
</span><span class="lnt">293
</span><span class="lnt">294
</span><span class="lnt">295
</span><span class="lnt">296
</span><span class="lnt">297
</span><span class="lnt">298
</span><span class="lnt">299
</span><span class="lnt">300
</span><span class="lnt">301
</span><span class="lnt">302
</span><span class="lnt">303
</span><span class="lnt">304
</span><span class="lnt">305
</span><span class="lnt">306
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="nd">@RequiredArgsConstructor</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RedisRedLock</span> <span class="kd">implements</span> <span class="n">RedLock</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="n">JedisPool</span> <span class="n">jedisPool</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">uuid</span><span class="o">;</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">WATCH_DOG_TIMEOUT_STRING</span> <span class="o">=</span> <span class="s">&#34;30000&#34;</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">WATCH_DOG_TASK_DURATION</span> <span class="o">=</span> <span class="n">10000L</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">CHANNEL_PREFIX</span> <span class="o">=</span> <span class="s">&#34;__red__lock:&#34;</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">UNLOCK_STATUS_STRING</span> <span class="o">=</span> <span class="s">&#34;0&#34;</span><span class="o">;</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">LOCK_LUA</span> <span class="o">=</span> <span class="s">&#34;if (redis.call(&#39;exists&#39;, KEYS[1]) == 0) then\n&#34;</span> <span class="o">+</span>
            <span class="s">&#34;    redis.call(&#39;hset&#39;, KEYS[1], ARGV[2], 1);\n&#34;</span> <span class="o">+</span>
            <span class="s">&#34;    redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[1]);\n&#34;</span> <span class="o">+</span>
            <span class="s">&#34;    return nil;\n&#34;</span> <span class="o">+</span>
            <span class="s">&#34;end;\n&#34;</span> <span class="o">+</span>
            <span class="s">&#34;if (redis.call(&#39;hexists&#39;, KEYS[1], ARGV[2]) == 1) then\n&#34;</span> <span class="o">+</span>
            <span class="s">&#34;    redis.call(&#39;hincrby&#39;, KEYS[1], ARGV[2], 1);\n&#34;</span> <span class="o">+</span>
            <span class="s">&#34;    redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[1]);\n&#34;</span> <span class="o">+</span>
            <span class="s">&#34;    return nil;\n&#34;</span> <span class="o">+</span>
            <span class="s">&#34;end;\n&#34;</span> <span class="o">+</span>
            <span class="s">&#34;return redis.call(&#39;pttl&#39;, KEYS[1]);&#34;</span><span class="o">;</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">UNLOCK_LUA</span> <span class="o">=</span> <span class="s">&#34;if (redis.call(&#39;hexists&#39;, KEYS[1], ARGV[3]) == 0) then\n&#34;</span> <span class="o">+</span>
            <span class="s">&#34;    return nil;\n&#34;</span> <span class="o">+</span>
            <span class="s">&#34;end;\n&#34;</span> <span class="o">+</span>
            <span class="s">&#34;local counter = redis.call(&#39;hincrby&#39;, KEYS[1], ARGV[3], -1);\n&#34;</span> <span class="o">+</span>
            <span class="s">&#34;if (counter &gt; 0) then\n&#34;</span> <span class="o">+</span>
            <span class="s">&#34;    redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[2]);\n&#34;</span> <span class="o">+</span>
            <span class="s">&#34;    return 0;\n&#34;</span> <span class="o">+</span>
            <span class="s">&#34;else\n&#34;</span> <span class="o">+</span>
            <span class="s">&#34;    redis.call(&#39;del&#39;, KEYS[1]);\n&#34;</span> <span class="o">+</span>
            <span class="s">&#34;    redis.call(&#39;publish&#39;, KEYS[2], ARGV[1]);\n&#34;</span> <span class="o">+</span>
            <span class="s">&#34;    return 1;\n&#34;</span> <span class="o">+</span>
            <span class="s">&#34;end;&#34;</span><span class="o">;</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">RENEW_LUA</span> <span class="o">=</span> <span class="s">&#34;if (redis.call(&#39;hexists&#39;, KEYS[1], ARGV[2]) == 1) then &#34;</span> <span class="o">+</span>
            <span class="s">&#34;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[1]); &#34;</span> <span class="o">+</span>
            <span class="s">&#34;return 1; &#34;</span> <span class="o">+</span>
            <span class="s">&#34;end; &#34;</span> <span class="o">+</span>
            <span class="s">&#34;return 0;&#34;</span><span class="o">;</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">ExecutorService</span> <span class="n">SUB_PUB_POOL</span> <span class="o">=</span> <span class="n">Executors</span><span class="o">.</span><span class="na">newCachedThreadPool</span><span class="o">();</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">ScheduledExecutorService</span> <span class="n">WATCH_DOG_POOL</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ScheduledThreadPoolExecutor</span><span class="o">(</span>
            <span class="n">Runtime</span><span class="o">.</span><span class="na">getRuntime</span><span class="o">().</span><span class="na">availableProcessors</span><span class="o">()</span> <span class="o">*</span> <span class="n">2</span>
    <span class="o">);</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">ThreadEntry</span> <span class="o">{</span>

        <span class="kd">private</span> <span class="kd">final</span> <span class="n">ConcurrentMap</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">threadCounter</span> <span class="o">=</span> <span class="n">Maps</span><span class="o">.</span><span class="na">newConcurrentMap</span><span class="o">();</span>

        <span class="kd">private</span> <span class="kd">volatile</span> <span class="n">WatchDogTask</span> <span class="n">watchDogTask</span><span class="o">;</span>

        <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">addThreadId</span><span class="o">(</span><span class="kt">long</span> <span class="n">threadId</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">Integer</span> <span class="n">counter</span> <span class="o">=</span> <span class="n">threadCounter</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">threadId</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">counter</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">counter</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">counter</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="n">threadCounter</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">threadId</span><span class="o">,</span> <span class="n">counter</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">boolean</span> <span class="nf">hasNoThreads</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">threadCounter</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kd">synchronized</span> <span class="n">Long</span> <span class="nf">getFirstThreadId</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">threadCounter</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">threadCounter</span><span class="o">.</span><span class="na">keySet</span><span class="o">().</span><span class="na">iterator</span><span class="o">().</span><span class="na">next</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">removeThreadId</span><span class="o">(</span><span class="kt">long</span> <span class="n">threadId</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">Integer</span> <span class="n">counter</span> <span class="o">=</span> <span class="n">threadCounter</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">threadId</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">counter</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">counter</span><span class="o">--;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">counter</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">threadCounter</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">threadId</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">threadCounter</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">threadId</span><span class="o">,</span> <span class="n">counter</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setWatchDogTask</span><span class="o">(</span><span class="n">WatchDogTask</span> <span class="n">watchDogTask</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">watchDogTask</span> <span class="o">=</span> <span class="n">watchDogTask</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="n">WatchDogTask</span> <span class="nf">getWatchDogTask</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">watchDogTask</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="nd">@Getter</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">SubPubEntry</span> <span class="o">{</span>

        <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">key</span><span class="o">;</span>
        <span class="kd">private</span> <span class="kd">final</span> <span class="n">Semaphore</span> <span class="n">latch</span><span class="o">;</span>
        <span class="kd">private</span> <span class="kd">final</span> <span class="n">SubscribeListener</span> <span class="n">subscribeListener</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">SubPubEntry</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">latch</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Semaphore</span><span class="o">(</span><span class="n">0</span><span class="o">);</span>
            <span class="k">this</span><span class="o">.</span><span class="na">subscribeListener</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SubscribeListener</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">latch</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">ConcurrentMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">ThreadEntry</span><span class="o">&gt;</span> <span class="n">THREAD_ENTRY_MAP</span> <span class="o">=</span> <span class="n">Maps</span><span class="o">.</span><span class="na">newConcurrentMap</span><span class="o">();</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">(</span><span class="n">String</span> <span class="n">resource</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">threadId</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getId</span><span class="o">();</span>
        <span class="n">String</span> <span class="n">lockName</span> <span class="o">=</span> <span class="n">uuid</span> <span class="o">+</span> <span class="s">&#34;:&#34;</span> <span class="o">+</span> <span class="n">threadId</span><span class="o">;</span>
        <span class="n">String</span> <span class="n">entryName</span> <span class="o">=</span> <span class="n">uuid</span> <span class="o">+</span> <span class="s">&#34;:&#34;</span> <span class="o">+</span> <span class="n">resource</span><span class="o">;</span>
        <span class="c1">// 获取锁
</span><span class="c1"></span>        <span class="n">Long</span> <span class="n">ttl</span> <span class="o">=</span> <span class="n">acquire</span><span class="o">(</span><span class="n">resource</span><span class="o">,</span> <span class="n">lockName</span><span class="o">,</span> <span class="n">threadId</span><span class="o">,</span> <span class="n">entryName</span><span class="o">);</span>
        <span class="c1">// 加锁成功直接返回
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">Objects</span><span class="o">.</span><span class="na">isNull</span><span class="o">(</span><span class="n">ttl</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// 订阅
</span><span class="c1"></span>        <span class="n">SubPubEntry</span> <span class="n">subPubEntry</span> <span class="o">=</span> <span class="n">subscribeAsync</span><span class="o">(</span><span class="n">resource</span><span class="o">);</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(;</span> <span class="o">;</span> <span class="o">)</span> <span class="o">{</span>
                <span class="n">ttl</span> <span class="o">=</span> <span class="n">acquire</span><span class="o">(</span><span class="n">resource</span><span class="o">,</span> <span class="n">lockName</span><span class="o">,</span> <span class="n">threadId</span><span class="o">,</span> <span class="n">entryName</span><span class="o">);</span>
                <span class="c1">// 加锁成功直接返回
</span><span class="c1"></span>                <span class="k">if</span> <span class="o">(</span><span class="n">Objects</span><span class="o">.</span><span class="na">isNull</span><span class="o">(</span><span class="n">ttl</span><span class="o">))</span> <span class="o">{</span>
                    <span class="k">return</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">ttl</span> <span class="o">&gt;</span> <span class="n">0L</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">subPubEntry</span><span class="o">.</span><span class="na">getLatch</span><span class="o">().</span><span class="na">tryAcquire</span><span class="o">(</span><span class="n">ttl</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">unsubscribeSync</span><span class="o">(</span><span class="n">subPubEntry</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="n">Long</span> <span class="nf">acquire</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">,</span> <span class="n">String</span> <span class="n">lockName</span><span class="o">,</span> <span class="kt">long</span> <span class="n">threadId</span><span class="o">,</span> <span class="n">String</span> <span class="n">entryName</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Object</span> <span class="n">result</span> <span class="o">=</span> <span class="n">execute0</span><span class="o">(</span><span class="n">jedis</span> <span class="o">-&gt;</span> <span class="n">jedis</span><span class="o">.</span><span class="na">eval</span><span class="o">(</span><span class="n">LOCK_LUA</span><span class="o">,</span> <span class="n">Lists</span><span class="o">.</span><span class="na">newArrayList</span><span class="o">(</span><span class="n">key</span><span class="o">),</span>
                <span class="n">Lists</span><span class="o">.</span><span class="na">newArrayList</span><span class="o">(</span><span class="n">WATCH_DOG_TIMEOUT_STRING</span><span class="o">,</span> <span class="n">lockName</span><span class="o">)));</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">Objects</span><span class="o">.</span><span class="na">nonNull</span><span class="o">(</span><span class="n">result</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">Long</span><span class="o">.</span><span class="na">parseLong</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">result</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="c1">// 启动看门狗
</span><span class="c1"></span>        <span class="n">ThreadEntry</span> <span class="n">entry</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ThreadEntry</span><span class="o">();</span>
        <span class="n">ThreadEntry</span> <span class="n">oldEntry</span> <span class="o">=</span> <span class="n">THREAD_ENTRY_MAP</span><span class="o">.</span><span class="na">putIfAbsent</span><span class="o">(</span><span class="n">entryName</span><span class="o">,</span> <span class="n">entry</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">oldEntry</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">oldEntry</span><span class="o">.</span><span class="na">addThreadId</span><span class="o">(</span><span class="n">threadId</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">entry</span><span class="o">.</span><span class="na">addThreadId</span><span class="o">(</span><span class="n">threadId</span><span class="o">);</span>
            <span class="n">Runnable</span> <span class="n">renewAction</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="n">executeWithoutResult</span><span class="o">(</span><span class="n">jedis</span> <span class="o">-&gt;</span> <span class="n">jedis</span><span class="o">.</span><span class="na">eval</span><span class="o">(</span><span class="n">RENEW_LUA</span><span class="o">,</span> <span class="n">Lists</span><span class="o">.</span><span class="na">newArrayList</span><span class="o">(</span><span class="n">key</span><span class="o">),</span>
                    <span class="n">Lists</span><span class="o">.</span><span class="na">newArrayList</span><span class="o">(</span><span class="n">WATCH_DOG_TIMEOUT_STRING</span><span class="o">,</span> <span class="n">lockName</span><span class="o">)));</span>
            <span class="n">WatchDogTask</span> <span class="n">watchDogTask</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WatchDogTask</span><span class="o">(</span><span class="k">new</span> <span class="n">AtomicReference</span><span class="o">&lt;&gt;(</span><span class="n">renewAction</span><span class="o">));</span>
            <span class="n">entry</span><span class="o">.</span><span class="na">setWatchDogTask</span><span class="o">(</span><span class="n">watchDogTask</span><span class="o">);</span>
            <span class="n">WATCH_DOG_POOL</span><span class="o">.</span><span class="na">scheduleWithFixedDelay</span><span class="o">(</span><span class="n">watchDogTask</span><span class="o">,</span> <span class="n">0</span><span class="o">,</span> <span class="n">WATCH_DOG_TASK_DURATION</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="n">SubPubEntry</span> <span class="nf">subscribeAsync</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">SubPubEntry</span> <span class="n">subPubEntry</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SubPubEntry</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="n">SUB_PUB_POOL</span><span class="o">.</span><span class="na">submit</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">SubscribeListener</span> <span class="n">subscribeListener</span> <span class="o">=</span> <span class="n">subPubEntry</span><span class="o">.</span><span class="na">getSubscribeListener</span><span class="o">();</span>
            <span class="n">executeWithoutResult</span><span class="o">(</span><span class="n">jedis</span> <span class="o">-&gt;</span> <span class="n">jedis</span><span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">subscribeListener</span><span class="o">,</span> <span class="n">subscribeListener</span><span class="o">.</span><span class="na">getChannelName</span><span class="o">()));</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">});</span>
        <span class="k">return</span> <span class="n">subPubEntry</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">unsubscribeSync</span><span class="o">(</span><span class="n">SubPubEntry</span> <span class="n">subPubEntry</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">SubscribeListener</span> <span class="n">subscribeListener</span> <span class="o">=</span> <span class="n">subPubEntry</span><span class="o">.</span><span class="na">getSubscribeListener</span><span class="o">();</span>
        <span class="n">subscribeListener</span><span class="o">.</span><span class="na">unsubscribe</span><span class="o">(</span><span class="n">subscribeListener</span><span class="o">.</span><span class="na">getChannelName</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">unlock</span><span class="o">(</span><span class="n">String</span> <span class="n">resource</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">threadId</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getId</span><span class="o">();</span>
        <span class="n">String</span> <span class="n">entryName</span> <span class="o">=</span> <span class="n">uuid</span> <span class="o">+</span> <span class="s">&#34;:&#34;</span> <span class="o">+</span> <span class="n">resource</span><span class="o">;</span>
        <span class="n">String</span> <span class="n">lockName</span> <span class="o">=</span> <span class="n">uuid</span> <span class="o">+</span> <span class="s">&#34;:&#34;</span> <span class="o">+</span> <span class="n">threadId</span><span class="o">;</span>
        <span class="n">String</span> <span class="n">channelName</span> <span class="o">=</span> <span class="n">CHANNEL_PREFIX</span> <span class="o">+</span> <span class="n">resource</span><span class="o">;</span>
        <span class="n">Object</span> <span class="n">result</span> <span class="o">=</span> <span class="n">execute0</span><span class="o">(</span><span class="n">jedis</span> <span class="o">-&gt;</span> <span class="n">jedis</span><span class="o">.</span><span class="na">eval</span><span class="o">(</span><span class="n">UNLOCK_LUA</span><span class="o">,</span> <span class="n">Lists</span><span class="o">.</span><span class="na">newArrayList</span><span class="o">(</span><span class="n">resource</span><span class="o">,</span> <span class="n">channelName</span><span class="o">),</span>
                <span class="n">Lists</span><span class="o">.</span><span class="na">newArrayList</span><span class="o">(</span><span class="n">UNLOCK_STATUS_STRING</span><span class="o">,</span> <span class="n">WATCH_DOG_TIMEOUT_STRING</span><span class="o">,</span> <span class="n">lockName</span><span class="o">)));</span>
        <span class="n">ThreadEntry</span> <span class="n">threadEntry</span> <span class="o">=</span> <span class="n">THREAD_ENTRY_MAP</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">entryName</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">Objects</span><span class="o">.</span><span class="na">nonNull</span><span class="o">(</span><span class="n">threadEntry</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">threadEntry</span><span class="o">.</span><span class="na">removeThreadId</span><span class="o">(</span><span class="n">threadId</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">threadEntry</span><span class="o">.</span><span class="na">hasNoThreads</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">Objects</span><span class="o">.</span><span class="na">nonNull</span><span class="o">(</span><span class="n">threadEntry</span><span class="o">.</span><span class="na">getWatchDogTask</span><span class="o">()))</span> <span class="o">{</span>
                <span class="n">threadEntry</span><span class="o">.</span><span class="na">getWatchDogTask</span><span class="o">().</span><span class="na">cancel</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">Objects</span><span class="o">.</span><span class="na">isNull</span><span class="o">(</span><span class="n">result</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalMonitorStateException</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">SubscribeListener</span> <span class="kd">extends</span> <span class="n">JedisPubSub</span> <span class="o">{</span>

        <span class="nd">@Getter</span>
        <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">key</span><span class="o">;</span>
        <span class="nd">@Getter</span>
        <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">channelName</span><span class="o">;</span>
        <span class="nd">@Getter</span>
        <span class="kd">private</span> <span class="kd">final</span> <span class="n">Semaphore</span> <span class="n">latch</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">SubscribeListener</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">,</span> <span class="n">Semaphore</span> <span class="n">latch</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">channelName</span> <span class="o">=</span> <span class="n">CHANNEL_PREFIX</span> <span class="o">+</span> <span class="n">key</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">latch</span> <span class="o">=</span> <span class="n">latch</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onMessage</span><span class="o">(</span><span class="n">String</span> <span class="n">channel</span><span class="o">,</span> <span class="n">String</span> <span class="n">message</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">channelName</span><span class="o">,</span> <span class="n">channel</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">UNLOCK_STATUS_STRING</span><span class="o">,</span> <span class="n">message</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">latch</span><span class="o">.</span><span class="na">release</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="nd">@RequiredArgsConstructor</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">WatchDogTask</span> <span class="kd">implements</span> <span class="n">Runnable</span> <span class="o">{</span>

        <span class="kd">private</span> <span class="kd">final</span> <span class="n">AtomicBoolean</span> <span class="n">running</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicBoolean</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
        <span class="kd">private</span> <span class="kd">final</span> <span class="n">AtomicReference</span><span class="o">&lt;</span><span class="n">Runnable</span><span class="o">&gt;</span> <span class="n">actionReference</span><span class="o">;</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">running</span><span class="o">.</span><span class="na">get</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">Objects</span><span class="o">.</span><span class="na">nonNull</span><span class="o">(</span><span class="n">actionReference</span><span class="o">.</span><span class="na">get</span><span class="o">()))</span> <span class="o">{</span>
                <span class="n">actionReference</span><span class="o">.</span><span class="na">get</span><span class="o">().</span><span class="na">run</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="n">WatchDogTaskStopException</span><span class="o">(</span><span class="s">&#34;watch dog cancel&#34;</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">cancel</span><span class="o">()</span> <span class="o">{</span>
            <span class="n">actionReference</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
            <span class="n">running</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="nf">execute0</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;</span><span class="n">Jedis</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">function</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">(</span><span class="n">Jedis</span> <span class="n">jedis</span> <span class="o">=</span> <span class="n">jedisPool</span><span class="o">.</span><span class="na">getResource</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">function</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">jedis</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">interface</span> <span class="nc">Action</span> <span class="o">{</span>

        <span class="kt">void</span> <span class="nf">apply</span><span class="o">(</span><span class="n">Jedis</span> <span class="n">jedis</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">executeWithoutResult</span><span class="o">(</span><span class="n">Action</span> <span class="n">action</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">(</span><span class="n">Jedis</span> <span class="n">jedis</span> <span class="o">=</span> <span class="n">jedisPool</span><span class="o">.</span><span class="na">getResource</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">action</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">jedis</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">WatchDogTaskStopException</span> <span class="kd">extends</span> <span class="n">RuntimeException</span> <span class="o">{</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kd">synchronized</span> <span class="n">Throwable</span> <span class="nf">fillInStackTrace</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">resourceName</span> <span class="o">=</span> <span class="s">&#34;resource:x&#34;</span><span class="o">;</span>
        <span class="n">RedLock</span> <span class="n">redLock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RedisRedLock</span><span class="o">(</span><span class="k">new</span> <span class="n">JedisPool</span><span class="o">(</span><span class="k">new</span> <span class="n">GenericObjectPoolConfig</span><span class="o">()),</span> <span class="n">UUID</span><span class="o">.</span><span class="na">randomUUID</span><span class="o">().</span><span class="na">toString</span><span class="o">());</span>
        <span class="n">Thread</span> <span class="n">threadA</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">redLock</span><span class="o">.</span><span class="na">lock</span><span class="o">(</span><span class="n">resourceName</span><span class="o">);</span>
                <span class="n">process</span><span class="o">(</span><span class="n">resourceName</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
                <span class="n">redLock</span><span class="o">.</span><span class="na">unlock</span><span class="o">(</span><span class="n">resourceName</span><span class="o">);</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">&#34;线程%s释放资源%s的锁&#34;</span><span class="o">,</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">(),</span> <span class="n">resourceName</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">},</span> <span class="s">&#34;threadA&#34;</span><span class="o">);</span>
        <span class="n">Thread</span> <span class="n">threadB</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">redLock</span><span class="o">.</span><span class="na">lock</span><span class="o">(</span><span class="n">resourceName</span><span class="o">);</span>
                <span class="n">process</span><span class="o">(</span><span class="n">resourceName</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
                <span class="n">redLock</span><span class="o">.</span><span class="na">unlock</span><span class="o">(</span><span class="n">resourceName</span><span class="o">);</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">&#34;线程%s释放资源%s的锁&#34;</span><span class="o">,</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">(),</span> <span class="n">resourceName</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">},</span> <span class="s">&#34;threadB&#34;</span><span class="o">);</span>
        <span class="n">threadA</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">threadB</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">Long</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">process</span><span class="o">(</span><span class="n">String</span> <span class="n">resourceName</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">threadName</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">();</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">&#34;线程%s获取到资源%s的锁&#34;</span><span class="o">,</span> <span class="n">threadName</span><span class="o">,</span> <span class="n">resourceName</span><span class="o">));</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">1000</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">ignore</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The above implementation was written in a short time, without doing detailed DEBUG, there may be mistakes. The result of a certain implementation is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">线程threadB获取到资源resource:x的锁
线程threadB释放资源resource:x的锁
线程threadA获取到资源resource:x的锁
线程threadA释放资源resource:x的锁
</code></pre></td></tr></table>
</div>
</div><h2 id="summary">Summary</h2>
<p>The red lock implementation in Redisson applies to the following core technologies.</p>
<ul>
<li>Rational application of Redis' basic data type HASH</li>
<li>Redis subscription publishing</li>
<li>Atomicity of Lua scripts</li>
<li>Promise implementation in Netty</li>
<li>Time wheel HashedWheelTimer in Netty and the corresponding timed task (HashedWheel) Timeout
Semaphore for deadline, permanent or interruptible blocking and wake-up, replacing the no-wait deadline blocking in CountDownLatch</li>
</ul>
<p>The above core technologies are applied in a reasonable manner to achieve an efficient and fault-tolerant distributed locking scheme, but from the current point of view, Redisson has not yet solved the failover defect in the red lock algorithm, which I believe may be an underlying defect in the Redis distributed locking scheme. Once applied to a Redis cluster (common master-slave, sentry or Cluster), there is a chance that the aforementioned node role switching will lead to the problem of multiple different clients acquiring the same lock corresponding to the same resource. There is no solution for now.</p>
<hr>
<p>Reference <code>https://www.throwx.cn/2021/01/14/learn-about-redisson/</code></p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/redisson/">redisson</a>
          <a href="/tags/redis/">redis</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2021-08/intel-help-with-drx-next/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Intel provides extensive graphics driver optimizations for Linux 5.15</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2021-08/node-event-loop/">
            <span class="next-text nav-default">Node Event Loop</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
