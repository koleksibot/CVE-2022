<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Node Event Loop - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="JavaScript is single-threaded and asynchronous operations are particularly important.
Whenever you use functions outside the engine, you need to interact with the outside world, thus creating asynchronous operations. Because there are so many asynchronous operations, JavaScript has to provide a lot of asynchronous syntax. It&amp;rsquo;s like, some people get hit all the time, and they have to become very resilient, or they&amp;rsquo;re screwed.
Node&amp;rsquo;s asynchronous syntax is more complex than the browser&amp;rsquo;s, because it talks to the kernel and has to make a special library, libuv, to do this." /><meta name="keywords" content="nodejs,Timer" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2021-08/node-event-loop/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Node Event Loop" />
<meta property="og:description" content="JavaScript is single-threaded and asynchronous operations are particularly important.
Whenever you use functions outside the engine, you need to interact with the outside world, thus creating asynchronous operations. Because there are so many asynchronous operations, JavaScript has to provide a lot of asynchronous syntax. It&rsquo;s like, some people get hit all the time, and they have to become very resilient, or they&rsquo;re screwed.
Node&rsquo;s asynchronous syntax is more complex than the browser&rsquo;s, because it talks to the kernel and has to make a special library, libuv, to do this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2021-08/node-event-loop/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-08-09T11:30:44+08:00" />
<meta property="article:modified_time" content="2021-08-09T11:30:44+08:00" />

<meta itemprop="name" content="Node Event Loop">
<meta itemprop="description" content="JavaScript is single-threaded and asynchronous operations are particularly important.
Whenever you use functions outside the engine, you need to interact with the outside world, thus creating asynchronous operations. Because there are so many asynchronous operations, JavaScript has to provide a lot of asynchronous syntax. It&rsquo;s like, some people get hit all the time, and they have to become very resilient, or they&rsquo;re screwed.
Node&rsquo;s asynchronous syntax is more complex than the browser&rsquo;s, because it talks to the kernel and has to make a special library, libuv, to do this."><meta itemprop="datePublished" content="2021-08-09T11:30:44+08:00" />
<meta itemprop="dateModified" content="2021-08-09T11:30:44+08:00" />
<meta itemprop="wordCount" content="1728">
<meta itemprop="keywords" content="nodejs," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Node Event Loop"/>
<meta name="twitter:description" content="JavaScript is single-threaded and asynchronous operations are particularly important.
Whenever you use functions outside the engine, you need to interact with the outside world, thus creating asynchronous operations. Because there are so many asynchronous operations, JavaScript has to provide a lot of asynchronous syntax. It&rsquo;s like, some people get hit all the time, and they have to become very resilient, or they&rsquo;re screwed.
Node&rsquo;s asynchronous syntax is more complex than the browser&rsquo;s, because it talks to the kernel and has to make a special library, libuv, to do this."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Node Event Loop</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-08-09 11:30:44 </span>
        <div class="post-category">
            <a href="/categories/implementation-details/"> implementation-details </a>
            </div>
          <span class="more-meta"> 1728 words </span>
          <span class="more-meta"> 9 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#1-synchronous-and-asynchronous-tasks">1. Synchronous and Asynchronous Tasks</a></li>
        <li><a href="#2-current-loop-and-second-loop">2. Current loop and second loop</a></li>
        <li><a href="#3-processnexttick">3. process.nextTick()</a></li>
        <li><a href="#4-microtasks">4. Microtasks</a></li>
        <li><a href="#5-the-concept-of-event-loops">5. The concept of event loops</a></li>
        <li><a href="#6-the-six-stages-of-the-event-cycle">6. The six stages of the event cycle</a>
          <ul>
            <li><a href="#1timers">（1）timers</a></li>
            <li><a href="#2io-callbacks">（2）I/O callbacks</a></li>
            <li><a href="#3idle-prepare">（3）idle, prepare</a></li>
            <li><a href="#4poll">（4）Poll</a></li>
            <li><a href="#5check">（5）check</a></li>
            <li><a href="#6close-callbacks">（6）close callbacks</a></li>
          </ul>
        </li>
        <li><a href="#7-example-of-an-event-loop">7. Example of an event loop</a></li>
        <li><a href="#8-settimeout-and-setimmediate">8. setTimeout And setImmediate</a></li>
        <li><a href="#9-reference-links">9. Reference Links</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>JavaScript is single-threaded and asynchronous operations are particularly important.</p>
<p>Whenever you use functions outside the engine, you need to interact with the outside world, thus creating asynchronous operations. Because there are so many asynchronous operations, JavaScript has to provide a lot of asynchronous syntax. It&rsquo;s like, some people get hit all the time, and they have to become very resilient, or they&rsquo;re screwed.</p>
<p>Node&rsquo;s asynchronous syntax is more complex than the browser&rsquo;s, because it talks to the kernel and has to make a special library, libuv, to do this. This library is responsible for the execution time of various callback functions, after all, asynchronous tasks end up back in the main thread, queued one by one.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/08/09/0fce55373e624dafa5c829f9b6ab961b.png" alt=" "></p>
<p>To coordinate asynchronous tasks, Node actually provides four timers that allow tasks to run at specified times.</p>
<ul>
<li>setTimeout()</li>
<li>setInterval()</li>
<li>setImmediate()</li>
<li>process.nextTick()</li>
</ul>
<p>The first two are standard for the language, the last two are unique to Node. They are written in a similar way and serve a similar purpose, and are not very easy to distinguish from each other.</p>
<p>Can you tell the result of the following code?</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="c1">// test.js
</span><span class="c1"></span><span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
<span class="nx">setImmediate</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
<span class="nx">process</span><span class="p">.</span><span class="nx">nextTick</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
<span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">().</span><span class="nx">then</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span>
<span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">5</span><span class="p">))();</span>
</code></pre></td></tr></table>
</div>
</div><p>The results of the run are as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">
$ node test.js
5
3
4
1
2
</code></pre></td></tr></table>
</div>
</div><p>If you can get it right in one sitting, you probably don&rsquo;t need to read any further. This article explains, in detail, how Node handles various timers, or more generally, how the libuv library schedules asynchronous tasks to execute on the main thread.</p>
<h2 id="1-synchronous-and-asynchronous-tasks">1. Synchronous and Asynchronous Tasks</h2>
<p>First, synchronous tasks are always executed earlier than asynchronous tasks.</p>
<p>In the previous section of code, only the last line is a synchronous task, so it is executed earliest.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">5</span><span class="p">))();</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="2-current-loop-and-second-loop">2. Current loop and second loop</h2>
<p>Asynchronous tasks can be divided into two types.</p>
<ul>
<li>Asynchronous tasks appended to <strong>this loop</strong></li>
<li>Asynchronous tasks added to <strong>next loop</strong></li>
</ul>
<p>The term &ldquo;loop&rdquo; refers to the event loop. This is how the JavaScript engine handles asynchronous tasks, and will be explained in more detail later. Just understand that the current loop must be executed before the next loop.</p>
<p>Node specifies that the callback functions for <code>process.nextTick</code> and <code>Promise</code> are appended to the current loop, i.e., they start executing as soon as the synchronous task is finished. The callbacks for <code>setTimeout</code>, <code>setInterval</code>, and <code>setImmediate</code> are appended to the second loop.</p>
<p>This means that the third and fourth lines of the code at the beginning of the text must be executed earlier than the first and second lines.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js">
<span class="c1">// The following two lines, the next round of loop execution
</span><span class="c1"></span><span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
<span class="nx">setImmediate</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
<span class="c1">// In the following two lines, the cycle is executed
</span><span class="c1"></span><span class="nx">process</span><span class="p">.</span><span class="nx">nextTick</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
<span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">().</span><span class="nx">then</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="3-processnexttick">3. process.nextTick()</h2>
<p>The name <code>process.nextTick</code> is a bit misleading, it is executed in the current loop and is the fastest executed of all asynchronous tasks.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/08/09/058e92d846024f9289a7459a62cc0a17.png" alt=" "></p>
<p>After Node executes all the synchronized tasks, the task queue of <code>process.nextTick</code> will be executed next. So, the following line of code is the second output.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">process</span><span class="p">.</span><span class="nx">nextTick</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
</code></pre></td></tr></table>
</div>
</div><p>Basically, if you want asynchronous tasks to execute as fast as possible, then use <code>process.nextTick</code>.</p>
<h2 id="4-microtasks">4. Microtasks</h2>
<p>According to the language specification, the callback function of the <code>Promise</code> object goes to the microtask queue inside the asynchronous task.</p>
<p>The microtask queue is appended to the <code>process.nextTick</code> queue, which is also part of the current loop. So, the following code always outputs <code>3</code> first and then <code>4</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">process</span><span class="p">.</span><span class="nx">nextTick</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
<span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">().</span><span class="nx">then</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span>
<span class="c1">// 3
</span><span class="c1">// 4
</span></code></pre></td></tr></table>
</div>
</div><p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/08/09/3e5391ad88fa4098868840c05a6f1c47.png" alt=" "></p>
<p>Note that the next queue will be executed only after the previous queue has been emptied.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">process</span><span class="p">.</span><span class="nx">nextTick</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
<span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">().</span><span class="nx">then</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
<span class="nx">process</span><span class="p">.</span><span class="nx">nextTick</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
<span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">().</span><span class="nx">then</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span>
<span class="c1">// 1
</span><span class="c1">// 3
</span><span class="c1">// 2
</span><span class="c1">// 4
</span></code></pre></td></tr></table>
</div>
</div><p>In the above code, all the callback functions of <code>process.nextTick</code> will be executed before <code>Promise</code>.</p>
<p>At this point, the execution order of the loop is finished.</p>
<ol>
<li>synchronize tasks</li>
<li>process.nextTick()</li>
<li>micro-task</li>
</ol>
<h2 id="5-the-concept-of-event-loops">5. The concept of event loops</h2>
<p>The following is the order of execution of the second loop, which requires an understanding of what an event loop is.</p>
<p>Node&rsquo;s <a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/">official documentation</a> describes it this way.</p>
<blockquote>
<p>&ldquo;When Node.js starts, it initializes the event loop, processes the provided input script which may make async API calls, schedule timers, or call process.nextTick(), then begins processing the event loop.&rdquo;</p>
</blockquote>
<p>This passage is important and needs to be read carefully. It expresses three levels of meaning.</p>
<p>First, some people assume that there is a separate event loop thread in addition to the main thread. This is not the case. There is only one main thread, and the event loop is done on the main thread.</p>
<p>Second, when Node starts executing a script, it will initialize the event loop first, but at that point the event loop has not yet started and will complete the following things first.</p>
<ul>
<li>Synchronous tasks</li>
<li>Sending asynchronous requests</li>
<li>Planning when the timer will take effect</li>
<li>Execute <code>process.nextTick()</code> and so on</li>
</ul>
<p>Finally, after all of the above is done, the event cycle officially begins.</p>
<h2 id="6-the-six-stages-of-the-event-cycle">6. The six stages of the event cycle</h2>
<p>The event loop is executed indefinitely, round after round. Execution stops only when the queue of callback functions for asynchronous tasks is emptied.</p>
<p>Each round of the event loop is divided into six phases. These phases are executed sequentially.</p>
<ol>
<li>timers</li>
<li>I/O callbacks</li>
<li>idle, prepare</li>
<li>poll</li>
<li>check</li>
<li>close callbacks</li>
</ol>
<p>Each stage has a first-in-first-out queue of callback functions. Only when the callback function queue of a stage is emptied and all the callback functions that should be executed are executed, the event loop will move to the next stage.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/08/09/1166c818e647474ea7e83326b3aa2a44.png" alt=" "></p>
<p>The following is a brief description of what each stage means. For details, see the <a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/">official documentation</a>, or refer to libuv&rsquo;s <a href="https://jsblog.insiderattack.net/handling-io-nodejs-event-loop-part-4-418062f917d1">source code interpretation</a>.</p>
<h3 id="1timers">（1）timers</h3>
<p>This is the timer phase, which handles the callback functions for <code>setTimeout()</code> and <code>setInterval()</code>. After entering this phase, the main thread checks the current time and whether the timer conditions are met. If it does, it executes the callback function, otherwise it leaves this phase.</p>
<h3 id="2io-callbacks">（2）I/O callbacks</h3>
<p>All callback functions are executed at this stage, except for the callback functions for the following operations.</p>
<ul>
<li>The callback functions for <code>setTimeout()</code> and <code>setInterval()</code></li>
<li>callback functions for <code>setImmediate()</code></li>
<li>callback functions for closing requests, such as <code>socket.on('close', ...)</code></li>
</ul>
<h3 id="3idle-prepare">（3）idle, prepare</h3>
<p>This stage is only called internally by libuv and can be ignored here.</p>
<h3 id="4poll">（4）Poll</h3>
<p>This phase is polling time for I/O events that have not yet been returned, such as server responses, user mouse movements, etc.</p>
<p>This phase can be quite long. If there are no other asynchronous tasks to process (such as expiring timers), it will stay in this phase and wait for I/O requests to return results.</p>
<h3 id="5check">（5）check</h3>
<p>This stage executes the <code>setImmediate()</code> callback function.</p>
<h3 id="6close-callbacks">（6）close callbacks</h3>
<p>This stage executes the callback function that closes the request, such as <code>socket.on('close', ...)</code> .</p>
<h2 id="7-example-of-an-event-loop">7. Example of an event loop</h2>
<p>Here is an example from the official documentation.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;fs&#39;</span><span class="p">);</span>

<span class="kr">const</span> <span class="nx">timeoutScheduled</span> <span class="o">=</span> <span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">();</span>

<span class="c1">// Asynchronous task I: Timer executed after 100ms
</span><span class="c1"></span><span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">delay</span> <span class="o">=</span> <span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">()</span> <span class="o">-</span> <span class="nx">timeoutScheduled</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`</span><span class="si">${</span><span class="nx">delay</span><span class="si">}</span><span class="sb">ms`</span><span class="p">);</span>
<span class="p">},</span> <span class="mi">100</span><span class="p">);</span>

<span class="c1">// Asynchronous task 2: After the file is read, there is a 200ms callback function
</span><span class="c1"></span><span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="s1">&#39;test.js&#39;</span><span class="p">,</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">startCallback</span> <span class="o">=</span> <span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">();</span>
  <span class="k">while</span> <span class="p">(</span><span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">()</span> <span class="o">-</span> <span class="nx">startCallback</span> <span class="o">&lt;</span> <span class="mi">200</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Do nothing
</span><span class="c1"></span>  <span class="p">}</span>
<span class="p">});</span>
</code></pre></td></tr></table>
</div>
</div><p>The above code has two asynchronous tasks, a timer that executes after 100ms and a file read, whose callback function takes 200ms. what is the result?</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/08/09/767601ee304b4a599479a74050aba6c7.png" alt=" "></p>
<p>After the script enters the first event loop, there is no timer that expires and no I/O callback function that is already executable, so it enters the Poll phase and waits for the kernel to return the result of the file read. Since reading small files usually takes less than 100ms, the Poll phase will get the result before the timer expires, so it will continue to execute.</p>
<p>In the second event loop, there is still no timer that expires, but there is already an I/O callback function that can be executed, so it will enter the I/O callbacks phase and execute the <code>fs.readFile</code> callback function. This callback function takes 200ms, which means that halfway through its execution, the 100ms timer will expire. However, it must wait until this callback function finishes executing before it leaves this stage.</p>
<p>For the third event loop, there is already an expiring timer, so the timer will be executed in the timers phase. The final output is about 200ms or so.</p>
<h2 id="8-settimeout-and-setimmediate">8. setTimeout And setImmediate</h2>
<p>Since <code>setTimeout</code> is executed in the timers phase, and <code>setImmediate</code> is executed in the check phase. So, <code>setTimeout</code> will finish before <code>setImmediate</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js">
<span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
<span class="nx">setImmediate</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
</code></pre></td></tr></table>
</div>
</div><p>The above code should output <code>1</code> first and then <code>2</code>, but when it is executed, the result is indeterminate, sometimes outputting <code>2</code> first and then <code>1</code>.</p>
<p>This is because the second parameter of <code>setTimeout</code> defaults to <code>0</code>. But in practice, Node cannot do 0 ms, it needs at least 1 ms. According to <a href="https://nodejs.org/api/timers.html#timers_settimeout_callback_delay_args">official documentation</a>, the second parameter can take values between 1 ms and 2147483647 milliseconds. That is, <code>setTimeout(f, 0)</code> is equivalent to <code>setTimeout(f, 1)</code>.</p>
<p>In practice, after entering the event loop, it may or may not reach 1 millisecond, depending on the state of the system at the time. If it does not reach 1 millisecond, then the timers phase will be skipped and the check phase will be executed first with the <code>setImmediate</code> callback function.</p>
<p>However, the following code must output 2 first, then 1.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js">
<span class="kr">const</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;fs&#39;</span><span class="p">);</span>

<span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="s1">&#39;test.js&#39;</span><span class="p">,</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">setTimeout</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
  <span class="nx">setImmediate</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
<span class="p">});</span>
</code></pre></td></tr></table>
</div>
</div><p>The above code will enter the I/O callbacks phase first, then the check phase, and finally the timers phase. Therefore, <code>setImmediate</code> will be executed before <code>setTimeout</code>.</p>
<h2 id="9-reference-links">9. Reference Links</h2>
<ul>
<li><a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/">The Node.js Event Loop, Timers, and process.nextTick()</a>, by Node.js</li>
<li><a href="https://jsblog.insiderattack.net/handling-io-nodejs-event-loop-part-4-418062f917d1">Handling IO &ndash; NodeJS Event Loop</a>, by Deepal Jayasekara</li>
<li><a href="http://voidcanvas.com/setimmediate-vs-nexttick-vs-settimeout/">setImmediate() vs nextTick() vs setTimeout(fn,0) - in depth explanation</a>, by Paul Shan</li>
<li><a href="http://voidcanvas.com/nodejs-event-loop/">Node.js event loop workflow &amp; lifecycle in low level</a>, by Paul Shan</li>
</ul>
<hr>
<p>Reference <code>https://www.ruanyifeng.com/blog/2018/02/node-event-loop.html</code></p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/nodejs/">nodejs</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2021-08/about-redisson-lock/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">About Redisson Lock</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2021-08/edge-super-duper-secure-mode/">
            <span class="next-text nav-default">Microsoft to disable JavaScript JIT to improve Edge security</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
