<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Python Multithreading and Multiprocessing - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="In the process of learning Python, I have come across knowledge points related to multi-threaded programming, which I have not been able to understand thoroughly before. Today I&amp;rsquo;m going to spend some time to sort out the details as clearly as possible. The difference between threads and processes Processes (process) and threads (thread) are basic operating system concepts, but they are rather abstract and not easy to grasp. The most" /><meta name="keywords" content="Python, Thread, Process" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2021-11/python-multi-thread-and-multi-process/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Python Multithreading and Multiprocessing" />
<meta property="og:description" content="In the process of learning Python, I have come across knowledge points related to multi-threaded programming, which I have not been able to understand thoroughly before. Today I&rsquo;m going to spend some time to sort out the details as clearly as possible. The difference between threads and processes Processes (process) and threads (thread) are basic operating system concepts, but they are rather abstract and not easy to grasp. The most" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2021-11/python-multi-thread-and-multi-process/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-11-06T11:47:20+08:00" />
<meta property="article:modified_time" content="2021-11-06T11:47:20+08:00" />

<meta itemprop="name" content="Python Multithreading and Multiprocessing">
<meta itemprop="description" content="In the process of learning Python, I have come across knowledge points related to multi-threaded programming, which I have not been able to understand thoroughly before. Today I&rsquo;m going to spend some time to sort out the details as clearly as possible. The difference between threads and processes Processes (process) and threads (thread) are basic operating system concepts, but they are rather abstract and not easy to grasp. The most"><meta itemprop="datePublished" content="2021-11-06T11:47:20+08:00" />
<meta itemprop="dateModified" content="2021-11-06T11:47:20+08:00" />
<meta itemprop="wordCount" content="8280">
<meta itemprop="keywords" content="python," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Python Multithreading and Multiprocessing"/>
<meta name="twitter:description" content="In the process of learning Python, I have come across knowledge points related to multi-threaded programming, which I have not been able to understand thoroughly before. Today I&rsquo;m going to spend some time to sort out the details as clearly as possible. The difference between threads and processes Processes (process) and threads (thread) are basic operating system concepts, but they are rather abstract and not easy to grasp. The most"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Python Multithreading and Multiprocessing</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-11-06 11:47:20 </span>
        <div class="post-category">
            <a href="/categories/skills/"> skills </a>
            </div>
          <span class="more-meta"> 8280 words </span>
          <span class="more-meta"> 17 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#the-difference-between-threads-and-processes">The difference between threads and processes</a>
          <ul>
            <li><a href="#difference-between-processes-and-threads">Difference between processes and threads</a></li>
            <li><a href="#comparison-of-multi-process-and-multi-thread">Comparison of multi-process and multi-thread</a></li>
          </ul>
        </li>
        <li><a href="#python-global-interpreter-lock-gil">Python Global Interpreter Lock GIL</a></li>
        <li><a href="#pythons-multiprocessing-package-multiprocessing">Python&rsquo;s multiprocessing package multiprocessing</a>
          <ul>
            <li><a href="#background-of-the-creation-of-multiprocessing">Background of the creation of Multiprocessing</a></li>
            <li><a href="#multiprocessing-common-components-and-functions">Multiprocessing common components and functions</a></li>
            <li><a href="#synchronize-subprocess-modules">Synchronize subprocess modules</a></li>
            <li><a href="#other-content">Other content</a></li>
          </ul>
        </li>
        <li><a href="#python-concurrency-of-concurrentfutures">Python Concurrency of concurrent.futures</a>
          <ul>
            <li><a href="#executor">Executor</a></li>
            <li><a href="#future">Future</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>In the process of learning Python, I have come across knowledge points related to multi-threaded programming, which I have not been able to understand thoroughly before. Today I&rsquo;m going to spend some time to sort out the details as clearly as possible.</p>
<h2 id="the-difference-between-threads-and-processes">The difference between threads and processes</h2>
<p>Processes (process) and threads (thread) are basic operating system concepts, but they are rather abstract and not easy to grasp. The most classic textbook quote about multiple processes and threads is &quot; <strong>Processes are the smallest unit of resource allocation, threads are the smallest unit of CPU scheduling</strong>&quot;. A thread is a single sequential control process in a program. A relatively independent, schedulable unit of execution within a process is the basic unit of the system for independent scheduling and CPU assignment refers to the scheduling unit of a running program. Running multiple threads simultaneously in a single program to accomplish different tasks is called multithreading.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/11/06/94671fe71fc14391b05cae4cd30120e6.png" alt=""></p>
<h3 id="difference-between-processes-and-threads">Difference between processes and threads</h3>
<p>A process is the basic unit of resource allocation. All the resources associated with that process are recorded in the process control block PCB to indicate that the process owns these resources or is using them. In addition, the process is also the scheduling unit of the preemptive processor, which has a complete virtual address space. When scheduling of processes occurs, different processes have different virtual address spaces, while different threads within the same process share the same address space.</p>
<p>In contrast to a process, a thread is independent of resource allocation; it belongs to a particular process and shares the process&rsquo;s resources with other threads within the process. A thread consists of only the associated stack (system stack or user stack) registers and the thread control table TCB. Registers can be used to store local variables within a thread, but not variables related to other threads.</p>
<p>Usually several threads can be included in a process, and they can take advantage of the resources available to the process. In operating systems that introduce threads, processes are usually used as the basic unit for allocating resources, while threads are used as the basic unit for independent operation and independent scheduling. Since threads are smaller than processes and basically do not own system resources, they can be scheduled with much less overhead and can increase the degree of concurrent execution between multiple programs in the system more efficiently, thus significantly improving the utilization of system resources and throughput. As a result, general-purpose operating systems introduced in recent years have introduced threads to further improve the concurrency of the system and consider it as an important indicator of modern operating systems.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/11/06/d9ad0abe90594769b41f9e77e2154658.png" alt=""></p>
<p>The difference between threads and processes can be summarized in the following 4 points.</p>
<ul>
<li>Address space and other resources (such as open files): processes are independent of each other and are shared between threads of the same process. Threads within a process are not visible to other processes.</li>
<li>Communication: Inter-process communication IPC, threads can communicate with each other by directly reading and writing process data segments (e.g. global variables) - the assistance of process synchronization and mutual exclusion means is needed to ensure data consistency.</li>
<li>Scheduling and switching: thread context switching is much faster than process context switching.</li>
<li>In a multi-threaded OS, a process is not an executable entity.</li>
</ul>
<h3 id="comparison-of-multi-process-and-multi-thread">Comparison of multi-process and multi-thread</h3>
<table>
<thead>
<tr>
<th>Comparison Dimension</th>
<th>Multiprocess</th>
<th>Multi-thread</th>
<th>Summary</th>
</tr>
</thead>
<tbody>
<tr>
<td>Data sharing, synchronization</td>
<td>Complex data sharing, simple synchronization</td>
<td>Simple data sharing, complex synchronization</td>
<td>Each has advantages and disadvantages</td>
</tr>
<tr>
<td>memory, CPU</td>
<td>memory consumption, complex switching, low CPU utilization</td>
<td>memory consumption, simple switching, high CPU utilization</td>
<td>thread dominance</td>
</tr>
<tr>
<td>create, destroy, switch</td>
<td>complex, slow</td>
<td>simple, fast</td>
<td>threads take precedence</td>
</tr>
<tr>
<td>Programming, debugging</td>
<td>Simple to program, simple to debug</td>
<td>Complex to program, complex to debug</td>
<td>Process dominance</td>
</tr>
<tr>
<td>reliability</td>
<td>processes don&rsquo;t affect each other</td>
<td>one thread hang will cause the whole process to hang</td>
<td>process dominance</td>
</tr>
<tr>
<td>distributed</td>
<td>for multi-core, multi-machine, scaling to multiple machines simple</td>
<td>for multi-core</td>
<td>process dominance</td>
</tr>
</tbody>
</table>
<p>To summarize, processes and threads can also be analogized to trains and carriages: the</p>
<ul>
<li>A thread travels under a process (a mere carriage cannot run)</li>
<li>A process can contain multiple threads (a train can have multiple cars)</li>
<li>It is difficult to share data between different processes (it is difficult for a passenger on one train to switch to another train, e.g., a station change)</li>
<li>It is easy to share data between different threads under the same process (it is easy to change from carriage A to carriage B)</li>
<li>Processes consume more computer resources than threads (using multiple trains is more resource-intensive than multiple cars)</li>
<li>Processes do not affect each other, a thread hang will cause the whole process to hang (one train will not affect another train, but if a car in the middle of a train catches fire, it will affect all cars of that train)</li>
<li>Processes can be expanded to multiple machines, and processes are suitable for up to multiple cores (different trains can drive on multiple tracks, and cars of the same train cannot be on different tracks of travel)</li>
<li>Memory addresses used by processes can be locked, i.e. when a thread uses some shared memory, other threads must wait for it to finish before they can use that piece of memory. (e.g. bathroom on a train) - &ldquo;Mutual exclusion lock (mutex)&rdquo;</li>
<li>The memory address used by a process can be limited in usage (e.g. a restaurant on a train, where only a maximum number of people are allowed to enter, and if it is full you need to wait at the door and wait for someone to come out before you can enter) - &ldquo;semaphore&rdquo;</li>
</ul>
<h2 id="python-global-interpreter-lock-gil">Python Global Interpreter Lock GIL</h2>
<p>Global Interpreter Lock (English: GIL), is not a Python feature, it is a concept introduced in the implementation of the Python parser (CPython). Since CPython is the default Python execution environment in most environments. So in many people&rsquo;s conception CPython is Python, and they take it for granted that GIL is a defect of the Python language. So what is the GIL in the CPython implementation? Let&rsquo;s look at the official explanation.</p>
<blockquote>
<p>The mechanism used by the CPython interpreter to assure that only one thread executes Python bytecode at a time. This simplifies the CPython implementation by making the object model (including critical built-in types such as dict) implicitly safe against concurrent access. Locking the entire interpreter makes it easier for the interpreter to be multi-threaded, at the expense of much of the parallelism afforded by multi-processor machines.</p>
</blockquote>
<p>The execution of Python code is controlled by the Python virtual machine (also called the interpreter main loop, in the CPython version), which was designed from the beginning with the idea that there would be only one thread executing at the same time in the interpreter&rsquo;s main loop, i.e., only one thread running in the interpreter at any given moment. Access to the Python virtual machine is controlled by the Global Interpreter Lock (GIL), and it is this lock that ensures that only one thread is running at the same time.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/11/06/2eacfd4beb18491f9f6d29215bea12e0.png" alt=""></p>
<p>What are the benefits of GIL? Simply put, it&rsquo;s faster in single-threaded situations and easier to use when combined with C libraries and without thread safety concerns, which was the most common application scenario and advantage of early Python. In addition, the design of GIL simplifies the CPython implementation by making the object model, including key built-in types such as dictionaries, implicitly accessible concurrently. Locking the global interpreter makes it relatively easy to implement support for multiple threads, but also loses the parallel computing power of multiprocessor hosts.</p>
<p>In a multi-threaded environment, the Python virtual machine performs as follows.</p>
<ol>
<li>set the GIL</li>
<li>switch to a thread to run</li>
<li>run until the specified number of bytecode instructions are completed, or the thread actively relinquishes control (either by calling sleep(0))</li>
<li>set the thread to sleep</li>
<li>unlock the GIL</li>
<li>repeat all the above steps again</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/11/06/a2d05d561b4745819583a68019514e15.png" alt=""></p>
<p>Before Python 3.2, the logic for releasing a GIL was to release it when the current thread encountered an IO operation or when the ticks count reached 100 (ticks can be thought of as python&rsquo;s own counter that is used specifically for GILs and is reset to zero after each release, which can be adjusted via sys.setcheckinterval). Because a compute-intensive thread will request a GIL immediately after releasing it, and usually reacquire it before other threads have finished scheduling, once a compute-intensive thread has acquired a GIL, it will occupy it for a long time, even until the end of the thread&rsquo;s execution.</p>
<p>Python 3.2 started using the new GIL, which uses a fixed timeout to instruct the current thread to relinquish the global lock. When the current thread holds the lock and another thread requests it, the current thread is forced to release the lock after 5 milliseconds. This improvement is better for single-core cases where a single thread occupies the GIL for a long time.</p>
<p>On single-core CPUs, it takes hundreds of interval checks to cause a thread switch. On multicore CPUs, there are severe thread bumps (thrashing). And each time the GIL lock is released, threads compete for locks and switch threads, which consumes resources. Under single-core multi-threading, every time the GIL is released, the thread that wakes up gets the GIL lock, so it can execute seamlessly, but under multi-core, after CPU0 releases the GIL, the threads on other CPUs will compete, but the GIL may be immediately obtained by CPU0 again, so the threads on other CPUs that are woken up will be awake and wait until the switchover time and then enter the pending scheduling state, which will cause thread bumps (thrashing), resulting in even lower efficiency.</p>
<p>In addition, it can be deduced from the implementation mechanism above that Python&rsquo;s multithreading is more friendly to IO-intensive code than CPU-intensive code.</p>
<p>Countermeasures for GIL.</p>
<ul>
<li>Use a higher version of Python (optimized for the GIL mechanism)</li>
<li>Use multi-processes instead of multi-threads (no GIL between multi-processes, but the processes themselves consume more resources)</li>
<li>Specify cpu to run threads (using affinity module)</li>
<li>Use GIL-free interpreters like Jython, IronPython, etc.</li>
<li>Use multithreading only for fully IO-intensive tasks</li>
<li>Use concurrent threads (efficient single-threaded mode, also called micro-threading; usually used with multi-processes)</li>
<li>Write key components in C/C++ as Python extensions, and make Python programs directly call exported functions from C-compiled dynamic link libraries via ctypes. (with nogil to call out GIL restrictions)</li>
</ul>
<h2 id="pythons-multiprocessing-package-multiprocessing">Python&rsquo;s multiprocessing package multiprocessing</h2>
<p>Python&rsquo;s threading package is mainly used for multi-threaded development, but due to GIL, multi-threading in Python is not really multi-threaded. If you want to use the full resources of a multi-core CPU, you need to use multi-processing in most cases. The multiprocessing package was introduced in Python version 2.6, and it replicates the complete set of interfaces provided by threading for easy migration. The only difference is that it uses multiple processes instead of multiple threads. Each process has its own independent GIL, so there is no GIL contention between processes.</p>
<p>With multiprocessing, you can easily make the transition from single process to concurrent execution. multiprocessing supports subprocesses, communication and shared data, performs different forms of synchronization, and provides components such as Process, Queue, Pipe, Lock, etc.</p>
<h3 id="background-of-the-creation-of-multiprocessing">Background of the creation of Multiprocessing</h3>
<p>In addition to dealing with Python&rsquo;s GIL, another reason for multiprocessing is the inconsistency between the Windows operating system and the Linux/Unix system.</p>
<p>Unix/Linux operating systems provide a fork() system call, which is very special. A normal function is called once and returns once, but fork() is called once and returns twice, because the OS automatically makes a copy of the current process (parent) and then returns it in the parent and child processes respectively. The reason for this is that a parent process can fork many child processes, so the parent process has to write down the ID of each child process, and the child process only has to call getpid() to get the ID of the parent process.</p>
<p>Python&rsquo;s os module encapsulates common system calls, including fork, that make it easy to create child processes in Python programs.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="kn">import</span> <span class="nn">os</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Process (</span><span class="si">%s</span><span class="s1">) start...&#39;</span> <span class="o">%</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">())</span>
<span class="c1"># Only works on Unix/Linux/Mac:</span>
<span class="n">pid</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">fork</span><span class="p">()</span>
<span class="k">if</span> <span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;I am child process (</span><span class="si">%s</span><span class="s1">) and my parent is </span><span class="si">%s</span><span class="s1">.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">(),</span> <span class="n">os</span><span class="o">.</span><span class="n">getppid</span><span class="p">()))</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;I (</span><span class="si">%s</span><span class="s1">) just created a child process (</span><span class="si">%s</span><span class="s1">).&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">(),</span> <span class="n">pid</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>The above code executes on Linux, Unix and Mac with the following results.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="n">Process</span> <span class="p">(</span><span class="mi">876</span><span class="p">)</span> <span class="n">start</span><span class="o">...</span>
<span class="n">I</span> <span class="p">(</span><span class="mi">876</span><span class="p">)</span> <span class="n">just</span> <span class="n">created</span> <span class="n">a</span> <span class="n">child</span> <span class="n">process</span> <span class="p">(</span><span class="mi">877</span><span class="p">)</span><span class="o">.</span>
<span class="n">I</span> <span class="n">am</span> <span class="n">child</span> <span class="n">process</span> <span class="p">(</span><span class="mi">877</span><span class="p">)</span> <span class="ow">and</span> <span class="n">my</span> <span class="n">parent</span> <span class="ow">is</span> <span class="mf">876.</span>
</code></pre></td></tr></table>
</div>
</div><p>With a fork call, a process can copy out a child process to handle a new task when it receives a new task. A common Apache server has a parent process listening on the port and forks out a child process to handle a new http request whenever there is a new http request.</p>
<p>Since Windows does not have fork calls, the above code will not work on Windows. Since Python is cross-platform, it is natural to provide a cross-platform multiprocessing support. multiprocessing module is a cross-platform version of multiprocessing module. multiprocessing module wraps the fork() call so that we don&rsquo;t need to focus on the details of fork(). Since Windows does not have a fork call, multiprocessing needs to &ldquo;emulate&rdquo; the effect of fork.</p>
<h3 id="multiprocessing-common-components-and-functions">Multiprocessing common components and functions</h3>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/11/06/6f146036fa2b4b4aa9174fa5dbff6129.png" alt=""></p>
<p>Create management process module.</p>
<ul>
<li>Process (for creating processes)</li>
<li>Pool (for creating a pool of managed processes)</li>
<li>Queue (for process communication, resource sharing)</li>
<li>Value, Array (for process communication, resource sharing)</li>
<li>Pipe (for pipe communication)</li>
<li>Manager (for resource sharing)</li>
</ul>
<p>Synchronized sub-process modules.</p>
<ul>
<li>Condition (condition variable)</li>
<li>Event</li>
<li>Lock (mutually exclusive lock)</li>
<li>RLock (reentrant mutually exclusive lock (the same process can get it multiple times without causing blocking))</li>
<li>Semaphore (semaphore)</li>
</ul>
<p>Next, let&rsquo;s learn how to use each component and function together.</p>
<h4 id="process-for-creating-processes">Process (for creating processes)</h4>
<p>The multiprocessing module provides a Process class to represent a process object.</p>
<p>In multiprocessing, each process is represented by a Process class.</p>
<p>Constructor: Process([group [, target [, name [, args [, kwargs]]]]])</p>
<ul>
<li>group: grouping, not actually used, value is always None</li>
<li>target: the target of the call, i.e. the task to be performed by the child process, you can pass in the method name</li>
<li>name: set the name for the child process</li>
<li>args: positional arguments to be passed to the target function, passed as a tuple.</li>
<li>kwargs: the dictionary parameter to be passed to the target function, passed as a dictionary.</li>
</ul>
<p>Instance methods.</p>
<ul>
<li>start(): start the process and call p.run() in this subprocess.</li>
<li>run(): the method that runs when the process starts, it is it that calls the function specified by target, we must implement this method in the class of our custom class</li>
<li>terminate(): force the termination of the process p, will not perform any cleanup operations, if p created a child process, the child process will become a zombie process, the use of this method need to be particularly careful of this situation. If p still has a lock, it will not be released, which will lead to deadlock.</li>
<li>is_alive(): Returns whether the process is running. If p is still running, return True</li>
<li>join([timeout]): process synchronization, the main process waits for the child process to finish before executing the code that follows. The thread waits for p to terminate (emphasis: the main thread is in the wait state, while p is in the run state). timeout is an optional timeout (after this time, the parent thread no longer waits for the child thread and continues to execute), it should be emphasized that p.join can only join the process started by start, but not the process started by run</li>
</ul>
<p>Properties</p>
<ul>
<li>daemon: the default value is False, if set to True, it means p is a daemon running in the background; when p&rsquo;s parent process terminates, p will also terminate, and after setting to True, p cannot create its own new process; must be set before p.start()</li>
<li>name: the name of the process</li>
<li>pid: the pid of the process</li>
<li>exitcode: the process is None at runtime, if it is -N, it means it is terminated by signal N (understand it)</li>
<li>authkey: the authentication key of the process, the default is a 32-character string randomly generated by os.urandom(). The purpose of this key is to provide security for the underlying inter-process communication involving network connections, which can only succeed if they have the same authentication key (just understand)</li>
</ul>
<p>Example usage: (Note: in windows Process() must be put under <code>if __name__ == '__main__'</code>:)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="k">def</span> <span class="nf">run_proc</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Run child process </span><span class="si">%s</span><span class="s1"> (</span><span class="si">%s</span><span class="s1">)...&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">()))</span>

<span class="k">if</span> <span class="vm">__name__</span><span class="o">==</span><span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Parent process </span><span class="si">%s</span><span class="s1">.&#39;</span> <span class="o">%</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">())</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">run_proc</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;test&#39;</span><span class="p">,))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Child process will start.&#39;</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Child process end.&#39;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="pool-for-creating-managed-process-pools">Pool (for creating managed process pools)</h4>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/11/06/9410c8f99ed348dbbd1057ef1f88c8b3.png" alt=""></p>
<p>Pool class is used when there are many targets to be executed and it is too cumbersome to limit the number of processes manually, or Process class can be used if there are few targets and the number of processes is not to be controlled. If the pool is not full, a new process is created to execute the request; however, if the number of processes in the pool has reached the specified maximum, the request waits until a process in the pool finishes, and then the processes in the pool are reused.</p>
<p>Constructor: Pool([processes[, initializer[, initargs[, maxtasksperchild[, context]]]]])</p>
<ul>
<li>processes : The number of processes to be created, if omitted, the number returned by cpu_count() will be used by default.</li>
<li>initializer : The callable object to be executed when each worker process starts, defaults to None. if initializer is None, then each worker process will call initializer(*initargs) at the beginning.</li>
<li>initargs: is the set of arguments to be passed to the initializer.</li>
<li>maxtasksperchild: The number of tasks that can be completed before the worker process exits, replacing the original process with a new one after completion to allow idle resources to be freed. maxtasksperchild is None by default, meaning that the worker process will remain alive as long as the Pool exists.</li>
<li>context: Used to set the context in which the worker process will start. Generally a pool is created using Pool() or the Pool() method of a context object, both of which set the context appropriately.</li>
</ul>
<p>Instance methods.</p>
<ul>
<li>apply(func[, args[, kwargs]]): Execute func(args,*kwargs) in a pool process, and return the result. It should be emphasized that this operation does not execute the func function concurrently in all pool processes. To execute the func function concurrently with different arguments, you must call the p.apply() function from different threads or use p.apply_async(). It is blocking. apply is rarely used</li>
<li>apply_async(func[, arg[, kwds={}[, callback=None]]]): Execute func(args,*kwargs) in a pool worker process and return the result. The result of this method is an instance of the AsyncResult class, and callback is the callable object that receives the input parameters. When the result of func becomes available, the understanding is passed to callback. callback prohibits any blocking operation, otherwise it will receive the result from other asynchronous operations. It is non-blocking.</li>
<li>map(func, iterable[, chunksize=None]): The map method in the Pool class, which behaves essentially the same as the built-in map function usage, causes the process to block until the result is returned. Note that although the second argument is an iterator, in practice, the program must have the entire queue ready before the subprocess will run.</li>
<li>map_async(func, iterable[, chunksize=None]): map_async has the same relationship to map as apply and apply_async</li>
<li>imap(): The difference between imap and map is that map is when all processes have been executed and the result is returned, imap() returns an iterable iterable object immediately.</li>
<li>imap_unordered(): The order of the returned results is not guaranteed to be the same as the order in which the processes are added.</li>
<li>close(): closes the process pool to prevent further operations. If all operations hang continuously, they will complete before the working process terminates.</li>
<li>join(): Wait for all working processes to exit. This method can only be called after close() or terminate(), so that it does not accept new Processes.</li>
<li>terminate(): Ends the working process and does not process any more unprocessed tasks.</li>
</ul>
<p>The return values of the methods apply_async() and map_async() are instances of AsyncResul obj. Instances have the following methods.</p>
<ul>
<li>get(): returns the result and waits for it to arrive if necessary. timeout is optional. If it has not arrived within the specified time, an exception will be thrown. If an exception is raised in a remote operation, it will be raised again when this method is called.</li>
<li>ready(): Returns True if the call is completed.</li>
<li>successful(): Returns True if the call completes and no exception is raised, or raises an exception if the method is called before the result is ready.</li>
<li>wait([timeout]): wait for the result to become available.</li>
<li>terminate(): terminates all working processes immediately, while not performing any cleanup or ending any pending work. This function will be called automatically if p is garbage collected</li>
</ul>
<p>Usage examples.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="c1"># -*- coding:utf-8 -*-</span>
<span class="c1"># Pool+map</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span>

<span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&#34;__main__&#34;</span><span class="p">:</span>
    <span class="n">lists</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">lists</span><span class="p">)</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="c1"># -*- coding:utf-8 -*-</span>
<span class="c1"># 异步进程池（非阻塞）</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span>

<span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&#34;__main__&#34;</span><span class="p">:</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
        <span class="s1">&#39;&#39;&#39;
</span><span class="s1">        For循环中执行步骤：
</span><span class="s1">        （1）循环遍历，将100个子进程添加到进程池（相对父进程会阻塞）
</span><span class="s1">        （2）每次执行8个子进程，等一个子进程执行完后，立马启动新的子进程。（相对父进程不阻塞）
</span><span class="s1">        apply_async为异步进程池写法。异步指的是启动子进程的过程，与父进程本身的执行（print）是异步的，而For循环中往进程池添加子进程的过程，与父进程本身的执行却是同步的。
</span><span class="s1">        &#39;&#39;&#39;</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">i</span><span class="p">,))</span>  <span class="c1"># 维持执行的进程总数为8，当一个进程执行完后启动一个新进程.</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;test&#34;</span><span class="p">)</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="c1"># -*- coding:utf-8 -*-</span>
<span class="c1"># 异步进程池（非阻塞）</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span>

<span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&#34;__main__&#34;</span><span class="p">:</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
        <span class="s1">&#39;&#39;&#39;
</span><span class="s1">            实际测试发现，for循环内部执行步骤：
</span><span class="s1">            （1）遍历100个可迭代对象，往进程池放一个子进程
</span><span class="s1">            （2）执行这个子进程，等子进程执行完毕，再往进程池放一个子进程，再执行。（同时只执行一个子进程）
</span><span class="s1">            for循环执行完毕，再执行print函数。
</span><span class="s1">        &#39;&#39;&#39;</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">i</span><span class="p">,))</span>  <span class="c1"># 维持执行的进程总数为8，当一个进程执行完后启动一个新进程.</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;test&#34;</span><span class="p">)</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="queue-for-process-communication-resource-sharing">Queue (for process communication, resource sharing)</h4>
<p>When using Multiprocessing, it is better not to use shared resources. Normal global variables cannot be shared by child processes, only data structures constructed by Multiprocessing components can be shared.</p>
<p><strong>Queue</strong> is a class used to create a queue for sharing resources between processes. Using Queue can achieve the function of data transfer between multiple processes (disadvantage: it is only applicable to Process class and cannot be used in Pool process pool).</p>
<p>Constructor: Queue([maxsize])</p>
<ul>
<li>maxsize is the maximum number of items allowed in the queue, omitted, there is no size limit.</li>
</ul>
<p>Instance methods.</p>
<ul>
<li>If blocked is True (the default) and timeout is positive, the method blocks for the time specified by timeout until there is space left in the queue. If it times out, a Queue.Full exception will be thrown. If blocked is False, but the Queue is full, a Queue.Full exception is thrown immediately.</li>
<li>If blocked is True (the default) and timeout is positive, then no element is fetched within the wait time and a Queue.Empty exception is thrown. If blocked is False, two cases exist, if the Queue has a value available, that value is returned immediately, otherwise, if the queue is empty, a Queue.Empty exception is thrown immediately. If you don&rsquo;t want to throw an exception when empty, just make blocked True or set all parameters to null.</li>
<li>get_nowait(): same as q.get(False)</li>
<li>put_nowait(): same as q.put(False)</li>
<li>empty(): Returns True if q is empty when this method is called. This result is not reliable, for example, if items are added to the queue in the process of returning True.</li>
<li>full(): Returns True if q is full when this method is called. This result is unreliable, for example, if an item is taken from the queue in the process of returning True.</li>
<li>qsize(): Returns the correct number of items currently in the queue. The result is also unreliable for the same reason as q.empty() and q.full()</li>
</ul>
<p>Usage examples.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">Queue</span>
<span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">time</span><span class="o">,</span> <span class="nn">random</span>

<span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Process to write: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">]:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Put </span><span class="si">%s</span><span class="s1"> to queue...&#39;</span> <span class="o">%</span> <span class="n">value</span><span class="p">)</span>
        <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Process to read: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">())</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Get </span><span class="si">%s</span><span class="s1"> from queue.&#39;</span> <span class="o">%</span> <span class="n">value</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&#34;__main__&#34;</span><span class="p">:</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>
    <span class="n">pw</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">write</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="p">,))</span>
    <span class="n">pr</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">read</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="p">,))</span>
    <span class="n">pw</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">pr</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">pw</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>  <span class="c1"># 等待pw结束</span>
    <span class="n">pr</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>  <span class="c1"># pr进程里是死循环，无法等待其结束，只能强行终止</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>JoinableQueue</strong> is like a Queue object, but the queue allows the user of the item to notify the generator that the item has been successfully processed. The notification process is implemented using shared signals and condition variables.</p>
<p>Constructor: JoinableQueue([maxsize])</p>
<ul>
<li>maxsize: the maximum number of items allowed in the queue, omitted for no size limit.</li>
</ul>
<p>Instance Methods</p>
<p>The instance p of JoinableQueue has, in addition to the same methods as the Queue object.</p>
<ul>
<li>task_done(): the user uses this method to signal that the returned items from q.get() have been processed. If the number of calls to this method is greater than the number of items removed from the queue, a ValueError exception will be raised</li>
<li>join(): The producer calls this method to block until all items in the queue have been processed. The blocking will continue until every item in the queue calls the q.task_done() method</li>
</ul>
<p>Usage examples.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="c1"># -*- coding:utf-8 -*-</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">JoinableQueue</span>
<span class="kn">import</span> <span class="nn">time</span><span class="o">,</span> <span class="nn">random</span>

<span class="k">def</span> <span class="nf">consumer</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;消费者拿到了 </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">res</span><span class="p">)</span>
        <span class="n">q</span><span class="o">.</span><span class="n">task_done</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">producer</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">seq</span><span class="p">:</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">randrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;生产者做好了 </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">item</span><span class="p">)</span>
    <span class="n">q</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&#34;__main__&#34;</span><span class="p">:</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">JoinableQueue</span><span class="p">()</span>
    <span class="n">seq</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;产品</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">consumer</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="p">,))</span>
    <span class="n">p</span><span class="o">.</span><span class="n">daemon</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># 设置为守护进程，在主线程停止时p也停止，但是不用担心，producer内调用q.join保证了consumer已经处理完队列中的所有元素</span>
    <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">producer</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;主线程&#39;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="value-array-for-process-communication-resource-sharing">Value, Array (for process communication, resource sharing)</h4>
<p>The implementation principle of Value and Array in multiprocessing is to create ctypes() objects in shared memory to achieve the purpose of sharing data, the two implementations are similar, just choose different ctypes data type.</p>
<p><strong>Value</strong></p>
<p>Constructor: Value((typecode_or_type, args[, lock])</p>
<ul>
<li>typecode_or_type: Define the type of the ctypes() object, you can pass Type code or C Type, see below for the comparison table.</li>
<li>args: arguments passed to the typecode_or_type constructor</li>
<li>lock: default is True, creates a mutually exclusive lock to restrict access to the Value object, if passed a lock, such as an instance of Lock or RLock, will be used for synchronization. If False is passed, the instance of Value will not be protected by a lock and it will not be process safe.</li>
</ul>
<p>Types supported by typecode_or_type.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">| Type code | C Type             | Python Type       | Minimum size in bytes |
| --------- | ------------------ | ----------------- | --------------------- |
| `&#39;b&#39;`     | signed char        | int               | 1                     |
| `&#39;B&#39;`     | unsigned char      | int               | 1                     |
| `&#39;u&#39;`     | Py_UNICODE         | Unicode character | 2                     |
| `&#39;h&#39;`     | signed short       | int               | 2                     |
| `&#39;H&#39;`     | unsigned short     | int               | 2                     |
| `&#39;i&#39;`     | signed int         | int               | 2                     |
| `&#39;I&#39;`     | unsigned int       | int               | 2                     |
| `&#39;l&#39;`     | signed long        | int               | 4                     |
| `&#39;L&#39;`     | unsigned long      | int               | 4                     |
| `&#39;q&#39;`     | signed long long   | int               | 8                     |
| `&#39;Q&#39;`     | unsigned long long | int               | 8                     |
| `&#39;f&#39;`     | float              | float             | 4                     |
| `&#39;d&#39;`     | double             | float             | 8                     |
</code></pre></td></tr></table>
</div>
</div><p>Reference address: <a href="https://docs.python.org/3/library/array.html">https://docs.python.org/3/library/array.html</a></p>
<p><strong>Array</strong></p>
<p>Constructor: Array(typecode_or_type, size_or_initializer, **kwds[, lock])</p>
<ul>
<li>typecode_or_type: same as above</li>
<li>size_or_initializer: if it is an integer, then it determines the length of the array and the array will be initialized to zero. Otherwise, size_or_initializer is the sequence used to initialize the array and its length determines the length of the array.</li>
<li>kwds: argument passed to the typecode_or_type constructor</li>
<li>lock: same as above</li>
</ul>
<p>Usage examples.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="kn">import</span> <span class="nn">multiprocessing</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
    <span class="n">n</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="mf">3.14</span>
    <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">num</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Value</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Array</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">arr</span><span class="p">))</span>
    <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">num</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">[:])</span>
</code></pre></td></tr></table>
</div>
</div><p>Note: Value and Array are only available for the Process class.</p>
<h4 id="pipe-for-pipe-communication">Pipe (for pipe communication)</h4>
<p>Pipe can create a pipe between processes and return a tuple (conn1,conn2), where conn1 and conn2 represent the connection objects at both ends of the pipe, emphasizing the point that the pipe must be created before the Process object is created.</p>
<p>Construct method: Pipe([dumplex])</p>
<ul>
<li>dumplex: the default pipe is full duplex, if duplex is shot to False, conn1 can only be used for receiving, conn2 can only be used for sending.</li>
</ul>
<p>Instance methods.</p>
<ul>
<li>send(obj): sends an object through a connection. obj is any object compatible with serialization</li>
<li>recv(): receive the object sent by conn2.send(obj). If there is no message to receive, the recv method will always block. If the other end of the connection is already closed, the recv method throws an EOFError.</li>
<li>close(): closes the connection. This method will be called automatically if conn1 is garbage collected</li>
<li>fileno(): return the integer file descriptor used by the connection</li>
<li>poll([timeout]):Returns True if data is available on the connection. timeout specifies the maximum time to wait. If this parameter is omitted, the method will return the result immediately. If timeout is shot to None, the operation will wait indefinitely for data to arrive.</li>
<li>recv_bytes([maxlength]):Receives a full byte message sent by the c.send_bytes() method. maxlength specifies the maximum number of bytes to receive. If the incoming message, exceeds this maximum, an IOError exception will be raised and no further reading will be possible on the connection. If the other end of the connection is closed and no more data exists, an EOFError exception will be raised.</li>
<li>send_bytes(buffer [, offset [, size]]): sends a buffer of byte data over the connection. buffer is any object that supports the buffer interface, offset is the byte offset in the buffer, and size is the number of bytes to be sent. The resultant data is sent as a single message and then received by calling the c.recv_bytes() function</li>
<li>recv_bytes_into(buffer [, offset]): receives a full byte message and stores it in a buffer object, which supports a writable buffer interface (i.e. bytearray object or similar). offset specifies the byte shift in the buffer where the message is placed. The return value is the number of bytes received. If the message length is greater than the available buffer space, a BufferTooShort exception is thrown.</li>
</ul>
<p>Usage examples.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">Pipe</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="c1"># 子进程执行方法</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">Subconn</span><span class="p">):</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">Subconn</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s2">&#34;吃了吗&#34;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;来自父亲的问候:&#34;</span><span class="p">,</span> <span class="n">Subconn</span><span class="o">.</span><span class="n">recv</span><span class="p">())</span>
    <span class="n">Subconn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&#34;__main__&#34;</span><span class="p">:</span>
    <span class="n">parent_conn</span><span class="p">,</span> <span class="n">child_conn</span> <span class="o">=</span> <span class="n">Pipe</span><span class="p">()</span>  <span class="c1"># 创建管道两端</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">child_conn</span><span class="p">,))</span>  <span class="c1"># 创建子进程</span>
    <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;来自儿子的问候:&#34;</span><span class="p">,</span> <span class="n">parent_conn</span><span class="o">.</span><span class="n">recv</span><span class="p">())</span>
    <span class="n">parent_conn</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s2">&#34;嗯&#34;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="manager-for-resource-sharing">Manager (for resource sharing)</h4>
<p>The manager object returned by manager() controls a server process, which contains python objects that can be accessed by other processes through proxies. The Manager module is often used together with the Pool module.</p>
<p>The types supported by Manager are list,dict,Namespace,Lock,RLock,Semaphore,BoundedSemaphore,Condition,Event,Queue,Value and Array.</p>
<p>Managers are independently running subprocesses in which real objects exist and run as servers, and other processes access shared objects by using proxies that run as clients. manager() is a subclass of BaseManager and returns a started instance of SyncManager() that can be used to create shared objects and return proxies that access those shared objects and return proxies that access those shared objects.</p>
<p><strong>BaseManager</strong> , the base class for creating the Manager server</p>
<p>Constructor: BaseManager([address[, authkey]])</p>
<ul>
<li>address: (hostname, port), specify the URL of the server, default is simply assign a free port</li>
<li>authkey: authentication of the client connected to the server, default is the value of current_process().authkey</li>
</ul>
<p>Instance methods.</p>
<ul>
<li>start([initializer[, initargs]]): start a separate child process and start the manager server in that child process</li>
<li>get_server(): get the server object</li>
<li>connect(): connect to the manager object</li>
<li>shutdown(): shutdown the manager object, can only be called after the start() method is called</li>
</ul>
<p>Instance properties.</p>
<ul>
<li>address: read-only property, the address being used by the manager server</li>
</ul>
<p><strong>SyncManager</strong>, The following types are not process-safe and require locking&hellip;</p>
<p>Instance methods.</p>
<ul>
<li>Array(self,*args,**kwds)</li>
<li>BoundedSemaphore(self,*args,**kwds)</li>
<li>Condition(self,*args,**kwds)</li>
<li>Event(self,*args,**kwds)</li>
<li>JoinableQueue(self,*args,**kwds)</li>
<li>Lock(self,*args,**kwds)</li>
<li>Namespace(self,*args,**kwds)</li>
<li>Pool(self,*args,**kwds)</li>
<li>Queue(self,*args,**kwds)</li>
<li>RLock(self,*args,**kwds)</li>
<li>Semaphore(self,*args,**kwds)</li>
<li>Value(self,*args,**kwds)</li>
<li>dict(self,*args,**kwds)</li>
<li>list(self,*args,**kwds)</li>
</ul>
<p>Example usage.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="kn">import</span> <span class="nn">multiprocessing</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">x</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="mf">3.14</span>
    <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Hello&#39;</span><span class="p">)</span>
    <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">n</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">10</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">server</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Manager</span><span class="p">()</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">server</span><span class="o">.</span><span class="n">Value</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">server</span><span class="o">.</span><span class="n">Array</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
    <span class="n">l</span> <span class="o">=</span> <span class="n">server</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">server</span><span class="o">.</span><span class="n">dict</span><span class="p">()</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">server</span><span class="o">.</span><span class="n">Namespace</span><span class="p">()</span>

    <span class="n">proc</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
    <span class="n">proc</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">proc</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="synchronize-subprocess-modules">Synchronize subprocess modules</h3>
<h4 id="lock-mutual-exclusion-lock">Lock (Mutual Exclusion Lock)</h4>
<p>Locking locks are used to avoid access conflicts when multiple processes need to access a shared resource. Locking ensures that when multiple processes modify the same piece of data, only one modification can be made at the same time, i.e., serially, sacrificing speed but ensuring data security. lock contains two states - locked and non-locked - and two basic methods.</p>
<p>Construct method: Lock()</p>
<p>Instance methods.</p>
<ul>
<li>acquire([timeout]): Puts the thread into a synchronous blocking state to try to acquire the lock.</li>
<li>release(): Releases the lock. The thread must have acquired the lock before using it, otherwise an exception will be thrown.</li>
</ul>
<p>Usage examples.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">Lock</span>

<span class="k">def</span> <span class="nf">l</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
    <span class="n">lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Hello Num: </span><span class="si">%s</span><span class="s2">&#34;</span> <span class="o">%</span> <span class="p">(</span><span class="n">num</span><span class="p">))</span>
    <span class="n">lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">lock</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>  <span class="c1"># 这个一定要定义为全局</span>
    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">):</span>
        <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">l</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">num</span><span class="p">))</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="rlock-reentrant-mutex-lock-the-same-process-can-get-it-multiple-times-without-causing-blocking">RLock (reentrant mutex lock (the same process can get it multiple times without causing blocking)</h4>
<p>RLock (reentrant lock) is a synchronization instruction that can be requested multiple times by the same thread. rlock uses the concepts of &ldquo;owned thread&rdquo; and &ldquo;recursive hierarchy&rdquo;. The thread that owns the RLock can call acquire() again and release() the same number of times when releasing the lock. Think of RLock as containing a lock pool and a counter with an initial value of 0. Each successful call to acquire()/release() will result in a counter of +1/-1, and 0 when the lock is in an unlocked state.</p>
<p>Construct method: RLock()</p>
<p>Instance methods.</p>
<ul>
<li>acquire([timeout]): same as Lock</li>
<li>release(): same as Lock</li>
</ul>
<h4 id="semaphore-signal-volume">Semaphore (signal volume)</h4>
<p>A semaphore is a more advanced locking mechanism. A semaphore has an internal counter unlike a lock object that has an internal lock identifier, and a thread blocks only when the number of threads occupying the semaphore exceeds the semaphore. This allows multiple threads to access the same code area at the same time. For example, if the toilet has 3 pits, then only 3 people are allowed to go to the toilet at most, and the people behind can only wait for someone to come out inside before they can go in again. If the specified semaphore is 3, then one person gets a lock, the count is added to 1, and when the count is equal to 3, everyone behind needs to wait. Once released, someone can get a lock.</p>
<p>Constructor: Semaphore([value])</p>
<ul>
<li>value: set semaphore, default value is 1</li>
</ul>
<p>Instance methods.</p>
<ul>
<li>acquire([timeout]): same as Lock</li>
<li>release(): same as Lock</li>
</ul>
<p>Usage examples.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">Semaphore</span>
<span class="kn">import</span> <span class="nn">time</span><span class="o">,</span> <span class="nn">random</span>

<span class="k">def</span> <span class="nf">go_wc</span><span class="p">(</span><span class="n">sem</span><span class="p">,</span> <span class="n">user</span><span class="p">):</span>
    <span class="n">sem</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> 占到一个茅坑&#39;</span> <span class="o">%</span> <span class="n">user</span><span class="p">)</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">sem</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">user</span><span class="p">,</span> <span class="s1">&#39;OK&#39;</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">sem</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">p_l</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">go_wc</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">sem</span><span class="p">,</span> <span class="s1">&#39;user</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">,))</span>
        <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="n">p_l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">p_l</span><span class="p">:</span>
        <span class="n">i</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="condition-condition-variable">Condition (condition variable)</h4>
<p>Condition maintains an internal lock object (RLock by default), which can be passed as an argument when creating a Condigtion object. Condition also provides acquire, release methods, the meaning of which is the same as the lock acquire, release methods, in fact, it simply calls the corresponding method of the internal lock object. condition also provides some other methods.</p>
<p>Constructor: Condition([lock/rlock])</p>
<ul>
<li>You can pass a Lock/RLock instance to the constructor method, otherwise it will generate a RLock instance by itself.</li>
</ul>
<p>Instance methods.</p>
<ul>
<li>acquire([timeout]): first do acquire, then judge some conditions. If the condition is not met then wait</li>
<li>release(): release Lock</li>
<li>wait([timeout]): Calling this method will cause the thread to enter the Condition&rsquo;s waiting pool to wait for notification and release the lock. The thread must have acquired the lock before using it, otherwise an exception will be thrown. The thread in the wait state will re-determine the condition when it is notified.</li>
<li>notify(): Calling this method will pick a thread from the wait pool and notify it. The thread that receives the notification will automatically call acquire() to try to get the lock (enter the lock pool); the other threads remain in the wait pool. Calling this method will not release the lock. The thread must have acquired the lock before using it, otherwise an exception will be thrown.</li>
<li>notifyAll(): Calling this method will notify all threads in the waiting pool that they will all enter the locking pool to try to obtain a lock. Calling this method will not release the lock. The threads must have acquired the lock before using it, otherwise an exception will be thrown.</li>
</ul>
<p>Usage examples.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="kn">import</span> <span class="nn">multiprocessing</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">stage_1</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
    <span class="s2">&#34;&#34;&#34;perform first stage of work,
</span><span class="s2">    then notify stage_2 to continue
</span><span class="s2">    &#34;&#34;&#34;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">current_process</span><span class="p">()</span><span class="o">.</span><span class="n">name</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Starting&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">cond</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> done and ready for stage 2&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
        <span class="n">cond</span><span class="o">.</span><span class="n">notify_all</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">stage_2</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
    <span class="s2">&#34;&#34;&#34;wait for the condition telling us stage_1 is done&#34;&#34;&#34;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">current_process</span><span class="p">()</span><span class="o">.</span><span class="n">name</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Starting&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">cond</span><span class="p">:</span>
        <span class="n">cond</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> running&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">condition</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Condition</span><span class="p">()</span>
    <span class="n">s1</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;s1&#39;</span><span class="p">,</span>
                                 <span class="n">target</span><span class="o">=</span><span class="n">stage_1</span><span class="p">,</span>
                                 <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">condition</span><span class="p">,))</span>
    <span class="n">s2_clients</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s1">&#39;stage_2[</span><span class="si">{}</span><span class="s1">]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>
            <span class="n">target</span><span class="o">=</span><span class="n">stage_2</span><span class="p">,</span>
            <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">condition</span><span class="p">,),</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="p">]</span>

    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">s2_clients</span><span class="p">:</span>
        <span class="n">c</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">s1</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

    <span class="n">s1</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">s2_clients</span><span class="p">:</span>
        <span class="n">c</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="event">Event</h4>
<p>Event contains an internal flag bit, which is initially false. set() can be used to set it to true, or clear() can be used to set it to false again. is_set() can be used to check the status of the flag bit. The other most important function is wait(timeout=None), which is used to block the current thread until the internal flag of event is set to true or timeout is timed out. If the internal flag is true, then the wait() function understands the return.</p>
<p>Usage examples.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="kn">import</span> <span class="nn">multiprocessing</span>
<span class="kn">import</span> <span class="nn">time</span>


<span class="k">def</span> <span class="nf">wait_for_event</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
    <span class="s2">&#34;&#34;&#34;Wait for the event to be set before doing anything&#34;&#34;&#34;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;wait_for_event: starting&#39;</span><span class="p">)</span>
    <span class="n">e</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;wait_for_event: e.is_set()-&gt;&#39;</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">is_set</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">wait_for_event_timeout</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="s2">&#34;&#34;&#34;Wait t seconds and then timeout&#34;&#34;&#34;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;wait_for_event_timeout: starting&#39;</span><span class="p">)</span>
    <span class="n">e</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;wait_for_event_timeout: e.is_set()-&gt;&#39;</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">is_set</span><span class="p">())</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
    <span class="n">w1</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="s1">&#39;block&#39;</span><span class="p">,</span>
        <span class="n">target</span><span class="o">=</span><span class="n">wait_for_event</span><span class="p">,</span>
        <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">e</span><span class="p">,),</span>
    <span class="p">)</span>
    <span class="n">w1</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

    <span class="n">w2</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="s1">&#39;nonblock&#39;</span><span class="p">,</span>
        <span class="n">target</span><span class="o">=</span><span class="n">wait_for_event_timeout</span><span class="p">,</span>
        <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="n">w2</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;main: waiting before calling Event.set()&#39;</span><span class="p">)</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">e</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;main: event is set&#39;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="other-content">Other content</h3>
<p>Difference between multiprocessing.dummy module and multiprocessing module: dummy module is multi-threaded, while multiprocessing is multi-processed, api are common. It is easy to switch code between multi-threaded and multi-processing. multiprocessing.dummy can usually be tried in an IO scenario, for example, by introducing a pool of threads in the following way.</p>
<p>from multiprocessing.dummy import Pool as ThreadPool</p>
<p>The difference between multiprocessing.dummy and the earlier threading seems to be that only one core is bound under a multi-core CPU (not verified).</p>
<p>Reference documentation.</p>
<ul>
<li><a href="https://docs.python.org/3/library/multiprocessing.html">https://docs.python.org/3/library/multiprocessing.html</a></li>
<li><a href="https://www.rddoc.com/doc/Python/3.6.0/zh/library/multiprocessing/">https://www.rddoc.com/doc/Python/3.6.0/zh/library/multiprocessing/</a></li>
</ul>
<h2 id="python-concurrency-of-concurrentfutures">Python Concurrency of concurrent.futures</h2>
<p>The Python standard library provides us with threading and multiprocessing modules to write the corresponding multi-threaded/multi-processing code. Starting with Python 3.2, the standard library provides us with the concurrent.futures module, which provides two classes, ThreadPoolExecutor and ProcessPoolExecutor, that implement a higher level abstraction of threading and multiprocessing, and are useful for writing ThreadPool/ProcessPool provides direct support for writing thread pools/process pools. The concurrent.futures base modules are executor and future.</p>
<h3 id="executor">Executor</h3>
<p>Executor is an abstract class, which cannot be used directly. It defines some basic methods for concrete asynchronous execution. ThreadPoolExecutor and ProcessPoolExecutor inherit from Executor and are used to create the code for thread pools and process pools respectively.</p>
<h4 id="threadpoolexecutor-object">ThreadPoolExecutor object</h4>
<p>The ThreadPoolExecutor class is a subclass of Executor that performs asynchronous calls using a thread pool.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="k">class</span> <span class="nc">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="n">max_workers</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Execute asynchronous calls using a pool of threads with max_workers number.</p>
<h4 id="processpoolexecutor-object">ProcessPoolExecutor object</h4>
<p>The ThreadPoolExecutor class is a subclass of Executor that performs asynchronous calls using a pool of processes.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="k">class</span> <span class="nc">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">ProcessPoolExecutor</span><span class="p">(</span><span class="n">max_workers</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Execute asynchronous calls using a pool of processes with max_workers number, or the number of processors of the machine if max_workers is None (e.g. 4 processes are used for asynchronous concurrency when max_worker is configured for a 4-core machine).</p>
<h4 id="submit-method">submit() method</h4>
<p>The submit() method is defined in Executor. The purpose of this method is to submit an executable callback task and return a future instance. future object represents the given call.</p>
<p>Executor.submit(fn, *args, **kwargs)</p>
<ul>
<li>fn: the function to be executed asynchronously</li>
<li>*args, **kwargs: fn arguments</li>
</ul>
<p>Usage examples.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="kn">from</span> <span class="nn">concurrent</span> <span class="kn">import</span> <span class="n">futures</span>

<span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="k">return</span> <span class="n">time</span><span class="o">.</span><span class="n">ctime</span><span class="p">(),</span> <span class="n">num</span>

<span class="k">with</span> <span class="n">futures</span><span class="o">.</span><span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="n">max_workers</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
    <span class="n">future</span> <span class="o">=</span> <span class="n">executor</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">future</span><span class="o">.</span><span class="n">result</span><span class="p">())</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="map-method">map() method</h4>
<p>In addition to submit, Exectuor also provides us with the map method, which returns a map(func, *iterables) iterator in which the callback execution returns an ordered result.</p>
<p>Executor.map(func, *iterables, timeout=None)</p>
<ul>
<li>func: function that needs to be executed asynchronously</li>
<li>*iterables: iterable objects, such as lists, etc. Each time func is executed, it takes arguments from iterables.</li>
<li>timeout: Set the timeout for each asynchronous operation. The value of timeout can be int or float. If the operation times out, raisesTimeoutError will be returned; if the timeout parameter is not specified, no timeout is set.</li>
</ul>
<p>Usage examples.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="kn">from</span> <span class="nn">concurrent</span> <span class="kn">import</span> <span class="n">futures</span>

<span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="k">return</span> <span class="n">time</span><span class="o">.</span><span class="n">ctime</span><span class="p">(),</span> <span class="n">num</span>

<span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="k">with</span> <span class="n">futures</span><span class="o">.</span><span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="n">max_workers</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">future</span> <span class="ow">in</span> <span class="n">executor</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">future</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="shutdown-method">shutdown() method</h4>
<p>Free system resources, called after asynchronous operations such as Executor.submit() or Executor.map(). Use the with statement to avoid calling this method explicitly.</p>
<p>Executor.shutdown(wait=True)</p>
<h3 id="future">Future</h3>
<p>A future can be understood as an operation that will be completed in the future, which is the basis of asynchronous programming. Usually, when we perform io operations and access the url (below) blocking occurs until the result is returned and the cpu can&rsquo;t do anything else, and the introduction of Future helps us to complete other operations during this time of waiting.</p>
<p>The Future class encapsulates callable asynchronous execution. future instances are created via the Executor.submit() method.</p>
<ul>
<li>cancel(): attempts to cancel the call. The method returns False if the call is currently executing and cannot be canceled, otherwise the call is canceled and the method returns True.</li>
<li>cancelled(): Returns True if the call is successfully cancelled.</li>
<li>running(): Returns True if the call is currently executing and cannot be canceled.</li>
<li>done(): Returns True if the call was successfully canceled or finished.</li>
<li>result(timeout=None): Returns the value returned by the call. If the call has not completed, then this method will wait for the timeout seconds. TimeoutError will be reported if the call does not complete within the timeout seconds. timeout can be a plastic or floating point value, if timeout is not specified or is None, the wait time is infinite. CancelledError will be reported if the futures is cancelled before completion.</li>
<li>exception(timeout=None): Returns the exception thrown by the call, if the call has not completed, the method will wait for the timeout specified, if the call has not completed after that timeout, a timeout error will be reported futures. If timeout is not specified or is None, the wait time is infinite. CancelledError will be raised if the futures is cancelled before it completes. If the call completes and no exception is raised, return None.</li>
<li>add_done_callback(fn): Bind a callable fn to a future. When the future is cancelled or finished, the fn will be called as the only argument to the future. If the future has finished running or is cancelled, fn will be called immediately.</li>
<li>wait(fs, timeout=None, return_when=ALL_COMPLETED)
<ul>
<li>Wait for the Future instance (possibly created by different Executor instances) provided by fs to finish running. Returns a named 2-tuple collection, with a sub-table representing completed and unfinished</li>
<li>return_when indicates when the function should return. Its value must be one of the following.
<ul>
<li>FIRST_COMPLETED :The function returns when any future ends or is cancelled.</li>
<li>FIRST_EXCEPTION : The function returns when any future ends due to an exception, which is equal to if no future reports an error.</li>
<li>ALL_COMPLETED : The function returns when all futures are finished.</li>
</ul>
</li>
</ul>
</li>
<li>as_completed(fs, timeout=None) : The argument is a list of Future instances and the return value is an iterator that outputs Future instances at the end of the run .</li>
</ul>
<p>Usage examples.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="kn">from</span> <span class="nn">concurrent.futures</span> <span class="kn">import</span> <span class="n">ThreadPoolExecutor</span><span class="p">,</span> <span class="n">wait</span><span class="p">,</span> <span class="n">as_completed</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">sleep</span>
<span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">randint</span>


<span class="k">def</span> <span class="nf">return_after_5_secs</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="n">sleep</span><span class="p">(</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
    <span class="k">return</span> <span class="s2">&#34;Return of </span><span class="si">{}</span><span class="s2">&#34;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>


<span class="n">pool</span> <span class="o">=</span> <span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">futures</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">futures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">return_after_5_secs</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">as_completed</span><span class="p">(</span><span class="n">futures</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">result</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Reference links.</p>
<ul>
<li><a href="https://pythonhosted.org/futures/">https://pythonhosted.org/futures/</a></li>
</ul>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/python/">python</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2021-11/linux-users-and-groups/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Linux user and user group management</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2021-11/python-true-false/">
            <span class="next-text nav-default">Python logical judgment True/False trap</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
