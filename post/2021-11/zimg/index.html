<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Build an image server with zimg - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Generally, large websites store their images on dedicated servers, which can be a good way to improve the performance of the website. A simpler way is to use the services provided by cloud vendors. Today we are going to introduce an open source implementation of the solution zing. zimg Introduction zimg is a set of Chinese open source programs designed and developed for image processing servers, aiming to solve the" /><meta name="keywords" content="zimg" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2021-11/zimg/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Build an image server with zimg" />
<meta property="og:description" content="Generally, large websites store their images on dedicated servers, which can be a good way to improve the performance of the website. A simpler way is to use the services provided by cloud vendors. Today we are going to introduce an open source implementation of the solution zing. zimg Introduction zimg is a set of Chinese open source programs designed and developed for image processing servers, aiming to solve the" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2021-11/zimg/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-11-20T14:11:59+08:00" />
<meta property="article:modified_time" content="2021-11-20T14:11:59+08:00" />

<meta itemprop="name" content="Build an image server with zimg">
<meta itemprop="description" content="Generally, large websites store their images on dedicated servers, which can be a good way to improve the performance of the website. A simpler way is to use the services provided by cloud vendors. Today we are going to introduce an open source implementation of the solution zing. zimg Introduction zimg is a set of Chinese open source programs designed and developed for image processing servers, aiming to solve the"><meta itemprop="datePublished" content="2021-11-20T14:11:59+08:00" />
<meta itemprop="dateModified" content="2021-11-20T14:11:59+08:00" />
<meta itemprop="wordCount" content="2838">
<meta itemprop="keywords" content="zimg," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Build an image server with zimg"/>
<meta name="twitter:description" content="Generally, large websites store their images on dedicated servers, which can be a good way to improve the performance of the website. A simpler way is to use the services provided by cloud vendors. Today we are going to introduce an open source implementation of the solution zing. zimg Introduction zimg is a set of Chinese open source programs designed and developed for image processing servers, aiming to solve the"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Build an image server with zimg</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-11-20 14:11:59 </span>
        <div class="post-category">
            <a href="/categories/skills/"> skills </a>
            </div>
          <span class="more-meta"> 2838 words </span>
          <span class="more-meta"> 6 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#zimg-introduction">zimg Introduction</a></li>
        <li><a href="#zimg-design-ideas">zimg design ideas</a></li>
        <li><a href="#zimgs-architecture-design">zimg&rsquo;s architecture design</a></li>
        <li><a href="#code-implementation-of-zimg">Code implementation of zimg</a>
          <ul>
            <li><a href="#mainc">main.c</a></li>
            <li><a href="#zhttpdc">zhttpd.c</a></li>
            <li><a href="#zimgc">zimg.c</a></li>
            <li><a href="#zcachec">zcache.c</a></li>
          </ul>
        </li>
        <li><a href="#zimg-deployment-and-installation-centos-7">zimg deployment and installation (centos 7)</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>Generally, large websites store their images on dedicated servers, which can be a good way to improve the performance of the website. A simpler way is to use the services provided by cloud vendors. Today we are going to introduce an open source implementation of the solution zing.</p>
<h2 id="zimg-introduction">zimg Introduction</h2>
<p><a href="http://zimg.buaa.us/">zimg</a> is a set of Chinese open source programs designed and developed for image processing servers, aiming to solve the following three problems in image services.</p>
<ul>
<li>Large traffic: For some small and medium-sized websites, the traffic problem is the cost problem, pictures increase the traffic by an order of magnitude compared to text, and every byte saved is a white silver. So any Internet application that involves pictures should be planned in an integrated manner to reduce traffic and save money.</li>
<li>High concurrency: The problem of high concurrency hardly occurs when the user volume is low, but once the user climbs, or encounters a hot event, such as a website being uploaded with an explosive news picture, a large number of browsing requests will flood in a short time, and if the architecture is poorly designed and there is no emergency response plan, it is likely to lead to a dead-end cycle of lots of waiting, more page refreshes and more requests. Overall, it&rsquo;s all about making the performance of the image service good enough.</li>
<li>Massive storage: Facebook users upload hundreds of millions of pictures, with a total capacity of over nPB. Such an order of magnitude is beyond the reach of general enterprises. Although it is difficult to make an application that can match Facebook, but from the perspective of architecture design, a good expansion plan is still necessary. Need to design in advance the most appropriate massive image data storage solutions and easy to operate the topology program to cope with the growing business needs in the future.</li>
</ul>
<p>The above three issues, in fact, are also mutually constrained and clamped, for example, to reduce the flow of traffic, it requires a large number of calculations, resulting in longer request processing time, the system processing capacity per unit of time decreases; and then for example, in order to store more pictures, it is inevitable to consume resources on the lookup, the same will also reduce the processing capacity. Therefore, although the picture service seems to be a simple business, it is not a trivial matter to actually do it.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/11/20/809e3e3ae7904c708fab5a4df054902c.png" alt=""></p>
<p>Positioning of zimg.</p>
<ul>
<li>zimg is an image storage and processing server. You can get compressed and scaled images from zimg using URL parameters.</li>
<li>zimg&rsquo;s concurrent I/O, distributed storage and just-in-time processing capabilities are excellent. You no longer need to use nginx in your image server. zimg can handle over 3000 image download jobs per second and over 90,000 HTTP display requests per second at high concurrency levels in benchmark tests. Performance is higher than PHP or other image processing servers.</li>
<li>For small and medium-sized image bed services</li>
</ul>
<p>The following features are supported by zimg.</p>
<ul>
<li>All images are returned as compressed images of 75% quality by default, in JPEG format, so that they are not recognizable to the naked eye, but are reduced in size</li>
<li>Get the image with width x, scaled equally</li>
<li>Get the rotated image</li>
<li>Get a fixed size image of a specified area</li>
<li>Get the image of a specific size, which is scaled differently from the original image to show the most content as possible, and the excess part needs to be cropped after scaling</li>
<li>Get an image of a specific size to show all the contents of the image, so the image will be stretched to a new scale and deformed.</li>
<li>Get an image of a specific size, but without scaling, just show the core content of the image</li>
<li>Get the image scaled by the specified percentage</li>
<li>Get the image with the specified compression ratio</li>
<li>Get the image with the color removed</li>
<li>Get the image in the specified format</li>
<li>Get image information</li>
<li>Delete the specified image</li>
<li>These above functions are provided with just one url + specific parameters by get.</li>
</ul>
<h2 id="zimg-design-ideas">zimg design ideas</h2>
<p>To have the best performance in the matter of presenting images, you first need to separate the image serving part from the overall business. Using a separate domain name and setting up a separate image server has many benefits, such as</p>
<ul>
<li>CDN triage. If you have noticed, popular websites have special domain names for their image addresses, such as sinaimg.cn for Weibo, fmn.xnpic.com for Renren, etc. Different domain names can achieve very obvious optimization effects at the CDN resolution level.</li>
<li>The number of concurrent browser connections is limited. Generally speaking, browsers will create many connections when loading HTML resources and download them in parallel. Different browsers have different limits on the number of concurrent connections to the same host. If the image server is independent, it will not take up the quota of the number of connections to the main site, which improves the performance of the site to some extent.</li>
<li>Browser caching. Nowadays, all browsers have caching function, but due to the existence of cookies, most browsers do not cache requests with cookies, resulting in a large number of image requests that cannot be hit and have to be downloaded again. A domain-independent image server can alleviate this problem to a large extent.</li>
</ul>
<p>The mainstream solution is to use Nginx for the front-end, PHP or self-developed modules for the middle, and physical storage for the back-end; for the more unusual ones, such as Facebook, they combine image request processing and storage into one, called haystack, which has the advantage that haystack only handles The advantage is that haystack only handles requests related to images, stripping away the cumbersome functions of an ordinary http server, making it lighter and more efficient, and also making deployment and operation and maintenance less difficult. zimg adopts a similar strategy to Facebook, taking the power of image processing into its own hands, handling most things by itself, and minimizing the introduction of third-party modules unless particularly necessary.</p>
<h2 id="zimgs-architecture-design">zimg&rsquo;s architecture design</h2>
<p>For the ultimate performance, zimg is developed entirely in C. It is generally divided into three layers, the front-end http processing layer, the middle image processing layer and the back-end storage layer. The following diagram shows the zimg architecture design.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/11/20/965bd596f1a240c096d6c7b9052ded57.png" alt=""></p>
<ul>
<li>http processing layer introduces the libevhtp library based on libevent, which specializes in handling basic http requests .</li>
<li>Image processing layer uses imagemagick library.</li>
<li>storage layer using memcached cache plus direct read and write hard disk solution, later may introduce TFS4 and so on.</li>
</ul>
<p>In order to avoid performance bottlenecks caused by databases, zimg does not introduce structured databases, and all image lookups are solved using hashing. In fact, the design of the image server is a game between I/O and CPU computing, and the best strategy is of course to continue to split: the CPU-sensitive http and image processing layers are deployed on machines with more computing power, the memory-sensitive cache layer is deployed on machines with more memory, and the I/O-sensitive physical storage layer is placed on machines equipped with SSDs, but not everyone can afford such an extravagant configuration. zimg compromises between cost and business requirements and currently only needs to be deployed on one server. The idea that zimg has chosen is to minimize I/O and put the pressure on the CPU, which has proven to be true, even on machines with poor hard drive performance; even if SSDs become fully popular in the future, the CPU&rsquo;s computing power will increase accordingly, and overall zimg&rsquo;s solution is not too unbalanced.</p>
<h2 id="code-implementation-of-zimg">Code implementation of zimg</h2>
<p>Although zimg is not sub-modular on the binary entity, for the reasons mentioned above, and at this stage is geared towards small to medium sized services that can be deployed on a single machine, the code is separated.</p>
<h3 id="mainc">main.c</h3>
<p>main.c is the entry point of the program, the main function is to handle the startup parameters, some of which function as follows.</p>
<ul>
<li>-p [port] Listening port number, default 4869</li>
<li>-t [thread_num] number of threads, default 4, please adjust to the number of CPU cores of the specific server</li>
<li>-k [max_keepalive_num] Maximum number of keepalive connections, default 1, no long connections are enabled, 0 is enabled</li>
<li>-l [keepalive_num] Enable logging, it will bring big performance loss, use your own discretion whether to enable it or not</li>
<li>-M [memcached_ip] The IP of the cache-enabled connection</li>
<li>-m [memcached_port] Cache-enabled connection port</li>
<li>-b [backlog_num] Maximum number of connections per thread, default 1024, set at your discretion</li>
</ul>
<h3 id="zhttpdc">zhttpd.c</h3>
<p>zhttpd.c is the part that parses http requests and is divided into two main parts: GET requests look for images based on the request URL parameters and forward them to the image processing layer for processing, and finally return the results to the user; POST receives upload requests and then deposits the images in the calculated path. To achieve the overall design vision of zimg, zhttpd takes on a large part of the work and has some key points, which are highlighted below.</p>
<ul>
<li>The unique Key value of an image in zimg is the MD5 of that image, which hides the path and reduces the storage pressure on the front end (meaning the front part of zimg, probably your application server) and zimg itself, and is the key to avoid introducing structured storage parts, so all GET requests are stitched together based on MD5. If you need to show an image somewhere on your website, the original size of this image is 1000<em>1000, but the place you want to show is only 300</em>300, how would you do it? Usually you still rely on CSS to control it, but that would result in a lot of wasted traffic. For this reason, zimg provides an image crop function, all you need to do is to add w=300&amp;h=300 (width and height) after the image URL.</li>
<li>In the image upload section, if we use Nginx for the front-end of our image server, the upload function is implemented in PHP, which requires very little code to be written, but the performance is very poor. First of all, after PHP receives the request from Nginx, it will separate the binary file according to the http protocol (RFC1867), store it in a temporary directory, and then we will use $_FILES[&ldquo;upfile&rdquo;][tmp_name] in the PHP code to get the file After calculating the MD5 and then stored in the specified directory, in this process there is a read file and a write file is redundant, in fact, the best case is that we get the binary file in the http request (preferably in memory), directly calculate the MD5 and then stored. So I went to read the source code of PHP and implemented the parsing of POST files by myself, so that the http layer is directly connected to the storage layer, improving the performance of uploading images. In addition to the POST request example, there are many places in the zimg code that reflect this idea of &ldquo;reduce disk I/O, try to read and write in memory&rdquo; and &ldquo;avoid memory replication&rdquo;, a little accumulation will eventually bring excellent performance.</li>
</ul>
<h3 id="zimgc">zimg.c</h3>
<p>zimg.c is the part that calls imagemagick to process images. At this stage zimg serves standalone image servers with terabytes of storage, so the storage path uses a 2-level subdirectory scheme. Since the number of subdirectories in the same directory in Linux should preferably not exceed 2000, plus the MD5 value itself is a 32-bit hexadecimal number, zimg takes a very tricky way: according to the first six bits of MD5 for hashing, 1-3 bits are converted to hexadecimal number and divided by 4, the range falls exactly within 1024, with this number as the first level subdirectory; 4-6 bits are similarly The second level subdirectory is a folder named after MD5, and each MD5 folder stores the original image and other versions of the image as needed. Assuming that a picture takes up an average space of 200KB, the total capacity supported by a zimg server can be calculated: 1024 * 1024 * 1024 * 200KB = 200TB</p>
<p>In addition to path planning, another great feature of zimg is image compression. From the user&rsquo;s point of view, the image returned by zimg only needs to look similar to the original image, and if the original image is really needed, it can be obtained by setting all parameters to null. Based on this condition, zimg.c compresses all converted images, which are almost indistinguishable to the naked eye, but the size is reduced by 67.05%. The specific processing is.</p>
<ul>
<li>image cropping with the LanczosFilter filter.</li>
<li>Compressing at a compression rate of 75%.</li>
<li>Removing the Exif information from the image.</li>
<li>Converting to JPEG format.</li>
</ul>
<p>After such processing the traffic can be reduced to a great extent to achieve the design goals.</p>
<h3 id="zcachec">zcache.c</h3>
<p>zcache.c is the section that introduces the memcached cache, and it is important to introduce the cache, especially after the volume of images rises. Caching is used as a very important feature in zimg, and almost all the lookup sections in zimg.c will first check if the cache exists. For example, if I want a (representing a certain MD5) image cropped to 100<em>100 and then grayed out, the process is to first find if the cache of a&amp;w=100&amp;h=100&amp;g=1 exists, and if not, to find if the file exists (the file name corresponding to this request is a/100</em>100pg), and if it doesn&rsquo;t exist, to find the color image cache of this resolution If it still does not exist, we will find out if the color image file exists (the corresponding file name is a/100*100p), if not, then we will query the original image cache, and if the original image cache is still not hit, we can only open the original image file, and then start cropping and graying, and then return it to the user and store it in the cache.</p>
<p>As you can see, if the cache is hit at some point in the above process, the number of I/O or image processing operations will be reduced accordingly. It is well known that the difference between memory and hard disk read/write speed is huge, so such a design will be very important for hotspot image resistance.</p>
<p>In addition to the above core code is some supporting code, such as log part, md5 calculation part, util part, etc.</p>
<h2 id="zimg-deployment-and-installation-centos-7">zimg deployment and installation (centos 7)</h2>
<p>Install the dependency libraries:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">sudo yum install -y  wget openssl-devel cmake libevent-devel libjpeg-devel giflib-devel libpng-devel libwebp-devel ImageMagick-devel libmemcached-devel 
sudo yum install -y glibc-headers gcc-c++
sudo yum install -y build-essential nasm
</code></pre></td></tr></table>
</div>
</div><p>Installation dependencies.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># openssl</span>
mkdir /usr/local/zimg/openssl
<span class="nb">cd</span> /usr/local/zimg/openssl
wget http://www.openssl.org/source/openssl-1.0.1i.tar.gz
tar zxvf openssl-1.0.1i.tar.gz
<span class="nb">cd</span> openssl-1.0.1i
./config shared --prefix<span class="o">=</span>/usr/local --openssldir<span class="o">=</span>/usr/ssl
make <span class="o">&amp;&amp;</span> make install

<span class="c1"># cmake</span>
mkdir /usr/local/zimg/cmake
<span class="nb">cd</span> /usr/local/zimg/cmake
wget http://www.cmake.org/files/v3.0/cmake-3.0.1.tar.gz
tar xzvf cmake-3.0.1.tar.gz 
<span class="nb">cd</span> cmake-3.0.1
./bootstrap --prefix<span class="o">=</span>/usr/local 
make <span class="o">&amp;&amp;</span> make install

<span class="c1"># libevent</span>
mkdir /usr/local/zimg/libevent
<span class="nb">cd</span> /usr/local/zimg/libevent
wget http://cloud.github.com/downloads/libevent/libevent/libevent-2.0.21-stable.tar.gz
tar zxvf libevent-2.0.21-stable.tar.gz
<span class="nb">cd</span> libevent-2.0.21-stable
./configure --prefix<span class="o">=</span>/usr/local 
make <span class="o">&amp;&amp;</span> make install

<span class="c1"># libjpeg-turbo</span>
mkdir /usr/local/zimg/libjpeg-turbo
<span class="nb">cd</span> /usr/local/zimg/libjpeg-turbo
wget https://downloads.sourceforge.net/project/libjpeg-turbo/1.3.1/libjpeg-turbo-1.3.1.tar.gz
tar zxvf libjpeg-turbo-1.3.1.tar.gz
<span class="nb">cd</span> libjpeg-turbo-1.3.1
./configure --prefix<span class="o">=</span>/usr/local --with-jpeg8
make <span class="o">&amp;&amp;</span> make install

<span class="c1"># webp</span>
mkdir /usr/local/zimg/webp
<span class="nb">cd</span> /usr/local/zimg/
wget http://downloads.webmproject.org/releases/webp/libwebp-0.4.1.tar.gz
tar zxvf libwebp-0.4.1.tar.gz
<span class="nb">cd</span> libwebp-0.4.1
./configure
make
sudo make install

<span class="c1"># jpegsrc</span>
mkdir /usr/local/zimg/jpegsrc
<span class="nb">cd</span> /usr/local/zimg/
wget http://www.ijg.org/files/jpegsrc.v8b.tar.gz
tar -xf  jpegsrc.v8b.tar.gz
<span class="nb">cd</span> jpeg-8b
./configure --prefix<span class="o">=</span>/usr/local --enable-shared --enable-static
make <span class="o">&amp;&amp;</span> make install

<span class="c1"># imageMagic</span>
mkdir /usr/local/zimg/imageMagick
<span class="nb">cd</span> /usr/local/zimg/
wget http://www.imagemagick.org/download/ImageMagick.tar.gz
tar zxvf ImageMagick.tar.gz
<span class="nb">cd</span> ImageMagick-6.9.1-10
./configure  --prefix<span class="o">=</span>/usr/local 
make <span class="o">&amp;&amp;</span> make install

<span class="c1"># libmemcached</span>
wget https://launchpad.net/libmemcached/1.0/1.0.18/+download/libmemcached-1.0.18.tar.gz
tar zxvf libmemcached-1.0.18.tar.gz
<span class="nb">cd</span> libmemcached-1.0.18
./configure -prefix<span class="o">=</span>/usr/local 
make <span class="o">&amp;&amp;</span>　make install
</code></pre></td></tr></table>
</div>
</div><p>Optional plug-ins.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># memcached</span>
wget http://www.memcached.org/files/memcached-1.4.19.tar.gz
tar zxvf memcached-1.4.19.tar.gz
<span class="nb">cd</span> memcached-1.4.19
./configure --prefix<span class="o">=</span>/usr/local
make
make install

<span class="c1"># beansdb</span>
git clone https://github.com/douban/beansdb
<span class="nb">cd</span> beansdb
./configure --prefix<span class="o">=</span>/usr/local
make

<span class="c1"># benseye</span>
git clone git@github.com:douban/beanseye.git
<span class="nb">cd</span> beanseye
make

<span class="c1"># SSDB</span>
wget --no-check-certificate https://github.com/ideawu/ssdb/archive/master.zip
unzip master
<span class="nb">cd</span> ssdb-master
make

<span class="c1"># twemproxy</span>
git clone git@github.com:twitter/twemproxy.git
<span class="nb">cd</span> twemproxy
autoreconf -fvi
./configure --enable-debug<span class="o">=</span>log
make
src/nutcracker -h
</code></pre></td></tr></table>
</div>
</div><p>Build zimg</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">cd</span> /usr/local
<span class="c1">#git clone https://github.com/buaazp/zimg -b master --depth=1</span>
<span class="nb">cd</span> zimg   
make
</code></pre></td></tr></table>
</div>
</div><p>After successful installation.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">cd</span> /usr/local/zimg/bin
./zimg conf/zimg.lua
</code></pre></td></tr></table>
</div>
</div><p>Open <code>http://localhost:4869</code> to see if the installation is successful.</p>
<p>If it&rsquo;s too much trouble to install manually, just use the docker image</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># 拉取zimg镜像</span>
$ docker pull iknow0612/zimg
<span class="c1"># 启动zimg容器</span>
$ docker run -it -d -p 4869:4869 -v /data/zimg/:/zimg/bin/img --name my_zimg iknow0612/zimg sh app.sh
</code></pre></td></tr></table>
</div>
</div><p>You can package your own image service based on zimg.</p>
<p>Reference links.</p>
<ul>
<li><a href="https://github.com/buaazp/zimg">https://github.com/buaazp/zimg</a></li>
<li><a href="https://github.com/fengkuangdejava/java-springboot-zimg">https://github.com/fengkuangdejava/java-springboot-zimg</a></li>
<li><a href="https://github.com/liyouzhi/zimg-python">https://github.com/liyouzhi/zimg-python</a></li>
</ul>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/zimg/">zimg</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2021-11/swig-python/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">SWIG implementation of Python calls C/C&#43;&#43; code</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2021-11/fuzzywuzzy/">
            <span class="next-text nav-default">Python string fuzzy matching library FuzzyWuzzy</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
