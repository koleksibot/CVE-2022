<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Real-time messaging technology in web applications - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="In Internet applications, many times we need real-time message interaction between the client and the server, such as the following scenarios. SNS site user interaction message notification (weibo/twitter) Real-time scrolling news (breaking news), live text (sports events) on portals Online chat rooms (online customer service) Real-time data display (real-time stock prices, real-time commodity prices, real-time server monitoring, etc.) Next, let&amp;rsquo;s take a look at the common technical solutions for real" /><meta name="keywords" content="websocket, socketio" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2021-11/real-time-web-application/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Real-time messaging technology in web applications" />
<meta property="og:description" content="In Internet applications, many times we need real-time message interaction between the client and the server, such as the following scenarios. SNS site user interaction message notification (weibo/twitter) Real-time scrolling news (breaking news), live text (sports events) on portals Online chat rooms (online customer service) Real-time data display (real-time stock prices, real-time commodity prices, real-time server monitoring, etc.) Next, let&rsquo;s take a look at the common technical solutions for real" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2021-11/real-time-web-application/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-11-13T13:06:51+08:00" />
<meta property="article:modified_time" content="2021-11-13T13:06:51+08:00" />

<meta itemprop="name" content="Real-time messaging technology in web applications">
<meta itemprop="description" content="In Internet applications, many times we need real-time message interaction between the client and the server, such as the following scenarios. SNS site user interaction message notification (weibo/twitter) Real-time scrolling news (breaking news), live text (sports events) on portals Online chat rooms (online customer service) Real-time data display (real-time stock prices, real-time commodity prices, real-time server monitoring, etc.) Next, let&rsquo;s take a look at the common technical solutions for real"><meta itemprop="datePublished" content="2021-11-13T13:06:51+08:00" />
<meta itemprop="dateModified" content="2021-11-13T13:06:51+08:00" />
<meta itemprop="wordCount" content="3027">
<meta itemprop="keywords" content="websocket,socketio," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Real-time messaging technology in web applications"/>
<meta name="twitter:description" content="In Internet applications, many times we need real-time message interaction between the client and the server, such as the following scenarios. SNS site user interaction message notification (weibo/twitter) Real-time scrolling news (breaking news), live text (sports events) on portals Online chat rooms (online customer service) Real-time data display (real-time stock prices, real-time commodity prices, real-time server monitoring, etc.) Next, let&rsquo;s take a look at the common technical solutions for real"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Real-time messaging technology in web applications</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-11-13 13:06:51 </span>
        <div class="post-category">
            <a href="/categories/skills/"> skills </a>
            </div>
          <span class="more-meta"> 3027 words </span>
          <span class="more-meta"> 7 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#normal-http">Normal HTTP</a></li>
        <li><a href="#common-real-time-messaging-technologies">Common real-time messaging technologies</a>
          <ul>
            <li><a href="#ajax-polling-polling">AJAX Polling (polling)</a></li>
            <li><a href="#ajax-long-polling-long-polling">AJAX Long-Polling (long polling)</a></li>
            <li><a href="#streaming-based-mode-http-streaming--iframe-streaming">Streaming-based mode (http-streaming / iframe-streaming)</a></li>
            <li><a href="#html5-server-sent-events-sse--eventsource">HTML5 Server Sent Events (SSE) / EventSource</a></li>
            <li><a href="#html5-websockets">HTML5 Websockets</a></li>
            <li><a href="#flash-socket">Flash Socket</a></li>
          </ul>
        </li>
        <li><a href="#how-to-choose-a-solution">How to choose a solution?</a>
          <ul>
            <li><a href="#socketio">Socket.IO</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>In Internet applications, many times we need real-time message interaction between the client and the server, such as the following scenarios.</p>
<ul>
<li>SNS site user interaction message notification (weibo/twitter)</li>
<li>Real-time scrolling news (breaking news), live text (sports events) on portals</li>
<li>Online chat rooms (online customer service)</li>
<li>Real-time data display (real-time stock prices, real-time commodity prices, real-time server monitoring, etc.)</li>
</ul>
<p>Next, let&rsquo;s take a look at the common technical solutions for real time messaging implementation in web development, each of which has its own advantages and disadvantages and different options for different application scenarios.</p>
<p>Real-time push technology in the Web domain, also known as Realtime technology. The goal of this technology is to allow users to get real-time updates without refreshing their browsers. It has a wide range of application scenarios, such as online chat rooms, online customer service systems, commenting systems, WebIM, etc.</p>
<h2 id="normal-http">Normal HTTP</h2>
<p>The HTTP protocol has one characteristic: passivity. What is passivity? In fact, the server cannot initiate contact with the client, it can only be initiated by the client. For example, if we want to get some data, we have to send a request from the client (such as a browser) to the server, and the server returns the query result. HTTP protocol can&rsquo;t do that the server actively pushes information to the client, such as the alert of receiving new emails. This one-way request feature predetermines that if the server has continuous state changes, the client will be very troublesome to be informed.</p>
<ul>
<li>The client requests a web page from the server</li>
<li>The server responds accordingly</li>
<li>The server returns the corresponding to the client</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/11/13/3b7d8639872e44a9b588b75271e77db5.png" alt=""></p>
<p>Before the WebSocket protocol, there were three ways to implement two-way communication: polling, long-polling, and iframe streaming.</p>
<h2 id="common-real-time-messaging-technologies">Common real-time messaging technologies</h2>
<h3 id="ajax-polling-polling">AJAX Polling (polling)</h3>
<p>The principle of polling is very simple, let the browser send a request every few seconds to ask the server if there is any new information.</p>
<ul>
<li>The client requests the web page from the server using the normal http method</li>
<li>The client executes a JavaScript polling script in the web page and sends requests to the server in a regular loop (e.g. every 5 seconds) to get information</li>
<li>The server responds to each request and returns the appropriate information, just like a normal http request</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/11/13/096ca8b034db4121a4eaea4571735421.png" alt=""></p>
<p>The client regularly requests the server to ask if a new message is generated, in this case the client has to establish an http connection for each request and the server has to generate a response message.</p>
<p>An example in layman&rsquo;s terms is.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">while True:
 客户端：妹子，请你吃饭有空吗？（Request）
 服务端：没有！（Response）
 客户端：妹子，请你吃饭有空吗？（Request）
 服务端：没有。。（Response）
 客户端：妹子，请你吃饭有空吗？（Request）
 服务端：你好烦啊，没有啊。。（Response）
 客户端：妹子，请你吃饭有空吗？（Request）
 服务端：好啦好啦，有啦。（Response）
 客户端：妹子，请你吃饭有空吗？（Request）
 服务端：。。。。。没。。。。没。。。没有（Response）
</code></pre></td></tr></table>
</div>
</div><p>As you can see, using polling, the connection between the client and the server will always be made, asking for it every so often. The disadvantage is also obvious: the number of connections will be many, one receiving and one sending. And every time a request is sent, there will be a Header of Http, which will be very traffic-consuming and will consume CPU utilization.</p>
<ul>
<li>Pros: Simple to implement, easy to use, very low development cost, suitable for small applications just starting out or a backup to other programs.</li>
<li>Disadvantages: delayed messages, high network communication consumption (especially in mobile networks), server prone to peak requests.</li>
<li>Implementation: timed requests in the browser with js, or timed http requests in nativeapp on mobile devices.</li>
<li>Scenario: suitable for small applications.</li>
</ul>
<h3 id="ajax-long-polling-long-polling">AJAX Long-Polling (long polling)</h3>
<p>Long-polling in fact, the principle is similar to polling, are using the polling method, but the adoption of the blocking model (keep calling, do not hang up if you do not receive), that is, the client initiates a connection, if there is no message, it does not return Response to the client. It does not return until there is a message, and after it returns, the client establishes a connection again, and so on.</p>
<ul>
<li>The client requests a web page from the server using the normal http method.</li>
<li>The client executes the JavaScript script in the web page to send data and request information to the server</li>
<li>The server does not respond to the client&rsquo;s request immediately, but waits for a valid update</li>
<li>The server pushes the data to the client only when the information is a valid update</li>
<li>When the client receives a notification from the server, it immediately sends a new request and moves on to the next poll</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/11/13/b111dd6aad9b453f9b06a89bec02084c.png" alt=""></p>
<p>Or, in the vernacular, for example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">while True:
 客户端：妹子，请你吃饭有空吗？没有的话就等有了再返回给我吧！（Request）
 服务端：（额。。现在好忙，先不回复他，电话先不挂。）
 服务端：现在有空了。（Response）
 客户端：妹子，请你吃饭有空吗？没有的话就等有了再返回给我吧！（Request）
 服务端：（额。。现在好忙，先不回复他，电话先不挂。）
 服务端：现在有空了。（Response）
</code></pre></td></tr></table>
</div>
</div><p>Essentially, long polling is an improved version of polling, where the client sends HTTP to the server and then sees if there is a new message, and if there is no new message, it waits. When there is a new message, it will be returned to the client. To some extent, this reduces the network bandwidth and CPU utilization problems. Since http packets often have a large amount of header data (usually more than 400 bytes), but very little data is actually needed by the server (sometimes only about 10 bytes), such packets are transmitted periodically on the network, which is inevitably a waste of network bandwidth.</p>
<p>Compared with the above polling mode.</p>
<p>Advantages: messages arrive at the client in a more timely manner; reduces the unnecessary waste of http requests constantly created and closed into. Long-polling supports most current browsers.</p>
<p>Disadvantages: The server side needs to maintain a large number of connections, the maintenance overhead of http connections is large; each time a message is generated, the connection needs to be recreated.</p>
<p>Implementation: The client simply sends a request and waits for a response. The server side needs to do two things: one is to maintain a large number of connections (Non-Blocking I/O); the other is to read the background message updates (asynchronous timing polling or triggered by events). Is a near real-time asynchronous approach.</p>
<p>Examples: WebQQ, Hi web version, Facebook IM.</p>
<h3 id="streaming-based-mode-http-streaming--iframe-streaming">Streaming-based mode (http-streaming / iframe-streaming)</h3>
<p>In this case, the client maintains a persistent connection with the server, and new messages are continuously returned to the client through this persistent connection when they are generated on the server side. This mode is similar to long polling above, the difference is that only one connection needs to be created. Also, note that the http header needs to set the attributes Connection: keep-alive and Transfer-Encoding: chunked. Compared to longpolling mode above.</p>
<ul>
<li>Advantages: messages can reach the client in real time; only one connection needs to be established between the client and the server.</li>
<li>Disadvantages: The server side also has to maintain a large number of connections, which is a lot of overhead.</li>
<li>Implementation: There are generally two ways for the client side: one is to hide the src of the iframe pointing to the server-side url and constantly dom rendering; the second is to use the XMLHttpRequest object in ajax to implement. For the server side, as with long polling, to maintain a large number of connections and handle background message updates.</li>
</ul>
<h3 id="html5-server-sent-events-sse--eventsource">HTML5 Server Sent Events (SSE) / EventSource</h3>
<p>Traditionally, the server side does not actively push messages to the client side, the client side usually takes the initiative to request the server side to get the latest data. SSE is a technology that can actively push messages from the server side.</p>
<p>The essence of SSE is actually an HTTP long connection, except that instead of sending a one-time packet to the client, it sends a stream in the format of text/event-stream, so the client will not close the connection and will keep waiting for the server to send a new stream, and video playback is an example of this.</p>
<ul>
<li>SSE uses the HTTP protocol, which is supported by existing server software. webSocket is a standalone protocol.</li>
<li>SSE is lightweight and simple to use; the WebSocket protocol is relatively complex.</li>
<li>SSE supports disconnected reconnection by default; WebSocket requires its own implementation.</li>
<li>SSE is generally used to send text only, binary data needs to be encoded and sent, WebSocket supports sending binary data by default.</li>
<li>SSE supports customizing the type of messages sent.</li>
<li>The client requests a web page from the server using the normal http method.</li>
<li>A connection is established between the client and the server by executing the JavaScript script in the web page</li>
<li>An event is sent to the client when there is a valid update on the server side
<ul>
<li>Real-time push of server-to-client data, most of which you need</li>
<li>You need a server that can do Event Loop</li>
<li>Cross-domain connections are not allowed</li>
<li>Default delay is 3 seconds, but can be adjusted.</li>
<li>Unless Server-Sent Events doesn&rsquo;t have to close the connection after every response is sent.</li>
<li>Supports Chrome 9+, Firefox 6+, Opera 11+, Safari 5+</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/11/13/0f56a43eaa514a57a78641fea399649b.png" alt=""></p>
<ul>
<li><a href="http://html5doctor.com/server-sent-events">Server-Sent Events</a></li>
<li><a href="http://www.html5rocks.com/en/tutorials/eventsource/basics/">Stream Updates with Server-Sent Events</a></li>
<li><a href="http://jaxenter.com/tutorial-jsf-2-and-html5-server-sent-events-42932.html">Tutorial: JSF 2 and HTML5 Server Sent Events</a></li>
</ul>
<h3 id="html5-websockets">HTML5 Websockets</h3>
<p>WebSocket was born in 2008, became an international standard in 2011 and is now supported by all browsers (see Quick Start for Beginners: A Concise Tutorial on WebSocket for more details). It is a new application layer protocol, a true full-duplex communication protocol designed specifically for web clients and servers, and can be compared to the HTTP protocol to understand the websocket protocol.</p>
<p>Their differences.</p>
<ul>
<li>The protocol identifier is http for HTTP and ws for WebSocket.</li>
<li>HTTP requests can only be initiated by the client, and the server cannot actively push messages to the client, while WebSocket can.</li>
<li>HTTP requests have homologation restrictions, and communication between different sources requires cross-domain, while WebSocket has no homologation restrictions.</li>
</ul>
<p>Their similarities.</p>
<ul>
<li>both are application layer communication protocols.</li>
<li>the default ports are the same, both are 80 or 443.</li>
<li>Both can be used for communication between browsers and servers.</li>
<li>Both are based on TCP protocol.</li>
</ul>
<p>Diagram of the relationship between the two and TCP.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/11/13/31eee17c7abb44958d99d95d5e8e079e.png" alt=""></p>
<ul>
<li>The client requests the web page from the server using the normal http method</li>
<li>The client executes the JavaScript script in the web page and establishes a connection with the server</li>
<li>The server and the client can send valid data to each other in both directions
<ul>
<li>The server can send data to the client in real time, while the client can also send data to the server in real time</li>
<li>You need a server that can do Event Loop</li>
<li>Using WebSockets allows connections to be established across domains</li>
<li>It also supports third-party websocket host servers, such as Pusher or others. This way you only need to care about the client implementation, which reduces the development effort.</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/11/13/bd774fb0c1764f7b9a9c6e337f7642e3.png" alt=""></p>
<ul>
<li>Benefits: Real-time communication, two-way interaction, saving server resources and bandwidth. True real-time.</li>
<li>Disadvantages: Insufficient browser support.</li>
<li>Implementation: client side requires html5 to implement, server side is generally supported by web servers.</li>
</ul>
<p>WebSocket protocol is still under development, Chrome and Safri browsers support WebSocket by default, while Firefox and Opera turn off WebSocket by default for security reasons, and IE does not support it (including 9), currently [WebSocket protocol](<a href="http://dev.w3.org/">http://dev.w3.org/</a> html5/websockets/) is the latest &ldquo;Draft 76&rdquo;. If you are interested, you can read the following information.</p>
<p>If you think this is not enough and want to learn more, you can refer to the following documents and manuals</p>
<ul>
<li><a href="http://www.developerfusion.com/article/143158/an-introduction-to-websockets/">An Introduction To WebSockets</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/WebSockets/Writing_WebSocket_client_applications">Writing WebSocket client applications</a></li>
<li><a href="http://code.tutsplus.com/tutorials/start-using-html5-websockets-today--net-13270">Starting Using HTML5 WebSockets Today</a></li>
</ul>
<h3 id="flash-socket">Flash Socket</h3>
<p>Embed a Flash program JavaScript using Socket class in the page to communicate with the socket interface on the server side by calling the socket interface provided by this Flash program, JavaScript controls the display of the page after receiving the information transmitted from the server side.</p>
<ul>
<li>Pros: Realize real instant communication instead of pseudo instant.</li>
<li>Disadvantages: Flash plug-in must be installed on the client side; non-HTTP protocol, cannot automatically traverse firewalls. (Flash is dead)</li>
<li>Example: Web-based interactive game.</li>
</ul>
<h2 id="how-to-choose-a-solution">How to choose a solution?</h2>
<p>In our practical application, how should the various schemes be chosen?</p>
<p>polling polling mechanism is very simple, easy to use, are http short connection, in the application architecture and ordinary interface api consistent, very suitable for small applications and just starting applications, can save a lot of development costs.</p>
<p>When the number of users rose to a certain level (such as daily activity of a million), the product has become more and more popular, we have higher requirements for the timeliness of the arrival of messages, and this polling mechanism is a test of the pressure on the server, then we can consider the long polling or http streaming way, these two ways in fact in the server-side implementation is similar, mainly to maintain a large number of long connections and asynchronous (or event-triggered) to get the message.</p>
<p>In terms of keeping connections, after the advent of java&rsquo;s nio, which provides us with convenience, mainstream application servers like tomcat and jetty have support, but the server working on jvm to keep a large number of socket connections when gc is a very serious problem. This can be achieved by using nginx&rsquo;s push module to maintain connections and push messages in real time.</p>
<ul>
<li>Module that supports long polling mode:https://pushmodule.slact.net/</li>
<li>Module that supports streaming mode: <a href="http://wiki.nginx.org/HttpPushStreamModule">http://wiki.nginx.org/HttpPushStreamModule</a></li>
</ul>
<p>These two modules work on nginx to maintain a large number of http connections, and implement the pub/sub protocol to support message sending, the basic process is the following figure, the sender (publisher) pushes the message to the nginx server, and then the push module is responsible for sending the message to the subscriber (client): with the help of this nginx push module, we can save a lot of work, and the application only needs to focus on business logic (that is, what the publisher does), simplifying the application architecture, while the high performance of nginx also has a good performance.</p>
<p>When our product grows to 10 million daily activities, we may have to consider better solutions, such as the WebSocket mentioned above, but this solution is not the mainstream solution for browser compatibility issues. Generally in this case, we have to consider tcp-based socket long connection mode, through some kind of message pushing protocol (xmpp/mqtt/self-defined protocol, etc.) to achieve real-time interaction between client and server side.</p>
<h3 id="socketio">Socket.IO</h3>
<p><a href="http://en.wikipedia.org/wiki/Socket.IO">Socket.IO</a> is a fully JavaScript implemented, Node.js based, WebSocket enabled protocol for real-time communication, cross-platform open source framework that includes client-side JavaScript and server-side Node.js. It is a library that provides cross-platform real-time communication for real-time applications. socket.io aims to make real-time applications possible on every browser and mobile device, blurring the differences between different transport mechanisms. socket.io gets its name from the fact that it uses the HTML5 WebSocket standard supported and adopted by browsers, since not all browsers support WebSocket, the library supports a number of downgraded features: the</p>
<ul>
<li>Websocket</li>
<li>Adobe® Flash® Socket</li>
<li>AJAX long polling</li>
<li>AJAX multipart streaming</li>
<li>Forever Iframe</li>
<li>JSONP Polling</li>
</ul>
<p>In most contexts, you have the option to maintain a similar long connection to the browser with these features.</p>
<p>IO is designed to build real-time applications that work well on different browsers and mobile devices, such as real-time analytics systems, binary stream data processing applications, online chat rooms, online customer service systems, commenting systems, WebIM, etc. Socket.IO already has many powerful modules and extension APIs, such as (<a href="https://github.com/functioncallback/session.socket.io">session. socket.io)</a> (http session middleware for session-related operations), <a href="https://github">socket.io-cookie</a> .com/ivpusic/socket.io-cookie) (cookie parsing middleware), <a href="https://github.com/kazuyukitanimura/session-web-sockets">session-web-sockets</a> (secure way to session passing), <a href="https://github.com/saikat/socket-logger/">socket-logger</a> (JSON format logging tool), <a href="https://github.com/">websocket.MQ</a> networkimprov/websocket.MQ) (reliable message queue), <a href="https://github.com/kof/socket.io-mongo">socket.io-mongo</a> (adapter using <a href="http://www.mongodb.org/">MongoDB</a> adapter), <a href="https://github.com/Automattic/socket.io-redis">socket.io-redis</a> (adapter for Redis), <a href="https://github.com/">socket.io-parser</a> Automattic/socket.io-parser) (the default protocol implementation module for server-side and client-side communication), etc.</p>
<p>IO implements a real-time, bi-directional, event-based communication mechanism, which solves the problem of real-time communication and unifies the way server and client are programmed. After starting Socket, it is like establishing a pipeline between the client and the server, so that both sides can communicate with each other. It also works well with traditional request methods provided by Express.js, i.e., it provides two types of connections on the same domain and port: request/response, websocket (flashsocket, ajax&hellip;).</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/websocket/">websocket</a>
          <a href="/tags/socketio/">socketio</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2021-11/cgi-fastcgi-wsgi/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Difference between gateway protocols CGI, FastCGI, WSGI</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2021-11/python-collections/">
            <span class="next-text nav-default">Python Module: Container DatatypesCollections</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
