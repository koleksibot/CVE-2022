<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Android applications: apk file decompilation - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="APK file introduction Each application that needs to be installed to the android platform is compiled and packaged as a separate file with the suffix .apk (Android application package), which contains the binary code, resources, configuration files, etc. of the application. The apk file is actually a zip archive that can be unzipped by an unzip tool (change the suffix to .zip and then unzip it with the unzip file.)" /><meta name="keywords" content="apk, Decompile, Android" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2021-11/apk-decompile/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Android applications: apk file decompilation" />
<meta property="og:description" content="APK file introduction Each application that needs to be installed to the android platform is compiled and packaged as a separate file with the suffix .apk (Android application package), which contains the binary code, resources, configuration files, etc. of the application. The apk file is actually a zip archive that can be unzipped by an unzip tool (change the suffix to .zip and then unzip it with the unzip file.)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2021-11/apk-decompile/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-11-04T21:58:29+08:00" />
<meta property="article:modified_time" content="2021-11-04T21:58:29+08:00" />

<meta itemprop="name" content="Android applications: apk file decompilation">
<meta itemprop="description" content="APK file introduction Each application that needs to be installed to the android platform is compiled and packaged as a separate file with the suffix .apk (Android application package), which contains the binary code, resources, configuration files, etc. of the application. The apk file is actually a zip archive that can be unzipped by an unzip tool (change the suffix to .zip and then unzip it with the unzip file.)"><meta itemprop="datePublished" content="2021-11-04T21:58:29+08:00" />
<meta itemprop="dateModified" content="2021-11-04T21:58:29+08:00" />
<meta itemprop="wordCount" content="7383">
<meta itemprop="keywords" content="apk,android," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Android applications: apk file decompilation"/>
<meta name="twitter:description" content="APK file introduction Each application that needs to be installed to the android platform is compiled and packaged as a separate file with the suffix .apk (Android application package), which contains the binary code, resources, configuration files, etc. of the application. The apk file is actually a zip archive that can be unzipped by an unzip tool (change the suffix to .zip and then unzip it with the unzip file.)"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Android applications: apk file decompilation</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-11-04 21:58:29 </span>
        <div class="post-category">
            <a href="/categories/skills/"> skills </a>
            </div>
          <span class="more-meta"> 7383 words </span>
          <span class="more-meta"> 15 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#apk-file-introduction">APK file introduction</a>
          <ul>
            <li><a href="#androidmanifestxml">AndroidManifest.xml</a></li>
            <li><a href="#res-folder">Res folder</a></li>
            <li><a href="#resourcesarsc-file">resources.arsc file</a></li>
            <li><a href="#meta-inf-directory">META-INF directory</a></li>
            <li><a href="#classesdex-file">classes.dex file</a></li>
            <li><a href="#lib-folder">lib folder</a></li>
          </ul>
        </li>
        <li><a href="#apk-packaging-process">Apk packaging process</a></li>
        <li><a href="#apk-file-decompilation">APK file decompilation</a>
          <ul>
            <li><a href="#resource-file-acquisition">Resource file acquisition</a></li>
            <li><a href="#decompilation-of-xml-files">Decompilation of XML files</a></li>
            <li><a href="#classesdex-file-decompilation">classes.dex file decompilation</a></li>
            <li><a href="#automation-tools-summary-onekey-decompile-apk">Automation Tools Summary (Onekey Decompile Apk)</a></li>
          </ul>
        </li>
        <li><a href="#apk-decompilation-advanced">APK Decompilation Advanced</a>
          <ul>
            <li><a href="#android-obfuscation-handling-proguard">Android obfuscation handling: ProGuard</a></li>
            <li><a href="#dexguard-obfuscation-anti-secondary-packaging">DexGuard Obfuscation (Anti-Secondary Packaging)</a></li>
            <li><a href="#apk-file-shelling">Apk file shelling</a></li>
            <li><a href="#identification-of-shells">Identification of shells</a></li>
            <li><a href="#commonly-used-shelling-software">Commonly used shelling software</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="apk-file-introduction">APK file introduction</h2>
<p>Each application that needs to be installed to the android platform is compiled and packaged as a separate file with the suffix .apk (Android application package), which contains the binary code, resources, configuration files, etc. of the application.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/11/04/f0d8d0e5f71f4811a79c9c18f4d171fc.png" alt=""></p>
<p>The apk file is actually a zip archive that can be unzipped by an unzip tool (change the suffix to .zip and then unzip it with the unzip file.) The approximate directory structure of the APK file is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">|– AndroidManifest.xml
|– META-INF
| |– CERT.RSA
| |– CERT.SF
| `– MANIFEST.MF
|– classes.dex
|– res
| |– drawable
| | `– icon.png
| `– layout
| `– main.xml
`– resources.arsc
</code></pre></td></tr></table>
</div>
</div><h3 id="androidmanifestxml">AndroidManifest.xml</h3>
<p>The official explanation of AndroidManifes.xml is the application manifest, which must contain one in the root directory of every application and the file name must be exactly the same. This file contains the configuration information of the APP, and the system needs to run the APP code and display the interface according to the content inside.</p>
<p>The above functions are explained in a very general way, the specific details are.</p>
<ul>
<li>Name the Java package for the application. The package name acts as a unique identifier for the application.</li>
<li>Describes the components of the application, including the Activity, services, broadcast receivers, and content providers that make up the application. It also names the classes that implement each component and publishes its functionality, such as the <a href="https://developer.android.com/reference/android/content/Intent.html?hl=zh-cn">Intent</a> messages they can handle. These declarations inform the Android system about the components and the conditions under which they can be launched.</li>
<li>Identifies the processes that host the application components.</li>
<li>Declares what permissions the application must have to access protected parts of the API and interact with other applications. Also declares the permissions that other applications need to have to interact with the application component</li>
<li>Lists the <a href="https://developer.android.com/reference/android/app/Instrumentation.html?hl=zh-cn">Instrumentation</a> classes that provide analysis and other information at application runtime. These declarations will only appear in the manifest while the app is in the development phase and will be removed before the app is released.</li>
<li>Declares the minimum Android API level required by the application</li>
<li>List the libraries that the app must link to</li>
</ul>
<p>The above is the official explanation. Many things are not understandable and not used yet, so let&rsquo;s pick the ones we can understand first for explanation.</p>
<ul>
<li>The first one: provide the package name. This is the name of our apk, usually our name is something like &ldquo;com.android.helloworld&rdquo;, similar to the Java class name, the purpose is to make sure that it is a unique value.</li>
<li>The second article: describes each component of the application. This is used to define the four main components. The one we use most often is the Activity component. It needs to define the presentation of the component (component name, theme, startup type), the actions the component can respond to (e.g. a certain startup intent), etc.</li>
<li>Article 3, 4 and 5: Not used yet, no explanation.</li>
<li>Article 5: Declares the minimum API level. This level can also be defined in the gradle file with the field minSdkVersion. it is less often defined in the AndroidManifest.xml file.</li>
<li>Article 6: List the necessary lib libraries. This thing doesn&rsquo;t seem to have much function in Android Studio after 0, because after 3.0 compilation uses CMakeLists.txt file, and build.gradle file to specify libraries.</li>
</ul>
<p>Example of AndroidManifest.xml file.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;manifest</span> <span class="na">xmlns:android=</span><span class="s">&#34;http://schemas.android.com/apk/res/android&#34;</span>
          <span class="na">package=</span><span class="s">&#34;com.sample.teapot&#34;</span>
          <span class="na">android:versionCode=</span><span class="s">&#34;1&#34;</span>
          <span class="na">android:versionName=</span><span class="s">&#34;1.0.0.1&#34;</span> <span class="nt">&gt;</span>

  <span class="nt">&lt;uses-feature</span> <span class="na">android:glEsVersion=</span><span class="s">&#34;0x00020000&#34;</span><span class="nt">&gt;&lt;/uses-feature&gt;</span>

  <span class="nt">&lt;application</span>
      <span class="na">android:allowBackup=</span><span class="s">&#34;false&#34;</span>
      <span class="na">android:fullBackupContent=</span><span class="s">&#34;false&#34;</span>
      <span class="na">android:supportsRtl=</span><span class="s">&#34;true&#34;</span>
      <span class="na">android:icon=</span><span class="s">&#34;@mipmap/ic_launcher&#34;</span>
      <span class="na">android:label=</span><span class="s">&#34;@string/app_name&#34;</span>
      <span class="na">android:theme=</span><span class="s">&#34;@style/AppTheme&#34;</span>
      <span class="na">android:name=</span><span class="s">&#34;com.sample.teapot.TeapotApplication&#34;</span>
      <span class="nt">&gt;</span>

    <span class="c">&lt;!-- Our activity is the built-in NativeActivity framework class.
</span><span class="c">         This will take care of integrating with our NDK code. --&gt;</span>
    <span class="nt">&lt;activity</span> <span class="na">android:name=</span><span class="s">&#34;com.sample.teapot.TeapotNativeActivity&#34;</span>
              <span class="na">android:label=</span><span class="s">&#34;@string/app_name&#34;</span>
              <span class="na">android:configChanges=</span><span class="s">&#34;orientation|keyboardHidden&#34;</span><span class="nt">&gt;</span>
      <span class="c">&lt;!-- Tell NativeActivity the name of our .so --&gt;</span>
      <span class="nt">&lt;meta-data</span> <span class="na">android:name=</span><span class="s">&#34;android.app.lib_name&#34;</span>
                 <span class="na">android:value=</span><span class="s">&#34;TeapotNativeActivity&#34;</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;intent-filter&gt;</span>
        <span class="nt">&lt;action</span> <span class="na">android:name=</span><span class="s">&#34;android.intent.action.MAIN&#34;</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;category</span> <span class="na">android:name=</span><span class="s">&#34;android.intent.category.LAUNCHER&#34;</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;/intent-filter&gt;</span>
    <span class="nt">&lt;/activity&gt;</span>
  <span class="nt">&lt;/application&gt;</span>
<span class="nt">&lt;/manifest&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>This is a file from the teapots project in the official Google example, and we will analyze the meaning of the fields for this file. The reference for the meaning of the fields is <a href="https://developer.android.com/guide/topics/manifest/manifest-element?hl=zh-cn">official documentation</a>.</p>
<p><strong><code>&lt;manifest&gt;</code> element:</strong> All xml&rsquo;s must contain the <code>&lt;manifest&gt;</code> element. This is the root node of the file. It must contain the <code>&lt;application&gt;</code> element and specify the xmlns:android and package attributes.</p>
<p>Attributes in the <strong><code>&lt;manifest&gt;</code> element</strong> :</p>
<ul>
<li>xmlns:android This attribute defines the Android namespace. It must be set to &ldquo;<a href="http://schemas.android.com/apk/res/android%22">http://schemas.android.com/apk/res/android&quot;</a>. Do not change it manually.</li>
<li>packageThis is a complete Java language style package name. Package names consist of letters (both upper and lower case), numbers and underscores. Each individual name must begin with a letter. The package name also represents the unique application ID, which is used to distribute the application. However, one thing to note is that in the last step of the APK build process, the package name is replaced by the applicationId property in the gradle file. If the two properties have the same value, then all is well, if not, then be careful. When building the APK, the build system uses this attribute to do two things.
<ul>
<li>Use this name as namespace when generating java classes (for accessing resources of the APP). For example: package is set to com.sample.teapot, then the generated R class is: com.sample.teapot.</li>
<li>Used to generate the full class name of the class defined in the manifest file. For example, if the package is set to sample.teapot and the activity element is declared as <code>&lt;activity android:name=&quot;.MainActivity&quot;&gt;</code>, the full class name is com.sample.teapot MainActivity.</li>
</ul>
</li>
<li>android:versionCode: the internal version number. Used to indicate which version is updated. This number is not displayed to the user. This number must be an integer. This number must be an integer. It cannot be in hexadecimal, i.e. it does not accept parameters like &ldquo;0x1″.</li>
<li>android:versionName: the version number to be shown to the user.</li>
</ul>
<p><strong>elements in the <code>&lt;manifest&gt;</code> element</strong></p>
<ul>
<li><code>&lt;uses-feature&gt;</code> element: Google Play uses the value of this element to filter the app from devices that don&rsquo;t match the app&rsquo;s needs. What this does is tell others about the hardware or software conditions that the app relies on. It states which features of the app can change with the device. When using it, note that each feature must be specified in a separate <code>&lt;uses-feature&gt;</code> element, and for multiple features, multiple <code>&lt;uses-feture&gt;</code> elements are required. For example, to require a device to have both Bluetooth and camera capabilities.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;uses-feature</span> <span class="na">android:name=</span><span class="s">&#34;android.hardware.bluetooth&#34;</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;uses-feature</span> <span class="na">android:name=</span><span class="s">&#34;android.hardware.camera&#34;</span> <span class="nt">/&gt;</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>Attributes of <code>&lt;uses-feature&gt;</code>.
<ul>
<li>android:name: This attribute specifies the hardware or software feature to be used by the app as a string.</li>
<li>android:required: This attribute is true if the feature is required or the app won&rsquo;t work, false if it means the app will use the feature when necessary, but the app will work without it.</li>
<li>android:glEsVersion: Specify the version of Opengl ES required by the application. The higher 16 bits indicate the major version number, and the lower 16 bits indicate the minor version number. For example, if it is to be version 2, it is 0x00030002. If multiple glEsVersions are defined, the application will automatically enable the highest setting.</li>
</ul>
</li>
<li><code>&lt;application&gt;</code> element: This element describes the configuration of the application. It is a required element that contains a number of child elements to describe the application&rsquo;s components, and its attributes affect all child components. Many attributes (such as icon, label, permission, process, taskAffinity, and allowTaskReparenting) can be set to default values.
<ul>
<li><code>&lt;application&gt;</code> properties
<ul>
<li>android:allowBackup: Indicates whether to allow the app to be added to the backup restore structure. If set to false, then the app will not backup restore. The default value is true.</li>
<li>android:fullBackupContent: This attribute points to an xml file that contains rules for full backups when automatic backups are performed. These rules define which files need to be backed up. This attribute is an optional attribute. By default, automatic backups include most of the app files.</li>
<li>android:supportsRtl: Declares whether your app supports RTL (Right To Left) layout. If set to true, and targetSdkVersion is set to 17 or higher. Many RTL APIs will be set to fire so that your app can display RTL layouts. If set to false or targetSdkVersion is set to 16 or lower. which RTL APIs will not work. The default value of this property is false.</li>
<li>android:icon: the icon of the app, and the default icon of each component. Icons can be customized in the group price. This property must be set to a reference to a drawable resource, which must contain an image. The system does not set a default icon. For example, mipmap/ic_launcher refers to the following resource</li>
<li>android🏷️ a user-readable label, and the default label for all components. Child components can define their own label with their label property, or if none is defined, then this label is used. Labels must be set to a reference to a string resource. This way they can be positioned like anything else, such as @string/app_name. of course, you can also define a raw string for development convenience.</li>
<li>android:theme: This attribute defines the theme&rsquo;s used by the application, it is a reference to a style resource. Each activity can also set its own theme with its own theme property.</li>
<li>android:name: the full name of the Application subclass. Include the preceding path. For example, sample.teapot.TeapotApplication. When the application is launched, the first instance of this class is created. This attribute is optional and is not required by most apps. In the absence of this attribute, Android will launch an instance of the Application class.</li>
</ul>
</li>
<li><code>&lt;activity&gt;</code> element: This element declares an Activity (a subclass of the Activity class) that implements the visual interface of the app. This is a required child element of the <code>&lt;application&gt;</code> element. All Activities must be represented by the <code>&lt;activity&gt;</code> element in the manifest file. Any Activity that is not declared there is not visible to the system and will never be executed.
<ul>
<li>android:name: The name of the Activity class, which is a subclass of the Activity class. The value of this attribute is the name of a fully qualified class, such as sample.teapot.TeapotNativeActivity. , then the package name in the <code>&lt;manifest&gt;</code> element needs to be added. This name should not be changed once the application is published. There is no default value and the name must be specified.</li>
<li><code>android:label</code>: Activity label, which can be read by the user. The label is displayed on the screen when the Activity is active. If not set, use the label attribute in <code>&lt;application&gt;</code>. The requirements for setting the attribute are the same as in <code>&lt;application&gt;</code>.</li>
<li>android:configChanges: Lists the configuration change messages that the Activity will handle on its own. When a configuration change occurs at runtime, the default is to shut down the Activity and restart it, but declaring the configuration with this attribute will prevent the Activity from restarting. Instead, the Activity will remain running and the system will call its <a href="https://developer.android.com/reference/android/app/Activity.html?hl=zh-cn#">onConfigurationChanged()</a> onConfigurationChanged(android.content.res.Configuration)) method. Note: This property should be avoided and should only be used as a last resort. For more information on how to properly handle restarts due to configuration changes, please read <a href="https://developer.android.com/guide/topics/resources/runtime-changes.html?hl=zh-cn">Handling Runtime Changes</a>. There are many items that can be set for this property, here is a list of commonly used items.
<ul>
<li>orientation: the screen has changed, e.g. the user has rotated the device</li>
<li>keyboardHidden: the keyboard accessibility has changed, for example, the user shows the hardware keyboard</li>
<li>android:launchMode: instructions on how to launch the Activity. There are four kinds of instructions: &ldquo;standard&rdquo;, &ldquo;singleTop&rdquo;, &ldquo;singleTask&rdquo;, &quot; These modes are divided into two categories: &ldquo;standard&rdquo; and &ldquo;singleTop&rdquo; are one. The Activity in this mode can be instantiated multiple times. Instances can belong to any task and can be located anywhere in the Activity stack. singleTask&rdquo; and &ldquo;singleInstance&rdquo; are a class. This mode can only start tasks, which are always located at the root of the Activity stack. In addition, the device can only keep one instance of Activity at a time. When set to singleTask, the system creates the Activity at the root of the new task and delivers an Intent to it. if an Activity instance already exists, the system delivers an Intent to it by calling the onNewIntent() method of that instance instead of creating a new Activity instance.</li>
</ul>
</li>
<li>android:theme: set the theme format, similar to the theme in <code>&lt;application&gt;</code>.</li>
</ul>
</li>
<li><code>&lt;meta-data&gt;</code> element: specifies an additional data item, which is a name-value pair, to be provided to its parent component. This data will form a Bundle object that can be used by the metaData field. Although multiple <code>&lt;meta-data&gt;</code> element tags can be used, it is not recommended to use them this way. If there are multiple data items to be specified, the recommended practice is to combine multiple data items into a single resource and then use a single <code>&lt;meta-data&gt;</code> to include them. This element has three attributes.
<ul>
<li>android:name: the name of the data item, which is a unique value.</li>
<li>android:resource: a reference to a resource.</li>
<li>android:value: the value of the data item.</li>
</ul>
</li>
<li><code>&lt;intent-filter&gt;</code> element: indicates what kind of intent (intent) this activity can be launched with. This element has several child elements that can be included. We&rsquo;ll start with the two that we encountered.
<ul>
<li><code>&lt;action&gt;</code> element: Indicates what action the activity is launched as. intent.action.MAIN indicates that it is launched as the main activity.</li>
<li><code>&lt;category&gt;</code> element: This is additional category information for the action element. intent.category.LAUNCHER indicates that this activity is the highest priority Activity for the current application.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>It should be noted that the AndroidManifest.xml file extracted directly by zip is compressed. If you open it directly with notepad, it will be messy. You can unzip it by AXMLPrinter2 tool. The specific process will be described in detail later.</p>
<h3 id="res-folder">Res folder</h3>
<p>Inside the Android project folder, the main <a href="https://developer.android.com/guide/topics/resources/providing-resources.html#ResourceTypes">resource files</a> are placed in the res folder. The res folder is for all the resource files.</p>
<ul>
<li>res/assets: assets folder is to store the native files without compilation processing, that is, the files inside this folder will not be pre-compiled like xml, java files, and can store some images, html, js, css and other files. assets directory will not be mapped to R, so the resources cannot be obtained by id, but must be operated and obtained through AssetManager can be manipulated and obtained. assets can have multiple levels of directories (only the /assets directory can contain any list of subdirectories. (Each other directory can only have files of that directory level). Note: Gradle does not create the asserts folder by default, but its path already exists under the main folder.</li>
<li>res/animator: The XML file used to define the attribute animation.</li>
<li>res/anim: The XML file used to define the animation object. Holds XML files that define tweened animation or frame by frame animation.</li>
<li>res/drawable: store various image types, can&rsquo;t define the file name purely numeric, can also create a new .xml file type Usually custom control style will create a new .xml format file in this folder as background image.</li>
<li>res/color: XML file for defining the color state list. See <a href="https://developer.android.com/guide/topics/resources/color-list-resource">color state list resource</a></li>
<li>res/layout: XML file for defining the layout of the user interface.</li>
<li>res/menu: XML file for defining application menus (such as option menus, context menus or submenus).</li>
<li>res/raw: any file to be saved in raw form. To open these resources using the raw InputStream, call Resources.openRawResource() with the resource ID (i.e. raw.filename). However, to access the original filename and file hierarchy, consider saving some resources in the assets/ directory instead of res/raw/. The files in assets/ do not have resource IDs, so you can only read them using the AssetManager.</li>
<li>res/values: XML files that contain simple values such as strings, integers, and colors. XML resource files in other res/ subdirectories define a single resource based on the XML filename, while files in the values/ directory can describe multiple resources. For the files in this directory, each child element of the <code>&lt;resources&gt;</code> element defines a resource. For example, the <code>&lt;string&gt;</code> element creates the string resource and the <code>&lt;color&gt;</code> element creates the R.color resource. Since each resource is defined using its own XML element, you can name the files as you like and put different resource types in a given file. However, you may need to put unique resource types in different files to make them visible at a glance. For example, for the resources that can be created in this directory, the appropriate filename conventions are given below.
<ul>
<li>xml: array of resources (type array).</li>
<li>xml: color value.</li>
<li>xml: size value.</li>
<li>xml: string value.</li>
<li>xml: style.</li>
</ul>
</li>
<li>res/xml: Any XML file that can be read at runtime by calling getXML(). Various XML configuration files (such as searchable configurations) must be saved here.</li>
<li>res/xml: a font file with an extension (such as .ttf, .otf, or .ttc), or an XML file containing the <code>&lt;font-family&gt;</code> element.</li>
</ul>
<h3 id="resourcesarsc-file">resources.arsc file</h3>
<p>The resource.arsc file is a resource index file generated during the Apk packaging process. You can see the resource.arsc file when you decompress the apk or analyze the apk with Android Studio. By learning the structure of resource.arsc file, it can help us understand the duplicate resource removal and resource file name obfuscation techniques used in apk package volume optimization.</p>
<p><strong>arsc file role</strong></p>
<p>Accessing a file in Java is required to provide the file path, e.g.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="s">&#34;./res/drawable-xxhdpi/img.png&#34;</span><span class="o">);</span>
</code></pre></td></tr></table>
</div>
</div><p>But in Android, you can get the resource file by drawable Id:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">getDrawable</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">drawable</span><span class="o">.</span><span class="na">img</span><span class="o">);</span>
</code></pre></td></tr></table>
</div>
</div><p>Here the content of the resource file can be obtained with an id, eliminating the need for manual input of the file path, which is achieved behind the scenes by reading the arsc file. These values of R.drawable.xxx, R.layout.xxx, R.string.xxx, etc. (stored in R.jar or R.java files) are called resource indexes, through which the actual resource paths or resource values can be retrieved in the arsc file. For example: getDrawable(R.drawable.img) becomes getDrawable(2131099964) after compilation, then convert the id to hex: 2131099964 = 0x7f06013c. This time the resource index is 0x7f06013c.</p>
<p>The resource index has a fixed format: 0xPPTTEEEE, PackageId (2 bits) + TypeId (2 bits) + EntryId (4 bits) :.</p>
<ul>
<li>PP:Package ID, the namespace of the package, takes values in the range of [0x01, 0x7f], third-party applications are 7f.</li>
<li>TT:Resource type, there are anim, layout, mipmap, string, style and other resource types.</li>
<li>EEEE:represents the value of a certain type of resource in the offset array</li>
</ul>
<p>So 0x7f06013c in PackageId = 0x7f, TypeId = 0x06, EntryId = 0x013c</p>
<p>At its simplest, we can imagine the arsc function as a file with multiple Pair arrays, and each resource type (TypeId) corresponds to a Pair[] (or more, just one for ease of understanding). So to find the value of element 0x7f06013c in arsc is to try to find the array Pair[] corresponding to TypeId=0x06, and then find the element Pair[0X013c] with the number 0X013c. This element happens to be Pair(&ldquo;img&rdquo;, &ldquo;. /res/drawable-xxhdpi/img.png&rdquo;), with the resource name img on the left and the file path of the resource on the right &ldquo;. /res/drawable-xxhdpi/img.png&rdquo;, with the file path, the program can access the corresponding resource file.</p>
<p>Of course, the actual arsc file is a little bit more complicated in structure, so here is the analysis of the arsc file structure.</p>
<p><strong>chunk</strong></p>
<p>For the sake of understanding, before formally introducing the resource.arsc (hereinafter referred to as arsc) file, we need to explain the chunk, and the word &ldquo;chunk&rdquo; has been used many times in other articles. (For example, a tree can be divided into three chunks: the crown, the stem, and the roots. You can also consider a tree as a chunk, and this chunk is the tree.</p>
<p><strong>arsc file structure</strong></p>
<p>resources.arsc is a binary file whose internal structure is defined in ResourceTypes.h. The arsc file structure.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/11/04/62e84af4136e47f191fc7885e22cb4f8.png" alt=""></p>
<p>The image as a whole describes the relationship of each chunk in the arsc file (note the combination of the left and right sides of the image):</p>
<ul>
<li>The entire arsc file is a chunk of type RES_TABLE_TYPE.</li>
<li>RES_TABLE_TYPE can be divided into three parts: the file header and two subchunks ( RES_STRING_POOL_TYPE , RES_TABLE_PACKAGE_TYPE ).</li>
<li>RES_TABLE_PACKAGE_TYPE contains: a header, a pool of resource type string constants, a pool of resource item name string constants, and multiple subchunks (RES_TABLE_TYPE_SPEC_TYPE and RES_TABLE_TYPE_TYPE );</li>
<li>Each type of chunk contains a header structure</li>
</ul>
<h3 id="meta-inf-directory">META-INF directory</h3>
<p>The signature information is stored in META-INF directory, which is used to ensure the integrity of apk package and the security of the system. can be installed and used normally, to a certain extent, to achieve the purpose of security.</p>
<p>There are four files in the META-INF directory: MANIFEST.MF, CERT.</p>
<ul>
<li>MF (summary file): The program iterates through all the files in the APK package, generates summary information with SHA1 for non-folder non-signature files one by one, and encodes it with Base64. If the files in the APK package are modified, the program will not be installed properly if the modified files are different from the verification information in MANIFEST.MF when the APK is installed and verified.</li>
<li>SF (signature file for summary file): For the generated MANIFEST.MF file use SHA1-RSA algorithm to sign the developer&rsquo;s private key. Only the public key can decrypt it during installation. After decryption it is compared with the unencrypted digest information and if it matches then the file has not been modified.</li>
<li>RSA stores the public key, encryption algorithm, and other information.</li>
</ul>
<p>When APK is installed, the APK can be secured by a loop that starts with the MANIFEST.MF file. For example, after getting an apk package, if you want to replace a picture, a piece of code, or a piece of copyright information inside, it is basically impossible to unzip, replace and repackage it directly. This makes it more difficult for virus infection and malicious modification, and helps to protect the security of the system. However, if these files or keys are obtained by the attacker or broken by the attacker through some technical means, the Android OS cannot verify its security.</p>
<h3 id="classesdex-file">classes.dex file</h3>
<p>dex file is a kind of file in Android system, it is a special data format, similar to APK, jar and other format files. It is a file format that can be recognized, loaded and executed by DVM. Compared with the java virtual machine on PC that can run .class; the Davlik virtual machine on android can run .dex. when Java program compiled into class, you also need to use the dx tool to integrate all the class files into a dex file, the purpose is that each class can share data, to a certain extent to reduce the redundancy, but also The file structure is more compact, and experiments show that the dex file is about 50% of the size of a traditional jar file.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/11/04/ef121d70ddd2484fbd4f8a930f75564f.png" alt=""></p>
<p>Before understanding what a Dex file is, it&rsquo;s important to understand JVM, Dalvik and ART. JVM is a JAVA virtual machine used to run JAVA bytecode programs. Dalvik is a runtime environment designed by Google for the Android platform, suitable for systems with limited memory and processor speed in mobile environments. ART is a new Android runtime environment designed by Google to replace Dalvik, which was introduced in Android 4.4. ART has better performance than Dalvik. Dex file format is a compression format designed for Dalvik. So it can be simply understood that Dex file is the product of processing many .class files, which can be executed in Android runtime environment.</p>
<p>The flow of converting Java code into dex files is shown in the diagram, but of course the real process is not that simple, so here is just a visual representation.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/11/04/c1853abdea7646ae9de0411f874f2788.png" alt=""></p>
<h3 id="lib-folder">lib folder</h3>
<p>Referenced so files of third-party sdk with C/C++ compilation.</p>
<h2 id="apk-packaging-process">Apk packaging process</h2>
<p>Let&rsquo;s first have a brief understanding of the Android packaging process so that we can understand how the .java file becomes part of the apk step by step. The process of generating the apk mainly consists of the following processes, with the tools used represented in parentheses.</p>
<ul>
<li>Package the resource file to generate the java file (aapt)</li>
<li>Process the aaidl file to generate the corresponding .java file (aaidl)</li>
<li>Compile the project source code to generate class files (javac)</li>
<li>Convert all class files to generate dex files (dx)</li>
<li>Compiled resources and .dex files are packaged by apkbuilder tool into the final .apk file. (apkbuilder)</li>
<li>Signing of APK files (jarsigner)</li>
<li>Alignment of the signed APK file (zipalign)</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/11/04/209edae8befe433aa48fcae8035de419.png" alt=""></p>
<h2 id="apk-file-decompilation">APK file decompilation</h2>
<h3 id="resource-file-acquisition">Resource file acquisition</h3>
<p><a href="https://ibotpeaches.github.io/Apktool/">apktool</a> is mainly used for resource file fetching. The main functions of Apktool are.</p>
<ul>
<li>Restore resource files to their original form (9.png, xml)</li>
<li>Decompile Android dex files into smali source code</li>
<li>Recompile decompiled resources into APK/JAR</li>
</ul>
<p>So Apktool can not only disassemble apk, but also add the already disassembled apk resources to reassemble into apk.</p>
<p>It&rsquo;s easy to use, you can decompile by executing the following command directly.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">apktool d bar.apk //直接解码
apktool d bar.apk -o baz //解码到baz的文件夹中
</code></pre></td></tr></table>
</div>
</div><p>Apktool, since it can decompile, can also recompile to Apk files.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">apktool b bar // 在父目录执行building
apktool b . // 在当前bar目录执行building
apktool b bar -o new_bar.apk //  在父目录执行building并生成名为new_bar的apk文件
</code></pre></td></tr></table>
</div>
</div><p>Using apktool has the following functions:</p>
<ul>
<li>View the content of AndroidManifest file, know the absolute path of each Activity, easy to view the code later to quickly locate</li>
<li>Get the complete resource files (assest, drawable, resouces&hellip; directory files)</li>
<li>If we are familiar with <a href="https://bitbucket.org/JesusFreke/smali/downloads/">smali</a> syntax, we can also modify other people&rsquo;s code and repackage it into apk (such as cracking membership verification)</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/11/04/a15750f6ee3247d3a2a4fbdd4e7fc768.png" alt=""></p>
<p>After decompression, we get AndroidManifest.xml file, assets folder, res folder, smali folder, etc. The original folder is the original AndroidManifest.xml file, the res folder is all the resources decompiled, and the smali folder is the decompiled code. Note that the structure under smali folder is exactly the same as the package of our source code, except that it is replaced by smali language. It is somewhat similar to assembly syntax, which is the register language used by Android virtual machine.</p>
<p>When using apktool version, if the version is too low, the following error will be reported.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="o">.........</span><span class="na">apktool</span><span class="o">..........</span>
<span class="nl">I:</span> <span class="n">Baksmaling</span><span class="o">...</span>
<span class="nl">testI:</span> <span class="n">Loading</span> <span class="n">resource</span> <span class="n">table</span><span class="o">...</span>
<span class="n">Exception</span> <span class="n">in</span> <span class="n">thread</span> <span class="s">&#34;main&#34;</span> <span class="n">brut</span><span class="o">.</span><span class="na">androlib</span><span class="o">.</span><span class="na">AndrolibException</span><span class="o">:</span> <span class="n">Could</span> <span class="n">not</span> <span class="n">decode</span> <span class="n">arsc</span> <span class="n">file</span>
        <span class="n">at</span> <span class="n">brut</span><span class="o">.</span><span class="na">androlib</span><span class="o">.</span><span class="na">res</span><span class="o">.</span><span class="na">decoder</span><span class="o">.</span><span class="na">ARSCDecoder</span><span class="o">.</span><span class="na">decode</span><span class="o">(</span><span class="n">ARSCDecoder</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="n">55</span><span class="o">)</span>
        <span class="n">at</span> <span class="n">brut</span><span class="o">.</span><span class="na">androlib</span><span class="o">.</span><span class="na">res</span><span class="o">.</span><span class="na">AndrolibResources</span><span class="o">.</span><span class="na">getResPackagesFromApk</span><span class="o">(</span><span class="n">AndrolibResources</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="n">315</span><span class="o">)</span>
        <span class="n">at</span> <span class="n">brut</span><span class="o">.</span><span class="na">androlib</span><span class="o">.</span><span class="na">res</span><span class="o">.</span><span class="na">AndrolibResources</span><span class="o">.</span><span class="na">loadMainPkg</span><span class="o">(</span><span class="n">AndrolibResources</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="n">50</span><span class="o">)</span>
        <span class="n">at</span> <span class="n">brut</span><span class="o">.</span><span class="na">androlib</span><span class="o">.</span><span class="na">res</span><span class="o">.</span><span class="na">AndrolibResources</span><span class="o">.</span><span class="na">getResTable</span><span class="o">(</span><span class="n">AndrolibResources</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="n">43</span><span class="o">)</span>
        <span class="n">at</span> <span class="n">brut</span><span class="o">.</span><span class="na">androlib</span><span class="o">.</span><span class="na">Androlib</span><span class="o">.</span><span class="na">getResTable</span><span class="o">(</span><span class="n">Androlib</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="n">44</span><span class="o">)</span>
        <span class="n">at</span> <span class="n">brut</span><span class="o">.</span><span class="na">androlib</span><span class="o">.</span><span class="na">ApkDecoder</span><span class="o">.</span><span class="na">getResTable</span><span class="o">(</span><span class="n">ApkDecoder</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="n">148</span><span class="o">)</span>
        <span class="n">at</span> <span class="n">brut</span><span class="o">.</span><span class="na">androlib</span><span class="o">.</span><span class="na">ApkDecoder</span><span class="o">.</span><span class="na">decode</span><span class="o">(</span><span class="n">ApkDecoder</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="n">98</span><span class="o">)</span>
        <span class="n">at</span> <span class="n">brut</span><span class="o">.</span><span class="na">apktool</span><span class="o">.</span><span class="na">Main</span><span class="o">.</span><span class="na">cmdDecode</span><span class="o">(</span><span class="n">Main</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="n">120</span><span class="o">)</span>
        <span class="n">at</span> <span class="n">brut</span><span class="o">.</span><span class="na">apktool</span><span class="o">.</span><span class="na">Main</span><span class="o">.</span><span class="na">main</span><span class="o">(</span><span class="n">Main</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="n">57</span><span class="o">)</span>
<span class="n">Caused</span> <span class="n">by</span><span class="o">:</span> <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">IOException</span><span class="o">:</span> <span class="n">Expected</span><span class="o">:</span> <span class="n">0x001c0001</span><span class="o">,</span> <span class="n">got</span><span class="o">:</span> <span class="n">0x00000000</span>
        <span class="n">at</span> <span class="n">brut</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">ExtDataInput</span><span class="o">.</span><span class="na">skipCheckInt</span><span class="o">(</span><span class="n">ExtDataInput</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="n">48</span><span class="o">)</span>
        <span class="n">at</span> <span class="n">brut</span><span class="o">.</span><span class="na">androlib</span><span class="o">.</span><span class="na">res</span><span class="o">.</span><span class="na">decoder</span><span class="o">.</span><span class="na">StringBlock</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">StringBlock</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="n">45</span><span class="o">)</span>
        <span class="n">at</span> <span class="n">brut</span><span class="o">.</span><span class="na">androlib</span><span class="o">.</span><span class="na">res</span><span class="o">.</span><span class="na">decoder</span><span class="o">.</span><span class="na">ARSCDecoder</span><span class="o">.</span><span class="na">readPackage</span><span class="o">(</span><span class="n">ARSCDecoder</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="n">97</span><span class="o">)</span>
        <span class="n">at</span> <span class="n">brut</span><span class="o">.</span><span class="na">androlib</span><span class="o">.</span><span class="na">res</span><span class="o">.</span><span class="na">decoder</span><span class="o">.</span><span class="na">ARSCDecoder</span><span class="o">.</span><span class="na">readTable</span><span class="o">(</span><span class="n">ARSCDecoder</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="n">82</span><span class="o">)</span>
        <span class="n">at</span> <span class="n">brut</span><span class="o">.</span><span class="na">androlib</span><span class="o">.</span><span class="na">res</span><span class="o">.</span><span class="na">decoder</span><span class="o">.</span><span class="na">ARSCDecoder</span><span class="o">.</span><span class="na">decode</span><span class="o">(</span><span class="n">ARSCDecoder</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="n">48</span><span class="o">)</span>
        <span class="o">...</span> <span class="n">8</span> <span class="n">more</span>
</code></pre></td></tr></table>
</div>
</div><p>The solution is to go to the official website to download the latest version and replace it if the following errors are found.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="o">.........</span><span class="na">apktool</span><span class="o">..........</span>
<span class="n">SmaliDebugging</span> <span class="n">has</span> <span class="n">been</span> <span class="n">removed</span> <span class="n">in</span> <span class="n">2</span><span class="o">.</span><span class="na">1</span><span class="o">.</span><span class="na">0</span> <span class="n">onward</span><span class="o">.</span> <span class="n">Please</span> <span class="n">see</span><span class="o">:</span> <span class="n">https</span><span class="o">:</span><span class="c1">//github.com/
</span><span class="c1"></span><span class="n">iBotPeaches</span><span class="o">/</span><span class="n">Apktool</span><span class="o">/</span><span class="n">issues</span><span class="o">/</span><span class="n">1061</span>
</code></pre></td></tr></table>
</div>
</div><p>The reason is that the latest version of apktool has removed SmaliDebugging, my solution is to download version 2.0.9.</p>
<h3 id="decompilation-of-xml-files">Decompilation of XML files</h3>
<p>The xml file in the apk is compressed and can be uncompiled by <a href="https://code.google.com/archive/p/android4me/downloads">AXMLPrinter2 tool</a> with a command like.</p>
<p>java -jar . \AXMLPrinter2.jar . \AndroidManifest.xml &gt; . \AndroidManifest.txt</p>
<p>apktool already comes with AndroidManifest.xml file decompression, so this tool is not very valuable.</p>
<h3 id="classesdex-file-decompilation">classes.dex file decompilation</h3>
<p>classes.dex is the java bytecode file generated after the java source code is compiled. But because the dalvik virtual machine used by Android is incompatible with the standard java virtual machine, the dex file is different from the class file, both in terms of file structure and opcode. At present, the common java decompiler tools can not handle dex files. dexdump, a decompiler tool for dex files, is provided in Android emulator. However, the readability of the result is very poor. Here is a tool with better readability.</p>
<ul>
<li><a href="https://github.com/pxb1988/dex2jar">dex2jar</a>: A tool to decompile dex files into jar files.</li>
<li><a href="http://jd.benow.ca/">JD-GUI</a>: A tool to decompile jar into java.</li>
</ul>
<p>Steps of decompiling.</p>
<ul>
<li>Extract the dex file from the APK, and get it by decompressing the APK file. Put it into the directory of dex2jar, open cmd and run bat classes.dex to generate classes.dex.dex2jar.jar.</li>
<li>Run the JD-GUI tool and open the above jar file to see the source code.</li>
</ul>
<p>Tools included in the dex2jar package.</p>
<ul>
<li>d2j-jar2dex: call dx to convert jar to dex</li>
<li>d2j-jar-remap: rename package/class/method/field in the jar file.</li>
<li>d2j-dex2jar: convert dex to jar</li>
<li>dex2jar: this tool is deprecated, use d2j-dex2jar if possible</li>
<li>d2j-jasmin2jar: compile .j files to .class files</li>
<li>d2j-jar-access: add or remove access to class/method/field from jar files</li>
<li>d2j-asm-verify: verify the .class file in the jar file</li>
<li>d2j-dex-dump: dump the data from .dex or .apk file to dump.jar file</li>
<li>d2j-init-deobf: generate the initialization configuration file for the anti-obfuscation jar file</li>
<li>d2j-apk-sign: digitally sign the apk file with a test certificate</li>
<li>d2j-jar2jasmin: disassemble the .class file from the jar file to the jasmin file</li>
</ul>
<p><a href="https://github.com/Storyyeller/enjarify">Enjarify</a> is a Python3-based decompiler tool launched by Google, similar to dex2jar, which can convert Dalvik bytecode to the corresponding Java bytecode, with more excellent compatibility, accuracy and higher efficiency.</p>
<p>Sometimes when you decompile with JD-GUI, some files (Constants class i.e. constant class) open with // INTERNAL ERROR //, solution, use other <a href="https://github.com/deathmarine/Luyten">Luyten</a> or [jadx](https:/ /github.com/skylot/jadx) instead.</p>
<h3 id="automation-tools-summary-onekey-decompile-apk">Automation Tools Summary (Onekey Decompile Apk)</h3>
<p><strong>onekey-decompile-apk</strong></p>
<p><a href="https://github.com/ufologist/onekey-decompile-apk">onekey-decompile-apk</a> is the apk decompile tool that I used earlier, the function is relatively simple, mainly apktool/dex2jar/jd-gui only need to execute one step to decompile all the apk files (resource files and jar, etc.). The usage is very simple.</p>
<ul>
<li>Unzip the downloaded onekey-decompile-apk.zip</li>
<li>Put the apk file into onekey-decompile-apk directory</li>
<li>Drag and drop the apk file to _onekey-decompile-apk.bat</li>
</ul>
<p>Since the author has not updated for a long time, you can actually upgrade the tools in the _tool directory yourself and change the path to the latest version of the software in _onekey-decompile-apk.bat.</p>
<p><strong>TTDeDroid</strong></p>
<p><a href="https://github.com/tp7309/TTDeDroid">TTDeDroid</a> is also a one-key decompile tool, supports decompile apk/aar/dex/jar, mainly integrated with jadx/dex2jar/enjarify (no need to install Python manually)</p>
<p><strong>Google Official: android-classysh</strong></p>
<p><a href="https://github.com/google/android-classyshark/">android-classysh</a> is a one-click decompilation tool exited by Google,, directly open Apk file, you can see all the file structure in Apk, and even integrated dex file view, java code view, method number analysis, import obfuscation mapping file and a series of tools. The purpose of Google to launch this tool is to let us developers more clearly understand what files are in their Apk, what changes before and after the obfuscation, and to facilitate us to further optimize their Apk packaging implementation. A rather bad experience is that exporting is not possible.</p>
<p><strong>Python implementation of the tool: Androguard</strong></p>
<p><a href="https://github.com/androguard/androguard/">Androguard</a> integrates a toolkit for decompiling various files such as resources and code. You need to install the Python environment to run this tool, which is written as different py function modules according to different decompilation needs, and static analysis functions. So if you want to use Python to develop a service to parse Apk files and perform static scan analysis, you can quote this tool to achieve it.</p>
<p><strong>Android Killer</strong></p>
<p><a href="https://github.com/liaojack8/AndroidKiller">AndroidKiller</a> combines Apk decompiling, Apk packaging, Apk signing, code interchange, ADB communication (application installation-uninstallation-running-device file management) and other features in one, supports logcat log output. Syntax highlighting, keyword-based (support for single-line code or multi-line code segment) project search, customizable external tools; absorption and integration of a variety of tools and features to create a one-stop reverse tool operating experience, greatly simplifying the user in the Android application / game modification process of all kinds of tedious work.</p>
<p><strong>GDA</strong></p>
<p><a href="https://github.com/charles2gan/GDA-android-reversing-Tool">GDA</a> supports package filtering analysis, algorithm tools, file conversion tools, etc. in addition to decompiling.</p>
<p><strong>Bytecode Viewer</strong></p>
<p><a href="https://github.com/Konloch/bytecode-viewer">Bytecode Viewer</a> is a powerful decompiler tool that integrates six Java decompiler libraries (including Fernflower and CFR), Andorid decompiler library and bytecode class library.</p>
<p>This tool provides a GUI interface that can enhance the user experience of using CFR.</p>
<h2 id="apk-decompilation-advanced">APK Decompilation Advanced</h2>
<p>The extent to which Java code in an Android APK can be decompiled depends on the level of encryption in the APK.</p>
<ul>
<li>The first case: no obfuscation, no encryption, no shelling. Directly use Dex2jar and JD-GUI to extract the source code from the APK, the code logic is clear and basically reusable, only the resource file references need to be calculated.</li>
<li>The second case: obfuscation. Usually the protection is done with ProGuard. Because it is an irreversible obfuscation of the jar (unless there is mapping), it cannot be reverted to the original code. However, the code structure and logic are the same, so if you spend a long time combing the code, you can find the core code, and the decryption method is the same as the first one.</li>
<li>The third case: encryption. Take DexGuard as an example. For this kind of code encryption method, it will definitely be decrypted when the program is running, as long as the logic of decryption is extracted.</li>
<li>The fourth case: shelling. This case is similar to the third one. No matter how you add the shell, it will definitely run with Dalvik-identifiable Odex code, so it is recommended to dump it directly in memory.</li>
</ul>
<h3 id="android-obfuscation-handling-proguard">Android obfuscation handling: ProGuard</h3>
<p>The Android SDK comes with the obfuscation tool Proguard, which is located under \tools\proguard in the root directory of the SDK. ProGuard is a free Java class file shrinker, optimizer, obfuscator and pre-checker. It can detect and remove unused classes, fields, methods and properties. It optimizes bytecode and removes unused directives. It can rename classes, fields and methods using short meaningless names. Finally, the pre-checked Java 6 or the processed code as described for Java MicroEdition. If obfuscation is enabled, Proguard will by default obfuscate all code, including third-party packages, but some code or third-party packages cannot be obfuscated, so we need to manually write obfuscation rules to keep the parts that cannot be obfuscated.</p>
<p>The &ldquo;obfuscation&rdquo; in Android can be divided into two parts, one is the optimization and obfuscation of Java code, which relies on the proguard obfuscator, and the other is the resource compression, which removes unused resources from the project and dependent libraries.</p>
<p><strong>Code obfuscation</strong></p>
<ul>
<li>Shrinking: enabled by default to reduce the size of the application, remove unused classes and members, and re-execute the optimization action after it has been performed (since it may expose some unused classes and members again).</li>
<li>Optimization: Enabled by default to perform optimizations at the bytecode level to make the application run faster.</li>
<li>Obfuscation: enabled by default, increases the difficulty of decompiling, class, function and variable names will be randomly named into meaningless code names such as: a,b,c&hellip;etc. unless protected by keep.</li>
</ul>
<p>These features are turned on by default, to turn them off you just need to configure the corresponding rules. By default, obfuscation generates a mapping.txt file in the project directory app/build/outputs/mapping/release, which is the obfuscation rule according to which we can push the obfuscated code back to the source code. In principle, the more messy and irregular the code is after obfuscation, the better, but there are some places where we have to avoid obfuscation, otherwise the program will run wrong.</p>
<p><strong>Resource Compression</strong></p>
<p>Resource compression removes unused resources from the project and dependent libraries, which can be useful in reducing the size of apk packages and is generally recommended. Note that resource compression will only take effect if code compression is enabled with minifyEnabled true. Resource compression consists of two processes, &ldquo;merge resources&rdquo; and &ldquo;remove resources&rdquo;. In the &ldquo;merge resources&rdquo; process, resources with the same name are considered duplicates and are merged. Note that this process is not controlled by the shrinkResources property and cannot be disabled. gradle will do this, as it will cause errors if resources with the same name exist in different projects. gradle looks for duplicate resources in four places.</p>
<ul>
<li>src/main/res/ path</li>
<li>different build types (debug, release, etc.)</li>
<li>different build channels</li>
<li>Third-party libraries that the project depends on Merge resources in the following order of priority.</li>
</ul>
<p>dependencies -&gt; main -&gt; channels -&gt; build types</p>
<p>For example, if duplicate resources exist in both the main folder and in different channels, gradle will choose to keep the resources in the channels. Also, if duplicate resources are present at the same level, such as src/main/res/ and src/main/res2/, gradle will not be able to complete the resource merge and will report a resource merge error. The &ldquo;remove resources&rdquo; process is known by its name. Note that, similar to the code, obfuscating resource removal can also define which resources need to be kept, which is given below.</p>
<h3 id="dexguard-obfuscation-anti-secondary-packaging">DexGuard Obfuscation (Anti-Secondary Packaging)</h3>
<p>DexGuard is developed by the same company as ProGuard, the main obfuscation tool on Android, but it has more features and stronger obfuscation than the free ProGuard.</p>
<ul>
<li>Progurad is free and already integrated into Android ADT, it is easy to use. proguard can only protect the code, but not our apk files. Anyone can use apktool tool to decompile our developed apk file, and then change various resources in it, or change part of the code, or even inject the code, and then package it back to apk, after secondary distribution, to achieve their own purpose. Or add ads, or add a malicious Trojan virus, etc. No multi-dex is required.</li>
<li>DexGuard is paid. DexGuard is based on Proguard with more protection. After using DexGuard to obfuscate the generated apk file, it can&rsquo;t be decompiled normally with apktool. Although it is still possible to decompile some of the resource files, they cannot be packaged into apk again because the decompilation process is incomplete. This protects our apk files from being packaged and distributed twice. Code obfuscation is stronger + resource obfuscation + so shelling etc. Comes with multi-dex scanning.</li>
</ul>
<h3 id="apk-file-shelling">Apk file shelling</h3>
<p>Apk shelling is the process of adding a layer of protection to the target Apk to hide important data and information. The Apk shell is essentially a class loader. The system executes the shell code first, then decrypts the encrypted dex and loads it into the system memory to run.</p>
<h4 id="android-dex-shelling-principle">Android dex shelling principle</h4>
<p>There are three main procedures in the shelling process.</p>
<ul>
<li>The source Apk1 (the original application without shelling)</li>
<li>Shell APK2 (used to decrypt and run apk1 program)</li>
<li>Encryption tool (encrypts the source APK1 and merges it with the dex of the shell APK2 to form a new dex)</li>
</ul>
<p>Encryption process.</p>
<ul>
<li>Get the apk to be encrypted and your own shelling program apk1.</li>
<li>Encrypt the source apk with the shelling tool. Write the encrypted apk data to the end of the Dex of the sheller and add the size of the encrypted data to the end of the file; modify the signature and file_size headers in the Dex header of the sheller; merge to get the new Dex1 file.</li>
<li>Then replace the dex file in the original sheller apk1 with the new Dex1 file. A new apk is generated, called the stripper apk.</li>
</ul>
<p>Shelling process.</p>
<ul>
<li>Read the data at the end of the Dex file to get the length of the encrypted data to be shelled.</li>
<li>Read the decrypted data from the Dex file and decrypt the encrypted data. Save the decrypted data as a file to *.apk file.</li>
<li>Load *.apk dynamically by DexClassLoader.</li>
</ul>
<h4 id="shell-history">Shell History</h4>
<p><strong>First generation shell: DEX encryption (obfuscation technique)</strong></p>
<ul>
<li>Dex string encryption</li>
<li>Resource encryption</li>
<li>Anti-decompilation</li>
<li>Anti-debugging</li>
<li>Custom DexClassLoader</li>
</ul>
<p><strong>Second generation shells: Dex extraction and So hardening (shelling technology)</strong></p>
<ul>
<li>Against the common dex method of first-generation shells</li>
<li>Dex Method code extraction to the outside</li>
<li>Dex Dynamic Loading</li>
<li>So encryption</li>
</ul>
<p>Class extraction is conventionally done by hiding the dex file and modifying the dex structure. Hiding dex file is done by encrypting or compressing the target dex file as a whole, converting the whole dex into another file and storing it in assert folder or other places, then decrypting it in memory and loading it using class loader technology. The dex structure is modified by extracting the bytecode instructions from the DexCode and filling them with zeros, or by modifying the method properties, and then making corrections and fixes in memory at runtime.</p>
<p>Regarding the dynamic loading of Dex, we should mention the dalvik virtual machine. Like the java virtual machine, it first needs to load the corresponding class into memory when running the program. In a standard virtual machine, class loading can be done either from a class file or from other binary streams, so that the class can be loaded manually while the program is running, thus allowing dynamic code execution. There are two classes commonly used: DexClassLoader and PathClassLoader, PathClassLoader is the default loader in Android applications. Differences.</p>
<ul>
<li>DexClassLoader can load any path of dex/dex/jar</li>
<li>PathClassLoader can only load the apk in data/app, which is already installed in the phone. This is also the reason why PathClassLoader is the default class loader, because generally the program is installed and then opened, when PathClassLoader will load the specified apk.</li>
</ul>
<p><strong>Third Generation Shell: Dex Dynamic Decryption and So Obfuscation (Instruction Extraction)</strong></p>
<ul>
<li>Dex Method code dynamic decryption</li>
<li>So code inflation obfuscation</li>
<li>Against all previously emerged decryption methods</li>
</ul>
<p><strong>Fourth generation shells: arm vmp (instruction conversion)</strong></p>
<p>vmp:The process of restoration after being hardened with vmp is more complex and difficult, and requires a lot of time for analysis.</p>
<h3 id="identification-of-shells">Identification of shells</h3>
<p>Domestic third-party technology companies that provide apk hardening include: Naga, Love Encryption, Bang Bang Hardening, 360 Hardening Protection, Baidu Hardening, Tencent Hardening, etc.</p>
<p>After reinforced apk, decompiled by dex2jar.</p>
<p>Tencent Le solidification.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/11/04/c8be537d1aef4cc4a770687c730d4f46.png" alt=""></p>
<p>360 reinforcement.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/11/04/2e4ef15ebf73430481d775e6f94f3cbd.png" alt=""></p>
<p>By looking at the information, I found that most encryptions generate a corresponding feature so file. This way, we can check the shell according to the so.</p>
<table>
<thead>
<tr>
<th>Features So file</th>
<th>belong to reinforcement company</th>
</tr>
</thead>
<tbody>
<tr>
<td>libchaosvmp.so</td>
<td>naga</td>
</tr>
<tr>
<td>libddog.so</td>
<td>Naga</td>
</tr>
<tr>
<td>libfdog.so</td>
<td>Naga</td>
</tr>
<tr>
<td>libedog.so</td>
<td>Naga Enterprise</td>
</tr>
<tr>
<td>libexec.so</td>
<td>Love Encryption</td>
</tr>
<tr>
<td>libexecmain.so</td>
<td>Love Encryption</td>
</tr>
<tr>
<td>ijiami.dat</td>
<td>Love Encryption</td>
</tr>
<tr>
<td>ijiami.ajm</td>
<td>Naga Enterprise</td>
</tr>
<tr>
<td>libsecexe.so</td>
<td>Bang Bang Bang Free Edition</td>
</tr>
<tr>
<td>libsecmain.so</td>
<td>Bang Bang Bang Free Edition</td>
</tr>
<tr>
<td>libSecShell.so</td>
<td>Bang Bang Bang Free</td>
</tr>
<tr>
<td>libDexHelper.so</td>
<td>Bang Bang Bang Enterprise</td>
</tr>
<tr>
<td>libDexHelper-x86.so</td>
<td>梆 Enterprise</td>
</tr>
<tr>
<td>libprotectClass.so</td>
<td>360</td>
</tr>
<tr>
<td>libjiagu.so</td>
<td>360</td>
</tr>
<tr>
<td>libjiagu_art.so</td>
<td>360</td>
</tr>
<tr>
<td>libjiagu_x86.so</td>
<td>360</td>
</tr>
<tr>
<td>libegis.so</td>
<td>password</td>
</tr>
<tr>
<td>libNSaferOnly.so</td>
<td>passwordshield</td>
</tr>
<tr>
<td>libnqshield.so</td>
<td>netqin</td>
</tr>
<tr>
<td>libbaiduprotect.so</td>
<td>baidu</td>
</tr>
<tr>
<td>aliprotect.dat</td>
<td>AlijuSecurity</td>
</tr>
<tr>
<td>libsgmain.so</td>
<td>aliju security</td>
</tr>
<tr>
<td>libsgsecuritybody.so</td>
<td>aliju security</td>
</tr>
<tr>
<td>libmobisec.so</td>
<td>Alijou Security</td>
</tr>
<tr>
<td>libtup.so</td>
<td>tencent</td>
</tr>
<tr>
<td>libexec.so</td>
<td>Tencent</td>
</tr>
<tr>
<td>libshell.so</td>
<td>Tencent</td>
</tr>
<tr>
<td>mix.dex</td>
<td>tencent</td>
</tr>
<tr>
<td>lib/armeabi/mix.dex</td>
<td>cent</td>
</tr>
<tr>
<td>lib/armeabi/mixz.dex</td>
<td>cent</td>
</tr>
<tr>
<td>libtosprotection.armeabi.so</td>
<td>腾讯御安全</td>
</tr>
<tr>
<td>libtosprotection.armeabi-v7a.so</td>
<td>Tencent</td>
</tr>
<tr>
<td>libtosprotection.x86.so</td>
<td>Tencent Security</td>
</tr>
<tr>
<td>libnesec.so</td>
<td>NetEaseShield</td>
</tr>
<tr>
<td>libAPKProtect.so</td>
<td>APKProtect</td>
</tr>
<tr>
<td>libkwscmm.so</td>
<td>Several Dimensional Security</td>
</tr>
<tr>
<td>libkwscr.so</td>
<td>several-dimensional security</td>
</tr>
<tr>
<td>libkwslinker.so</td>
<td>several-dimensional security</td>
</tr>
<tr>
<td>libx3g.so</td>
<td>Top Image Technology</td>
</tr>
<tr>
<td>libapssec.so</td>
<td>Shanda</td>
</tr>
<tr>
<td>librsprotect.so</td>
<td>Risingstar</td>
</tr>
</tbody>
</table>
<p>This feature can be used as the characteristics of the shelling vendor. In this way, you can get the set of vendors shelling, and there is a way to crack the shelling.
The working principle of ApkScan-PKID is to match the shelling vendor based on the feature file generated after the apk shelling.</p>
<h3 id="commonly-used-shelling-software">Commonly used shelling software</h3>
<p><strong>VirtualXposed</strong></p>
<p><a href="https://vxposed.com/">VirtualXposed</a>: You can use Xposed framework without rooting your phone.</p>
<p><strong>ZjDroid</strong></p>
<p><a href="https://github.com/halfkiss/ZjDroid">ZjDroid</a> is a dynamic reverse analysis module based on Xposed Framewrok, reverse analysts can use ZjDroid to do the following: 1. memory dump of DEX files 2. memory based on Dalvik key pointers BackSmali, effectively crack the mainstream reinforcement program 3, dynamic monitoring of sensitive API 4, the specified memory area data dump 5, get the application loaded DEX information. 6、Get the specified DEX file loading class information. 7、dump Dalvik java heap information. 8、Run lua script dynamically in the target process.</p>
<p><strong>FDex2</strong></p>
<p>FDex2, can dump export useful dex file from android app for subsequent then export jar package from dex, jar package export java source code, very powerful function.</p>
<p><strong>frida</strong></p>
<p>The principle of <a href="https://frida.re/">frida</a> is that by installing Frida on the PC, running frida-server on the phone, to achieve PC control of the phone, while the way through js injection, the dex from the &ldquo;shell&rdquo; &ldquo;hook&rdquo; out. It is a python based hook (hook) tool, so before installing it we need to configure the Py environment, now frida only supports the environment below 3.7, above 3.8 is not supported for the time being. <a href="https://github.com/hluwa/FRIDA-DEXDump">FRIDA-DEXDump</a></p>
<p><strong>dumpDex</strong></p>
<p><a href="https://github.com/WrBug/dumpDex">dumpDex</a> is an Android shelling tool, need xposed support</p>
<p><strong>drizzleDumper</strong></p>
<p><a href="https://github.com/DrizzleRisk/drizzleDumper">drizzleDumper</a> is a memory search-based Android deshelling tool that can export dex files from running Android apps using the ptrace mechanism</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/apk/">apk</a>
          <a href="/tags/android/">android</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2021-11/how-dropbox-securely-stores-your-passwords/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Dropbox account password storage practices</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2021-11/hive-sql-datediff-current_date/">
            <span class="next-text nav-default">Hive SQL CURRENT_DATE causes datediff error</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
