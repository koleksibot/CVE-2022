<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Nanosecond High Performance Logging System - ATC &#39;18 - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="In this paper, we would like to present a paper from the 2018 ATC Journal &amp;ndash; NanoLog: A Nanosecond Scale Logging System, which implements NanoLog, a high-performance logging system that can perform 1 ~ 2 orders of magnitude better than other logging systems in the C&#43;&#43; community, e.g., spdlog, glog, and Boost Log. In this article, we will briefly analyze the design and implementation principles of NanoLog.
Logging is an important part of system observability, and I&amp;rsquo;m sure many engineers have had the experience of adding logs on the fly to check for problems, a process the author has just re-visited." /><meta name="keywords" content="nanoLog" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2021-11/papers-nanolog/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Nanosecond High Performance Logging System - ATC &#39;18" />
<meta property="og:description" content="In this paper, we would like to present a paper from the 2018 ATC Journal &ndash; NanoLog: A Nanosecond Scale Logging System, which implements NanoLog, a high-performance logging system that can perform 1 ~ 2 orders of magnitude better than other logging systems in the C&#43;&#43; community, e.g., spdlog, glog, and Boost Log. In this article, we will briefly analyze the design and implementation principles of NanoLog.
Logging is an important part of system observability, and I&rsquo;m sure many engineers have had the experience of adding logs on the fly to check for problems, a process the author has just re-visited." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2021-11/papers-nanolog/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-11-28T10:56:38+08:00" />
<meta property="article:modified_time" content="2021-11-28T10:56:38+08:00" />

<meta itemprop="name" content="Nanosecond High Performance Logging System - ATC &#39;18">
<meta itemprop="description" content="In this paper, we would like to present a paper from the 2018 ATC Journal &ndash; NanoLog: A Nanosecond Scale Logging System, which implements NanoLog, a high-performance logging system that can perform 1 ~ 2 orders of magnitude better than other logging systems in the C&#43;&#43; community, e.g., spdlog, glog, and Boost Log. In this article, we will briefly analyze the design and implementation principles of NanoLog.
Logging is an important part of system observability, and I&rsquo;m sure many engineers have had the experience of adding logs on the fly to check for problems, a process the author has just re-visited."><meta itemprop="datePublished" content="2021-11-28T10:56:38+08:00" />
<meta itemprop="dateModified" content="2021-11-28T10:56:38+08:00" />
<meta itemprop="wordCount" content="1738">
<meta itemprop="keywords" content="nanolog," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Nanosecond High Performance Logging System - ATC &#39;18"/>
<meta name="twitter:description" content="In this paper, we would like to present a paper from the 2018 ATC Journal &ndash; NanoLog: A Nanosecond Scale Logging System, which implements NanoLog, a high-performance logging system that can perform 1 ~ 2 orders of magnitude better than other logging systems in the C&#43;&#43; community, e.g., spdlog, glog, and Boost Log. In this article, we will briefly analyze the design and implementation principles of NanoLog.
Logging is an important part of system observability, and I&rsquo;m sure many engineers have had the experience of adding logs on the fly to check for problems, a process the author has just re-visited."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Nanosecond High Performance Logging System - ATC &#39;18</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-11-28 10:56:38 </span>
        <div class="post-category">
            <a href="/categories/skills/"> skills </a>
            </div>
          <span class="more-meta"> 1738 words </span>
          <span class="more-meta"> 9 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#architecture-design">Architecture Design</a></li>
        <li><a href="#implementation-principles">Implementation Principles</a>
          <ul>
            <li><a href="#preprocessing">Preprocessing</a></li>
            <li><a href="#runtime">Runtime</a></li>
            <li><a href="#post-processing">Post-processing</a></li>
          </ul>
        </li>
        <li><a href="#summary">Summary</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>In this paper, we would like to present a paper from the 2018 ATC Journal &ndash; <a href="https://www.usenix.org/system/files/conference/atc18/atc18-yang.pdf">NanoLog: A Nanosecond Scale Logging System</a>, which implements NanoLog, a high-performance logging system that can perform 1 ~ 2 orders of magnitude better than other logging systems in the C++ community, e.g., spdlog, glog, and Boost Log. In this article, we will briefly analyze the design and implementation principles of NanoLog.</p>
<p>Logging is an important part of system observability, and I&rsquo;m sure many engineers have had the experience of adding logs on the fly to check for problems, a process the author has just re-visited.</p>
<p>Printing logs is a simple task, and almost all engineers learn how to print strings to standard output using functions such as printf from the first day they start programming, and in 99% of programs this is used without performance problems, except in production environments where we use a structured, easy-to-parse format instead of printf, e.g., adding information such as timestamps, filenames, and line numbers to the logs.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/11/28/15978f70a3bb4dfaac20a95d6ff0d5ca.png" alt=""></p>
<p>But the remaining 1% of programs require ultra-low latency systems, where response time requirements can be in the microsecond or even nanosecond range. In this scenario, if the logging system is still needed to provide observability, we need to delve into the details of writing logs to standard output or files, such as using buffers, writing to files asynchronously, and reducing the use of dynamic features such as reflection, in addition to ensuring that log output is sequential and avoiding lost or truncated messages.</p>
<p>While spdlog, glog and Boost Log already meet the needs of most applications, for these latency machine-sensitive applications, the few microseconds needed to print the log can significantly increase the processing time of the request and affect the performance of the application.</p>
<h2 id="architecture-design">Architecture Design</h2>
<p>NanoLog is able to print logs on a nanosecond scale because it can extract static log messages during compilation and handle issues such as formatting of the logs during the offline phase. Its core optimizations are all built on two conditions.</p>
<ul>
<li>that formatted logs directly readable by developers do not have to be generated directly at application runtime; we can record the dynamic parameters of the logs during runtime and generate them on-demand afterwards.</li>
<li>the vast majority of information in log messages is statically redundant, with only a few parameters changing, and we can obtain the static contents of the log during compilation and print it only once in the post-processor.</li>
</ul>
<p>It is because most logs follow the above characteristics that NanoLog can build on them to achieve nanosecond-scale log printing. the different design approach of NanoLog dictates that it will differ significantly in architecture from traditional logging modules, and it consists of three components.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/11/28/2b1901eab4d04f4a90ae70353197935d.png" alt=""></p>
<ul>
<li>Preprocessor: extracts log messages from source code during compilation, replaces raw log statements with optimized code, and generates compressed, dictionary helper functions for each log message.</li>
<li>Runtime library: caches logs printed by multiple threads in a buffer and outputs compressed binary logs using helper functions generated in the preprocessing phase.</li>
<li>Decoder: decodes the logs using a dictionary containing static information generated in the preprocessing phase to obtain logs that can be read by humans.</li>
</ul>
<p>However, NanoLog breaks this traditional design by migrating some of the operations to compile-time and post-run in order to reduce run-time overhead, following the <em>Law of Conservation of Work Quality</em>: work does not disappear into thin air, it just moves from run-time to other phases of the program life cycle.</p>
<ul>
<li>rewriting logging statements at compile time to remove static information and deferring expensive formatting operations to a post-running phase of the code, which can reduce significant computational and I/O bandwidth requirements at runtime.</li>
<li>compiles specific code for each log message, enabling efficient handling of dynamic parameters and avoiding parsing log messages and encoding parameter types at runtime.</li>
<li>reduced runtime I/O and processing time using lightweight compression algorithms and out-of-order logging.</li>
<li>generating readable logs using a post-processing combination of compressed log data and static information extracted at compile time.</li>
</ul>
<h2 id="implementation-principles">Implementation Principles</h2>
<p>In this section we will briefly analyze the implementation principles of the three main components of the NanoLog system, namely pre-processing, runtime and post-processing.</p>
<h3 id="preprocessing">Preprocessing</h3>
<p>NanoLog uses Python to implement the preprocessor. The entry point for the program is in <a href="https://github.com/PlatformLab/NanoLog/blob/2a94d70f9d1db4da416053b1b926387fa068a59b/preprocessor/parser.py#L577"><code>processor/parser</code></a>, which scans the user&rsquo;s source files, generates metadata files and modified source code, and then compiles the modified code into <code>.so</code> or <code>.a</code> files instead of instead of compiling the initial code. In addition, the preprocessor reads all generated metadata files, generates C++ source code and compiles it into the NanoLog runtime library and finally into the user program.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/11/28/2250b0aa7af54169b804080a72c6a6b9.png" alt=""></p>
<p>It generates two statements for each NANO_LOG in the source code, record and compress, where the former records the dynamic parameters in the log and the latter compresses the recorded data to reduce the program&rsquo;s I/O time. Here is the record function generated by the preprocessor.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__syang0__fl__E32374s3237424642lf__s46cc__100__</span><span class="p">(</span><span class="n">NanoLog</span><span class="o">::</span><span class="n">LogLevel</span> <span class="n">level</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">fmtStr</span> <span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">arg0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">arg1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">arg2</span><span class="p">,</span> <span class="kt">double</span> <span class="n">arg3</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">extern</span> <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">__fmtId__E32374s3237424642lf__s46cc__100__</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">&gt;</span> <span class="n">NanoLog</span><span class="o">::</span><span class="n">getLogLevel</span><span class="p">())</span>
        <span class="k">return</span><span class="p">;</span>

    <span class="kt">uint64_t</span> <span class="n">timestamp</span> <span class="o">=</span> <span class="n">PerfUtils</span><span class="o">::</span><span class="n">Cycles</span><span class="o">::</span><span class="n">rdtsc</span><span class="p">();</span>
    <span class="n">size_t</span> <span class="n">str0Len</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">arg0</span><span class="p">);;</span>
    <span class="n">size_t</span> <span class="n">allocSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">arg1</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">arg2</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">arg3</span><span class="p">)</span> <span class="o">+</span>  <span class="n">str0Len</span> <span class="o">+</span>  <span class="k">sizeof</span><span class="p">(</span><span class="n">NanoLogInternal</span><span class="o">::</span><span class="n">Log</span><span class="o">::</span><span class="n">UncompressedEntry</span><span class="p">);</span>
    <span class="n">NanoLogInternal</span><span class="o">::</span><span class="n">Log</span><span class="o">::</span><span class="n">UncompressedEntry</span> <span class="o">*</span><span class="n">re</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">NanoLogInternal</span><span class="o">::</span><span class="n">Log</span><span class="o">::</span><span class="n">UncompressedEntry</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">NanoLogInternal</span><span class="o">::</span><span class="n">RuntimeLogger</span><span class="o">::</span><span class="n">reserveAlloc</span><span class="p">(</span><span class="n">allocSize</span><span class="p">));</span>

    <span class="n">re</span><span class="o">-&gt;</span><span class="n">fmtId</span> <span class="o">=</span> <span class="n">__fmtId__E32374s3237424642lf__s46cc__100__</span><span class="p">;</span>
    <span class="n">re</span><span class="o">-&gt;</span><span class="n">timestamp</span> <span class="o">=</span> <span class="n">timestamp</span><span class="p">;</span>
    <span class="n">re</span><span class="o">-&gt;</span><span class="n">entrySize</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">allocSize</span><span class="p">);</span>

    <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">re</span><span class="o">-&gt;</span><span class="n">argData</span><span class="p">;</span>

    <span class="c1">// Record the non-string arguments
</span><span class="c1"></span>    <span class="n">NanoLogInternal</span><span class="o">::</span><span class="n">Log</span><span class="o">::</span><span class="n">recordPrimitive</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">arg1</span><span class="p">);</span>
	<span class="n">NanoLogInternal</span><span class="o">::</span><span class="n">Log</span><span class="o">::</span><span class="n">recordPrimitive</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">arg2</span><span class="p">);</span>
	<span class="n">NanoLogInternal</span><span class="o">::</span><span class="n">Log</span><span class="o">::</span><span class="n">recordPrimitive</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">arg3</span><span class="p">);</span>

    <span class="c1">// Record the strings (if any) at the end of the entry
</span><span class="c1"></span>    <span class="n">memcpy</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">arg0</span><span class="p">,</span> <span class="n">str0Len</span><span class="p">);</span> <span class="n">buffer</span> <span class="o">+=</span> <span class="n">str0Len</span><span class="p">;</span><span class="o">*</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">remove_const</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">remove_pointer</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">arg0</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="sa">L</span><span class="sc">&#39;\0&#39;</span><span class="p">;</span>

    <span class="c1">// Make the entry visible
</span><span class="c1"></span>    <span class="n">NanoLogInternal</span><span class="o">::</span><span class="n">RuntimeLogger</span><span class="o">::</span><span class="n">finishAlloc</span><span class="p">(</span><span class="n">allocSize</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Each function contains a specific fmtId, and the logs are compressed and decompressed using the identifiers generated here. The above functions also allocate memory space for the arguments and call recordPrimitive in order to record all arguments into a buffer. The compress used for compression follows a similar logic.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="kr">inline</span> <span class="n">ssize_t</span>
<span class="nf">compressArgs__E32374s3237424642lf__s46cc__100__</span><span class="p">(</span><span class="n">NanoLogInternal</span><span class="o">::</span><span class="n">Log</span><span class="o">::</span><span class="n">UncompressedEntry</span> <span class="o">*</span><span class="n">re</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">out</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">originalOutPtr</span> <span class="o">=</span> <span class="n">out</span><span class="p">;</span>

    <span class="c1">// Allocate nibbles
</span><span class="c1"></span>    <span class="n">BufferUtils</span><span class="o">::</span><span class="n">TwoNibbles</span> <span class="o">*</span><span class="n">nib</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">BufferUtils</span><span class="o">::</span><span class="n">TwoNibbles</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">out</span><span class="p">);</span>
    <span class="n">out</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>

    <span class="kt">char</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="n">re</span><span class="o">-&gt;</span><span class="n">argData</span><span class="p">;</span>

    <span class="c1">// Read back all the primitives
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">arg1</span><span class="p">;</span> <span class="n">std</span><span class="o">::</span><span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arg1</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span> <span class="n">args</span> <span class="o">+=</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">arg2</span><span class="p">;</span> <span class="n">std</span><span class="o">::</span><span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arg2</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span> <span class="n">args</span> <span class="o">+=</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
	<span class="kt">double</span> <span class="n">arg3</span><span class="p">;</span> <span class="n">std</span><span class="o">::</span><span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arg3</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span> <span class="n">args</span> <span class="o">+=</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span>

    <span class="c1">// Pack all the primitives
</span><span class="c1"></span>    <span class="n">nib</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">first</span> <span class="o">=</span> <span class="mh">0x0f</span> <span class="o">&amp;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">BufferUtils</span><span class="o">::</span><span class="n">pack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">out</span><span class="p">,</span> <span class="n">arg1</span><span class="p">));</span>
	<span class="n">nib</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">second</span> <span class="o">=</span> <span class="mh">0x0f</span> <span class="o">&amp;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">BufferUtils</span><span class="o">::</span><span class="n">pack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">out</span><span class="p">,</span> <span class="n">arg2</span><span class="p">));</span>
	<span class="n">nib</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">first</span> <span class="o">=</span> <span class="mh">0x0f</span> <span class="o">&amp;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">BufferUtils</span><span class="o">::</span><span class="n">pack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">out</span><span class="p">,</span> <span class="n">arg3</span><span class="p">));</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// memcpy all the strings without compression
</span><span class="c1"></span>        <span class="n">size_t</span> <span class="n">stringBytes</span> <span class="o">=</span> <span class="n">re</span><span class="o">-&gt;</span><span class="n">entrySize</span> <span class="o">-</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">arg1</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">arg2</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">arg3</span><span class="p">)</span> <span class="o">+</span>  <span class="mi">0</span><span class="p">)</span>
                                            <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">NanoLogInternal</span><span class="o">::</span><span class="n">Log</span><span class="o">::</span><span class="n">UncompressedEntry</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">stringBytes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">memcpy</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">stringBytes</span><span class="p">);</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="n">stringBytes</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">out</span> <span class="o">-</span> <span class="n">originalOutPtr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The logging and compression functions are generated by Python&rsquo;s preprocessor parsing the source code, and the <code>NANO_LOG</code> used by the engineer at the beginning is expanded into new code by the preprocessor, which has very similar functionality to the C++ preprocessor, except that the code that needs to be expanded here is so complex that it&rsquo;s hard to implement in C++ using the preprocessor.</p>
<h3 id="runtime">Runtime</h3>
<p>The application&rsquo;s statically linked NanoLog runtime decouples low-latency <code>record</code> operations that record dynamic parameters from high-latency operations such as disk I/O through a buffer on the thread. The buffer on the thread stores the results of <code>record</code> method calls, which are also visible to the background compression threads.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/11/28/412cbae395164c2ea46150057fd79d6c.png" alt=""></p>
<p>The buffer used for staging data on the thread is the key to improve the performance of the program. We want to meet the additional overhead of avoiding lock contention and cache coherency as much as possible, and the staging buffer uses a ring queue and a single-producer consumer model to reduce the synchronization overhead of data.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/11/28/d3e50664cefc42dcabab9de30d9616f7.png" alt=""></p>
<p>A ring queue is a continuous, fixed-size cache data structure with connected heads and tails, ideal for caching data streams. The Linux kernel uses this data structure as a read/write buffer for sockets2 , and audio and video also use ring queues to temporarily store data that has just been received and not yet decoded.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">struct</span> <span class="nc">__kfifo</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">in</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">out</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">mask</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">esize</span><span class="p">;</span>
	<span class="kt">void</span>		<span class="o">*</span><span class="n">data</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>The runtime not only improves performance with a lock-free ring queue, but also needs to address the consumption of logs in the ring queue. To improve the processing power of background threads, the runtime defers the assembly of logs to post-processing and compresses log data to reduce the impact of high I/O latency.</p>
<h3 id="post-processing">Post-processing</h3>
<p>The post-processor is relatively simple to implement, as each log contains a specific identifier, based on which the post-processor finds the compile-time information in the compressed log header, and expands and decompresses the log based on that information.</p>
<p>Note that because each thread has its own staging buffer to store the logs during runtime, the logs that NanoLog eventually prints are not strictly chronological; it only ensures that the log output is in a generally ordered order.</p>
<h2 id="summary">Summary</h2>
<p>NanoLog is a very interesting and worthwhile logging system, but it is not suitable for all projects. It shifts the work that needs to be done at runtime to the compilation and post-processing stages, reducing the burden on the program at runtime, but its output binary logs are not directly readable, which also increases the workload of the developer in handling logs.</p>
<p>Although it is mentioned in the paper that log analysis engines basically collect, parse and analyze logs that engineers can read directly, and most of the time is spent on reading and parsing logs, using binary logs not only reduces the time spent on reading and parsing, but also reduces expensive I/O and bandwidth usage, but whether this is an advantage in our system is a matter of opinion.</p>
<p>Using a binary output format for logs does reduce costs in many ways, but it not only requires the support of a log collection and parsing system, but also sacrifices the developer&rsquo;s local debugging experience, and without a module that automatically collects and decompresses logs, manually decompressing online logs to troubleshoot problems is a very bad experience, but in extreme performance scenarios we may not have much choice, even at the expense of the experience may have to be on.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/nanolog/">nanolog</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2021-11/papers-twine/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Facebook Cluster Scheduling Management System - OSDI &#39;20</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2021-11/whys-the-design-olap-column-oriented/">
            <span class="next-text nav-default">Why OLAP Needs Columnar Storage</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
