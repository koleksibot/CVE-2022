<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Extracting text features using Scikit-Learn - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Text analysis is the main application area of machine learning algorithms. Since most machine learning algorithms can only receive fixed-length numeric matrix features, resulting in text strings and so on cannot be used directly, Scikit-Learn provides a method to convert text to numeric features for this problem, so let&amp;rsquo;s learn it together today. sklearn.feature_extraction.text in Scikit-Learn provides tools for converting text into feature vectors:. CountVectorizer(): converts text into a word" /><meta name="keywords" content="Scikit-Learn" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2021-11/sklearn-feature-extraction-text/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Extracting text features using Scikit-Learn" />
<meta property="og:description" content="Text analysis is the main application area of machine learning algorithms. Since most machine learning algorithms can only receive fixed-length numeric matrix features, resulting in text strings and so on cannot be used directly, Scikit-Learn provides a method to convert text to numeric features for this problem, so let&rsquo;s learn it together today. sklearn.feature_extraction.text in Scikit-Learn provides tools for converting text into feature vectors:. CountVectorizer(): converts text into a word" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2021-11/sklearn-feature-extraction-text/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-11-01T19:20:41+08:00" />
<meta property="article:modified_time" content="2021-11-01T19:20:41+08:00" />

<meta itemprop="name" content="Extracting text features using Scikit-Learn">
<meta itemprop="description" content="Text analysis is the main application area of machine learning algorithms. Since most machine learning algorithms can only receive fixed-length numeric matrix features, resulting in text strings and so on cannot be used directly, Scikit-Learn provides a method to convert text to numeric features for this problem, so let&rsquo;s learn it together today. sklearn.feature_extraction.text in Scikit-Learn provides tools for converting text into feature vectors:. CountVectorizer(): converts text into a word"><meta itemprop="datePublished" content="2021-11-01T19:20:41+08:00" />
<meta itemprop="dateModified" content="2021-11-01T19:20:41+08:00" />
<meta itemprop="wordCount" content="2189">
<meta itemprop="keywords" content="scikit-learn," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Extracting text features using Scikit-Learn"/>
<meta name="twitter:description" content="Text analysis is the main application area of machine learning algorithms. Since most machine learning algorithms can only receive fixed-length numeric matrix features, resulting in text strings and so on cannot be used directly, Scikit-Learn provides a method to convert text to numeric features for this problem, so let&rsquo;s learn it together today. sklearn.feature_extraction.text in Scikit-Learn provides tools for converting text into feature vectors:. CountVectorizer(): converts text into a word"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Extracting text features using Scikit-Learn</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-11-01 19:20:41 </span>
        <div class="post-category">
            <a href="/categories/skills/"> skills </a>
            </div>
          <span class="more-meta"> 2189 words </span>
          <span class="more-meta"> 5 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#countvectorizer">CountVectorizer</a></li>
        <li><a href="#tfidftransformer">TfidfTransformer</a></li>
        <li><a href="#tfidfvectorizer">TfidfVectorizer</a></li>
        <li><a href="#hashingvectorizer">HashingVectorizer</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>Text analysis is the main application area of machine learning algorithms. Since most machine learning algorithms can only receive fixed-length numeric matrix features, resulting in text strings and so on cannot be used directly, Scikit-Learn provides a method to convert text to numeric features for this problem, so let&rsquo;s learn it together today.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/11/01/e494cfb756204ae281bed22fd49856e4.png" alt=""></p>
<p>sklearn.feature_extraction.text in Scikit-Learn provides tools for converting text into feature vectors:.</p>
<ul>
<li>CountVectorizer(): converts text into a word frequency matrix</li>
<li>TfidfTransformer(): converts the CountVectorizer() word frequency matrix into a tf-idf matrix</li>
<li>TfidfVectorizer(): convert text directly into TF-IDF matrix</li>
<li>HashingVectorizer(): convert the text into a Hash matrix</li>
</ul>
<h2 id="countvectorizer">CountVectorizer</h2>
<p>CountVectorizer is to transform the words in the text into a word frequency matrix by the fit_transform function. The element a[i][j] of the matrix indicates the word frequency of word j under the ith text. That is, the number of occurrences of each word. The keywords of all texts can be seen by get_feature_names(), and the results of the word frequency matrix can be seen by toarray().</p>
<p>Example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="kn">from</span> <span class="nn">sklearn.feature_extraction.text</span> <span class="kn">import</span> <span class="n">CountVectorizer</span>

<span class="n">corpus</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;This is the first document.&#39;</span><span class="p">,</span>
    <span class="s1">&#39;This is the second second document.&#39;</span><span class="p">,</span>
    <span class="s1">&#39;And the third one.&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Is this the first document?&#39;</span><span class="p">,</span>
<span class="p">]</span>

<span class="n">vectorizer</span> <span class="o">=</span> <span class="n">CountVectorizer</span><span class="p">()</span>
<span class="n">count</span> <span class="o">=</span> <span class="n">vectorizer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">corpus</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">vectorizer</span><span class="o">.</span><span class="n">get_feature_names</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="n">vectorizer</span><span class="o">.</span><span class="n">vocabulary_</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">count</span><span class="o">.</span><span class="n">toarray</span><span class="p">())</span>

<span class="c1"># 输出</span>
<span class="c1"># [&#39;and&#39;, &#39;document&#39;, &#39;first&#39;, &#39;is&#39;, &#39;one&#39;, &#39;second&#39;, &#39;the&#39;, &#39;third&#39;, &#39;this&#39;]</span>
<span class="c1"># {&#39;this&#39;: 8, &#39;is&#39;: 3, &#39;the&#39;: 6, &#39;first&#39;: 2, &#39;document&#39;: 1, &#39;second&#39;: 5, &#39;and&#39;: 0, &#39;third&#39;: 7, &#39;one&#39;: 4}</span>
<span class="c1"># [[0 1 1 1 0 0 1 0 1]</span>
<span class="c1">#  [0 1 0 1 0 2 1 0 1]</span>
<span class="c1">#  [1 0 0 0 1 0 1 1 0]</span>
<span class="c1">#  [0 1 1 1 0 0 1 0 1]]</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="k">class</span> <span class="nc">sklearn</span><span class="o">.</span><span class="n">feature_extraction</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">CountVectorizer</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="err">’</span><span class="n">content</span><span class="err">’</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="err">’</span><span class="n">utf</span><span class="o">-</span><span class="mi">8</span><span class="err">’</span><span class="p">,</span> <span class="n">decode_error</span><span class="o">=</span><span class="err">’</span><span class="n">strict</span><span class="err">’</span><span class="p">,</span> <span class="n">strip_accents</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lowercase</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">preprocessor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tokenizer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop_words</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">token_pattern</span><span class="o">=</span><span class="err">’</span><span class="p">(</span><span class="err">?</span><span class="n">u</span><span class="p">)</span>\<span class="n">b</span>\<span class="n">w</span>\<span class="n">w</span><span class="o">+</span>\<span class="n">b</span><span class="err">’</span><span class="p">,</span> <span class="n">ngram_range</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">analyzer</span><span class="o">=</span><span class="err">’</span><span class="n">word</span><span class="err">’</span><span class="p">,</span> <span class="n">max_df</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">min_df</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_features</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vocabulary</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">binary</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=&lt;</span><span class="k">class</span> <span class="err">‘</span><span class="nc">numpy</span><span class="o">.</span><span class="n">int64</span><span class="err">’</span><span class="o">&gt;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Parameter description.</p>
<ul>
<li>input:string {&lsquo;filename&rsquo;, &lsquo;file&rsquo;, &lsquo;content&rsquo;}
<ul>
<li>If &lsquo;filename&rsquo;, the sequence passed as an argument to fit is expected to be a list of filenames that need to be read to get the original content to be analyzed.</li>
<li>If &lsquo;file&rsquo;, the sequence item must have a &lsquo;read&rsquo; method (file-like object) that is called to get the bytes in memory.</li>
<li>Otherwise, the expected input is the sequence string or byte item is expected to be parsed directly.</li>
</ul>
</li>
<li>encoding:string,&lsquo;utf-8&rsquo; by default.
<ul>
<li>If bytes or files are given for analysis, this encoding is used for decoding.</li>
</ul>
</li>
<li>decode_error: {&lsquo;strict&rsquo;,&lsquo;ignore&rsquo;,&lsquo;replace&rsquo;}
<ul>
<li>Instructs what to do if given a sequence of bytes to parse that contains characters that are not of the given encoding. By default, it is &lsquo;strict&rsquo;, which means UnicodeDecodeError will be raised. other values are &lsquo;ignore&rsquo; and &lsquo;replace &ldquo;.</li>
</ul>
</li>
<li>strip_accents: {&lsquo;ascii&rsquo;, &lsquo;unicode&rsquo;, None}
<ul>
<li>Whether to remove accents in the preprocessing step.&rsquo; ascii' is a fast method that applies only to characters with direct ASCII mappings.' unicode' is a slightly slower method for any character. none (default) does nothing.</li>
</ul>
</li>
<li>lowercase: boolean, True by default
<ul>
<li>Convert all characters to lowercase before the token token</li>
</ul>
</li>
<li>preprocessor: callable or None (default)
<ul>
<li>Override the preprocessor (string conversion) stage while preserving the tokenizing and n-grams generation steps.</li>
</ul>
</li>
<li>tokenizer: callable or None (default)
<ul>
<li>Override the string tokenization step, while keeping the preprocessing and n-grams generation steps.</li>
<li>Only applies to analyzer == &lsquo;word&rsquo;</li>
</ul>
</li>
<li>stop_words: string {&lsquo;english&rsquo;}, list, or None (default)
<ul>
<li>If it is a string, pass it to _check_stop_list and return the corresponding stop list.' english' is currently the only string value supported.</li>
<li>If a list, which is assumed to contain stop words, all of these will be removed from the generated token. Applies only if. analyzer == &lsquo;word&rsquo;</li>
<li>If not, stop words will not be used. max_df can be set to a value in the range [0.7,1.0] to automatically detect and filter stop words based on the corpus document frequency of the term.</li>
</ul>
</li>
<li>token_pattern: string
<ul>
<li>Regular expression that filters by default for mixed alphabetic and numeric characters of length &gt;= 2 (punctuation is completely ignored and always treated as a token separator). Only used if analyzer==&lsquo;word&rsquo; is used.</li>
<li>ngram_range: tuple (min_n, max_n)</li>
<li>The lower and upper bounds of the n-value range for different n-values are extracted. All n values will be used such that min_n &lt;= n &lt;= max_n.</li>
</ul>
</li>
<li>analyzer: string, {&lsquo;word&rsquo;, &lsquo;char&rsquo;, &lsquo;char_wb&rsquo;} or callable
<ul>
<li>Whether the feature should consist of a word or a character n-gram. The option &lsquo;char_wb&rsquo; creates character n-grams only from text inside word boundaries; n-grams at the edges of words are filled with spaces.</li>
<li>If passed callable, it will be used to extract feature sequences from the original unprocessed input.</li>
</ul>
</li>
<li>max_df: float in range [0.0, 1.0] or int, default=1.0
<ul>
<li>When constructing a vocabulary, words with a document frequency higher than the given threshold are strictly ignored, and the corpus specifies deactivated words. In case of floating point values, this parameter represents the proportion of documents, integer absolute count value, if the vocabulary is not None, this parameter is ignored.</li>
</ul>
</li>
<li>min_df: float in range [0.0, 1.0] or int, default=1
<ul>
<li>When constructing the vocabulary, words with document frequencies below the given threshold are strictly ignored, and the corpus specifies deactivated words. In case of floating point values, this parameter represents the proportion of documents, integer absolute count value, if the vocabulary is not None, this parameter is ignored.</li>
</ul>
</li>
<li>max_features: int or None, default=None
<ul>
<li>If None, construct a vocabulary considering only max_features</li>
<li>Sort by corpus word frequency, if vocabulary is not None, this parameter is ignored</li>
</ul>
</li>
<li>vocabulary: Mapping or iterable, optional
<ul>
<li>Also a Map (e.g., a dictionary) where the keys are the lexical entries and the values are indexed in the feature matrix, or iterators in the lexical entries. If not given, the vocabulary is determined from the input file. There must be no duplication of indexes in the mapping, and there must be no breaks between 0 and the maximum index value.</li>
</ul>
</li>
<li>binary: boolean, default=False
<ul>
<li>If not True, all non-zero counts are set to 1. This is useful for discrete probability models, modeling binary events instead of integer counts</li>
</ul>
</li>
<li>dtype: type, optional
<ul>
<li>The type of the matrix returned by fit_transform() or transform().</li>
</ul>
</li>
</ul>
<p>Attributes.</p>
<ul>
<li>vocabulary_: dict
<ul>
<li>A mapping of terms to feature indexes.</li>
</ul>
</li>
<li>stop_words_: set
<ul>
<li>Terms that are ignored because they.
<ul>
<li>appear in too many files (max_df)</li>
<li>appear in too few files (min_df)</li>
<li>cut off by feature selection (max_features)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Method.</p>
<ul>
<li>build_analyzer(self) Return a callable that handles preprocessing and tokenization</li>
<li>build_preprocessor(self) Return a function to preprocess the text before tokenization</li>
<li>build_tokenizer(self) Return a function that splits a string into a sequence of tokens</li>
<li>decode(self, doc) Decode the input into a string of unicode symbols</li>
<li>fit(self, raw_documents[, y]) The main purpose is to load the data and compute it accordingly.</li>
<li>transform(self, raw_documents) The main purpose is to transform the data into matrix form.</li>
<li>fit_transform(self, raw_documents[, y]) puts the fit and transform steps together.</li>
<li>get_feature_names(self) Get all features, i.e. a list of keywords</li>
<li>get_params(self[, deep]) Get parameters for this estimator.</li>
<li>get_stop_words(self) Build or fetch the effective stop words list</li>
<li>inverse_transform(self, X) Return terms per document with nonzero entries in X.</li>
<li>set_params(self, **params) Set the parameters of this estimator.</li>
</ul>
<h2 id="tfidftransformer">TfidfTransformer</h2>
<p>TfidfTransformer is to count the tf-idf weights of each word in CountVectorizer.</p>
<p>Example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="kn">from</span> <span class="nn">sklearn.feature_extraction.text</span> <span class="kn">import</span> <span class="n">CountVectorizer</span><span class="p">,</span> <span class="n">TfidfTransformer</span>

<span class="n">corpus</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;This is the first document.&#39;</span><span class="p">,</span>
    <span class="s1">&#39;This is the second second document.&#39;</span><span class="p">,</span>
    <span class="s1">&#39;And the third one.&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Is this the first document?&#39;</span><span class="p">,</span>
<span class="p">]</span>

<span class="n">vectorizer</span> <span class="o">=</span> <span class="n">CountVectorizer</span><span class="p">()</span>
<span class="n">transformer</span> <span class="o">=</span> <span class="n">TfidfTransformer</span><span class="p">()</span>
<span class="n">count</span> <span class="o">=</span> <span class="n">vectorizer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">corpus</span><span class="p">)</span>
<span class="n">tfidf_matrix</span> <span class="o">=</span> <span class="n">transformer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">tfidf_matrix</span><span class="o">.</span><span class="n">toarray</span><span class="p">())</span>

<span class="c1"># 输出</span>
<span class="c1"># [[0.         0.43877674 0.54197657 0.43877674 0.         0.</span>
<span class="c1">#   0.35872874 0.         0.43877674]</span>
<span class="c1">#  [0.         0.27230147 0.         0.27230147 0.         0.85322574</span>
<span class="c1">#   0.22262429 0.         0.27230147]</span>
<span class="c1">#  [0.55280532 0.         0.         0.         0.55280532 0.</span>
<span class="c1">#   0.28847675 0.55280532 0.        ]</span>
<span class="c1">#  [0.         0.43877674 0.54197657 0.43877674 0.         0.</span>
<span class="c1">#   0.35872874 0.         0.43877674]]</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="k">class</span> <span class="nc">sklearn</span><span class="o">.</span><span class="n">feature_extraction</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">TfidfTransformer</span><span class="p">(</span><span class="n">norm</span><span class="o">=</span><span class="err">’</span><span class="n">l2</span><span class="err">’</span><span class="p">,</span> <span class="n">use_idf</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">smooth_idf</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sublinear_tf</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Parameters.</p>
<ul>
<li>norm: &lsquo;l1&rsquo;, &lsquo;l2&rsquo; or None, optional (default=&lsquo;l2&rsquo;)
<ul>
<li>Whether to normalize the data, None means no normalization.</li>
</ul>
</li>
<li>use_idf : boolean (default=True)
<ul>
<li>whether to use idf, if False, then degrade to simple word frequency statistics</li>
</ul>
</li>
<li>smooth_idf: boolean (default=True)
<ul>
<li>smooth idf weight by adding 1 to document frequency, adding an extra document to prevent division by zero</li>
</ul>
</li>
<li>sublinear_tf: boolean (default=False)
<ul>
<li>Apply linear scaling TF, if True, use 1 + log(tf) instead of tf</li>
</ul>
</li>
</ul>
<p>Attributes.</p>
<ul>
<li>idf_: array, shape (n_features)
<ul>
<li>The inverse document frequency (IDF) vector; only defined if use_idf is True.</li>
</ul>
</li>
</ul>
<p>Methods:</p>
<ul>
<li>fit(self, X[, y]) Learn the idf vector (global term weights)</li>
<li>transform(self, X[, copy]) Transform a count matrix to a tf or tf-idf representation</li>
<li>fit_transform(self, X[, y]) Fit to data, then transform it.</li>
<li>get_params(self[, deep]) Get parameters for this estimator.</li>
<li>set_params(self, **params) Set the parameters of this estimator.</li>
<li>transform(self, X[, copy]) Transform a count matrix to a tf or tf-idf representation</li>
</ul>
<h2 id="tfidfvectorizer">TfidfVectorizer</h2>
<p>The collection of original documents is transformed into a matrix of tf-idf characteristics, which is equivalent to the effect of CountVectorizer used with TfidfTransformer. That is, the TfidfVectorizer class will CountVectorizer and TfidfTransformer class wrapped together.</p>
<p>Example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="kn">from</span> <span class="nn">sklearn.feature_extraction.text</span> <span class="kn">import</span> <span class="n">TfidfVectorizer</span>

<span class="n">corpus</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;This is the first document.&#39;</span><span class="p">,</span>
    <span class="s1">&#39;This is the second second document.&#39;</span><span class="p">,</span>
    <span class="s1">&#39;And the third one.&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Is this the first document?&#39;</span><span class="p">,</span>
<span class="p">]</span>

<span class="n">tfidf_vec</span> <span class="o">=</span> <span class="n">TfidfVectorizer</span><span class="p">()</span>
<span class="n">tfidf_matrix</span> <span class="o">=</span> <span class="n">tfidf_vec</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">corpus</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">tfidf_vec</span><span class="o">.</span><span class="n">get_feature_names</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="n">tfidf_vec</span><span class="o">.</span><span class="n">vocabulary_</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">tfidf_matrix</span><span class="o">.</span><span class="n">toarray</span><span class="p">())</span>

<span class="c1"># 输出</span>
<span class="c1"># [&#39;and&#39;, &#39;document&#39;, &#39;first&#39;, &#39;is&#39;, &#39;one&#39;, &#39;second&#39;, &#39;the&#39;, &#39;third&#39;, &#39;this&#39;]</span>
<span class="c1"># {&#39;this&#39;: 8, &#39;is&#39;: 3, &#39;the&#39;: 6, &#39;first&#39;: 2, &#39;document&#39;: 1, &#39;second&#39;: 5, &#39;and&#39;: 0, &#39;third&#39;: 7, &#39;one&#39;: 4}</span>
<span class="c1"># [[0.         0.43877674 0.54197657 0.43877674 0.         0.</span>
<span class="c1">#   0.35872874 0.         0.43877674]</span>
<span class="c1">#  [0.         0.27230147 0.         0.27230147 0.         0.85322574</span>
<span class="c1">#   0.22262429 0.         0.27230147]</span>
<span class="c1">#  [0.55280532 0.         0.         0.         0.55280532 0.</span>
<span class="c1">#   0.28847675 0.55280532 0.        ]</span>
<span class="c1">#  [0.         0.43877674 0.54197657 0.43877674 0.         0.</span>
<span class="c1">#   0.35872874 0.         0.43877674]]</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="hashingvectorizer">HashingVectorizer</h2>
<p>Word frequencies and weights are useful, but when the vocabulary becomes large, the above two approaches become limited. In turn, this would require huge vectors to encode the document and would be very memory demanding and slow down the algorithm. A good approach is to use a one-way hashing method to convert words into integers. The advantage is that the method does not require a vocabulary and can choose an arbitrarily long fixed-length vector. The disadvantage is that the hash quantization is one-way, so it is not possible to convert the encoding back to words (perhaps not important with many supervised learning tasks).</p>
<p>The HashingVectorizer class implements this method, so it can be used to continuously hash quantize words and then lexicalize and encode documents on demand. Here is an example of encoding a single document using HashingVectorizer. We have chosen an arbitrary vector of fixed length 20. This value corresponds to the range of the hash function; small values (e.g., 20) may lead to hash collisions. In previous computer science courses, we have introduced heuristic algorithms that allow the choice of hash length and collision probability based on the estimated vocabulary.</p>
<p>Note that this quantization method does not require calling a function to fit the training data file. Instead, after instantiation, it can be used directly to encode the document.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="kn">from</span> <span class="nn">sklearn.feature_extraction.text</span> <span class="kn">import</span> <span class="n">HashingVectorizer</span>

<span class="n">text</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&#34;The quick brown fox jumped over the lazy dog.&#34;</span><span class="p">]</span>
<span class="n">vectorizer</span> <span class="o">=</span> <span class="n">HashingVectorizer</span><span class="p">(</span><span class="n">n_features</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">vector</span> <span class="o">=</span> <span class="n">vectorizer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">vector</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">vector</span><span class="o">.</span><span class="n">toarray</span><span class="p">())</span>
</code></pre></td></tr></table>
</div>
</div><p>Running the sample code encodes the sample document as a sparse matrix with 20 elements. The value of the encoded document corresponds to the regularized word count, which defaults to a value between -1 and 1, but the default can be modified and then set to an integer count value.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="p">[[</span> <span class="mf">0.</span>          <span class="mf">0.</span>          <span class="mf">0.</span>          <span class="mf">0.</span>          <span class="mf">0.</span>          <span class="mf">0.33333333</span>
   <span class="mf">0.</span>         <span class="o">-</span><span class="mf">0.33333333</span>  <span class="mf">0.33333333</span>  <span class="mf">0.</span>          <span class="mf">0.</span>          <span class="mf">0.33333333</span>
   <span class="mf">0.</span>          <span class="mf">0.</span>          <span class="mf">0.</span>         <span class="o">-</span><span class="mf">0.33333333</span>  <span class="mf">0.</span>          <span class="mf">0.</span>
  <span class="o">-</span><span class="mf">0.66666667</span>  <span class="mf">0.</span>        <span class="p">]]</span>
</code></pre></td></tr></table>
</div>
</div><p>Reference link.</p>
<ul>
<li><a href="https://scikit-learn.org/stable/modules/classes.html#module-sklearn.feature_extraction.text">module-sklearn.feature_extraction.text</a></li>
</ul>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/scikit-learn/">scikit-learn</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2021-11/control-character-python/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Python handles control characters in text</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2021-11/python-excel/">
            <span class="next-text nav-default">Python reads and writes Excel tables</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
