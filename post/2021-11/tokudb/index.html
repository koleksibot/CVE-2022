<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>MySQL High Performance Storage Engine TokuDB - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="When installing MariaDB, I learned about TokuDB, which replaces InnoDB, and it&amp;rsquo;s great to see the introduction.
What is TokuDB? The most popular MySQL engine that supports full transactions is INNODB, which is characterized by the fact that the data itself is organized by B-TREE, which is a huge B-TREE index clustered by primary key. So at this point, the write speed will be somewhat reduced, because to write each time to use an IO to do the index tree rearrangement." /><meta name="keywords" content="mysql, Tokudb" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2021-11/tokudb/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="MySQL High Performance Storage Engine TokuDB" />
<meta property="og:description" content="When installing MariaDB, I learned about TokuDB, which replaces InnoDB, and it&rsquo;s great to see the introduction.
What is TokuDB? The most popular MySQL engine that supports full transactions is INNODB, which is characterized by the fact that the data itself is organized by B-TREE, which is a huge B-TREE index clustered by primary key. So at this point, the write speed will be somewhat reduced, because to write each time to use an IO to do the index tree rearrangement." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2021-11/tokudb/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-11-20T14:54:12+08:00" />
<meta property="article:modified_time" content="2021-11-20T14:54:12+08:00" />

<meta itemprop="name" content="MySQL High Performance Storage Engine TokuDB">
<meta itemprop="description" content="When installing MariaDB, I learned about TokuDB, which replaces InnoDB, and it&rsquo;s great to see the introduction.
What is TokuDB? The most popular MySQL engine that supports full transactions is INNODB, which is characterized by the fact that the data itself is organized by B-TREE, which is a huge B-TREE index clustered by primary key. So at this point, the write speed will be somewhat reduced, because to write each time to use an IO to do the index tree rearrangement."><meta itemprop="datePublished" content="2021-11-20T14:54:12+08:00" />
<meta itemprop="dateModified" content="2021-11-20T14:54:12+08:00" />
<meta itemprop="wordCount" content="6589">
<meta itemprop="keywords" content="mysql," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="MySQL High Performance Storage Engine TokuDB"/>
<meta name="twitter:description" content="When installing MariaDB, I learned about TokuDB, which replaces InnoDB, and it&rsquo;s great to see the introduction.
What is TokuDB? The most popular MySQL engine that supports full transactions is INNODB, which is characterized by the fact that the data itself is organized by B-TREE, which is a huge B-TREE index clustered by primary key. So at this point, the write speed will be somewhat reduced, because to write each time to use an IO to do the index tree rearrangement."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">MySQL High Performance Storage Engine TokuDB</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-11-20 14:54:12 </span>
        <div class="post-category">
            <a href="/categories/skills/"> skills </a>
            </div>
          <span class="more-meta"> 6589 words </span>
          <span class="more-meta"> 31 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#what-is-tokudb">What is TokuDB?</a></li>
        <li><a href="#features-of-tokudb">Features of TokuDB</a></li>
        <li><a href="#tokudbs-index-structure-fractal-tree">TokuDB&rsquo;s Index Structure: Fractal Tree</a>
          <ul>
            <li><a href="#introduction-to-fractal-tree">Introduction to Fractal tree</a></li>
          </ul>
        </li>
        <li><a href="#multiple-version-concurrency-control-mvcc-for-tokudb">Multiple Version Concurrency Control (MVCC) for TokuDB</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>When installing MariaDB, I learned about TokuDB, which replaces InnoDB, and it&rsquo;s great to see the introduction.</p>
<h2 id="what-is-tokudb">What is TokuDB?</h2>
<p>The most popular MySQL engine that supports full transactions is INNODB, which is characterized by the fact that the data itself is organized by B-TREE, which is a huge B-TREE index clustered by primary key. So at this point, the write speed will be somewhat reduced, because to write each time to use an IO to do the index tree rearrangement. Especially when the amount of data itself is much larger than the memory, the CPU itself is too tangled up in disk IO to do anything else. At this point we have to consider how to reduce the IO to disk to relieve the CPU situation, common methods are.</p>
<ul>
<li>Increase the INNODB PAGE (default 16KB), but the increase also brings some defects. For example, the time to perform CHECKPOINT on disk will be delayed.</li>
<li>Put the log file on a faster disk, such as an SSD.</li>
</ul>
<p>TokuDB is a &ldquo;new&rdquo; transaction-enabled engine with excellent data compression, developed by TokuTek (now acquired by Percona). With excellent data compression, if you have more writes and less reads, and a large amount of data, it is highly recommended that you use TokuDB to save space costs and significantly reduce storage usage and IOPS overhead, but with a corresponding increase in CPU strain.</p>
<h2 id="features-of-tokudb">Features of TokuDB</h2>
<p><strong>1.Rich index types and fast index creation</strong></p>
<p>TokuDB supports existing index types, but also adds (second) aggregate indexes to meet the diversity of queries covering indexes, and improves the efficiency of queries in terms of fast index creation</p>
<p><strong>2.(Second) aggregate indexes</strong></p>
<p>This type of index also contains all the columns in the table and can be used for queries that need to override indexes, such as the following example, which directly hits the index_b index in the where condition, avoiding another lookup from the primary key.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="k">table</span><span class="w"> </span><span class="p">(</span><span class="w">
</span><span class="w"></span><span class="n">column_a</span><span class="w"> </span><span class="nb">INT</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="n">column_b</span><span class="w"> </span><span class="nb">INT</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="n">column_c</span><span class="w"> </span><span class="nb">INT</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="n">index_a</span><span class="w"> </span><span class="p">(</span><span class="n">column_a</span><span class="p">),</span><span class="w">
</span><span class="w"></span><span class="n">CLUSTERING</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="n">index_b</span><span class="w"> </span><span class="p">(</span><span class="n">column_b</span><span class="p">))</span><span class="w"> </span><span class="n">ENGINE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TokuDB</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">column_c</span><span class="w">
</span><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="k">table</span><span class="w">
</span><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">column_b</span><span class="w"> </span><span class="k">BETWEEN</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>For more information, see. <a href="https://www.percona.com/blog/2009/05/27/introducing_multiple_clustering_indexes/">Introducing Multiple Clustering Indexes</a></p>
<p><strong>3. Hot Index Creation</strong></p>
<p>TokuDB allows to add indexes to tables directly without affecting the execution of update statements (insert, update, etc.). You can control whether this feature is enabled or not by the variable tokudb_create_index_online, but unfortunately it can only be created online by the CREATE INDEX syntax, not by ALTER TABLE. This is much slower than the usual creation process, which can be viewed by show processlist. However, tokudb does not support online deletion of indexes, and a global lock will be applied to the marker when the index is deleted.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="o">&gt;</span><span class="w"> </span><span class="k">SET</span><span class="w"> </span><span class="n">tokudb_create_index_online</span><span class="o">=</span><span class="k">ON</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="n">Query</span><span class="w"> </span><span class="n">OK</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="k">rows</span><span class="w"> </span><span class="n">affected</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">00</span><span class="w"> </span><span class="n">sec</span><span class="p">)</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="o">&gt;</span><span class="w"> </span><span class="k">CREATE</span><span class="w"> </span><span class="k">INDEX</span><span class="w"> </span><span class="k">index</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="k">table</span><span class="w"> </span><span class="p">(</span><span class="n">field_name</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p><strong>4. Online column changes (Add, Delete, Expand, Rename)</strong>.</p>
<p>TokuDB can allow the following operations with minor blocking of update or query statements.</p>
<ul>
<li>Adding or deleting columns in a table</li>
<li>Expand fields: char, varchar, varbinary and int type columns</li>
<li>Rename columns, unsupported field types: TIME, ENUM, BLOB, TINYBLOB, MEDIUMBLOB, LONGBLOB</li>
</ul>
<p>These operations usually block (for a few seconds) the execution of other queries at table lock level, and when the table record is next loaded from disk to memory, the system will then modify the record (add, delete or expand), and in the case of rename operations, all operations will be completed within a few seconds of downtime.</p>
<p>The reason for the speed is probably due to the feature of the Fractal-tree index, which replaces random IO operations with sequential IO operations, and the feature of the Fractal-tree will broadcast these operations to all rows, unlike InnoDB, which needs to open table and create temporary table to complete.</p>
<p>Take a look at some of the official guidance on this feature:</p>
<ul>
<li>All of these operations are not performed immediately, but are done in the background by the Fractal Tree, including primary and non-primary key indexes. You can also force these operations manually, using the OPTIMIZE TABLE X command, TokuDB supports online completion of the OPTIMIZE TABLE command since 1.0, but it will not rebuild the indexes</li>
<li>Don&rsquo;t update multiple columns at once, do it separately for each column</li>
<li>Avoid add, delete, expand or drop operations on a column at the same time</li>
<li>The table lock time is mainly determined by the dirty pages in the cache, the more dirty pages, the longer the flush time. Every time you do an update, MySQL closes the table join to release the previous resources.</li>
<li>Avoid deleting a column that is part of an index, which can be particularly slow, or remove the index from the column if you have to.</li>
<li>The expand class only supports char, varchar, varbinary and int fields.</li>
<li>rename one column at a time, operation on multiple columns will degrade to standard MySQL behavior, the column attributes must be specified in the syntax, as follows.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="k">table</span><span class="w">
</span><span class="w"></span><span class="n">CHANGE</span><span class="w"> </span><span class="n">column_old</span><span class="w"> </span><span class="n">column_new</span><span class="w">
</span><span class="w"></span><span class="n">DATA_TYPE</span><span class="w"> </span><span class="n">REQUIRED_NESS</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>The rename operation does not support the fields: TIME, ENUM, BLOB, TINYBLOB, MEDIUMBLOB, LONGBLOB.</li>
<li>Update temporary table is not supported</li>
</ul>
<p><strong>5. Data compression</strong></p>
<p>All compression operations in TokuDB are performed in the background, high level compression will degrade system performance, some scenarios will require high level compression. According to the official recommendation: standard compression is recommended for machines with less than 6 cores, otherwise you can use high level compression.</p>
<p>The compression algorithm is specified by ROW_FORMAT for each table when creating or altering the table.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="k">table</span><span class="w"> </span><span class="p">(</span><span class="w">
</span><span class="w"></span><span class="n">column_a</span><span class="w"> </span><span class="nb">INT</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="n">column_b</span><span class="w"> </span><span class="nb">INT</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">)</span><span class="w"> </span><span class="n">ENGINE</span><span class="o">=</span><span class="n">TokuDB</span><span class="w">
</span><span class="w"></span><span class="n">ROW_FORMAT</span><span class="o">=</span><span class="n">row_format</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>ROW_FORMAT is by default controlled by the variable tokudb_row_format, which defaults to tokudb_zlib, and can have the following values:</p>
<ul>
<li>tokudb_zlib: uses the compression mode of the zlib library, providing a medium level of compression ratio and medium level of CPU consumption.</li>
<li>tokudb_quicklz: Uses the compression mode of the quicklz library, providing a lightweight compression ratio and low basic CPU consumption.</li>
<li>tokudb_lzma: Compression mode using the lzma library, providing a high compression ratio and high CPU consumption.</li>
<li>tokudb_uncompressed: No compression mode is used.</li>
</ul>
<p><strong>Read free</strong> <strong>Replication feature</strong></p>
<p>Thanks to the feature of Fractal Tree index, TokuDB&rsquo;s slave side can apply changes on the master side with lower consumption than read IO, which mainly depends on the feature of Fractal Tree index and can be enabled in the configuration</p>
<ul>
<li>insert/delete/update operations can be partially inserted directly into the appropriate Fractal Tree index, avoiding the overhead of read-modify-write behavior;</li>
<li>delete/update operations can ignore the IO overhead of uniqueness checking</li>
</ul>
<p>The bad thing is, if the Read Free Replication feature is enabled, the Server side needs to do the following settings:</p>
<ul>
<li>master: the replication format must be ROW, because tokudb has not yet implemented locking for the auto-increment function, so multiple concurrent insert statements may cause uncertain auto-increment values, resulting in inconsistent data between master and slave.</li>
<li>slave: turn on read-only; turn off uniqueness checking (set tokudb_rpl_unique_checks=0); turn off lookup (read-modify-write) function (set tokudb_rpl_lookup_rows=0);</li>
</ul>
<p>The settings on the slave side can be set in one or more slave: only tables with primary keys defined in MySQL 5.5 and MariaDB 5.5 can use this feature, MySQL 5.6, Percona 5.6 and MariaDB 10.X do not have this restriction</p>
<p><strong>7. Transactions, ACID and Recovery</strong></p>
<ul>
<li>By default, TokuDB checks all open tables periodically and records all updates during the checkpoint, so in case of system crash, the table can be restored to its previous state (ACID-compliant), all committed transactions will be updated to the table, and uncommitted transactions will be rolled back. The default checkpoint cycle is every 60s, from the start time of the current checkpoint to the start time of the next checkpoint. If the checkpoint requires more information, the next checkpoint check will start immediately, but this is related to the frequent refresh of the log file. Users can also manually execute the flush logs command at any time to cause a checkpoint check; all open transactions are ignored during normal database shutdown.</li>
<li>Manage log size: TokuDB keeps the latest checkpoing in the log file, when the log reaches 100M, a new log file will be started; each time checkpoint is made, any log older than the current checkpoint will be ignored, if the check period is set very large, the log cleaning frequency will be reduced. TokuDB also maintains a rollback log for each open transaction, the size of the log is related to the transaction volume, it is compressed and saved to disk, when the transaction ends, the rollback log will be cleaned up accordingly.</li>
<li>Recovery: TokuDB automatically performs recovery operations, using logs and rollback logs to recover after a crash, recovery time is determined by the log size (including uncompressed rollback logs).</li>
<li>Disable write caching: If you want to ensure transaction security, you have to consider hardware write caching. TokuDB also supports transaction safe feature in MySQL, for the system, the updated data of the database is not really written to disk, but cached, it will still lose data when the system crashes, for example, TokuDB cannot guarantee that the mounted NFS volume can be recovered properly, so if you want to be safe, it is better to So if you want to be safe, it is better to turn off write caching, but it may cause performance degradation. Normally you need to turn off the disk write cache, but for performance reasons, the XFS file system cache can be turned on, but after threading the error &ldquo;Disabling barriers&rdquo;, you need to turn off the cache. Some scenarios require turning off the file system (ext3) cache, LVM, soft RAID, and RAID cards with BBU (battery-backed-up) features</li>
</ul>
<p><strong>8. Procedure tracing</strong>.</p>
<p>TokuDB provides a mechanism for tracing long-running statements. For LOAD DATA command, SHOW PROCESSLIST can display process information, the first one is a status message like &ldquo;Inserted about 1000000 rows&rdquo;, the next one is a percentage of completion information, for example &quot; Loading of data about 45% done&quot;; When adding indexes, SHOW PROCESSLIST can show the process information of CREATE INDEX and ALTER TABLE, which will show the estimated number of rows, and also the percentage of completion; SHOW PROCESSLIST also shows the execution status of transactions, such as committing or aborting status.</p>
<p><strong>9. Migrating to TokuDB</strong></p>
<p>You can change the table storage engine in the traditional way, such as &ldquo;ALTER TABLE &hellip; ENGINE = TokuDB&rdquo; or mysqldump export and dump, INTO OUTFILE and LOAD DATA INFILE are also possible.</p>
<p><strong>10. Hot Standby</strong></p>
<p>Percona Xtrabackup does not yet support hot standby for TokuDB, <a href="http://www.percona.com/blog/2014/07/15/tokudb-tips-mysql-backups/">Percona has also indicated that it intends to support it</a>; for large tables you can <a href="https://launchpad.net/mylvmbackup">use the LVM feature</a>, or mysdumper. TokuDB officially provides a hot standby plugin [tokudb_backup.so](<a href="https://github.com/Tokutek/tokudb">https://github.com/Tokutek/tokudb</a> -backup-plugin), which allows online backups, but it relies on backup-enterprise and cannot compile so dynamic libraries, and is a commercial paid version, see <a href="https://www.percona.com/doc/percona-">TokuDB Installation</a> server/5.6/tokudb/tokudb_installation.html).</p>
<p><strong>Summary</strong></p>
<p>Advantages of TokuDB:</p>
<ul>
<li>High compression ratio, using zlib for compression by default, especially for string (varchar, text, etc.) type has a very high compression ratio, more suitable for storing logs, raw data, etc.. The official claim is that it can reach 1:12.</li>
<li>Add index online, does not affect the read and write operations</li>
<li>HCADER features, support online field addition, deletion, extension, renaming operations, (instant or second to complete)</li>
<li>Full ACID feature and transaction mechanism support</li>
<li>Very fast write performance, Fractal-tree has an advantage in transaction implementation, no undo log, officially at least 9 times higher than innodb.</li>
<li>Support show processlist progress view</li>
<li>Data volume can scale to several terabytes.</li>
<li>No index fragmentation.</li>
<li>Support hot column addition,hot indexing,mvcc</li>
</ul>
<p>TokuDB Disadvantages.</p>
<ul>
<li>Does not support foreign key (foreign key) function, if your table has a foreign key, this constraint will be ignored after switching to TokuDB engine.</li>
<li>TokuDB is not suitable for large number of read scenarios, because of compression and decompression, CPU usage will be 2-3 times higher, but because of the small space after compression, IO overhead is low, the average response time is about 2 times.</li>
<li>online ddl does not work for text, blob and other types of fields.</li>
<li>No perfect hot backup tool, only logical backup by mysqldump</li>
</ul>
<p>Applicable scenarios.</p>
<ul>
<li>Data that is not frequently accessed or historical data archiving</li>
<li>Data tables are very large and require DDL operations from time to time</li>
</ul>
<h2 id="tokudbs-index-structure-fractal-tree">TokuDB&rsquo;s Index Structure: Fractal Tree</h2>
<p>The biggest difference between TokuDB and InnoDB is that TokuDB uses an index structure called Fractal Tree, which makes it a great improvement in handling randomly written data. Currently both SQL Server and MySQL&rsquo;s innodb use B+Tree (SQL Server uses standard B-Tree) index structure. innoDB is a B+Tree structure organized by primary key, and data is ordered by primary key. The difference between Fractal Tree and B-Tree mainly lies in the internal nodes of index tree, the internal structure of B-Tree index only has The internal structure of B-Tree index only has pointers to parent and child nodes, while the internal nodes of Fractal Tree not only have pointers to parent and child nodes, but also have a Buffer area. When data is written, it will first fall into this Buffer area, which is a FIFO structure, and writing is a sequential process, just like other buffers, when it is full, data will be flushed at once. So inserting data on TokuDB basically becomes a sequential adding process.</p>
<p>Comparison of BTree and Fractal tree.</p>
<table>
<thead>
<tr>
<th>Structure</th>
<th>Inserts</th>
<th>Point Queries</th>
<th>Range Queries</th>
</tr>
</thead>
<tbody>
<tr>
<td>B-Tree</td>
<td>Horrible</td>
<td>Good</td>
<td>Good (young)</td>
</tr>
<tr>
<td>Append</td>
<td>Wonderful</td>
<td>Horrible</td>
<td>Horrible</td>
</tr>
<tr>
<td>Fractal Tree</td>
<td>Good</td>
<td>Good</td>
<td>Good</td>
</tr>
</tbody>
</table>
<h3 id="introduction-to-fractal-tree">Introduction to Fractal tree</h3>
<p>A fractal tree is a write-optimized disk index data structure. In general, the write performance of fractal tree (Insert/Update/Delete) is better, while it can ensure that the read performance of fractal tree is similar to that of B+ tree. According to Percona&rsquo;s test results, TokuDB fractal tree has better write performance than InnoDB&rsquo;s B+ tree), and slightly lower read performance than B+ tree.</p>
<p><strong>ft-index</strong> <strong>disk storage structure</strong></p>
<p>ft-index uses larger index pages and data pages (4M by default for ft-index, 16K by default for InnoDB), which makes the compression ratio of data pages and index pages higher for ft-index. In other words, with index page and data page compression on, ft-index takes less storage space when inserting the same amount of data. ft-index supports online modification of DDL (Hot Schema Change). In simple terms, users can still perform write operations while doing DDL operations (e.g. adding indexes), which is a feature naturally supported by ft-index tree structure. In addition, ft-index also supports transactions (ACID) and MVCC (Multiple Version Cocurrency Control) of transactions, and supports crash recovery. Because of the above features, Percona claims that TokuDB provides customers with significant performance improvements on the one hand, and reduces their storage costs on the other.</p>
<p>The index structure of ft-index is as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/11/20/a8610e6c7ecd43ee947edcdd1c486328.png" alt=""></p>
<p>The gray area indicates a page of the ft-index fractal tree, the green area indicates a key value, and between the two green areas indicates a son pointer. BlockNum indicates the offset of the page pointed by the son pointer, Fanout indicates the fanout of the fractal tree, i.e. the number of son pointers. NodeSize indicates the number of bytes occupied by a page. nonLeafNode indicates that the current page is a non-leaf node, LeafNode indicates that the current page is a leaf node, leaf node is the bottom node that stores Key-value key-value pairs, non-leaf node does not store value. Heigth indicates the height of the tree, the height of the root node is 3, the height of the node below the root node is 3, and the height of the node below the root node is 3. Depth denotes the depth of the tree, where the root node has depth 0 and the node next to the root node has depth 1.</p>
<p>The tree structure of a fractal tree is very similar to a B+ tree, which consists of several nodes (we call them Node or Block, in InnoDB, we call them Page or Page). Each node consists of an ordered set of keys. Suppose the key sequence of a node is [3, 8], then this key divides the whole interval (-00, +00) into 3 intervals (-00, 3), [3, 8), [8, +00), each of which corresponds to a son pointer (Child pointer). In a B+ tree, the Child pointer usually points to a page, while in a fractal tree, each Child pointer needs to point to a Node address (BlockNum) in addition to a Message Buffer (msg_buffer), which is a First-In-First-Out (FIFO) queue that is used to store the Insert/Disconnected messages. This Message Buffer is a FIFO queue used to hold update operations like Insert/Delete/Update/HotSchemaChange.</p>
<p>According to the ft-index source code implementation, a more rigorous description of the fractal tree in ft-index would be</p>
<ul>
<li>A node (block or node, in InnoDB we call it a Page or page) is composed of a set of ordered keys, with the first key set to a null key, indicating negative infinity.</li>
<li>There are two types of nodes, one is a leaf node and the other is a non-leaf node. A leaf node&rsquo;s son pointer points to a BasementNode, and a non-leaf node points to a normal Node. The BasementNode node stores multiple K-V key-value pairs, which means that all the final lookup operations need to locate the BasementNode in order to successfully retrieve the data (Value). This is also similar to the LeafPage of the B+ tree, where the data (Value) is stored in the leaf nodes and the non-leaf nodes are used to store the key values (Key) for indexing. When the leaf nodes are loaded into memory, in order to quickly find the data (Value) in the BasementNode, ft-index converts the key-value in the entire BasementNode into a weakly balanced binary tree, which has a funny name, called [scapegoat tree](https://en. wikipedia.org/wiki/Scapegoat_tree).</li>
<li>The key interval of each node corresponds to a Child Pointer. The son pointer of a non-leaf node carries a <a href="https://github.com/Tokutek/ft-index/blob/master/ft/msg_buffer.cc">MessageBuffer</a>, and the MessageBuffer is a FIFO queue. It is used to hold update operations like Insert/Delete/Update/HotSchemaChange. The son pointer as well as the MessageBuffer are serialized and stored in the Node&rsquo;s disk file.</li>
<li>The number of sons of each Non Leaf Node must be within the interval [fantout/4, fantout]. Here fantout is a parameter of the fractal tree (B+ tree also has this concept), which is mainly used to maintain the height of the tree. When the number of sons of a non-leaf node is less than fantout/4, the node is considered too empty and needs to be merged with other nodes to form a single node (Node Merge), which reduces the height of the tree. When the number of son pointers of a non-leaf node exceeds fantout, then we consider the node too full and need to split a node into two (Node Split). By controlling this constraint, we can theoretically maintain the disk data in a normal and relatively balanced tree structure, which can control the upper limit of insertion and query complexity.</li>
<li>Note: In ft-index implementation, the conditions to control the tree balance are more complicated, for example, in addition to considering the fantout, we also need to ensure that the total number of bytes of nodes is in the interval of [NodeSize/4, NodeSize], which is generally 4M, and when it is not in this interval, we need to do the corresponding Merge or Split operation.</li>
</ul>
<p><strong>Insert/Delete/Update Implementation of Fractal Trees</strong></p>
<p>We said that fractal tree is a write-optimized data structure, and its write performance is better than that of B+ tree. So how exactly does it achieve better write performance? First, by write performance, we mean random write operations. For a simple example, suppose we execute this SQL statement continuously in MySQL InnoDB table: insert into sbtest set x = uuid(), where there is a unique index field x in sbtest table. Due to the randomness of uuid(), the data inserted into sbtest table will be scattered in different leaf nodes (Leaf Node). In the B+ tree, a large number of such random write operations will result in a large number of hot data pages in the LRU-Cache falling in the upper level of the B+ tree (as shown in the figure below). This reduces the probability of the leaf nodes at the bottom hitting the Cache, resulting in a large number of disk IO operations, and thus a bottleneck in the random write performance of the B+ tree. However, the sequential write operation of the B+ tree is very fast because it makes full use of the local hotspots and the number of disk IO operations is greatly reduced.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/11/20/4762ad773b6848c38c0b34af3bf109d7.png" alt=""></p>
<p>Here is the flow of the fractal tree insertion operation. To facilitate the description later, the convention is as follows.</p>
<ul>
<li>Take Insert operation as an example, assuming that the inserted data is (Key, Value)</li>
<li>Only when the cache is not hit, ft-index will read the data page into memory by seed locating the offset.</li>
<li>Crash logging and transaction processing are not considered for now.</li>
</ul>
<p>The detailed flow is as follows.</p>
<ol>
<li>load the Root node.</li>
<li>determine whether the Root node needs to be split (or merged), and if the split (or merge) condition is met, split (or merge) the Root node. The specific process of splitting Root nodes, interested students can open their minds.</li>
<li>When Root node height&gt;0, i.e. Root is a non-leaf node, the key-value range where Key is located is found by dichotomous search, and (Key, Value) is wrapped into a message (Insert, Key, Value) and put into the Message of the Child pointer corresponding to the key-value range. Buffer. 4.</li>
<li>When Root node height=0, i.e. Root is a leaf node, the message (Insert, Key, Value) is applied to the BasementNode, i.e. inserted into the BasementNode.</li>
</ol>
<p>Here is a very strange place, in the case of a large number of insertions (including random and sequential insertions), the Root node will be regularly filled up, which will lead to a large number of splits in the Root node. Then, after the Root node does a lot of splitting, a lot of nodes with height=1 are created, and after the nodes with height=1 are full, a lot of nodes with height=2 are created, and finally the tree height gets higher and higher. The secret of the high performance of fractal tree write operations compared to B+ trees is hidden in this weirdness: each insertion operation lands on the Root node and returns immediately, and each write operation does not need to search the BasementNode at the bottom of the tree structure, which leads to a large amount of hot data concentrated in the upper layer of the Root node (the distribution of hot data is similar to the above figure), thus The localization of hot data is fully utilized, which greatly reduces disk IO operations.</p>
<p>The case of Update/Delete operation is similar to that of Insert operation, but the special point to note is that the random read performance of fractal tree is not as good as InnoDB&rsquo;s B+ tree. Therefore, the Update/Delete operation needs to be subdivided into two cases, and the performance difference between these two tests can be huge.</p>
<ul>
<li>Overwrite Update/Delete (overwrite). That is, when the key exists, Update/Delete is performed; when the key does not exist, no operation is done and no error is reported.</li>
<li>Strictly matching Update/Delete. When the key exists, update/delete is executed; when the key does not exist, an error is reported to the upper application. In this case, we need to check whether the key exists in the basementnode of ft-index first, so Point-Query silently drags the performance of Update/Delete operations backwards.</li>
</ul>
<p>In addition, ft-index does some optimizations for sequential insert operations in order to improve the performance of sequential writes, such as <a href="http://www.kancloud.cn/taobaomysql/monthly/67144">Sequential Write Acceleration</a>.</p>
<p><strong>Point-Query implementation of fractal tree</strong></p>
<p>In ft-index, a query like select from table where id = ? (where id is the index) is called a Point-Query; a query operation like select from table where id &gt;= ? and id &lt;= ? (where id is the index) is called Range-Query. As mentioned above, Point-Query read operations do not perform as well as InnoDB&rsquo;s B+ tree, so here is a detailed description of the Point-Query process. (The key value to be queried is assumed to be Key here)</p>
<ol>
<li>Load the Root node and determine the Range of the key value range of the Root node by dichotomous search, and find the Child pointer of the corresponding Range.</li>
<li>Load the node corresponding to the Child pointer. If the node is a non-leaf node, continue to search down the fractal tree until it stops at the leaf node. If the current node is a leaf node, then stop the search.</li>
</ol>
<p>After finding a leaf node, we do not directly return the Value of the BasementNode in the leaf node to the user. Because the insertion operation of fractal tree is inserted by way of Message, we need to apply all the messages on the path from Root node to leaf node to the BasementNode of leaf node in turn. After all the messages are applied, the value corresponding to the key in the BasementNode is the value that the user needs to find. The user needs to find the value.</p>
<p>The lookup process of fractal tree is basically similar to the lookup process of InnoDB&rsquo;s B+ tree, the difference is that the fractal tree needs to push down the messge buffer on the path from Root node to the leaf node and apply the message to the BasementNode. Note that the lookup process needs to push down the messages, which may cause some nodes on the path to be full, but ft-index does not split and merge the leaf nodes during the query process, because the design principle of ft-index is: Insert/Update/Delete operations are responsible for splitting and merging the nodes, Select operations are responsible for delaying the pushing down of the messages (the &ldquo;merge&rdquo; operation). is responsible for the Lazy Push of messages. In this way, the fractal tree applies Insert/Delete/Update operations to specific data nodes through future Select operations to complete the update.</p>
<p><strong>Range-Query implementation for fractal trees</strong></p>
<p>The following section describes the implementation of Range-Query. In simple terms, Range-Query for a fractal tree is basically equivalent to performing N Point-Query operations, and the cost of the operation is basically equivalent to the cost of N Point-Query operations. Since the fractal tree stores the update operation of the BasementNode in the msg_buffer of the non-leaf node, we need to look up the Value of each Key from the root node to the leaf node, and then apply the message on this path to the Value of the BasementNode. This process can be represented by the following diagram.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/11/20/7b894a9458f044b58cdb643749a9ca68.png" alt=""></p>
<p>However, in the B+ tree, the underlying leaf nodes are organized into a bidirectional chain table by pointers, as shown in the figure below. Therefore, we only need to locate the first Key that satisfies the condition from the heel node to the leaf node, and then iterate the next pointer at the leaf node to obtain all the Key-Value keys of the Range-Query. Therefore, for the B+ tree Range-Query operation, except for the first traversal from the root node to the leaf nodes to do random write operations, the subsequent data reads can basically be regarded as sequential IO.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/11/20/d769c0b4aa574e4385f6c1f47136b342.png" alt=""></p>
<p>By comparing the Range-Query implementation of the fractal tree and the B+ tree, we can see that the Range-Query query cost of the fractal tree is significantly higher than that of the B+ tree, because the fractal tree needs to traverse the entire subtree of the Root node covering Range, while the B+ tree only needs to Seed to the starting Key of Range once, and the subsequent iterations are basically equivalent to sequential IO.</p>
<p><strong>Summary</strong></p>
<p>Overall, fractal tree is a write optimized data structure, its core idea is to make full use of the MessageBuffer cache of nodes to update operations, and make full use of the data locality principle to convert random writes to sequential writes, which greatly improves the efficiency of random writes. iiBench test results of Tokutek R&amp;D team show that: the performance of TokuDB&rsquo;s insert operation (random write) is much faster than InnoDB, while the performance of Select operation (random read) is lower than InnoDB&rsquo;s performance, but the difference is smaller. This is the reason why Percona claims that TokuDB is higher performance and lower cost.</p>
<p>In addition, the online update table structure (Hot Schema Change) implementation is also based on MessageBuffer, but the difference with Insert/Delete/Update operation is that the former message push down is broadcast push down (a message from the parent node is applied to all son nodes), and the latter message push down is unicast push down (a message from the parent node is applied to the son nodes of the corresponding key value interval), because the implementation is similar to Insert operation, so I will not expand the description.</p>
<h2 id="multiple-version-concurrency-control-mvcc-for-tokudb">Multiple Version Concurrency Control (MVCC) for TokuDB</h2>
<p>In traditional relational databases (e.g. Oracle, MySQL, SQLServer), transactions are arguably the most central element of development and discussion. And the most core nature of transaction is ACID.</p>
<ul>
<li>A denotes atomicity, which means that all subtasks that make up a transaction have only two outcomes: either all subtasks are successfully executed as the transaction is committed, or all subtasks are undone as the transaction is rolled back.</li>
<li>C denotes consistency, which means that no matter the transaction commits or rolls back, it cannot break the consistency constraints on the data. These consistency constraints include key-value uniqueness constraints, key-value association relationship constraints, and so on.</li>
<li>I denotes isolation, isolation is generally for multiple concurrent transactions, that is, at the same point in time, t1 transaction and t2 transaction read data should be isolated, these two transactions are like into the same hotel two rooms, each in their own room inside the activity, they can not see each other what each is doing.</li>
<li>D means persistence, this nature ensures that once a transaction commits to the user successfully, then even if the succeeding database process crashes or the operating system crashes, as long as the disk data is not broken, then the execution result of the transaction can still be read after the next database start.</li>
</ul>
<p>TokuDB currently fully supports ACID for transactions. From the implementation point of view, since TokuDB uses <a href="http://openinx.github.io/2015/11/25/ft-index-implement/">fractal tree</a> as index, while InnoDB uses B+ tree as index structure, thus TokuDB is very different from InnoDB in the implementation of transactions.</p>
<p>In InnoDB, two kinds of logs are designed, redo and undo. redo stores the physical modification log of the page, which is used to ensure the persistence of the transaction; undo stores the logical modification log of the transaction, which actually stores multiple versions of a record under multiple concurrent transactions, and is used to realize the isolation of the transaction (MVCC) and rollback operation. Since TokuDB&rsquo;s fractal tree uses message passing to do add, delete, change and update operations, a message is a version of the record modified by the transaction, therefore, there is no additional concept and implementation of undo-log in the TokuDB source code implementation, instead, there is a management mechanism of multiple messages for a record. Although the multiple messages per record approach can achieve transaction MVCC, it cannot solve the problem of transaction rollback, so TokuDB has designed the additional tokudb.rollback log file to help achieve transaction rollback.</p>
<p>Here we mainly analyze the implementation of TokuDB&rsquo;s transaction isolation, which is often referred to as Multiple Version Concurrency Control (MVCC).</p>
<p><strong>TokuDB</strong> <strong>Transaction representation</strong></p>
<p>In tokudb, a transaction executed by a user is broken up into many smaller transactions at the storage engine level (such smaller transactions are denoted as txn). For example, a user executes a transaction such as</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">begin</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">insert</span><span class="w"> </span><span class="k">into</span><span class="w"> </span><span class="n">hello</span><span class="w"> </span><span class="k">set</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;1&#39;</span><span class="p">;</span><span class="w"> 
</span><span class="w"></span><span class="k">commit</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>The log in the redo-log corresponding to the TokuDB storage engine is</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="n">xbegin</span><span class="w">          </span><span class="s1">&#39;b&#39;</span><span class="p">:</span><span class="w"> </span><span class="n">lsn</span><span class="o">=</span><span class="mi">236599</span><span class="w"> </span><span class="n">xid</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span><span class="mi">0</span><span class="w"> </span><span class="n">parentxid</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="w"> </span><span class="n">crc</span><span class="o">=</span><span class="mi">29</span><span class="n">e4d0a1</span><span class="w"> </span><span class="n">len</span><span class="o">=</span><span class="mi">53</span><span class="w">
</span><span class="w"></span><span class="n">xbegin</span><span class="w">          </span><span class="s1">&#39;b&#39;</span><span class="p">:</span><span class="w"> </span><span class="n">lsn</span><span class="o">=</span><span class="mi">236600</span><span class="w"> </span><span class="n">xid</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span><span class="mi">1</span><span class="w"> </span><span class="n">parentxid</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span><span class="mi">0</span><span class="w"> </span><span class="n">crc</span><span class="o">=</span><span class="mi">282</span><span class="n">cb1a1</span><span class="w"> </span><span class="n">len</span><span class="o">=</span><span class="mi">53</span><span class="w">
</span><span class="w"></span><span class="n">enq_insert</span><span class="w">      </span><span class="s1">&#39;I&#39;</span><span class="p">:</span><span class="w"> </span><span class="n">lsn</span><span class="o">=</span><span class="mi">236601</span><span class="w"> </span><span class="n">filenum</span><span class="o">=</span><span class="mi">13</span><span class="w"> </span><span class="n">xid</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span><span class="mi">1</span><span class="w"> </span><span class="k">key</span><span class="o">=</span><span class="err">{</span><span class="p">...</span><span class="err">}</span><span class="w"> </span><span class="n">value</span><span class="o">=</span><span class="err">{</span><span class="p">...</span><span class="err">}</span><span class="w"> </span><span class="n">crc</span><span class="o">=</span><span class="n">a42128e5</span><span class="w"> </span><span class="n">len</span><span class="o">=</span><span class="mi">58</span><span class="w">
</span><span class="w"></span><span class="n">xcommit</span><span class="w">         </span><span class="s1">&#39;C&#39;</span><span class="p">:</span><span class="w"> </span><span class="n">lsn</span><span class="o">=</span><span class="mi">236602</span><span class="w"> </span><span class="n">xid</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span><span class="mi">1</span><span class="w"> </span><span class="n">crc</span><span class="o">=</span><span class="n">ec9bba3d</span><span class="w"> </span><span class="n">len</span><span class="o">=</span><span class="mi">37</span><span class="w">
</span><span class="w"></span><span class="n">xprepare</span><span class="w">        </span><span class="s1">&#39;P&#39;</span><span class="p">:</span><span class="w"> </span><span class="n">lsn</span><span class="o">=</span><span class="mi">236603</span><span class="w"> </span><span class="n">xid</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span><span class="mi">0</span><span class="w"> </span><span class="n">xa_xid</span><span class="o">=</span><span class="err">{</span><span class="p">...</span><span class="err">}</span><span class="w"> </span><span class="n">crc</span><span class="o">=</span><span class="n">db091de4</span><span class="w"> </span><span class="n">len</span><span class="o">=</span><span class="mi">67</span><span class="w">
</span><span class="w"></span><span class="n">xcommit</span><span class="w">         </span><span class="s1">&#39;C&#39;</span><span class="p">:</span><span class="w"> </span><span class="n">lsn</span><span class="o">=</span><span class="mi">236604</span><span class="w"> </span><span class="n">xid</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span><span class="mi">0</span><span class="w"> </span><span class="n">crc</span><span class="o">=</span><span class="n">ec997b3d</span><span class="w"> </span><span class="n">len</span><span class="o">=</span><span class="mi">37</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>The corresponding transaction tree is shown in the following figure.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/11/20/707b8127a992485c839cadf5b59857b6.png" alt=""></p>
<p>For a more complex example of a transaction with a savepoint.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">begin</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">insert</span><span class="w"> </span><span class="k">into</span><span class="w"> </span><span class="n">hello</span><span class="w"> </span><span class="k">set</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;2&#39;</span><span class="w"> </span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="n">savepoint</span><span class="w"> </span><span class="n">mark1</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">insert</span><span class="w"> </span><span class="k">into</span><span class="w"> </span><span class="n">hello</span><span class="w"> </span><span class="k">set</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;3&#39;</span><span class="w"> </span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="n">savepoint</span><span class="w"> </span><span class="n">mark2</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">commit</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>The corresponding redo-log records are</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="n">xbegin</span><span class="w">           </span><span class="s1">&#39;b&#39;</span><span class="p">:</span><span class="w"> </span><span class="n">lsn</span><span class="o">=</span><span class="mi">236669</span><span class="w"> </span><span class="n">xid</span><span class="o">=</span><span class="mi">17</span><span class="p">,</span><span class="mi">0</span><span class="w"> </span><span class="n">parentxid</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="w"> </span><span class="n">crc</span><span class="o">=</span><span class="n">c01888a6</span><span class="w"> </span><span class="n">len</span><span class="o">=</span><span class="mi">53</span><span class="w">
</span><span class="w"></span><span class="n">xbegin</span><span class="w">           </span><span class="s1">&#39;b&#39;</span><span class="p">:</span><span class="w"> </span><span class="n">lsn</span><span class="o">=</span><span class="mi">236670</span><span class="w"> </span><span class="n">xid</span><span class="o">=</span><span class="mi">17</span><span class="p">,</span><span class="mi">1</span><span class="w"> </span><span class="n">parentxid</span><span class="o">=</span><span class="mi">17</span><span class="p">,</span><span class="mi">0</span><span class="w"> </span><span class="n">crc</span><span class="o">=</span><span class="n">cf400ba6</span><span class="w"> </span><span class="n">len</span><span class="o">=</span><span class="mi">53</span><span class="w">
</span><span class="w"></span><span class="n">enq_insert</span><span class="w">       </span><span class="s1">&#39;I&#39;</span><span class="p">:</span><span class="w"> </span><span class="n">lsn</span><span class="o">=</span><span class="mi">236671</span><span class="w"> </span><span class="n">filenum</span><span class="o">=</span><span class="mi">13</span><span class="w"> </span><span class="n">xid</span><span class="o">=</span><span class="mi">17</span><span class="p">,</span><span class="mi">1</span><span class="w"> </span><span class="k">key</span><span class="o">=</span><span class="err">{</span><span class="p">...</span><span class="err">}</span><span class="w"> </span><span class="n">value</span><span class="o">=</span><span class="err">{</span><span class="p">...</span><span class="err">}</span><span class="w"> </span><span class="n">crc</span><span class="o">=</span><span class="mi">8</span><span class="n">ce371e3</span><span class="w"> </span><span class="n">len</span><span class="o">=</span><span class="mi">58</span><span class="w">
</span><span class="w"></span><span class="n">xcommit</span><span class="w">          </span><span class="s1">&#39;C&#39;</span><span class="p">:</span><span class="w"> </span><span class="n">lsn</span><span class="o">=</span><span class="mi">236672</span><span class="w"> </span><span class="n">xid</span><span class="o">=</span><span class="mi">17</span><span class="p">,</span><span class="mi">1</span><span class="w"> </span><span class="n">crc</span><span class="o">=</span><span class="n">ec4a923d</span><span class="w"> </span><span class="n">len</span><span class="o">=</span><span class="mi">37</span><span class="w">
</span><span class="w"></span><span class="n">xbegin</span><span class="w">           </span><span class="s1">&#39;b&#39;</span><span class="p">:</span><span class="w"> </span><span class="n">lsn</span><span class="o">=</span><span class="mi">236673</span><span class="w"> </span><span class="n">xid</span><span class="o">=</span><span class="mi">17</span><span class="p">,</span><span class="mi">2</span><span class="w"> </span><span class="n">parentxid</span><span class="o">=</span><span class="mi">17</span><span class="p">,</span><span class="mi">0</span><span class="w"> </span><span class="n">crc</span><span class="o">=</span><span class="n">cb7c6fa6</span><span class="w"> </span><span class="n">len</span><span class="o">=</span><span class="mi">53</span><span class="w">
</span><span class="w"></span><span class="n">xbegin</span><span class="w">           </span><span class="s1">&#39;b&#39;</span><span class="p">:</span><span class="w"> </span><span class="n">lsn</span><span class="o">=</span><span class="mi">236674</span><span class="w"> </span><span class="n">xid</span><span class="o">=</span><span class="mi">17</span><span class="p">,</span><span class="mi">3</span><span class="w"> </span><span class="n">parentxid</span><span class="o">=</span><span class="mi">17</span><span class="p">,</span><span class="mi">2</span><span class="w"> </span><span class="n">crc</span><span class="o">=</span><span class="n">c9a4c3a6</span><span class="w"> </span><span class="n">len</span><span class="o">=</span><span class="mi">53</span><span class="w">
</span><span class="w"></span><span class="n">enq_insert</span><span class="w">       </span><span class="s1">&#39;I&#39;</span><span class="p">:</span><span class="w"> </span><span class="n">lsn</span><span class="o">=</span><span class="mi">236675</span><span class="w"> </span><span class="n">filenum</span><span class="o">=</span><span class="mi">13</span><span class="w"> </span><span class="n">xid</span><span class="o">=</span><span class="mi">17</span><span class="p">,</span><span class="mi">3</span><span class="w"> </span><span class="k">key</span><span class="o">=</span><span class="err">{</span><span class="p">...</span><span class="err">}</span><span class="w"> </span><span class="n">value</span><span class="o">=</span><span class="err">{</span><span class="p">...</span><span class="err">}</span><span class="w"> </span><span class="n">crc</span><span class="o">=</span><span class="mi">641148</span><span class="n">e2</span><span class="w"> </span><span class="n">len</span><span class="o">=</span><span class="mi">58</span><span class="w">
</span><span class="w"></span><span class="n">xcommit</span><span class="w">          </span><span class="s1">&#39;C&#39;</span><span class="p">:</span><span class="w"> </span><span class="n">lsn</span><span class="o">=</span><span class="mi">236676</span><span class="w"> </span><span class="n">xid</span><span class="o">=</span><span class="mi">17</span><span class="p">,</span><span class="mi">3</span><span class="w"> </span><span class="n">crc</span><span class="o">=</span><span class="n">ec4e143d</span><span class="w"> </span><span class="n">len</span><span class="o">=</span><span class="mi">37</span><span class="w">
</span><span class="w"></span><span class="n">xcommit</span><span class="w">          </span><span class="s1">&#39;C&#39;</span><span class="p">:</span><span class="w"> </span><span class="n">lsn</span><span class="o">=</span><span class="mi">236677</span><span class="w"> </span><span class="n">xid</span><span class="o">=</span><span class="mi">17</span><span class="p">,</span><span class="mi">2</span><span class="w"> </span><span class="n">crc</span><span class="o">=</span><span class="n">ec4cf43d</span><span class="w"> </span><span class="n">len</span><span class="o">=</span><span class="mi">37</span><span class="w">
</span><span class="w"></span><span class="n">xprepare</span><span class="w">         </span><span class="s1">&#39;P&#39;</span><span class="p">:</span><span class="w"> </span><span class="n">lsn</span><span class="o">=</span><span class="mi">236678</span><span class="w"> </span><span class="n">xid</span><span class="o">=</span><span class="mi">17</span><span class="p">,</span><span class="mi">0</span><span class="w"> </span><span class="n">xa_xid</span><span class="o">=</span><span class="err">{</span><span class="p">...</span><span class="err">}</span><span class="w"> </span><span class="n">crc</span><span class="o">=</span><span class="mi">76</span><span class="n">e302b4</span><span class="w"> </span><span class="n">len</span><span class="o">=</span><span class="mi">67</span><span class="w">
</span><span class="w"></span><span class="n">xcommit</span><span class="w">          </span><span class="s1">&#39;C&#39;</span><span class="p">:</span><span class="w"> </span><span class="n">lsn</span><span class="o">=</span><span class="mi">236679</span><span class="w"> </span><span class="n">xid</span><span class="o">=</span><span class="mi">17</span><span class="p">,</span><span class="mi">0</span><span class="w"> </span><span class="n">crc</span><span class="o">=</span><span class="n">ec42b43d</span><span class="w"> </span><span class="n">len</span><span class="o">=</span><span class="mi">37</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>This transaction forms a transaction tree as follows:</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/11/20/182a6aa72c9e40b8b1995151bcb95c72.png" alt=""></p>
<p>In tokudb, a binary group like {parent_id, child_id} is used to record the dependencies of a txn and other txn. This way, a set of numbers from the root transaction to the leaf points can uniquely identify a txn, and this list of numbers is called xids, which I think can also be called transaction numbers. For example, xids for txn3 = {17, 2, 3 } , xids for txn2 = {17, 2}, xids for txn1 = {17, 1}, and xids for txn0 = {17, 0}.</p>
<p>So for each operation in a transaction (xbegin/xcommit/enq_insert/xprepare), there is an xids to identify the transaction number where this operation is located. Each message (insert/delete/update message) in TokuDB carries such an xids transaction number. This xids transaction number plays a very important role in the TokuDB implementation, and the functionality associated with it is particularly complex.</p>
<p><strong>Transaction Manager</strong></p>
<p>The Transaction Manager is used to manage the set of all transactions for the TokuDB storage engine.</p>
<ul>
<li>Active transaction list. The list of active transactions only records the root transaction, because the root transaction is actually the basis for finding all child transactions of the entire transaction tree. This transaction list holds all the root transactions that have started at this point in time but have not yet ended.</li>
<li>The list of snapshot read transactions.</li>
<li>A list of references to active transactions (referred_xids). This concept is not easy to understand. Suppose an active transaction starts (xbegin) at the time of begin_id and commits (xcommit) at the time of end_id. then referenced_xids is a binary that maintains (begin_id, end_id). the use of this binary is to find all active transactions of a transaction&rsquo;s The use of this binary is to find all active transactions in the entire life cycle of a transaction, which is mainly used to do the full gc operation mentioned later.</li>
</ul>
<p><strong>Fractal tree LeafEntry</strong></p>
<p>As mentioned above in the tree structure of the fractal tree, when doing operations like insert/delete/update, all messages from root to leaf are applied to the LeafNode node. In order to describe the apply process in detail later, we first introduce the storage structure of LeafNode.</p>
<p>A leafNode simply consists of multiple leafEntry, each leafEntry is a key-value pair {k, v1, v2, &hellip; }, where v1, v2 &hellip; denote multiple versions of a value corresponding to a key. The structure of a key corresponding to a leafEntry is detailed in the following figure.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/11/20/f4557e01156b442984d45fe3e9e07d76.png" alt=""></p>
<p>From the above figure, a leafEntry is actually a stack, and the bottom of the stack [0~5] represents the value of the transaction that has been committed (commited transaction). The top of the stack [6~9] represents the active transaction (uncommited transaction) that has not yet been committed. The single element in the stack is a quadruplet of (txid, type, len, data), which indicates the value of the transaction. More generally, the stack of [0, cxrs-1] represents committed transactions, which should not exist on the stack, but exist because other transactions refer to them by snapshot read. -1] of this stack will not be reclaimed unless all transactions referencing [0, cxrs-1] are committed. The [cxrs, cxrs+pxrs-1] segment of the stack represents the list of currently active uncommitted transactions. When this segment commits, cxrs will move backwards and eventually to the top of the stack.</p>
<p><strong>MVCC</strong> <strong>Implementation</strong></p>
<ol>
<li>Write operations</li>
</ol>
<p>Here we consider three types of write operations, insert / delete / commit. For the two types of write operations, insert and delete, you only need to place an element at the top of the stack of LeafEntry. The following figure shows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/11/20/4895a3eb67944aa4831eb5106ebfe586.png" alt=""></p>
<p>For commit operation, just put the top element of the stack of LeafEntry at the pointer cxrs, and then shrink the top pointer of the stack. The following figure shows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/11/20/2cfd9098ef4d4658bc7bdb99abb317d1.png" alt=""></p>
<ol start="2">
<li>Read Operations</li>
</ol>
<p>MySQL InnoDB supports Read UnCommitted (RU), Read REPEATABLE (RR), Read Commited (RC), SERIALIZABLE (S). Among them, RU has dirty reads (dirty reads refer to reading uncommitted transactions), RC/RR/RU have phantom reads (phantom reads generally refer to a transaction may update records that have already been committed by other transactions when updating).</p>
<p>TokuDB also supports the above 4 isolation levels, in the source code implementation, ft-index divides the transaction read operations into 3 categories according to the transaction isolation level:</p>
<ul>
<li>TXN_SNAPSHOT_NONE : This category does not require snapshot read, SERIALIZABLE and Read Uncommited belong to this category.</li>
<li>TXN_SNAPSHOT_ROOT : The Read REPEATABLE isolation level belongs to this category. In this case, it means that the transaction only needs to read records that have been committed before the xid corresponding to the root transaction.</li>
<li>TXN_SNAPSHOT_CHILD: READ COMMITTED belongs to this category. In this case, the son transaction A needs to find the snapshot read version according to the xid of its own transaction, because when this transaction A is opened, there may be other transaction B did the update and committed, then transaction A must read the result after the update of B.</li>
</ul>
<p><strong>Multi-version record recycling</strong></p>
<p>As time goes by, more and more old transactions are committed and new transactions start to execute. The number of commited transactions in the LeafNode in the fractal tree will increase, and if we don&rsquo;t find a way to clean up these expired transaction records, it will cause the BasementNode nodes to occupy a lot of space, and also cause the TokuDB data files to store a lot of useless data. In TokuDB, the operation of cleaning up these expired transactions is called Garbage Collection. In fact, InnoDB also has such a process as recycling expired transactions, multiple versions of InnoDB&rsquo;s Value of the same Key are stored on the undo log page, when the transaction expires, there is a purge thread in the background dedicated to complex cleanup of these expired transactions, thus freeing up the undo log page for later transactions. This can control the infinite growth of undo log.</p>
<p>TokuDB storage engine does not have a purge thread similar to InnoDB to clean up the expired transactions, because the expired transactions are cleaned up by GC during the update operation. In other words, when Insert/Delete/Update operations are executed, it will determine whether the current LeafEntry satisfies the GC condition, and if it does, it will delete the expired transactions in the LeafEntry and reorganize the memory space of the LeafEntry. According to the TokuDB source code implementation, there are two types of GCs.</p>
<ul>
<li>Simple GC: Every time a message is applied to a LeafEntry, it carries a gc_info, which contains the oldest_referenced_xid field. So what is the meaning of simple_gc? simple_gc is to do a simple GC, directly clean up the list of commited transactions (remember to leave a commited transaction record, otherwise how to find this commited record next time? ). This is simple_gc, simple, violent and efficient.</li>
<li>Full GC: The trigger conditions and gc process of full gc are more complicated, but the basic intention is to clean up the expired committed transactions. Here is not to expand.</li>
</ul>
<p><strong>Summary</strong></p>
<p>This article introduces the isolation principle of TokuDB transactions, including the transaction representation of TokuDB, the structure of LeafEntry of fractal tree, the implementation process of MVCC, and the multi-version record recovery method. TokuDB does not have undo log because the update message in the fractal tree itself records the version of the transaction record. In addition, TokuDB does not need to open a background thread to recycle expired transactions asynchronously as InnoDB does, but only during the execution of update operations. In short, since TokuDB implements transactions on top of fractal tree, there are big differences in all aspects of thinking, which is the innovation of TokuDB team, I think.</p>
<p>Reference.</p>
<ul>
<li><a href="http://openinx.github.io/2015/12/13/ft-mvcc/">TokuDB&rsquo;s Multi-Version Concurrency Control (MVCC)</a></li>
<li><a href="http://openinx.github.io/2015/11/25/ft-index-implement/">TokuDB&rsquo;s Index Structure - Implementation of Fractal Tree</a></li>
</ul>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/mysql/">mysql</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2021-11/storing-trees-in-rdbms/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Tree structured data database storage solution</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2021-11/swig-python/">
            <span class="next-text nav-default">SWIG implementation of Python calls C/C&#43;&#43; code</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
