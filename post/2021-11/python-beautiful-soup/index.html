<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>HTML parsing and extraction tool Beautiful Soup - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Beautiful Soup is a Python library that can extract data from HTML or XML files. Simply put, it can parse HTML tag files into a tree structure and then easily get the corresponding attributes of the specified tags. This feature is similar to lxml. Beautiful Soup installation Beautiful Soup 3 is currently out of development and it is recommended to use Beautiful Soup 4 in your current projects, installed by" /><meta name="keywords" content="Python, Beautiful Soup" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2021-11/python-beautiful-soup/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="HTML parsing and extraction tool Beautiful Soup" />
<meta property="og:description" content="Beautiful Soup is a Python library that can extract data from HTML or XML files. Simply put, it can parse HTML tag files into a tree structure and then easily get the corresponding attributes of the specified tags. This feature is similar to lxml. Beautiful Soup installation Beautiful Soup 3 is currently out of development and it is recommended to use Beautiful Soup 4 in your current projects, installed by" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2021-11/python-beautiful-soup/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-11-16T22:14:48+08:00" />
<meta property="article:modified_time" content="2021-11-16T22:14:48+08:00" />

<meta itemprop="name" content="HTML parsing and extraction tool Beautiful Soup">
<meta itemprop="description" content="Beautiful Soup is a Python library that can extract data from HTML or XML files. Simply put, it can parse HTML tag files into a tree structure and then easily get the corresponding attributes of the specified tags. This feature is similar to lxml. Beautiful Soup installation Beautiful Soup 3 is currently out of development and it is recommended to use Beautiful Soup 4 in your current projects, installed by"><meta itemprop="datePublished" content="2021-11-16T22:14:48+08:00" />
<meta itemprop="dateModified" content="2021-11-16T22:14:48+08:00" />
<meta itemprop="wordCount" content="3358">
<meta itemprop="keywords" content="python," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="HTML parsing and extraction tool Beautiful Soup"/>
<meta name="twitter:description" content="Beautiful Soup is a Python library that can extract data from HTML or XML files. Simply put, it can parse HTML tag files into a tree structure and then easily get the corresponding attributes of the specified tags. This feature is similar to lxml. Beautiful Soup installation Beautiful Soup 3 is currently out of development and it is recommended to use Beautiful Soup 4 in your current projects, installed by"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">HTML parsing and extraction tool Beautiful Soup</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-11-16 22:14:48 </span>
        <div class="post-category">
            <a href="/categories/skills/"> skills </a>
            </div>
          <span class="more-meta"> 3358 words </span>
          <span class="more-meta"> 7 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#beautiful-soup-installation">Beautiful Soup installation</a>
          <ul>
            <li><a href="#beautiful-soups-parsers">Beautiful Soup&rsquo;s parsers</a></li>
          </ul>
        </li>
        <li><a href="#use-of-beautiful-soup">Use of Beautiful Soup</a>
          <ul>
            <li><a href="#creating-beautiful-soup-objects">Creating Beautiful Soup objects</a></li>
            <li><a href="#traversing-the-document-tree">Traversing the document tree</a></li>
            <li><a href="#search-the-document-tree">search the document tree</a></li>
          </ul>
        </li>
        <li><a href="#css-selector">CSS selector</a>
          <ul>
            <li><a href="#find-by-tag-name"><strong>Find by tag name</strong></a></li>
            <li><a href="#find-by-class-name"><strong>Find by class name</strong></a></li>
            <li><a href="#find-by-id-name"><strong>Find by id name</strong></a></li>
            <li><a href="#combination-search"><strong>combination search</strong></a></li>
            <li><a href="#attribute-lookup"><strong>attribute lookup</strong></a></li>
          </ul>
        </li>
        <li><a href="#encoding-issues">Encoding issues</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>Beautiful Soup is a Python library that can extract data from HTML or XML files. Simply put, it can parse HTML tag files into a tree structure and then easily get the corresponding attributes of the specified tags. This feature is similar to lxml.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/11/16/b385f290b1714981bfa1df0bcdd4b548.png" alt=""></p>
<h2 id="beautiful-soup-installation">Beautiful Soup installation</h2>
<p>Beautiful Soup 3 is currently out of development and it is recommended to use Beautiful Soup 4 in your current projects, installed by</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="n">pip</span> <span class="n">install</span> <span class="n">beautifulsoup4</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="beautiful-soups-parsers">Beautiful Soup&rsquo;s parsers</h3>
<p>If you just want to parse an HTML document, just create a BeautifulSoup object with the document. Beautiful Soup automatically chooses a parser to parse the document, but you can also specify which parser to use with parameters. The first parameter to BeautifulSoup should be the document string or file handle to be parsed, and the second parameter should identify how to parse the document. If the second parameter is empty, Beautiful Soup automatically selects a parser based on the libraries currently installed on the system, in the following order of preference: lxml, html5lib, Python standard library.</p>
<p>The parser priority will change under the following two conditions.</p>
<ul>
<li>What type of document to parse: currently supports &ldquo;html&rdquo;, &ldquo;xml&rdquo;, and &ldquo;html5&rdquo;</li>
<li>Which parser to use: currently &ldquo;lxml&rdquo;, &ldquo;html5lib&rdquo;, and &ldquo;parser&rdquo; are supported.</li>
</ul>
<p>If the specified parser is not installed Beautiful Soup will automatically choose another option. Currently only the lxml parser supports parsing XML documents, so creating beautifulsoup objects without the lxml library installed will not result in parsed objects regardless of whether lxml is specified.</p>
<p>To install the parser.</p>
<ul>
<li>lxml, Windows installation may cause problems</li>
<li>html5lib Directly execute: <code>pip install html5lib</code></li>
</ul>
<p>Here it is recommended to use lxml as parser because it is more efficient.</p>
<h2 id="use-of-beautiful-soup">Use of Beautiful Soup</h2>
<h3 id="creating-beautiful-soup-objects">Creating Beautiful Soup objects</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="c1"># -*- coding: utf-8 -*-</span>

<span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">BeautifulSoup</span>
<span class="kn">import</span> <span class="nn">requests</span>

<span class="n">url</span> <span class="o">=</span> <span class="s1">&#39;https://www.biaodianfu.com&#39;</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">content</span><span class="p">,</span> <span class="s1">&#39;html.parser&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">soup</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>The second parameter of the BeautifulSoup constructor is the document parser, if this parameter is not passed, BeautifulSoup will choose the most appropriate parser to parse the document on its own, but there will be a warning prompt. It can also be initialized by a file handle, which can be used to save the HTML source code to the local sibling directory reo.html, and then the file name as a parameter.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s1">&#39;test.html&#39;</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>Beautiful Soup will be a complex HTML document into a complex tree structure, each node is a Python object, all objects can be grouped into four kinds.</p>
<p><strong>Tag</strong></p>
<p>What is a Tag? In layman&rsquo;s terms, it&rsquo;s a tag in HTML. Here&rsquo;s how to use Beautiful Soup to easily get Tags.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">title</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">h1</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>We can easily get the content of these tags using soup plus the tag name, but one thing is that it looks for the first tag that matches in all the content, if we want to query all the tags, we will introduce it later.</p>
<p>For Tag, it has two important properties, which are name and attrs.</p>
<ul>
<li>name: The soup object itself is special in that its name is [document], and for other internal tags, the output value is then the name of the tag itself.</li>
<li>attrs: A Tag object can have more than one attribute, the operation method is the same as a dictionary, the attribute contains key and value, you can also get the information of value.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;class&#39;</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;class&#39;</span><span class="p">))</span> <span class="c1">#等价print(soup.p[&#39;class&#39;])</span>
</code></pre></td></tr></table>
</div>
</div><p>The attributes of tag can be added, deleted (del soup.b[&lsquo;class&rsquo;]) and modified, same as the dictionary method. If an attribute key corresponds to more than one value, a list of values is returned.</p>
<p><strong>NavigableString</strong></p>
<p>Now that we have got the content of the tag, the question arises, what if we want to get the text inside the tag? It&rsquo;s simple, just use .string, the string in the Tag is the NavigableString object.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Use this type outside of BeautifulSoup, conversion to Unicode is recommended: unicode(Tag.string). tag can contain other tags or strings, while NavigableString cannot contain other objects. No support for .content, .string, find(), only partial support for traversing the document tree and searching for properties in the document tree.</p>
<p><strong>Comment</strong></p>
<p>Comment object is a special type of NavigableString object, in fact, the output still does not include comment symbols, but if we do not handle it properly, it may cause unexpected trouble for our text processing.</p>
<p>Let&rsquo;s find a tag with a comment</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">a</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">string</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>The results of the run are as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="nt">&lt;a</span> <span class="na">class=</span><span class="s">&#34;sister&#34;</span> <span class="na">href=</span><span class="s">&#34;http://example.com/elsie&#34;</span> <span class="na">id=</span><span class="s">&#34;link1&#34;</span><span class="nt">&gt;</span><span class="c">&lt;!-- Elsie --&gt;</span><span class="nt">&lt;/a&gt;</span>
 Elsie
<span class="nt">&lt;class</span> <span class="err">&#39;bs4.element.Comment&#39;</span><span class="nt">&gt;</span>
</code></pre></td></tr></table>
</div>
</div><p>The content of the a tag is actually a comment, but if we use .string to output its content, we find that it has removed the comment symbol, so this may bring us unnecessary trouble.</p>
<p>In addition, we print out its type and find that it is a Comment type, so we&rsquo;d better make a judgment before using it, the judgment code is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">string</span><span class="p">)</span> <span class="o">==</span> <span class="n">bs4</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">Comment</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>In the code above, we first determine its type, whether it is the Comment type, and then perform other operations such as printing the output.</p>
<h3 id="traversing-the-document-tree">Traversing the document tree</h3>
<p>BeautifulSoup object as a tree, there are multiple nodes. For a node, relative to where it is located, there are child nodes, parent nodes, and sibling nodes.</p>
<h4 id="child-nodes"><strong>child nodes</strong></h4>
<p>A Tag can contain multiple Tags as well as Strings, which are all child nodes of that Tag. And NavigableString will not have child nodes.</p>
<p><strong>Direct child nodes</strong></p>
<p>The .content attribute of a .content tag can output the tag&rsquo;s child nodes as a list: the</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">contents</span><span class="p">)</span>
<span class="c1">#[&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;]</span>
</code></pre></td></tr></table>
</div>
</div><p>.children It does not return a list, but we can get all the children by iterating over them.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
<span class="c1">#&lt;listiterator object at 0x7f71457f5710&gt;</span>
<span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>If you want to get a certain Tag, the above mentioned methods have been mentioned.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="n">soup</span><span class="o">.</span><span class="n">tag_name</span>
</code></pre></td></tr></table>
</div>
</div><p>By pointing to the attribute, you can only get the first tag of the current name, to get all, you need to use the method in the search document tree:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s1">&#39;tag_name&#39;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>The tag&rsquo;s .contents property outputs all child nodes as a list. The tag&rsquo;s .children generator can be used to iterate over all child nodes. .contents and .children are only useful for getting the direct children of a tag, .descendants can be used to iterate over all the children of a tag.</p>
<p>If tag has only one child node of type NavigableString, use .string to get it. If it contains more than one, use .strings to traverse it. If the output string contains spaces or blank lines, use .stripped_strings to remove them.</p>
<p><strong>All children nodes</strong></p>
<p>The .contents and .children properties contain only the direct children of the tag, while the .descendants property recursively loops over all the children of the tag, and similar to children, we need to iterate through them to get their contents.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">descendants</span><span class="p">:</span>
    <span class="nb">print</span> <span class="n">child</span>
</code></pre></td></tr></table>
</div>
</div><p>If the tag has only one child of type NavigableString, then the tag can use .string to get the child node. If a tag has only one child node, then the tag can also use the .string method, and the output will be the same as the .string result of the current unique child node.</p>
<p>In layman&rsquo;s terms, if there is no tag inside a tag, then .string will return the contents of the tag. If there is only one tag inside the tag, then .string will also return the innermost content. For example</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>
<span class="c1">#The Dormouse&#39;s story</span>
<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">title</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>
<span class="c1">#The Dormouse&#39;s story</span>
</code></pre></td></tr></table>
</div>
</div><p>If the tag contains more than one child, the tag cannot determine which child should be called by the string method, and the output of .string is None.</p>
<p>to get more than one content, but you need to iterate through them, as in the following example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="k">for</span> <span class="n">string</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">strings</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">string</span><span class="p">))</span>
    <span class="c1"># u&#34;The Dormouse&#39;s story&#34;</span>
    <span class="c1"># u&#39;\n\n&#39;</span>
    <span class="c1"># u&#34;The Dormouse&#39;s story&#34;</span>
    <span class="c1"># u&#39;\n\n&#39;</span>
    <span class="c1"># u&#39;Once upon a time there were three little sisters; and their names were\n&#39;</span>
    <span class="c1"># u&#39;Elsie&#39;</span>
    <span class="c1"># u&#39;,\n&#39;</span>
    <span class="c1"># u&#39;Lacie&#39;</span>
    <span class="c1"># u&#39; and\n&#39;</span>
    <span class="c1"># u&#39;Tillie&#39;</span>
    <span class="c1"># u&#39;;\nand they lived at the bottom of a well.&#39;</span>
    <span class="c1"># u&#39;\n\n&#39;</span>
    <span class="c1"># u&#39;...&#39;</span>
    <span class="c1"># u&#39;\n&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p>.stripped_strings, the output string may contain many spaces or blank lines, use .stripped_strings to remove the extra whitespace.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="k">for</span> <span class="n">string</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">stripped_strings</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">string</span><span class="p">))</span>
    <span class="c1"># u&#34;The Dormouse&#39;s story&#34;</span>
    <span class="c1"># u&#34;The Dormouse&#39;s story&#34;</span>
    <span class="c1"># u&#39;Once upon a time there were three little sisters; and their names were&#39;</span>
    <span class="c1"># u&#39;Elsie&#39;</span>
    <span class="c1"># u&#39;,&#39;</span>
    <span class="c1"># u&#39;Lacie&#39;</span>
    <span class="c1"># u&#39;and&#39;</span>
    <span class="c1"># u&#39;Tillie&#39;</span>
    <span class="c1"># u&#39;;\nand they lived at the bottom of a well.&#39;</span>
    <span class="c1"># u&#39;...&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>parent node</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="n">p</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">p</span>
<span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="c1">#body</span>

<span class="n">content</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">title</span><span class="o">.</span><span class="n">string</span>
<span class="nb">print</span><span class="p">(</span><span class="n">content</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="c1">#title</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>All Parent Nodes</strong></p>
<p>All parent nodes of an element can be obtained recursively through the .parents attribute of the element, for example</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="n">content</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">title</span><span class="o">.</span><span class="n">string</span>
<span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">content</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">parent</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Return data.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="n">title</span>
<span class="n">head</span>
<span class="n">html</span>
<span class="p">[</span><span class="n">document</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>sibling node</strong></p>
<p>The .next_sibling attribute gets the next sibling of the node, while .previous_sibling returns None if the node does not exist.</p>
<p>Note: The .next_sibling and .previous_sibling attributes of the tag in the actual document are usually strings or whitespace, since a whitespace or newline can also be treated as a node, so the result may be a whitespace or newline.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">next_sibling</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">prev_sibling</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">next_sibling</span><span class="o">.</span><span class="n">next_sibling</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Return data.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="n">title</span>
<span class="n">head</span>
<span class="n">html</span>
<span class="p">[</span><span class="n">document</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>sibling node</strong></p>
<p>The .next_sibling attribute gets the next sibling of the node, while .previous_sibling returns None if the node does not exist.</p>
<p>Note: The .next_sibling and .previous_sibling attributes of the tag in the actual document are usually strings or whitespace, since a whitespace or newline can also be treated as a node, so the result may be a whitespace or newline.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">next_sibling</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">prev_sibling</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">next_sibling</span><span class="o">.</span><span class="n">next_sibling</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>All Siblings</strong></p>
<p>The .next_siblings and .previous_siblings attributes allow iterative output of the current node&rsquo;s siblings.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="k">for</span> <span class="n">sibling</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">next_siblings</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">sibling</span><span class="p">))</span>
    <span class="c1"># u&#39;,\n&#39;</span>
    <span class="c1"># &lt;a class=&#34;sister&#34; href=&#34;http://example.com/lacie&#34; id=&#34;link2&#34;&gt;Lacie&lt;/a&gt;</span>
    <span class="c1"># u&#39; and\n&#39;</span>
    <span class="c1"># &lt;a class=&#34;sister&#34; href=&#34;http://example.com/tillie&#34; id=&#34;link3&#34;&gt;Tillie&lt;/a&gt;</span>
    <span class="c1"># u&#39;; and they lived at the bottom of a well.&#39;</span>
    <span class="c1"># None</span>
</code></pre></td></tr></table>
</div>
</div><p>The .next_element .previous_element attribute differs from .next_sibling .previous_sibling in that it is not specific to sibling nodes, but in all nodes, regardless of hierarchy.</p>
<p><strong>all preceding and following nodes</strong></p>
<p>The .next_elements and .previous_elements iterators make it possible to access the parsed content of a document forward or backward, as if the document were being parsed.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">last_a_tag</span><span class="o">.</span><span class="n">next_elements</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">element</span><span class="p">))</span>
<span class="c1"># u&#39;Tillie&#39;</span>
<span class="c1"># u&#39;;\nand they lived at the bottom of a well.&#39;</span>
<span class="c1"># u&#39;\n\n&#39;</span>
<span class="c1"># &lt;p class=&#34;story&#34;&gt;...&lt;/p&gt;</span>
<span class="c1"># u&#39;...&#39;</span>
<span class="c1"># u&#39;\n&#39;</span>
<span class="c1"># None</span>
</code></pre></td></tr></table>
</div>
</div><p>The above is the basic usage of traversing the document tree.</p>
<h3 id="search-the-document-tree">search the document tree</h3>
<h4 id="find_all-name--attrs--recursive--text--kwargs-">**find_all( name , attrs , recursive , text , <strong>kwargs )</strong></h4>
<p>find_all() method searches all tag children nodes of the current tag and determines if the conditions of the filter are met.</p>
<p><strong>name argument</strong></p>
<p>It can find all the tag with the name name, string objects will be ignored automatically.</p>
<p>A. Pass string</p>
<p>The simplest filter is a string. Passing a string parameter to the search method Beautiful Soup will find a complete match to the string, the following example is used to find all <code>&lt;b&gt;</code> tags in the document.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>B. Passing regular expressions</p>
<p>If you pass a regular expression as a parameter Beautiful Soup will match the content by the match() of the regular expression. The following example finds all tags starting with b, which means that both <code>&lt;body&gt;</code> and <code>&lt;b&gt;</code> tags should be found.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="kn">import</span> <span class="nn">re</span>
<span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&#34;^b&#34;</span><span class="p">)):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="c1"># body</span>
<span class="c1"># b</span>
</code></pre></td></tr></table>
</div>
</div><p>C. Passing a list</p>
<p>If you pass in the list parameter Beautiful Soup will return the content that matches any element in the list. The following code finds all <code>&lt;a&gt;</code> tags and <code>&lt;b&gt;</code> tags in the document.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">([</span><span class="s2">&#34;a&#34;</span><span class="p">,</span> <span class="s2">&#34;b&#34;</span><span class="p">])</span>
</code></pre></td></tr></table>
</div>
</div><p>D. Pass True</p>
<p>True can match any value, the following code finds all the tags but does not return the string node</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="kc">True</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>E. Passing a method</p>
<p>If there is no appropriate filter, then you can also define a method that accepts only one element parameter and returns True if the current element matches and is found, or False if it is not.</p>
<p>The following method checks the current element and returns True if it contains the class attribute but not the id attribute.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="k">def</span> <span class="nf">has_class_but_no_id</span><span class="p">(</span><span class="n">tag</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">tag</span><span class="o">.</span><span class="n">has_attr</span><span class="p">(</span><span class="s1">&#39;class&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">tag</span><span class="o">.</span><span class="n">has_attr</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Passing this method as an argument to the find_all() method will get all <code>&lt;p&gt;</code> tags:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">has_class_but_no_id</span><span class="p">)</span>
<span class="c1"># [&lt;p class=&#34;title&#34;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt;,</span>
<span class="c1">#  &lt;p class=&#34;story&#34;&gt;Once upon a time there were...&lt;/p&gt;,</span>
<span class="c1">#  &lt;p class=&#34;story&#34;&gt;...&lt;/p&gt;]</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>keyword parameter</strong></p>
<p>Note: If a parameter with a specified name is not a built-in parameter name, the search will treat the parameter as an attribute of the specified name tag to search.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s1">&#39;link2&#39;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&#34;sister&#34; href=&#34;http://example.com/lacie&#34; id=&#34;link2&#34;&gt;Lacie&lt;/a&gt;]</span>
</code></pre></td></tr></table>
</div>
</div><p>If the href parameter is passed, Beautiful Soup will search for the &ldquo;href&rdquo; attribute of each tag.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">href</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&#34;elsie&#34;</span><span class="p">))</span>
<span class="c1"># [&lt;a class=&#34;sister&#34; href=&#34;http://example.com/elsie&#34; id=&#34;link1&#34;&gt;Elsie&lt;/a&gt;]</span>
</code></pre></td></tr></table>
</div>
</div><p>Multiple attributes of a tag can be filtered at the same time using multiple parameters with specified names.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">href</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&#34;elsie&#34;</span><span class="p">),</span> <span class="nb">id</span><span class="o">=</span><span class="s1">&#39;link1&#39;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&#34;sister&#34; href=&#34;http://example.com/elsie&#34; id=&#34;link1&#34;&gt;three&lt;/a&gt;]</span>
</code></pre></td></tr></table>
</div>
</div><p>Here we want to filter by class, but class is a python keyword, so what do we do? Just add an underscore</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&#34;a&#34;</span><span class="p">,</span> <span class="n">class_</span><span class="o">=</span><span class="s2">&#34;sister&#34;</span><span class="p">)</span>
<span class="c1"># [&lt;a class=&#34;sister&#34; href=&#34;http://example.com/elsie&#34; id=&#34;link1&#34;&gt;Elsie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&#34;sister&#34; href=&#34;http://example.com/lacie&#34; id=&#34;link2&#34;&gt;Lacie&lt;/a&gt;,</span>
<span class="c1">#  &lt;a class=&#34;sister&#34; href=&#34;http://example.com/tillie&#34; id=&#34;link3&#34;&gt;Tillie&lt;/a&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s1">&#39;tag.name&#39;</span><span class="p">,</span><span class="n">attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;class&#39;</span><span class="p">:</span><span class="s1">&#39;class_value&#39;</span><span class="p">})</span>
</code></pre></td></tr></table>
</div>
</div><p>Some tag attributes are not available in search, such as the data-* attribute in HTML5</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="n">data_soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s1">&#39;&lt;div data-foo=&#34;value&#34;&gt;foo!&lt;/div&gt;&#39;</span><span class="p">)</span>
<span class="n">data_soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">data</span><span class="o">-</span><span class="n">foo</span><span class="o">=</span><span class="s2">&#34;value&#34;</span><span class="p">)</span>
<span class="c1"># SyntaxError: keyword can&#39;t be an expression</span>
</code></pre></td></tr></table>
</div>
</div><p>However, it is possible to define a dictionary parameter to search for tags containing special attributes via the attrs parameter of the find_all() method.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="n">data_soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">attrs</span><span class="o">=</span><span class="p">{</span><span class="s2">&#34;data-foo&#34;</span><span class="p">:</span> <span class="s2">&#34;value&#34;</span><span class="p">})</span>
<span class="c1"># [&lt;div data-foo=&#34;value&#34;&gt;foo!&lt;/div&gt;]</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>text</strong> <strong>parameters</strong></p>
<p>The text parameter allows you to search for string content in a document. Like the optional value of the name parameter, the text parameter accepts strings, regular expressions, lists, True</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="s2">&#34;Elsie&#34;</span><span class="p">)</span>
<span class="c1"># [u&#39;Elsie&#39;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="p">[</span><span class="s2">&#34;Tillie&#34;</span><span class="p">,</span> <span class="s2">&#34;Elsie&#34;</span><span class="p">,</span> <span class="s2">&#34;Lacie&#34;</span><span class="p">])</span>
<span class="c1"># [u&#39;Elsie&#39;, u&#39;Lacie&#39;, u&#39;Tillie&#39;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&#34;Dormouse&#34;</span><span class="p">))</span>
<span class="p">[</span><span class="sa">u</span><span class="s2">&#34;The Dormouse&#39;s story&#34;</span><span class="p">,</span> <span class="sa">u</span><span class="s2">&#34;The Dormouse&#39;s story&#34;</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>limit parameters</strong></p>
<p>The find_all() method returns the entire search structure, which can be very slow if the document tree is large. If we do not need all the results we can use the limit parameter to limit the number of results returned. The effect is similar to the limit keyword in SQL, when the number of search results reaches the limit the search will stop returning results.</p>
<p>There are 3 tags in the document tree that match the search criteria but only 2 results are returned because we have limited the number of results.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&#34;a&#34;</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>recursive parameter</strong></p>
<p>Beautiful Soup retrieves all children of the current tag when calling the find_all() method of the tag, if you want to search only the direct children of the tag you can use the parameter recursive=False.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="n">soup</span><span class="o">.</span><span class="n">html</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&#34;title&#34;</span><span class="p">)</span>
<span class="c1"># [&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;]</span>

<span class="n">soup</span><span class="o">.</span><span class="n">html</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&#34;title&#34;</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="c1"># []</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="find-name--attrs--recursive--text--kwargs-">find( name , attrs , recursive , text , **kwargs )</h4>
<p>The find() method is equivalent to find_all(limit=1) and returns the first object that matches the condition. The only difference between it and the find_all() method is that the find_all() method returns a list of values containing one element while the find() method returns the result directly.</p>
<p>In addition to find() and find_all() there are a number of search methods.</p>
<ul>
<li>find_parent()</li>
<li>find_next_sibling()</li>
<li>find_previous_sibling()</li>
</ul>
<p>The above three can be followed by &rsquo;s' for all.</p>
<ul>
<li>find_next()</li>
<li>find_previous()</li>
<li>find_all_next()</li>
<li>find_all_previous()</li>
</ul>
<h4 id="find_parents-find_parent">find_parents() find_parent()</h4>
<p>find_all() and find() search only for all children, grandchildren, etc. of the current node. find_parents () and find_parent () used to search for the current node&rsquo;s parent nodes, search methods and ordinary tag search method is the same, search the document search document contains the content</p>
<h4 id="find_next_siblings--find_next_sibling-">find_next_siblings () find_next_sibling ()</h4>
<p>these two methods through the .next_siblings attribute when the tag of all the later resolved sibling tag nodes to iterate, find_next_siblings () method to return all eligible later sibling nodes, find_next_sibling () only to return to the eligible later the first tag node</p>
<h4 id="find_previous_siblings-find_previous_sibling"><strong>find_previous_siblings() find_previous_sibling()</strong></h4>
<p>These two methods iterate over the preceding resolved sibling tag nodes of the current tag using the .previous_siblings attribute. find_previous_siblings() method returns all eligible preceding siblings, find_previous_sibling() method returns the first eligible previous siblings</p>
<h4 id="find_all_next-find_next"><strong>find_all_next() find_next()</strong></h4>
<p>These two methods iterate over the tags and strings after the current tag using the .next_elements attribute. find_all_next() method returns all eligible nodes, find_next() method returns the first eligible node</p>
<h4 id="find_all_previous-and-find_previous">find_all_previous() and find_previous()</h4>
<p>These two methods iterate over the tag and string preceding the current node using the .previous_elements attribute. find_all_previous() method returns all eligible nodes, find_previous() method returns the first eligible node.</p>
<p>Note: The usage of the above methods is exactly the same as find_all(), and the principles are similar, so we will not repeat them here.</p>
<h2 id="css-selector">CSS selector</h2>
<p>When we write CSS, the tag name is not modified, the class name is preceded by a dot and the id name is preceded by #, here we can also use a similar method to filter the elements, the method used is soup.select(), the return type is list</p>
<h3 id="find-by-tag-name"><strong>Find by tag name</strong></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s1">&#39;title&#39;</span><span class="p">))</span>
<span class="c1">#[&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;]</span>

<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">))</span>
<span class="c1">#[&lt;a class=&#34;sister&#34; href=&#34;http://example.com/elsie&#34; id=&#34;link1&#34;&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;, &lt;a class=&#34;sister&#34; href=&#34;http://example.com/lacie&#34; id=&#34;link2&#34;&gt;Lacie&lt;/a&gt;, &lt;a class=&#34;sister&#34; href=&#34;http://example.com/tillie&#34; id=&#34;link3&#34;&gt;Tillie&lt;/a&gt;]</span>

<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">))</span>
<span class="c1">#[&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;]</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="find-by-class-name"><strong>Find by class name</strong></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s1">&#39;.sister&#39;</span><span class="p">))</span>
<span class="c1">#[&lt;a class=&#34;sister&#34; href=&#34;http://example.com/elsie&#34; id=&#34;link1&#34;&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;, &lt;a class=&#34;sister&#34; href=&#34;http://example.com/lacie&#34; id=&#34;link2&#34;&gt;Lacie&lt;/a&gt;, &lt;a class=&#34;sister&#34; href=&#34;http://example.com/tillie&#34; id=&#34;link3&#34;&gt;Tillie&lt;/a&gt;]</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="find-by-id-name"><strong>Find by id name</strong></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s1">&#39;#link1&#39;</span><span class="p">))</span>
<span class="c1">#[&lt;a class=&#34;sister&#34; href=&#34;http://example.com/elsie&#34; id=&#34;link1&#34;&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;]</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="combination-search"><strong>combination search</strong></h3>
<p>Combined search is the same as the combination of tag name, class name and id name when writing class files, for example, to find the contents of p tag, id equal to link1, the two need to be separated by spaces</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s1">&#39;p #link1&#39;</span><span class="p">))</span>
<span class="c1">#[&lt;a class=&#34;sister&#34; href=&#34;http://example.com/elsie&#34; id=&#34;link1&#34;&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;]</span>
</code></pre></td></tr></table>
</div>
</div><p>Direct sub-label search</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&#34;head &gt; title&#34;</span><span class="p">))</span>
<span class="c1">#[&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;]</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="attribute-lookup"><strong>attribute lookup</strong></h3>
<p>Find can also add attribute elements, attributes need to be enclosed in brackets, note that attributes and tags belong to the same node, so no spaces can be added in between, otherwise they will not be matched to.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s1">&#39;a[class=&#34;sister&#34;]&#39;</span><span class="p">))</span>
<span class="c1">#[&lt;a class=&#34;sister&#34; href=&#34;http://example.com/elsie&#34; id=&#34;link1&#34;&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;, &lt;a class=&#34;sister&#34; href=&#34;http://example.com/lacie&#34; id=&#34;link2&#34;&gt;Lacie&lt;/a&gt;, &lt;a class=&#34;sister&#34; href=&#34;http://example.com/tillie&#34; id=&#34;link3&#34;&gt;Tillie&lt;/a&gt;]</span>

<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s1">&#39;a[href=&#34;http://example.com/elsie&#34;]&#39;</span><span class="p">))</span>
<span class="c1">#[&lt;a class=&#34;sister&#34; href=&#34;http://example.com/elsie&#34; id=&#34;link1&#34;&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;]</span>
</code></pre></td></tr></table>
</div>
</div><p>Again, attributes can still be combined with the above lookup, not in the same node separated by spaces, the same node without spaces</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s1">&#39;p a[href=&#34;http://example.com/elsie&#34;]&#39;</span><span class="p">))</span>
<span class="c1">#[&lt;a class=&#34;sister&#34; href=&#34;http://example.com/elsie&#34; id=&#34;link1&#34;&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;]</span>
</code></pre></td></tr></table>
</div>
</div><p>The above select methods return results in list form, which can be iterated through and then get_text() to get its content. get_text(strip=True) removes the white space before and after the text.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">html</span><span class="p">,</span> <span class="s1">&#39;lxml&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s1">&#39;title&#39;</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s1">&#39;title&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_text</span><span class="p">())</span>

<span class="k">for</span> <span class="n">title</span> <span class="ow">in</span> <span class="n">soup</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s1">&#39;title&#39;</span><span class="p">):</span>
    <span class="nb">print</span> <span class="n">title</span><span class="o">.</span><span class="n">get_text</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="encoding-issues">Encoding issues</h2>
<p>Beautiful Soup automatically converts input documents to Unicode encoding and output documents to utf-8 encoding by default. beautifulSoup object&rsquo;s .original_encoding property to get the result of automatic encoding recognition. Of course, this is slow and sometimes wrong. Using the chartdet library can improve the efficiency of encoding detection. You can create a BeautifulSoup object by specifying the from_encoding parameter to tell you the encoding of the document. Sometimes when transcoding some special characters are replaced with special Unicode, you can determine if this is the case by using the .contains_repalcement_characters property of the BeautifulSoup object, which is True that there is a special replacement.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/python/">python</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2021-11/requests-best-practice/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Tips for using the Python network request library Requests</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2021-11/python-re/">
            <span class="next-text nav-default">Regular Expressions and Python Re Modules</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
