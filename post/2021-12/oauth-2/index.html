<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>OAuth 2.0 Authorization Authentication Explained - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Auth2.0 Protocol Introduction Regarding the application system user identity management requirements, including authentication, permission authorization, single sign-on, federated authentication and other business scenarios, there are a bunch of standards and specifications in the industry, such as CAS and Kerberos for single sign-on, OpenID for third-party authentication, OAuth for third-party user authorization, SAML for federated authentication and authorization data standards, and so on. Each technology has its own application scenarios and there are also crossover scenarios." /><meta name="keywords" content="oauth2" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2021-12/oauth-2/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="OAuth 2.0 Authorization Authentication Explained" />
<meta property="og:description" content="Auth2.0 Protocol Introduction Regarding the application system user identity management requirements, including authentication, permission authorization, single sign-on, federated authentication and other business scenarios, there are a bunch of standards and specifications in the industry, such as CAS and Kerberos for single sign-on, OpenID for third-party authentication, OAuth for third-party user authorization, SAML for federated authentication and authorization data standards, and so on. Each technology has its own application scenarios and there are also crossover scenarios." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2021-12/oauth-2/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-12-23T15:15:22+08:00" />
<meta property="article:modified_time" content="2021-12-23T15:15:22+08:00" />

<meta itemprop="name" content="OAuth 2.0 Authorization Authentication Explained">
<meta itemprop="description" content="Auth2.0 Protocol Introduction Regarding the application system user identity management requirements, including authentication, permission authorization, single sign-on, federated authentication and other business scenarios, there are a bunch of standards and specifications in the industry, such as CAS and Kerberos for single sign-on, OpenID for third-party authentication, OAuth for third-party user authorization, SAML for federated authentication and authorization data standards, and so on. Each technology has its own application scenarios and there are also crossover scenarios."><meta itemprop="datePublished" content="2021-12-23T15:15:22+08:00" />
<meta itemprop="dateModified" content="2021-12-23T15:15:22+08:00" />
<meta itemprop="wordCount" content="4618">
<meta itemprop="keywords" content="oauth2," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="OAuth 2.0 Authorization Authentication Explained"/>
<meta name="twitter:description" content="Auth2.0 Protocol Introduction Regarding the application system user identity management requirements, including authentication, permission authorization, single sign-on, federated authentication and other business scenarios, there are a bunch of standards and specifications in the industry, such as CAS and Kerberos for single sign-on, OpenID for third-party authentication, OAuth for third-party user authorization, SAML for federated authentication and authorization data standards, and so on. Each technology has its own application scenarios and there are also crossover scenarios."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">OAuth 2.0 Authorization Authentication Explained</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-12-23 15:15:22 </span>
        <div class="post-category">
            <a href="/categories/skills/"> skills </a>
            </div>
          <span class="more-meta"> 4618 words </span>
          <span class="more-meta"> 22 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#auth20-protocol-introduction">Auth2.0 Protocol Introduction</a></li>
        <li><a href="#oauth-20-authorization-authentication-process">OAuth 2.0 authorization authentication process</a>
          <ul>
            <li><a href="#the-core-concepts-of-oauth-20">The core concepts of OAuth 2.0</a></li>
            <li><a href="#authentication-ideas-and-processes">Authentication ideas and processes</a></li>
          </ul>
        </li>
        <li><a href="#the-four-modes-of-oauth20">The four modes of OAuth2.0</a>
          <ul>
            <li><a href="#authorization-code-mode-authorization-code">Authorization code mode (authorization code)</a></li>
            <li><a href="#implicit-grant-model">Implicit Grant model</a></li>
            <li><a href="#resource-owner-password-credentials-grant">Resource Owner Password Credentials Grant</a></li>
            <li><a href="#client-credentials-mode-client-credentials-grant">Client Credentials Mode (Client Credentials Grant)</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="auth20-protocol-introduction">Auth2.0 Protocol Introduction</h2>
<p>Regarding the application system user identity management requirements, including authentication, permission authorization, single sign-on, federated authentication and other business scenarios, there are a bunch of standards and specifications in the industry, such as CAS and Kerberos for single sign-on, OpenID for third-party authentication, OAuth for third-party user authorization, SAML for federated authentication and authorization data standards, and so on. Each technology has its own application scenarios and there are also crossover scenarios. To figure them out, you need to understand the working principles and application scenarios of various technologies. Today, starting with one of these technologies, a brief introduction to OAuth2.0 user authorization framework, want a comprehensive understanding of the framework can refer to the framework&rsquo;s standard RFC6749.</p>
<p>Oauth use scenarios.</p>
<ul>
<li>third-party login (to determine the identity of the login and other information)</li>
<li>API authentication (to determine whether the requesting party is licensed)</li>
</ul>
<p>Before OAuth, HTTP Basic Authentication, i.e., user authentication in the form of user name &amp; password, was insecure, and OAuth emerged to address the security and flexibility of accessing resources. To give a common example, a user stores photos, videos, and contact data in the Picture, Video, and Contact modules of the content hosting cloud service R (Resource); the user uses the online photo printing service P (Printer), and the user needs to let the P service read the photos in the R service for printing, but does not want the P service to read the other data in the R service. but does not want the P service to read the other data in the R service.</p>
<p>In the traditional way, the user can only provide the user name and password of the R service to the P service, and the P service logs into the R service through the user name and password to read the photos, and cannot restrict the scope of the P service to read.</p>
<p>Using the OAuth framework, the following authorization process is used to grant the P service limited permission to operate the S service without exposing the user password, and the overall process is as follows.</p>
<ul>
<li>The user logs in to the P service and clicks on the link to obtain the privileges of the R service.</li>
<li>The browser jumps to the R service. After the user logs in to the R service, the interface for granting permissions to the P service pops up.</li>
<li>The user selects the authorization options for granting Picture module, read-only, and valid for 1 hour permissions and submits them.</li>
<li>The page jumps back to the P service and carries the authorization code produced by the R service (read-only permission for the Picture module).</li>
<li>The P service obtains the authorization code and initiates a read Picture module request to the R service via the authorization code (with clint_id and client_secret appended).</li>
<li>The R service verifies the user information and authorization code and provides the P service with the Picture read access.</li>
</ul>
<p>OAuth has developed to date, there are three versions, respectively: the initialization version OAuth1.0; vulnerability repair version OAuth 1.0a; not backward-compatible OAuth2.0 version. 2.0 version is mainly to repair the security vulnerabilities of the previous version, the authorization process has been optimized to provide a richer use of the scenario, because the optimization of the streamlined steps of authorization, so can not Backward compatible.</p>
<h2 id="oauth-20-authorization-authentication-process">OAuth 2.0 authorization authentication process</h2>
<h3 id="the-core-concepts-of-oauth-20">The core concepts of OAuth 2.0</h3>
<p>According to the RFC description, OAuth 2.0 defines four service roles, which are described as follows.</p>
<ul>
<li>Resource Owner Resource Owner, the entity that can grant access to protected resources, when the resource owner is a person, the resource owner is the end user.</li>
<li>Resource Server A server that hosts protected resources and can accept and respond to protected resource requests using an Access Token.</li>
<li>Client, the application that initiates requests to the protected resource on behalf of the resource owner and with its authorization.</li>
<li>Authorization Server, an authorization server that authenticates the resource owner and obtains authorization, and then issues an Access Token to the client</li>
</ul>
<p>Some of the concepts involved in the process of authentication and authorization.</p>
<p><strong>access token</strong></p>
<p>Access token is an authorization credential issued by the authorization server to the client under the user&rsquo;s authorization, the token means &ldquo;the user grants the APP to access which services related to himself within how much time range&rdquo;, so the access token is mainly controlled in two dimensions: time range and permission range.</p>
<p><strong>refresh token</strong></p>
<p>The role of refresh token is to update the access token, the validity period of the access token is generally short, so as to ensure that in the event of access token leakage, not to cause too bad impact, but the side effect of setting the validity period of the access token is too short is that the user needs to authorize frequently, although a certain mechanism can be silent authorization, but frequent calls to the authorization interface, the authorization server is also a kind of pressure In this case, you can issue a refresh token at the same time as the access token, the refresh token is obviously longer than the access token, so that when the access token fails, you can use the refresh token to authorize the server for a new access token, but the protocol for the refresh token is not mandatory, whether the token is needed is the client can choose.</p>
<p><strong>Callback address (redirect uri)</strong></p>
<p>OAuth2.0 is a callback-based authorization protocol. In the authorization code model, the entire authorization needs to be divided into two steps: the first step is to issue the authorization code, and the second step is to request the authorization server to issue the access token based on the authorization code obtained in the first step.</p>
<p>In the first step, OAuth adds the authorization code to the callback address in the form of parameters and sends it in the form of 302 hops, which simplifies the operation of the client and does not need to actively trigger another request to enter the next process. In addition, it will make the authorization server into a &ldquo;request sender&rdquo;, using the authorization server as a proxy to request the target address, consuming the performance of the authorization server while generating DDOS attacks on the target address server.</p>
<p>In order to avoid the above security risks, OAuth protocol forces clients to fill in their own callback address during registration, the purpose of this callback address is to allow callback requests to reach the client&rsquo;s own server, so that they can go through the process of obtaining access tokens. The client can configure multiple callback addresses at the same time and carry one address when requesting authorization. The server will verify whether the callback address passed up by the client is the same as the previously registered callback address, or the former is an element of the latter set, and only when this condition is met is the authorization code allowed to be issued, and the protocol also requires that the callback address carried by the client in both steps of the request must be the same, through these measures to ensure that the callback process can properly reach the client&rsquo;s own server, and continue the process of taking the authorization code for the access token later.</p>
<p><strong>Permission scope</strong></p>
<p>Access tokens come with an expiration time to control authorization in the time dimension, while in the scope dimension, OAuth introduces the concept of scope. scope can be seen as an object containing the ID, name, and description of a permission, such as &ldquo;Get your basic information (avatar, nickname) &ldquo;. The scope must be requested from the third-party login service provider when accessing the account service, and the parameter must be specified when requesting authorization (otherwise it indicates that all permissions allowed by the application are obtained), and these permissions must be shown to the user without reservation when the user confirms the authorization, so that the user knows which data or services the app needs to obtain from the user.</p>
<h3 id="authentication-ideas-and-processes">Authentication ideas and processes</h3>
<p>OAuth sets up an authorization layer between the &ldquo;client&rdquo; and the &ldquo;service provider&rdquo;. client&rdquo; cannot log in directly to the &ldquo;service provider&rdquo;, but only to the authorization layer, thus distinguishing the user from the client. The token used by the &ldquo;client&rdquo; to log in to the authorization layer is different from the user&rsquo;s password, and the user can specify the scope of authority and validity of the authorization layer token at the time of logging in. After the &ldquo;client&rdquo; logs in to the authorization layer, the &ldquo;service provider&rdquo; opens the user&rsquo;s stored data to the &ldquo;client&rdquo; based on the token&rsquo;s permission range and validity period.</p>
<p>The OAuth 2.0 flowchart in the official RFC 6749 document is a bit obscure and has been optimized as follows</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/23/c25d1b6516a1474797b1dcc173c36ced.png" alt="image"></p>
<ol>
<li>After the user accesses the third party application (referred to as: client), the client asks the user to grant authorization.</li>
<li>The user agrees to grant authorization to the client. 3.</li>
<li>The client uses the authorization obtained in step 2 to request a token from the authentication server.</li>
<li>After the authentication server authenticates the client, it confirms that the token is correct and agrees to issue the token.</li>
<li>The client uses the token to request resources from the resource server. 6.</li>
<li>The resource server confirms that the token is correct and agrees to open the resources to the client.</li>
</ol>
<p>Step 2 of the above is the key, that is, how the user can give authorization to the client. With this authorization, the client can get the token and then get the resources with the token.</p>
<h2 id="the-four-modes-of-oauth20">The four modes of OAuth2.0</h2>
<p>OAuth2.0 has more refinements in authorization modes compared to version 1.0, and there are four defined authorization modes: Authorization Code Grant, Implicit Grant, Resource Owner Password Credentials Grant), and Client Credentials Grant.</p>
<h3 id="authorization-code-mode-authorization-code">Authorization code mode (authorization code)</h3>
<p>Authorization code mode is the most similar to version 1.0 in the whole authorization process, but the whole process is still much simpler, and it is also the most standard and widely used authorization mode in OAuth2.0. This authorization mode is very suitable for applications with server side, of course, most APPs have their own server side nowadays, so most of the OAuth authorization of APPs can take the authorization code mode, the following figure shows the interaction sequence between the roles of authorization code (here the user is directly involved, omitting the user agent).</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/23/e011d629640a466ea21b8cc80b1c8f47.png" alt="image"></p>
<p>The entire authorization process is described as follows.</p>
<ul>
<li>The client carries client_id, scope, redirect_uri, state and other information to guide the user to request the authorization server to issue the code from the authorization endpoint.</li>
<li>The authorization server verifies the client&rsquo;s identity and asks the user if he agrees to the authorization (at this point, it will jump to the authorization page that the user can visually see and wait for the user to click to confirm the authorization)</li>
<li>Assuming that the user agrees to the authorization, the authorization server splices the code and state (if the client passes the parameter) after the redirect_uri and sends the code as a 302</li>
<li>The client carries the code, redirect_uri, and client_secret to request the authorization server&rsquo;s token endpoint to issue the access_token (this step actually goes through the client&rsquo;s server, except for the code, all other parameters are added on the application server side)</li>
<li>The authorization server verifies the client&rsquo;s identity and verifies that the code and redirect_uri are the same as when the code was requested, and then issues the access_token and optionally the refresh_token.</li>
</ul>
<p><strong>Get Authorization Code</strong></p>
<p>Authorization code is an intermediate temporary credential of the authorization process, a temporary certificate for the user to confirm the authorization of this operation, its life cycle is generally short, the protocol recommends that the maximum should not exceed 10 minutes, in this effective time cycle, the client can rely on this temporary certificate to the authorization server in exchange for access tokens.</p>
<p>Request parameter description.</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Must</th>
<th>Descriptive Information</th>
</tr>
</thead>
<tbody>
<tr>
<td>response_type</td>
<td>must</td>
<td>for authorization code mode response_type=code</td>
</tr>
<tr>
<td>client_id</td>
<td>must</td>
<td>The client ID, used to identify a client, equivalent to appId, generated when registering the application</td>
</tr>
<tr>
<td>redirect_uri</td>
<td>Optional</td>
<td>Authorization callback address, see sub-section 2.2.3</td>
</tr>
<tr>
<td>scope</td>
<td>optional</td>
<td>permission scope, used to control the client&rsquo;s permissions, if the client does not pass this parameter, then the server replaces it with all permissions for that application</td>
</tr>
<tr>
<td>state</td>
<td>recommended</td>
<td>is used to maintain the state of the request and callback process, to prevent CSRF attacks, the server does not do any processing of this parameter, if the client carries the parameter, then the server returns it as is in the response</td>
</tr>
</tbody>
</table>
<p>Example of request parameters.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">GET /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;state=xyz&amp;redirect_uri=https://client.example.com/cb HTTP/1.1  
Host: server.example.com
</code></pre></td></tr></table>
</div>
</div><p>The client will request the token endpoint of the authorization server with the above parameters. The authorization server will verify the identity of the client and the relevant parameters, and pop up the confirmation authorization page to ask the user whether to authorize or not on the premise of confirming the user&rsquo;s login, and if the user agrees to authorize, the authorization code (code) and state information (if the client has passed the parameter) will be added to the callback address and sent down as 302.</p>
<p>Successful response parameters are described as follows</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Must</th>
<th>Descriptive Information</th>
</tr>
</thead>
<tbody>
<tr>
<td>code</td>
<td>must</td>
<td>Authorization code, the authorization code represents a temporary credential for the user to confirm authorization, can only be used once, and the recommended maximum lifetime is no more than 10 minutes</td>
</tr>
<tr>
<td>state</td>
<td>Optional</td>
<td>If the client passes this parameter, it must be returned unchanged</td>
</tr>
</tbody>
</table>
<p>Example of a successful response.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">HTTP/1.1 302 Found
Location: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA&amp;state=xyz
</code></pre></td></tr></table>
</div>
</div><p>If the request parameters are wrong, or the server-side response is wrong, then the error message needs to be added to the callback address and sent down as 302 (except for the callback address error, or invalid client-side identifier).</p>
<p>Error response parameter description.</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Must</th>
<th>Descriptive Information</th>
</tr>
</thead>
<tbody>
<tr>
<td>error</td>
<td>mandatory</td>
<td>error code</td>
</tr>
<tr>
<td>error_description</td>
<td>Optional</td>
<td>Error description information with readability</td>
</tr>
<tr>
<td>error_uri</td>
<td>Optional</td>
<td>Error_description</td>
</tr>
<tr>
<td>state</td>
<td>optional</td>
<td>must be returned unchanged if the client passes this parameter</td>
</tr>
</tbody>
</table>
<p>Example error response.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">HTTP/1.1 302 Found
Location: https://client.example.com/cb?error=access_denied&amp;state=xyz
</code></pre></td></tr></table>
</div>
</div><p><strong>Dispatching access token</strong></p>
<p>After the authorization endpoint of the authorization server sends the code in the form of 302, the user User-Agent, such as a browser, will request the user-specified redirect_url with the corresponding code, which should ensure that the request hits the corresponding interface of the application server, which can thus get the code and request the token endpoint of the authorization server with the corresponding parameters, and the authorization endpoint will verify the code and the related parameters, and send the access_token if the verification is passed.</p>
<p>The request parameters are described as follows</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Must</th>
<th>Descriptive Information</th>
</tr>
</thead>
<tbody>
<tr>
<td>grant_type</td>
<td>must</td>
<td>for authorization code mode grant_type=authorization_code</td>
</tr>
<tr>
<td>code</td>
<td>must</td>
<td>The authorization code obtained in the previous step</td>
</tr>
<tr>
<td>redirect_uri</td>
<td>must</td>
<td>authorization callback address, see subsection 2.2.3, must be the same if set in previous step</td>
</tr>
<tr>
<td>client_id</td>
<td>must</td>
<td>The client ID to identify a client, equivalent to the appId, which is generated when registering the application</td>
</tr>
</tbody>
</table>
<ul>
<li>If client credential information (client_secret) is sent down when registering the application, then the client must carry this parameter in order for the authorization server to verify the validity of the client.</li>
<li>One more point that needs to be made about client credentials is that they cannot be passed to the client, the client cannot guarantee the security of the credentials, the credentials should always stay on the server side of the application and when the downcode callback request is made to the application server, carry the credentials on the server side to request the downcode token again.</li>
</ul>
<p>Example of request parameters.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded

grant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA&amp;redirect_uri=https://client.example.com/cb
</code></pre></td></tr></table>
</div>
</div><p>The authorization server needs to verify the validity of the client and whether it is the same as the client that requested the authorization code before (the information when requesting authorization can be recorded in the code, or create a cache with the code as the key), and the authorization server also needs to ensure that the code is in the life cycle (recommended to be valid within 10 minutes) and can only be used once. The authorization server generates access_token and optionally sends refresh_token after verification. The OAuth2.0 protocol specifies the token sending policy, but does not explain much about the generation policy.</p>
<p>The success response parameters are described as follows</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Must</th>
<th>Descriptive Information</th>
</tr>
</thead>
<tbody>
<tr>
<td>access_token</td>
<td>must</td>
<td>access_token</td>
</tr>
<tr>
<td>token_type</td>
<td>must</td>
<td>access token type, such as bearer, mac, etc.</td>
</tr>
<tr>
<td>expires_in</td>
<td>recommended</td>
<td>The lifecycle of the access token, in seconds, indicating how long the token expires after it is issued, or the default value if it is not specified</td>
</tr>
<tr>
<td>refresh_token</td>
<td>recommended</td>
<td>refresh the token, optionally, see 2.2.2</td>
</tr>
<tr>
<td>scope</td>
<td>optional</td>
<td>permission range, if the final access token issued corresponds to a permission range different from the one specified by the actual application, then this parameter must be used when issuing the access token to specify</td>
</tr>
</tbody>
</table>
<p>The final access token responds in JSON format and requires that the response headers Cache-Control: no-store and Pragma: no-cache be specified.</p>
<p>Example of a successful response.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
    &#34;access_token&#34;: &#34;2YotnFZFEjr1zCsicMWpAA&#34;,
    &#34;token_type&#34;: &#34;example&#34;,
    &#34;expires_in&#34;: 3600,
    &#34;refresh_token&#34;: &#34;tGzv3JOkF0XG5Qx2TlKWIA&#34;,
    &#34;example_parameter&#34;: &#34;example_value&#34;
}
</code></pre></td></tr></table>
</div>
</div><p>Error response parameter description.</p>
<table>
<thead>
<tr>
<th>name</th>
<th>must</th>
<th>description information</th>
</tr>
</thead>
<tbody>
<tr>
<td>error</td>
<td>mandatory</td>
<td>error code</td>
</tr>
<tr>
<td>error_description</td>
<td>Optional</td>
<td>Error description with readable information</td>
</tr>
<tr>
<td>error_uri</td>
<td>Optional</td>
<td>Error_description</td>
</tr>
</tbody>
</table>
<p>Example error response.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">HTTP/1.1 400 Bad Request
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
    &#34;error&#34;: &#34;invalid_request&#34;
}
</code></pre></td></tr></table>
</div>
</div><p>The authorization code authorization process is divided into two steps, separating user authorization and token issuance, which brings more flexibility to the authorization process. However, in some scenarios, such as an internal SSO login application integrated with a third-party application based on OAuth login, a better user experience in OAuth authorization to log in to the third-party application does not require the user to enter the user name and password again to log in, which requires the peripheral APP login state to be passed to the application, but this is a security problem, the user&rsquo;s login state must be grasped in the application that takes the SSO login process, so the two-step process of authorization code authorization mode in such a scenario can In such a scenario, the two-step process of the authorization code authorization mode can be satisfied without handing over the user&rsquo;s login state and authorizing it without logging in again.</p>
<p>The internal application can take the client_id and other information of the third-party application to request the code instead of the third-party application, because it holds the user&rsquo;s login state, so the user does not need to enter the user name and password again during the process, and after getting the code, it will give it to the third-party application, which will use the code and its own client_secret information to request authorization. The server issues the token, and the internal application does not need to give up its own user login state, and the third-party application does not need to give up its own client_secret information, so that the whole authorization process can be completed without logging in again while protecting the user login credentials.</p>
<p><strong>Token refresh</strong></p>
<p>In order to prevent the client from using a token for an unlimited number of times, the token will generally have an expiration time limit, when it is about to expire, you need to reacquire the token, and if you go through the authorization process of the authorization code again, it is very bad for the user experience, so OAuth 2.0 allows users to automatically renew the token.</p>
<p>The specific method is, when the B site issues a token, two tokens are issued at once, one for getting data and the other for getting a new token (refresh token field). Before the token expires, the user uses the refresh token to send a request to renew the token.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">https://b.com/oauth/token?grant_type=refresh_token&amp;client_id=CLIENT_ID&amp;client_secret=CLIENT_SECRET&amp;refresh_token=REFRESH_TOKEN
</code></pre></td></tr></table>
</div>
</div><p>In the URL above.</p>
<ul>
<li>the grant_type parameter is refresh_token to indicate a request to renew the token, the value here is fixed to refresh_token, mandatory.</li>
<li>client_id parameter and client_secret parameter are used to confirm the identity.</li>
<li>refresh_token parameter is the token used to update the token.</li>
</ul>
<p>After the B site is verified, a new token will be issued.</p>
<p>Note: The third-party application server gets the refresh token and must store it on the server and reacquire the new token through the background to protect the confidentiality of the refresh token.</p>
<h3 id="implicit-grant-model">Implicit Grant model</h3>
<p>Some web applications are purely front-end applications, with no back-end. RFC 6749 specifies a second way, allowing tokens to be issued directly to the front end. This approach does not have an authorization code as an intermediate step, so it is called (authorization code) &ldquo;hidden&rdquo; (implicit).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">+----------+
| Resource |
|  Owner   |
|          |
+----------+
     ^
     |
    (B)
+----|-----+          Client Identifier     +---------------+
|         -+----(A)-- &amp; Redirection URI ---&gt;|               |
|  User-   |                                | Authorization |
|  Agent  -|----(B)-- User authenticates --&gt;|     Server    |
|          |                                |               |
|          |&lt;---(C)--- Redirection URI ----&lt;|               |
|          |          with Access Token     +---------------+
|          |            in Fragment
|          |                                +---------------+
|          |----(D)--- Redirection URI ----&gt;|   Web-Hosted  |
|          |          without Fragment      |     Client    |
|          |                                |    Resource   |
|     (F)  |&lt;---(E)------- Script ---------&lt;|               |
|          |                                +---------------+
+-|--------+
  |    |
 (A)  (G) Access Token
  |    |
  ^    v
+---------+
|         |
|  Client |
|         |
+---------+
</code></pre></td></tr></table>
</div>
</div><p>It proceeds as follows.</p>
<ul>
<li>(A) The client directs the user to the authentication server.</li>
<li>(B) The user decides whether to grant authorization to the client.</li>
<li>(C) Assuming the user gives authorization, the authentication server directs the user to the &ldquo;redirect URI&rdquo; specified by the client, and includes the access token in the hash portion of the URI.</li>
<li>(D) The browser sends a request to the resource server, which does not include the hash value received in the previous step.</li>
<li>(E) The resource server returns a web page that contains code to obtain the token in the Hash value.</li>
<li>(F) The browser executes the script obtained in the previous step and extracts the token.</li>
<li>(G) The browser sends the token to the client.</li>
</ul>
<p>The following are the parameters needed for these steps above.</p>
<p><strong>A step</strong>, the HTTP request from the client, contains the following parameters.</p>
<ul>
<li>response_type: the authorization type, the value here is fixed to &ldquo;token&rdquo;, mandatory.</li>
<li>client_id: the ID of the client, mandatory.</li>
<li>redirect_uri: URI of the redirect, optional.</li>
<li>scope: the scope of the permission, optional.</li>
<li>state: the current state of the client, any value can be specified, the authentication server will return the value as is.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">GET /authorize?response_type=token&amp;client_id=s6BhdRkqt3&amp;state=xyz&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1
Host: server.example.com
</code></pre></td></tr></table>
</div>
</div><p><strong>C step</strong>, the authentication server responds to the client&rsquo;s URI with the following parameters.</p>
<ul>
<li>access_token: indicates the access token, mandatory.</li>
<li>token_type: indicates the token type, the value is case-insensitive, mandatory.</li>
<li>expires_in: indicates the expiration time in seconds. If this parameter is omitted, the expiration time must be set in some other way.</li>
<li>scope: the scope of the permission. If the scope is the same as the client&rsquo;s request, this parameter can be omitted.</li>
<li>state: If the client&rsquo;s request contains this parameter, the authentication server&rsquo;s response must also contain this parameter in exactly the same way.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">HTTP/1.1 302 Found
Location: http://example.com/cb#access_token=2YotnFZFEjr1zCsicMWpAA&amp;state=xyz&amp;token_type=example&amp;expires_in=3600
</code></pre></td></tr></table>
</div>
</div><p>In the above example, the authentication server uses the Location field of the HTTP header message to specify the URL of the browser redirect. Note that the Hash portion of this URL contains the token.</p>
<p>According to step D above, the browser will next access the URL specified by Location, but the Hash part will not be sent. The next step E, the code sent from the service provider&rsquo;s resource server, will extract the token in the Hash.</p>
<h3 id="resource-owner-password-credentials-grant">Resource Owner Password Credentials Grant</h3>
<p>RFC 6749 also allows users to give their user name and password directly to an application if you have a high level of trust in that application. This is usually used when the user has a high degree of trust in the client, such as when the client is part of an operating system or produced by a reputable company. The authentication server, on the other hand, should only consider using this mode if other authorization modes cannot be enforced. The application then uses your password to request a token, in a way called &ldquo;password&rdquo;.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">+----------+
| Resource |
|  Owner   |
|          |
+----------+
     v
     |    Resource Owner
    (A) Password Credentials
     |
     v
+---------+                                  +---------------+
|         |&gt;--(B)---- Resource Owner -------&gt;|               |
|         |         Password Credentials     | Authorization |
| Client  |                                  |     Server    |
|         |&lt;--(C)---- Access Token ---------&lt;|               |
|         |    (w/ Optional Refresh Token)   |               |
+---------+                                  +---------------+
</code></pre></td></tr></table>
</div>
</div><p>It proceeds as follows.</p>
<ul>
<li>(A) The user provides the user name and password to the client.</li>
<li>(B) The client sends the user name and password to the authentication server and requests a token from the latter.</li>
<li>(C) The authentication server confirms that there is no error and then provides the access token to the client.</li>
</ul>
<p>In step B, the client sends an HTTP request containing the following parameters.</p>
<ul>
<li>grant_type: indicates the authorization type, the value here is fixed to &ldquo;password&rdquo;, mandatory.</li>
<li>username: user name, mandatory.</li>
<li>password: The password of the user, mandatory.</li>
<li>scope: The scope of the permission, optional.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded

grant_type=password&amp;username=johndoe&amp;password=A3ddj3w
</code></pre></td></tr></table>
</div>
</div><p>In step C, the authentication server sends an access token to the client, an example of which is shown below.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
    &#34;access_token&#34;: &#34;2YotnFZFEjr1zCsicMWpAA&#34;,
    &#34;token_type&#34;: &#34;example&#34;,
    &#34;expires_in&#34;: 3600,
    &#34;refresh_token&#34;: &#34;tGzv3JOkF0XG5Qx2TlKWIA&#34;,
    &#34;example_parameter&#34;: &#34;example_value&#34;
}
</code></pre></td></tr></table>
</div>
</div><p>The client shall not save the user&rsquo;s password during the whole process.</p>
<h3 id="client-credentials-mode-client-credentials-grant">Client Credentials Mode (Client Credentials Grant)</h3>
<p>The last approach is credential-based (client credentials) for command-line applications that do not have a front-end, i.e., requesting a token at the command line.</p>
<p>When a client requests access to a protected resource under its control, the client can only use its client credentials (or other supported authentication method) to request an access token. Or other resource owners previously arranged with the authorization server (whose methods are outside the scope of this document). The client credential grant type must be used by confidential clients only.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">+---------+                                  +---------------+
|         |                                  |               |
|         |&gt;--(A)- Client Authentication ---&gt;| Authorization |
| Client  |                                  |     Server    |
|         |&lt;--(B)---- Access Token ---------&lt;|               |
|         |                                  |               |
+---------+                                  +---------------+
</code></pre></td></tr></table>
</div>
</div><p>It proceeds as follows.</p>
<ul>
<li>(A) The client authenticates itself to the authentication server and requests an access token.</li>
<li>(B) The authentication server confirms that there is no error and provides the access token to the client.</li>
</ul>
<p>In step A, the client sends an HTTP request with the following parameters.</p>
<ul>
<li>granttype: indicates the authorization type, the value here is fixed to &ldquo;clientcredentials&rdquo;, mandatory.</li>
<li>scope: indicates the scope of the authority, optional.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded

grant_type=client_credentials
</code></pre></td></tr></table>
</div>
</div><p>The authentication server must, in some way, verify the identity of the client.</p>
<p>In step B, the authentication server sends an access token to the client.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
    &#34;access_token&#34;: &#34;2YotnFZFEjr1zCsicMWpAA&#34;,
    &#34;token_type&#34;: &#34;example&#34;,
    &#34;expires_in&#34;: 3600,
    &#34;example_parameter&#34;: &#34;example_value&#34;
}
</code></pre></td></tr></table>
</div>
</div>
    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/oauth2/">oauth2</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2021-12/apache-http-server-vulnerabilities/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Apache HTTP Server Multiple Vulnerability Risk Notice</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2021-12/http/">
            <span class="next-text nav-default">HTTP protocol evolution and features of each version</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
