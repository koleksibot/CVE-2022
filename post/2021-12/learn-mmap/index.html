<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Re-learning memory mapping (mmap) in Java - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="mmap Basic Concepts mmap is a memory mapping method that maps a file to a process address space, mapping a file&amp;rsquo;s disk address to a process virtual address. Once such a mapping relationship is implemented, the process can read and write to this section of memory using pointers, and the system will automatically write back dirty pages to the corresponding file disk, i.e., it is done with the file without" /><meta name="keywords" content="java, mmap" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2021-12/learn-mmap/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Re-learning memory mapping (mmap) in Java" />
<meta property="og:description" content="mmap Basic Concepts mmap is a memory mapping method that maps a file to a process address space, mapping a file&rsquo;s disk address to a process virtual address. Once such a mapping relationship is implemented, the process can read and write to this section of memory using pointers, and the system will automatically write back dirty pages to the corresponding file disk, i.e., it is done with the file without" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2021-12/learn-mmap/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-12-10T15:13:04+08:00" />
<meta property="article:modified_time" content="2021-12-10T15:13:04+08:00" />

<meta itemprop="name" content="Re-learning memory mapping (mmap) in Java">
<meta itemprop="description" content="mmap Basic Concepts mmap is a memory mapping method that maps a file to a process address space, mapping a file&rsquo;s disk address to a process virtual address. Once such a mapping relationship is implemented, the process can read and write to this section of memory using pointers, and the system will automatically write back dirty pages to the corresponding file disk, i.e., it is done with the file without"><meta itemprop="datePublished" content="2021-12-10T15:13:04+08:00" />
<meta itemprop="dateModified" content="2021-12-10T15:13:04+08:00" />
<meta itemprop="wordCount" content="2444">
<meta itemprop="keywords" content="java," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Re-learning memory mapping (mmap) in Java"/>
<meta name="twitter:description" content="mmap Basic Concepts mmap is a memory mapping method that maps a file to a process address space, mapping a file&rsquo;s disk address to a process virtual address. Once such a mapping relationship is implemented, the process can read and write to this section of memory using pointers, and the system will automatically write back dirty pages to the corresponding file disk, i.e., it is done with the file without"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Re-learning memory mapping (mmap) in Java</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-12-10 15:13:04 </span>
        <div class="post-category">
            <a href="/categories/skills/"> skills </a>
            </div>
          <span class="more-meta"> 2444 words </span>
          <span class="more-meta"> 5 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#mmap-basic-concepts">mmap Basic Concepts</a></li>
        <li><a href="#mmap-in-java">mmap in Java</a></li>
        <li><a href="#mmap-is-not-a-silver-bullet">mmap is not a silver bullet</a></li>
        <li><a href="#mmap-vs-filechannel">mmap vs FileChannel</a>
          <ul>
            <li><a href="#pagecache">pageCache</a></li>
            <li><a href="#missing-page-interrupts">Missing page interrupts</a></li>
            <li><a href="#number-of-memory-copies">Number of memory copies</a></li>
            <li><a href="#user-state-vs-kernel-state">User state vs. kernel state</a></li>
          </ul>
        </li>
        <li><a href="#mmap-details-added">mmap details added</a>
          <ul>
            <li><a href="#copy-on-write-mode">copy on write mode</a></li>
            <li><a href="#reclaiming-mmap-memory">Reclaiming mmap memory</a></li>
          </ul>
        </li>
        <li><a href="#mmap-usage-scenarios">mmap usage scenarios</a>
          <ul>
            <li><a href="#using-mmap-to-handle-frequent-reads-and-writes-of-small-data">Using mmap to handle frequent reads and writes of small data</a></li>
            <li><a href="#mmap-caching">mmap caching</a></li>
            <li><a href="#reading-and-writing-small-files">Reading and writing small files</a></li>
            <li><a href="#reads-and-writes-in-a-cpu-crunch">Reads and Writes in a cpu crunch</a></li>
            <li><a href="#special-hardware-and-software-factors">Special hardware and software factors</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="mmap-basic-concepts">mmap Basic Concepts</h2>
<p>mmap is a memory mapping method that maps a file to a process address space, mapping a file&rsquo;s disk address to a process virtual address. Once such a mapping relationship is implemented, the process can read and write to this section of memory using pointers, and the system will automatically write back dirty pages to the corresponding file disk, i.e., it is done with the file without having to call read, write, and other system calls. On the contrary, changes to this area in kernel space are directly reflected in user space, thus allowing file sharing between processes.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/10/4c9f2d632ddb43a5b5ddd2e86543e1ce.png" alt=""></p>
<p>The operating system provides this set of mmap companion functions</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kt">void</span> <span class="o">*</span><span class="n">mmap</span><span class="o">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">start</span><span class="o">,</span> <span class="n">size_t</span> <span class="n">length</span><span class="o">,</span> <span class="kt">int</span> <span class="n">prot</span><span class="o">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="o">,</span> <span class="n">off_t</span> <span class="n">offset</span><span class="o">);</span>
<span class="kt">int</span> <span class="nf">munmap</span><span class="o">(</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">addr</span><span class="o">,</span> <span class="n">size_t</span> <span class="n">len</span><span class="o">);</span>
<span class="kt">int</span> <span class="nf">msync</span><span class="o">(</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="o">,</span> <span class="n">size_t</span> <span class="n">len</span><span class="o">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">);</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="mmap-in-java">mmap in Java</h2>
<p>Native read and write methods in Java can be roughly divided into three types: normal IO, FileChannel, and mmap. For example, FileWriter and FileReader exist in the java.io package, and they belong to normal IO; FileChannel exists in the java.nio package, and is the most common file manipulation class in Java; and today&rsquo;s main character, mmap, is a special way of reading and writing files derived from the map method called by FileChannel. The main character, mmap, is a special way of reading and writing files derived from the map method called by FileChannel, which is called memory mapping.</p>
<p>The way mmap is used.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">FileChannel</span> <span class="n">fileChannel</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RandomAccessFile</span><span class="o">(</span><span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="s">&#34;db.data&#34;</span><span class="o">),</span> <span class="s">&#34;rw&#34;</span><span class="o">).</span><span class="na">getChannel</span><span class="o">();</span>
<span class="n">MappedByteBuffer</span> <span class="n">mappedByteBuffer</span> <span class="o">=</span> <span class="n">fileChannel</span><span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">FileChannel</span><span class="o">.</span><span class="na">MapMode</span><span class="o">.</span><span class="na">READ_WRITE</span><span class="o">,</span> <span class="n">0</span><span class="o">,</span> <span class="n">filechannel</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>MappedByteBuffer</strong> is the mmap operation class in Java.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 写
</span><span class="c1"></span><span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="n">4</span><span class="o">];</span>
<span class="kt">int</span> <span class="n">position</span> <span class="o">=</span> <span class="n">8</span><span class="o">;</span>
<span class="c1">// 从当前 mmap 指针的位置写入 4b 的数据
</span><span class="c1"></span><span class="n">mappedByteBuffer</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
<span class="c1">// 指定 position 写入 4b 的数据
</span><span class="c1"></span><span class="n">MappedByteBuffer</span> <span class="n">subBuffer</span> <span class="o">=</span> <span class="n">mappedByteBuffer</span><span class="o">.</span><span class="na">slice</span><span class="o">();</span>
<span class="n">subBuffer</span><span class="o">.</span><span class="na">position</span><span class="o">(</span><span class="n">position</span><span class="o">);</span>
<span class="n">subBuffer</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>

<span class="c1">// 读
</span><span class="c1"></span><span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="n">4</span><span class="o">];</span>
<span class="kt">int</span> <span class="n">position</span> <span class="o">=</span> <span class="n">8</span><span class="o">;</span>
<span class="c1">// 从当前 mmap 指针的位置读取 4b 的数据
</span><span class="c1"></span><span class="n">mappedByteBuffer</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">data</span><span class="o">)</span><span class="err">；</span>
<span class="c1">// 指定 position 读取 4b 的数据
</span><span class="c1"></span><span class="n">MappedByteBuffer</span> <span class="n">subBuffer</span> <span class="o">=</span> <span class="n">mappedByteBuffer</span><span class="o">.</span><span class="na">slice</span><span class="o">();</span>
<span class="n">subBuffer</span><span class="o">.</span><span class="na">position</span><span class="o">(</span><span class="n">position</span><span class="o">);</span>
<span class="n">subBuffer</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="mmap-is-not-a-silver-bullet">mmap is not a silver bullet</h2>
<p>A big motivation for writing this article came from a lot of misconceptions about mmap in the web. When I first learned about mmap, many articles mentioned that mmap was suitable for handling large files, but in retrospect, this is a ridiculous view, and I hope that this article will clarify what mmap is supposed to be.</p>
<p>The coexistence of FileChannel and mmap probably means that both have their appropriate use cases, and they do. When you look at them, you can think of them as two tools for implementing file IO, and there is no good or bad tool per se.</p>
<h2 id="mmap-vs-filechannel">mmap vs FileChannel</h2>
<p>This section details the similarities and differences between FileChannel and mmap for file IO.</p>
<h3 id="pagecache">pageCache</h3>
<p>Both FileChannel and mmap reads and writes go through the pageCache, or more precisely the <code>cache</code> part of memory observed by <code>vmstat</code>, rather than the user space memory.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 3  0      0 4622324  40736 351384    0    0     0     0 2503  200 50  1 50  0  0
</code></pre></td></tr></table>
</div>
</div><p>I have not researched whether this part of memory mapped by mmap can be called pageCache, but in the OS view, there is not much difference between them, as this part of the cache is controlled by the kernel. Later in this article, we will also call the memory from mmap a pageCache.</p>
<h3 id="missing-page-interrupts">Missing page interrupts</h3>
<p>Readers with a basic understanding of Linux file IO may not be too familiar with the concept of page-out interrupts. mmap and FileChannel both read and write to files in a page-out interrupt fashion.</p>
<p>Take the example of mmap reading a 1G file, <code>fileChannel.map(FileChannel.MapMode.READ_WRITE, 0, _GB);</code> The mapping is a minimal consumption operation, but it does not mean that the 1G file is read into the pageCache. pageCache.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">FileChannel</span> <span class="n">fileChannel</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RandomAccessFile</span><span class="o">(</span><span class="n">file</span><span class="o">,</span> <span class="s">&#34;rw&#34;</span><span class="o">).</span><span class="na">getChannel</span><span class="o">();</span>
<span class="n">MappedByteBuffer</span> <span class="n">map</span> <span class="o">=</span> <span class="n">fileChannel</span><span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">MapMode</span><span class="o">.</span><span class="na">READ_WRITE</span><span class="o">,</span> <span class="n">0</span><span class="o">,</span> <span class="n">_GB</span><span class="o">);</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">_GB</span><span class="o">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">_4kb</span><span class="o">)</span> <span class="o">{</span>
	<span class="n">temp</span> <span class="o">+=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>MappedByteBuffer#load method, the load method is also triggered by a per-page access break</p>
</blockquote>
<p>The following is the gradual growth of the pageCache, which has grown by about 1.034G in total, indicating that the contents of the file are fully loaded at this point.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 2  0      0 4824640   1056 207912    0    0     0     0 2374  195 50  0 50  0  0
 2  1      0 4605300   2676 411892    0    0 205256     0 3481 1759 52  2 34 12  0
 2  1      0 4432560   2676 584308    0    0 172032     0 2655  346 50  1 25 24  0
 2  1      0 4255080   2684 761104    0    0 176400     0 2754  380 50  1 19 29  0
 2  3      0 4086528   2688 929420    0    0 167940    40 2699  327 50  1 25 24  0
 2  2      0 3909232   2692 1106300    0    0 176520     4 2810  377 50  1 23 26  0
 2  2      0 3736432   2692 1278856    0    0 172172     0 2980  361 50  1 17 31  0
 3  0      0 3722064   2840 1292776    0    0 14036     0 2757  392 50  1 29 21  0
 2  0      0 3721784   2840 1292892    0    0   116     0 2621  283 50  1 50  0  0
 2  0      0 3721996   2840 1292892    0    0     0     0 2478  237 50  0 50  0  0
</code></pre></td></tr></table>
</div>
</div><p>Two details.</p>
<ol>
<li>the mmap mapping process can be interpreted as a lazy load, only get() will trigger a page out interrupt</li>
<li>the pre-reading size is determined by the OS algorithm and can be treated as 4kb by default, i.e. if you want lazy loading to become real-time loading, you need to iterate through it once according to step=4kb</li>
</ol>
<p>The same principle of FileChannel out-of-page interrupt, both need to use PageCache as a springboard to finish reading and writing files.</p>
<h3 id="number-of-memory-copies">Number of memory copies</h3>
<p>Many argue that mmap makes one less copy than FileChannel, but I personally think we need to differentiate between scenarios.</p>
<p>For example, if the requirement is to read an int from the first address of a file, the two links are actually the same: SSD -&gt; pageCache -&gt; application memory, and mmap does not make one less copy.</p>
<p>But if the requirement is to maintain a 100M multiplexed buffer, and it involves file IO, mmap can be used directly as a 100M buffer, instead of maintaining another 100M buffer in the process memory (user space).</p>
<h3 id="user-state-vs-kernel-state">User state vs. kernel state</h3>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/10/bdd1c63117f84268a5c3d85ac2064481.png" alt=""></p>
<p>For security reasons, the operating system encapsulates some of the underlying capabilities and provides system calls for users to use. Here is the problem of switching between &ldquo;user state&rdquo; and &ldquo;kernel state&rdquo;, and I think this is where many people&rsquo;s concepts are blurred, so I&rsquo;ll sort out my personal knowledge here.</p>
<p>Let&rsquo;s look at FileChannel first, the following two pieces of code, who do you think is faster?</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 方法一: 4kb 刷盘
</span><span class="c1"></span><span class="n">FileChannel</span> <span class="n">fileChannel</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RandomAccessFile</span><span class="o">(</span><span class="n">file</span><span class="o">,</span> <span class="s">&#34;rw&#34;</span><span class="o">).</span><span class="na">getChannel</span><span class="o">();</span>
<span class="n">ByteBuffer</span> <span class="n">byteBuffer</span> <span class="o">=</span> <span class="n">ByteBuffer</span><span class="o">.</span><span class="na">allocateDirect</span><span class="o">(</span><span class="n">_4kb</span><span class="o">);</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">_4kb</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="n">byteBuffer</span><span class="o">.</span><span class="na">put</span><span class="o">((</span><span class="kt">byte</span><span class="o">)</span><span class="n">0</span><span class="o">);</span>
<span class="o">}</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">_GB</span><span class="o">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">_4kb</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">byteBuffer</span><span class="o">.</span><span class="na">position</span><span class="o">(</span><span class="n">0</span><span class="o">);</span>
    <span class="n">byteBuffer</span><span class="o">.</span><span class="na">limit</span><span class="o">(</span><span class="n">_4kb</span><span class="o">);</span>
    <span class="n">fileChannel</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">byteBuffer</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 方法二: 单字节刷盘
</span><span class="c1"></span><span class="n">FileChannel</span> <span class="n">fileChannel</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RandomAccessFile</span><span class="o">(</span><span class="n">file</span><span class="o">,</span> <span class="s">&#34;rw&#34;</span><span class="o">).</span><span class="na">getChannel</span><span class="o">();</span>
<span class="n">ByteBuffer</span> <span class="n">byteBuffer</span> <span class="o">=</span> <span class="n">ByteBuffer</span><span class="o">.</span><span class="na">allocateDirect</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
<span class="n">byteBuffer</span><span class="o">.</span><span class="na">put</span><span class="o">((</span><span class="kt">byte</span><span class="o">)</span><span class="n">0</span><span class="o">);</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">_GB</span><span class="o">;</span> <span class="n">i</span> <span class="o">++)</span> <span class="o">{</span>
    <span class="n">byteBuffer</span><span class="o">.</span><span class="na">position</span><span class="o">(</span><span class="n">0</span><span class="o">);</span>
    <span class="n">byteBuffer</span><span class="o">.</span><span class="na">limit</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
    <span class="n">fileChannel</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">byteBuffer</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>Using method 1: 4kb buffering to swipe the disk (regular operation), it only took 1.2s to finish writing 1G on my test machine, while method 2, which does not use any buffering, was almost straightforwardly stuck, the file grew very slowly, and after waiting for 5 minutes before it was finished, the test was interrupted.</strong></p>
<p>Using a write buffer is a very classic optimization trick. Users only need to set a write buffer of 4kb integer multiples to aggregate small data writes, so that the data is swiped from the pageCache in as many integer multiples of 4kb as possible to avoid write amplification problems. But this is not the focus of this section, have you ever thought, pageCache is actually a layer of buffer itself, the actual write 1byte is not synchronized with the disk, the equivalent of writing the memory, pageCache disk by the operating system&rsquo;s own decision. Then why is method two so slow? **The main reason is that the underlying read/write associated system calls of the filechannel need to switch between kernel and user states. Method 2 switches 4096 times more than method 1, and the state switching becomes the bottleneck, resulting in a serious time consumption.</p>
<p>To summarize the key points at this stage, the act of setting user write buffers in DRAM has two implications: 1.</p>
<ol>
<li>convenient to do 4kb alignment, ssd swipe disk friendly</li>
<li>reduce the number of user state and kernel state switch, cpu friendly</li>
</ol>
<p>However, unlike mmap, the underlying mapping capability does not involve switching between kernel and user states, note that there is still nothing to do with memory copying here, and the root cause of the state not switching is the system call itself associated with mmap. It is also very easy to verify this, as we use the mmap implementation of method 2 to see how fast.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">FileChannel</span> <span class="n">fileChannel</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RandomAccessFile</span><span class="o">(</span><span class="n">file</span><span class="o">,</span> <span class="s">&#34;rw&#34;</span><span class="o">).</span><span class="na">getChannel</span><span class="o">();</span>
<span class="n">MappedByteBuffer</span> <span class="n">map</span> <span class="o">=</span> <span class="n">fileChannel</span><span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">MapMode</span><span class="o">.</span><span class="na">READ_WRITE</span><span class="o">,</span> <span class="n">0</span><span class="o">,</span> <span class="n">_GB</span><span class="o">);</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">_GB</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
		<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">((</span><span class="kt">byte</span><span class="o">)</span><span class="n">0</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>On my test machine, it took 3s, which is slower than a FileChannel + 4kb buffered write, but far faster than a FileChannel writing a single byte.</p>
<h2 id="mmap-details-added">mmap details added</h2>
<h3 id="copy-on-write-mode">copy on write mode</h3>
<p>We notice that the first parameter of <code>public abstract MappedByteBuffer map(MapMode mode, long position, long size)</code>, MapMode, actually has three values, and when surfing the web, we hardly find any articles explaining MapMode. MapMode has three enumerated values <code>READ_WRITE</code>, <code>READ_ONLY</code>, <code>PRIVATE</code>, most of the time the one used is probably <code>READ_WRITE</code>, while <code>READ_ONLY</code> is just a restriction of <code>WRITE</code>, which is easy to understand, but this <code>PRIVATE</code> seems to have a mysterious veil on it. But this <code>PRIVATE</code> seems to have a veil of mystery.</p>
<p>In fact, the <code>PRIVATE</code> mode is the copy on write mode of mmap, and when using MapMode.</p>
<ol>
<li>any other modifications to the file will be directly reflected in the current mmap map. 2.</li>
<li>private mmap&rsquo;s own put behavior afterwards will trigger a copy, forming its own copy, and any changes will not be swiped to the file and will no longer sense changes to that page of the file.</li>
</ol>
<p>Commonly known as: copy on write.</p>
<p>What is the point of this? The point is that any changes will not be swiped back to the file. For one thing, you get a copy of the file, and if you happen to need it, you can use PRIVATE mode to map it directly, and for another, it&rsquo;s a little exciting because you get a real PageCache and don&rsquo;t have to worry about it being overhead by the OS swiping the disk. The remaining 1G can only be used by the kernel state, and if you want to use it for user state programs, you can use the copy on write mode of mmap, which will not take up your in-heap or out-of-heap memory.</p>
<h3 id="reclaiming-mmap-memory">Reclaiming mmap memory</h3>
<p>To correct an error in a previous blog post about mmap memory recycling, recycling mmap is simple</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="o">((</span><span class="n">DirectBuffer</span><span class="o">)</span> <span class="n">mmap</span><span class="o">).</span><span class="na">cleaner</span><span class="o">().</span><span class="na">clean</span><span class="o">();</span>
</code></pre></td></tr></table>
</div>
</div><p>The life of an mmap can be simply divided into: map (mapping), get/load (missing page interrupt), and clean (recycling). A useful trick is to dynamically allocate memory map areas that can be reclaimed asynchronously after they have been read.</p>
<h2 id="mmap-usage-scenarios">mmap usage scenarios</h2>
<h3 id="using-mmap-to-handle-frequent-reads-and-writes-of-small-data">Using mmap to handle frequent reads and writes of small data</h3>
<p>If IO is very frequent but data is very small, it is recommended to use mmap to avoid tangent problems caused by FileChannel. For example, appending writes to index files.</p>
<h3 id="mmap-caching">mmap caching</h3>
<p>When using FileChannel for file reads and writes, a piece of write cache is often needed for aggregation purposes, most often using in-heap/out-of-heap memory, but they both have the problem that when the process hangs, the in-heap/out-of-heap memory is immediately lost, and this part of the data that did not fall on the disk is lost. Using mmap as a cache, on the other hand, stores directly in the pageCache and does not result in data loss, although this only circumvents the process being killed, not the power loss.</p>
<h3 id="reading-and-writing-small-files">Reading and writing small files</h3>
<p>Contrary to many statements on the web, mmap is particularly suitable for sequential reading and writing due to its non-tangent state, but due to the size limitation in <code>sun.nio.ch.FileChannelImpl#map(MapMode mode, long position, long size)</code>, only an int value can be passed, so If 2G is used as the threshold for large or small files, it is generally advantageous to use mmap to read and write files smaller than 2G. This is also exploited in RocketMQ, where the commitLog size is sliced by 1G to make it easier to use mmap. By the way, I forgot to mention that RocketMQ and other message queues use mmap all the time.</p>
<h3 id="reads-and-writes-in-a-cpu-crunch">Reads and Writes in a cpu crunch</h3>
<p>In most scenarios, the combination of a FileChannel and a read/write buffer has an advantage over mmap, or a tie, but in cpu-critical reads and writes, using mmap for reads and writes is often optimized, based on the fact that mmap does not overwhelm the cpu with user-state and kernel-state switching (but then takes on the overhead of dynamic mapping and asynchronous memory reclamation).</p>
<h3 id="special-hardware-and-software-factors">Special hardware and software factors</h3>
<p>For example, persistent memory Pmem, different generations of SSDs, different CPUs, different cores, different file systems, different file system mounts, etc. all affect the speed of mmap and filechannel read/write, because they correspond to different system calls. Only after benchmarking will we know how fast or slow they are.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/java/">java</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2021-12/grafana-k8s-plugin-kubegraf/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Excellent Grafana K8S Plugin - DevOpsProdigy KubeGraf</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2021-12/whys-the-design-dns-udp-tcp/">
            <span class="next-text nav-default">Why DNS uses the UDP protocol</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
