<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Understanding HTTPS principles, SSL/TLS protocols in detail - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Introduction to SSL/TLS When we use the HTTP protocol, the data transmitted is insecure, because all data going to and from the client and the server is in plaintext:.
 Third parties can get access to the real data Third parties can tamper with the data Third parties can impersonate the server or client  The full name of HTTPS is Hypertext Transfer Protocol Secure, which is used to exchange information securely (secure communication) between two end systems on a computer network, which is equivalent to adding a Secure secure word eye to HTTP, then we can give a HTTPS definition: HTTPS is a protocol and specification for secure transmission of text, images, audio, video and other hypertext data between two points in the computer world." /><meta name="keywords" content="https, ssl, tls" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2021-12/https-ssl-tls/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Understanding HTTPS principles, SSL/TLS protocols in detail" />
<meta property="og:description" content="Introduction to SSL/TLS When we use the HTTP protocol, the data transmitted is insecure, because all data going to and from the client and the server is in plaintext:.
 Third parties can get access to the real data Third parties can tamper with the data Third parties can impersonate the server or client  The full name of HTTPS is Hypertext Transfer Protocol Secure, which is used to exchange information securely (secure communication) between two end systems on a computer network, which is equivalent to adding a Secure secure word eye to HTTP, then we can give a HTTPS definition: HTTPS is a protocol and specification for secure transmission of text, images, audio, video and other hypertext data between two points in the computer world." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2021-12/https-ssl-tls/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-12-14T16:10:13+08:00" />
<meta property="article:modified_time" content="2021-12-14T16:10:13+08:00" />

<meta itemprop="name" content="Understanding HTTPS principles, SSL/TLS protocols in detail">
<meta itemprop="description" content="Introduction to SSL/TLS When we use the HTTP protocol, the data transmitted is insecure, because all data going to and from the client and the server is in plaintext:.
 Third parties can get access to the real data Third parties can tamper with the data Third parties can impersonate the server or client  The full name of HTTPS is Hypertext Transfer Protocol Secure, which is used to exchange information securely (secure communication) between two end systems on a computer network, which is equivalent to adding a Secure secure word eye to HTTP, then we can give a HTTPS definition: HTTPS is a protocol and specification for secure transmission of text, images, audio, video and other hypertext data between two points in the computer world."><meta itemprop="datePublished" content="2021-12-14T16:10:13+08:00" />
<meta itemprop="dateModified" content="2021-12-14T16:10:13+08:00" />
<meta itemprop="wordCount" content="9082">
<meta itemprop="keywords" content="https,ssl,tls," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Understanding HTTPS principles, SSL/TLS protocols in detail"/>
<meta name="twitter:description" content="Introduction to SSL/TLS When we use the HTTP protocol, the data transmitted is insecure, because all data going to and from the client and the server is in plaintext:.
 Third parties can get access to the real data Third parties can tamper with the data Third parties can impersonate the server or client  The full name of HTTPS is Hypertext Transfer Protocol Secure, which is used to exchange information securely (secure communication) between two end systems on a computer network, which is equivalent to adding a Secure secure word eye to HTTP, then we can give a HTTPS definition: HTTPS is a protocol and specification for secure transmission of text, images, audio, video and other hypertext data between two points in the computer world."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Understanding HTTPS principles, SSL/TLS protocols in detail</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-12-14 16:10:13 </span>
        <div class="post-category">
            <a href="/categories/skills/"> skills </a>
            </div>
          <span class="more-meta"> 9082 words </span>
          <span class="more-meta"> 43 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#introduction-to-ssltls">Introduction to SSL/TLS</a>
          <ul>
            <li><a href="#the-design-goal-of-tls">The design goal of TLS</a></li>
          </ul>
        </li>
        <li><a href="#principle-of-tls">Principle of TLS</a>
          <ul>
            <li><a href="#cryptographic-communication-protocol-architecture-top-down-layered-abstraction">Cryptographic communication protocol architecture: top-down, layered abstraction</a></li>
            <li><a href="#tls-ciphersuite">TLS CipherSuite</a></li>
            <li><a href="#architecture-of-the-tls-protocol">Architecture of the TLS protocol</a></li>
            <li><a href="#tls-handshake-protocol">TLS Handshake Protocol</a></li>
            <li><a href="#tls-logging-protocol">TLS logging protocol</a></li>
            <li><a href="#digital-certificates">Digital certificates</a></li>
          </ul>
        </li>
        <li><a href="#tls-13-vs-tls-12">TLS 1.3 vs TLS 1.2</a>
          <ul>
            <li><a href="#faster-access-speed">Faster access speed</a></li>
            <li><a href="#stronger-security">Stronger Security</a></li>
            <li><a href="#tls-13-specific-changes">TLS 1.3 specific changes</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="introduction-to-ssltls">Introduction to SSL/TLS</h2>
<p>When we use the HTTP protocol, the data transmitted is insecure, because all data going to and from the client and the server is in plaintext:.</p>
<ul>
<li>Third parties can get access to the real data</li>
<li>Third parties can tamper with the data</li>
<li>Third parties can impersonate the server or client</li>
</ul>
<p>The full name of HTTPS is Hypertext Transfer Protocol Secure, which is used to exchange information securely (secure communication) between two end systems on a computer network, which is equivalent to adding a Secure secure word eye to HTTP, then we can give a HTTPS definition: HTTPS is a protocol and specification for secure transmission of text, images, audio, video and other hypertext data between two points in the computer world. HTTPS is an extension of the HTTP protocol, which does not guarantee the security of the transmission itself, so who guarantees the security? In HTTPS, the communication protocol is encrypted using Transport Layer Security (TLS) or Secure Sockets Layer (SSL). That is, HTTP + SSL(TLS) = HTTPS.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/14/36f6d41564b74715a86df6a331e01c6b.png" alt=""></p>
<p>SSL (Secure Sockets Layer) and TLS (Transport Layer Security) were designed by Netscape as secure transport protocols for the Web. The first versions of SSL (SSL 1.0, SSL 2.0, SSL 3.0) were designed and maintained by Netscape, and starting with version 3.1, the SSL protocol was officially taken over by the Internet Engineering Task Force (IETF) and renamed TLS. From version 3.1, the SSL protocol was officially taken over by the Internet Engineering Task Force (IETF) and renamed as TLS (Transport Layer Security), which has been developed into TLS 1.0, TLS 1.1, TLS 1.2 and TLS 1.3.</p>
<ul>
<li>In 1994, NetScape designed SSL 1.0</li>
<li>In 1995, SSL 2.0, with serious vulnerabilities</li>
<li>In 1996, SSL 3.0, which was adopted on a large scale</li>
<li>In 1999, the IETF standardized on SSL and released TLS 1.0</li>
<li>In 2006 and 2008, TLS was upgraded twice, to TLS 1.1 and TLS 1.2</li>
<li>In 2018, TLS 1.3 was published as a recommended standard in <a href="https://www.rfc-editor.org/info/rfc8446">RFC 8446</a></li>
</ul>
<p>Since the 2 versions of SSL have been retired from history, only the name TLS is used later. The reader should understand that what is generally referred to as SSL is TLS.</p>
<p>SSL is a separate protocol that can be used not only by HTTP, but also by other application layer protocols such as SMTP (email protocol), Telnet (remote login protocol), etc.</p>
<h3 id="the-design-goal-of-tls">The design goal of TLS</h3>
<p>The design goal of TLS is to build a secure transport layer (Transport Layer Security) that provides, on top of a connection-based transport layer (such as tcp).</p>
<ul>
<li>cryptographic security
<ul>
<li>confidentiality, message privacy (confidentiality is achieved by encryption, where all messages are transmitted encrypted and cannot be eavesdropped on by third parties)</li>
<li>integrity, message integrity (through the MAC verification mechanism, once tampered with, both sides of the communication will immediately detect)</li>
<li>authentication, mutual authentication (both sides can be equipped with certificates to prevent identity impersonation)</li>
</ul>
</li>
<li>interoperability, universal (according to the public rfc, any rfc-compliant software implementation can interoperate, not limited by any proprietary technology)</li>
<li>Extensibility (there are a large number of new features that can be added through the extension mechanism tls_ext)</li>
<li>high efficiency (through session cache, after proper deployment of cache, tls is highly efficient)</li>
</ul>
<p><strong>How do I determine the version of TSL used on my website?</strong></p>
<p>In your browser, press F12 to bring up the debug window and select the Security TAB to see something like the following.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/14/79fe093729c0499e958f14aee1ba4a9c.png" alt=""></p>
<h2 id="principle-of-tls">Principle of TLS</h2>
<h3 id="cryptographic-communication-protocol-architecture-top-down-layered-abstraction">Cryptographic communication protocol architecture: top-down, layered abstraction</h3>
<p>A common way to build software is layered, abstracting the problem domain into multiple layers, with each layer&rsquo;s concepts defined as a set of primitives that are implemented by the previous layer using the components of the next layer to construct and be used by the previous layer, and the layers are stacked to form software.</p>
<ul>
<li>For example, in the programming language domain, assembly language is a layer, above assembly is a static compiled language such as C/C++, above C/C++ is a dynamically typed scripting language layer such as python/php/lua, and above that often domain-specific DSLs are constructed</li>
<li>In network architecture, Ethernet is a layer on top of which is the network layer of the ip protocol, above ip is the transport layer such as tcp, and above tcp is the application layer such as http</li>
</ul>
<p>Cryptographic communication protocols are also constructed in layers to obtain. The layers can be roughly divided as follows.</p>
<ul>
<li>The bottom layer is the implementation of the basic algorithm language, such as: aes , rsa, md5, sha256, ecdsa, ecdh, etc.</li>
<li>The top layer is the implementation of the standard cryptographic algorithms with selected parameters, including block encryption algorithms, signature algorithms, asymmetric encryption algorithms, MAC algorithms, etc., such as: aes-128-cbc-pkcs7, rsaes-oaep, rsassa-pkcs1-v1_5, hmac-sha256, ecdsa-p256, curve25519, etc.</li>
<li>On top of that, it is a semi-finished component that combines multiple standard algorithms, for example: symmetric transport components such as aes-128-cbc + hmac-sha256, aes-128-gcm, authentication key negotiation algorithm: rsassa-OAEP + ecdh-secp256r1, digital envelope: rsaes-oaep + aes-cbc -128 + hmac-sha256, file password encryption storage component: pbkdf2 + aes-128-cbc-hmac-sha256, key extension algorithm PRF-sha256, etc.</li>
<li>On top of that, there are various finished cryptographic protocols/software assembled with various components, such as: tls protocol, ssh protocol, srp protocol, gnupg file format, iMessage protocol, bitcoin protocol, etc.</li>
</ul>
<p>For each layer.</p>
<ul>
<li>Layer 1, which is generally understood by programmers, such as rsa, is simply known to everyone; md5 is widely used (and, of course, widely misused)</li>
<li>Layer 2, a variety of inexplicable parameters, generally very baffling to programmers, need to study in depth to sort out.</li>
<li>Layer 3, many programmers build their own wheels, often to be frank, is just trying to repeat the implementation of a component of layer 3.</li>
<li>Layer 4, properly understanding, using, and deploying such mature open protocols, is not so easy. A lot of misuse comes from a lack of understanding and requires a background knowledge of cryptography to figure out what, why, and how it works.</li>
</ul>
<p>In layer 2, cryptographic algorithms, the following categories are common.</p>
<ul>
<li>block cipher: AES, Serpent, etc.</li>
<li>Stream cipher: RC4, ChaCha20, etc.</li>
<li>Hash functions: MD5, sha1, sha256, sha512 , ripemd 160, poly1305, etc.</li>
<li>message authentication code: HMAC-sha256, AEAD, etc.</li>
<li>key exchange: DH, ECDH, RSA, PFS method (DHE, ECDHE), etc.</li>
<li>public-key encryption: RSA, rabin-williams, etc.</li>
<li>signature algorithm: RSA, DSA, ECDSA (secp256r1 , ed25519), etc.</li>
<li>key derivation function: TLS-12-PRF(SHA-256), bcrypto, scrypto, pbkdf2, etc.</li>
<li>random number generators: /dev/urandom etc.</li>
</ul>
<p>The process of designing a cryptographic communication protocol is a top-down process of selecting various components and assembling them into a complete protocol</p>
<h3 id="tls-ciphersuite">TLS CipherSuite</h3>
<p>From the above layered perspective, TLS is roughly spelled out in 3 components.</p>
<ul>
<li>Symmetric encrypted transport component, e.g. aes-128-gcm (these are examples of the most dominant choices currently available in 2015);</li>
<li>an authentication key negotiation component, e.g. rsa-ecdhe;</li>
<li>key extension components, e.g. TLS-PRF-sha256</li>
</ul>
<p>These components can be subdivided into 5 classes of algorithms, which in TLS are combined together in a CipherSuite: the</p>
<ul>
<li>authentication (authentication algorithm)</li>
<li>encryption (encryption algorithm)</li>
<li>message authentication code (Message Authentication Code algorithm, MAC)</li>
<li>key exchange (key exchange algorithm)</li>
<li>key derivation function</li>
</ul>
<p>The TLS protocol was designed with the evolution of each of these algorithms in mind, so instead of fixing the algorithm, an algorithm negotiation process was designed to allow the addition of new algorithms, and the negotiated combination of algorithms, a CipherSuite TLS CipherSuite, is registered in the iana set. for identification, which can be viewed at <a href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-4">iana&rsquo;s registration page</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/14/3f0d7fb1fa24458bbb832cbc605cfd68.png" alt=""></p>
<p>The list of supported CipherSuite on the server side, if openssl is used, can be viewed with the openssl ciphers -V | column -t command, the output is as follows</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/14/483e71893819426eb07aa051da45820b.png" alt=""></p>
<h3 id="architecture-of-the-tls-protocol">Architecture of the TLS protocol</h3>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/14/2a563ba7f5b04a21a97b45d95d34dc93.png" alt=""></p>
<p>The main purpose of TLS (Transport Layer Security Protocol) is to provide privacy and data integrity between two communicating applications. The protocol consists of two layers: the TLS Record protocol and the TLS Handshake protocol.</p>
<ul>
<li>The bottom layer is the TLS Record protocol, which is primarily responsible for encrypting messages using symmetric ciphers.</li>
<li>The upper layer is the TLS Handshake protocol, which is divided into four parts: the handshake protocol, the cipher specification change protocol, and the application data protocol.
<ul>
<li>The handshake protocol is responsible for agreeing on the cryptographic algorithm and shared key on the client and server side, including certificate authentication, and is the most complex part of the 4 protocols.</li>
<li>The cryptographic specification change protocol is responsible for signaling a change in cryptographic method to the communicating object (somewhat redundant and has been removed in 3)</li>
<li>The warning protocol is responsible for communicating errors to the other party in the event of an error</li>
<li>The application data protocol is responsible for communicating the application data carried by TLS to the communicating object.</li>
</ul>
</li>
</ul>
<p>This structure of authenticated key negotiation + symmetric encrypted transport is common to most encrypted communication protocols.</p>
<h3 id="tls-handshake-protocol">TLS Handshake Protocol</h3>
<p>Before communicating with SSL, the handshake protocol of SSL is first used to shake hands at both ends of the communication, negotiate the relevant security parameters to be used in the data transmission (e.g. encryption algorithm, shared key, materials required to generate the key, etc.), and to authenticate the identity of the other end.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/14/53c7a984f85e4cd087ab9cadfa57a04e.png" alt=""></p>
<p>The SSL build process has a total of 13 packets, with at least 9 packets required for the first build.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/14/b240c9edb87743e389298ce01361bada.png" alt=""></p>
<p><strong>SSL establishes the first stage: the client first sends a ClientHello message to the server, the server receives the ClientHello message, and then sends a ServerHello message in response to the client.</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/14/cf5d476025884cf79532d744828d5bf8.png" alt=""></p>
<p><strong>ClientHello</strong></p>
<p>The first step of the handshake is for the client to send a Client Hello message to the server, which contains a client-generated random number Random1, the encryption suite supported by the client (Support Ciphers), and the SSL Version, among other information.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/14/378f4b453b9c489e9b485ee0ab207851.png" alt=""></p>
<p>The messages involved in ClientHello are specified as follows.</p>
<ul>
<li>Client Version: lists the protocol versions supported by the client by priority, preferring the latest protocol version that the client wishes to support.</li>
<li>Client random numberRandom</li>
<li>Session ID (Session id): If the client connects to the server for the first time, then this field will remain empty. The field is empty in the above image, indicating that this is the first time connecting to the server. If the field is not empty, it means that there was a previous connection to the server, during which time the server will use the Session ID to map the symmetric key and store the Session ID in the client browser, setting a time limit for the mapping. If the browser connects to the same server in the future (before the time limit expires), it will send the Session ID and the server will verify the mapped Session ID and use the previously used symmetric key to recover the Session, no full handshake is required in this case. Also called as SSL session recovery. It will be described later.</li>
<li>Cipher suites: The client sends the server a list of cipher suites it already knows, this is prioritized by the client but it is entirely up to the server to decide whether to send them or not. there is a standard format for the cipher suites used in TLS. In the above message, the client sends 74 cipher suites. The server will select one of them to be the common cipher suite for both sides.</li>
<li>Compression method: Compression is possible in order to reduce bandwidth. However, from the examples of successful attacks on TLS, where the attack when using compression can capture the parameters sent with HTTP hair, this attack can hijack cookies, a vulnerability we call CRIME. since TLS 1.3, the protocol has disabled TLS compression.</li>
<li>Extension packets: Other parameters (such as server name, padding, supported signature algorithms, etc.) can be used as extensions.</li>
</ul>
<p>These are part of the client greeting. If the client greeting has been received, the next step is the server acknowledgement and the server will send the server greeting.</p>
<p><strong>ServerHello</strong></p>
<p>After receiving the client hello the server must send a server hello message, the server checks the conditions of the client hello specifying things like TLS version and algorithm, if the server accepts and supports all the conditions it will send its certificate and other details, otherwise the server will send a handshake failure message.</p>
<p>If accepted, the second step is for the server to send a Server Hello message to the client, which determines a cipher suite from the Support Ciphers passed from the Client Hello, which determines which algorithms are used for subsequent encryption and digest generation, and also generates a random number, Random2. Note that both the client and server have two random numbers (Random1+ Random2), which will be used in the subsequent generation of the symmetric secret key.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/14/a0344c3fee0044438a210c087a26a26e.png" alt=""></p>
<p>The specific parameters involved in ServerHello.</p>
<ul>
<li>ServerVersion: The server will select the latest version supported by the client.</li>
<li>ServerRandom: Both server and client will generate a 32-byte random number. This is used to create the encryption key.</li>
<li>Encryption Suite: The server will select an encryption suite from the list of encryption suites sent by the client.</li>
<li>Session ID: The server stores the agreed Session parameters in the TLS cache and generates the Session id corresponding to it. it is sent to the client along with the Server Hello. The client can write the agreed parameters to this Session id with a given expiration time. If the client connects to the server again before this expiration time, the server can check the cached parameters corresponding to the Session id and reuse them without a full handshake. This is very useful because both the server and the client can save a lot of computational costs. There are drawbacks to this approach when it comes to applications with huge traffic such as Amazon and Google. Millions of people connect to the server every day, and the server must keep a TLS cache of all Session parameters using Session keys. This is a huge overhead. To solve this problem, Session Tickets were added to the extension package, where the client can specify in the client hello whether it supports Session Tickets. the server will then create a new Session Ticket with a private key encrypted with only the server&rsquo;s knowledge of the Session parameters. It will be stored on the client, so all Session data is stored only on the client computer, but the Ticket is still secure, because the key is known only to the server. This data can be included in the Client Hello as an extension named Session Ticket.</li>
<li>Compression algorithm: if supported, the server will agree to the client&rsquo;s preferred compression method.</li>
<li>Extended Package</li>
</ul>
<p>After this phase, the following is known to the client server.</p>
<ul>
<li>SSL version</li>
<li>Key exchange, message authentication and encryption algorithms</li>
<li>Compression method</li>
<li>Two random numbers about the key generation.</li>
</ul>
<p><strong>SSL establishes the second phase: the server sends a message to the client.</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/14/ff36cda352b243789352310ffa1af757.png" alt=""></p>
<p>The server initiates SSL handshake phase 2 and is the sole sender of all messages in this phase and the client is the sole recipient of all messages. This phase is divided into 4 steps.</p>
<ul>
<li>Certificate: The server sends the digital certificate and the entire chain to the root CA to the client, enabling the client to authenticate the server with the server public key in the server certificate.</li>
<li>Server key exchange (optional): Here it depends on the key exchange algorithm</li>
<li>Certificate request: The server may ask the client to authenticate itself.</li>
<li>Server handshake completion: the end of phase 2 and the signal for the start of phase 3</li>
</ul>
<p><strong>Certificate message (optional) - certificate is required for the first establishment</strong></p>
<p>This message is normally required to be included in the full flow of the SSL handshake, except that it is not required to be sent when the session resumes. The message contains an X.509 certificate, which contains the public key and is sent to the client to verify the signature or to encrypt the message during the key exchange.</p>
<p>This is the step where the server sends its certificate to the client to verify its identity, and the client verifies that it has passed and removes the public key from the certificate.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/14/5cb81777115848f1ac3a0d1dd0ada545.png" alt=""></p>
<p><strong>Server Key Exchange (optional)</strong></p>
<p>Based on the CipherSuite information previously included in the ClientHello message, which determines the key exchange method (e.g. RSA or DH), the Server Key Exchange message contains a set of parameters required to complete the key exchange.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/14/49feffe050f14aae835c424eef6de421.png" alt=""></p>
<p>Because this is a DH algorithm, it is necessary to send the DH parameters used by the server. the RSA algorithm does not require this step.</p>
<p>In Diffie-Hellman, the client cannot compute the premaster key itself; both parties help to compute it, so the client needs to obtain the Diffie-Hellman public key from the server.</p>
<p>As can be seen from the above diagram, the key exchange is also protected by signatures at this point.</p>
<p><strong>Certificate Request (optional) - can be a one-way authentication or a two-way authentication</strong></p>
<p>This step is optional and may be used if there is a high demand for security in common. The server is used to authenticate the client. The server side sends a Certificate Request message, asking the client to send his own certificate for verification. The message contains the certificate types supported by the server side (RSA, DSA, ECDSA, etc.) and a list of all CAs trusted by the server side as certificate issuers, and the client will use this information to filter the certificates.</p>
<p><strong>Server Hello Done</strong></p>
<p>This message indicates that the server has sent all the information and is waiting for a message from the client next.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/14/f138a7a6adcf42a79dc88be03dfea16c.png" alt=""></p>
<p><strong>SSL establishes the third phase: the client receives a series of messages from the server and parses them, then sends the corresponding messages from this end to the server.</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/14/0399eff46e6046b09a252ca1e1f2e75c.png" alt=""></p>
<p>The client initiates SSL handshake phase 3 and is the sole sender of all messages in this phase and the server is the sole recipient of all messages. This phase is divided into 3 steps.</p>
<ul>
<li>Certificate (optional): In order to prove itself to the server, the client has to send a certificate message, this is optional and can be configured in IIS to force client certificate authentication.</li>
<li>Client key exchange (Pre-master-secret): Here the client sends the prepared master key to the server, note that the server&rsquo;s public key will be used here for encryption.</li>
<li>Certificate verification (optional), sign the prepared secret and random number to prove the possession of (a) the public key of the certificate.</li>
</ul>
<p><strong>Certificate (optional)</strong></p>
<p>If in the second phase the server-side asks for a client certificate, the client sends its own certificate in that phase. The server-side Certificate Request message sent earlier contains a list of certificate types and CAs supported by the server-side, so the client will choose the first certificate among its own that meets these two conditions and send it. If the client does not have a certificate, a no_certificate warning is sent.</p>
<p><strong>Client Key exchange</strong></p>
<p>If the client does not have a certificate, it sends a no_certificate warning.</p>
<p>If it is RSA algorithm, a 48-byte random number will be generated and then encrypted with the server&rsquo;s public key and put into the message. If it is DH algorithm, this is the DH parameter sent to the client, and then the server and the client each calculate the same pre-master secret according to the DH algorithm.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/14/c7762fc4b5ce48dabb1204207419ed84.png" alt=""></p>
<p>This message is sent to the server using the server&rsquo;s public key encryption. The server decrypts it with its own private key to get the pre-master key.(Prove to the server that it does hold the client certificate private key.)</p>
<p><strong>Certificate verify (optional)</strong></p>
<p>This message needs to be sent only if the client has sent its own certificate to the server side. It contains a signature that signs the HMAC value (with master_secret) of all handshake messages since the first message.</p>
<p><strong>SSL Establishment Phase 4: The handshake protocol is completed and the SSL connection is established.</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/14/ab960e988e134f46bcdd61b1d251daf1.png" alt=""></p>
<p>The client initiates SSL handshake phase 4, which brings the server to an end. This phase is divided into 4 steps, with the first 2 messages coming from the client and the last 2 messages coming from the server.</p>
<p>A secure connection is established, the client sends a Change Cipher Spec message and copies the negotiated CipherSuite into the current connection state. Then, the client sends a Finished message with the new algorithm, key parameters, which checks whether the key exchange and authentication process has been successful. It includes a checksum value that verifies the message for the entire handshake process of the client. The server also sends a Change Cipher Spec message and a Finished message. The handshake process is complete and the client and server can exchange application layer data for communication.</p>
<p><strong>ChangeCipherSpec</strong></p>
<p>Notification of a change in encoding, indicating that all subsequent messages will be sent with the mutually agreed encryption method and key (ChangeCipherSpec is a separate protocol, embodied in the packet as a single byte of data, used to inform the server that the client has switched to the state of the previously negotiated Cipher Suite and is ready to encrypt the data and transmit it using the previously negotiated Cipher Suite).</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/14/9aa76a2be5b849d88d657aba7d632e27.png" alt=""></p>
<p><strong>Clinet Finished</strong></p>
<p>A client handshake completion notification, indicating that the client&rsquo;s handshake phase has ended. This item is also the hash value of all the content sent earlier, and is used by the server for verification (the HMAC algorithm is used to calculate the digest of all the handshake messages received and sent, and then a pseudo-function <a href="http://tools.ietf.org/html/rfc5246#section-5">PRF</a> defined in RFC 5246 is used to The result is computed, encrypted and sent. (This data is to verify the encryption and decryption channel just established by the handshake before the official transmission of the application data.)</p>
<p><strong>Server Finished</strong></p>
<p>Notification of the end of the server-side handshake.</p>
<ul>
<li>Use the private key to decrypt the encrypted Pre-Master data, based on the two plaintext random numbers random_C and random_S exchanged before (Client Hello and Server Hello), and calculate the negotiation key:enc_key=Fuc(random_C, random_S, Pre-Master) ;</li>
<li>Calculate the hash value of all previously received messages, then decrypt the encrypted_handshake_message sent by the client to verify the correctness of the data and key;</li>
<li>Send a ChangeCipherSpec (informing the client that it has switched to the negotiated encryption suite state and is ready to encrypt the data using the encryption suite and Session Secret)</li>
<li>The server also encrypts a Finish message to the client using Session Secret to verify the success of the encryption and decryption channel previously established by the handshake.</li>
</ul>
<p>According to the previous handshake information, if both the client and the server can encrypt and decrypt the Finish message normally and the message is verified correctly, the handshake channel has been established successfully, and then both parties can use the Session Secret generated above to encrypt the data for transmission.</p>
<h3 id="tls-logging-protocol">TLS logging protocol</h3>
<p>The TLS logging protocol is responsible for message compression, encryption and data authentication.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/14/361d36a08cd44c1f841a402c4744707f.png" alt=""></p>
<p>The message is first segmented, then compressed, its message authentication code is calculated, and then encrypted using a symmetric cipher, which uses the CBC mode, the initial vector of which is generated by the master cipher. After the ciphertext is obtained, other information such as type, version and length are appended to make up the final message data.</p>
<p>The record protocol does symmetric encryption of application data and accounts for the majority of the traffic on a TLS connection.</p>
<p>Record protocol - accepts data from the application layer and does:</p>
<ul>
<li>fragmentation, and in the reverse direction, reassembly</li>
<li>Sequence number generation, which generates a unique number for each data block to prevent it from being replayed or reordered</li>
<li>Compression, an optional step that uses the compression algorithm negotiated by the handshake protocol to do the compression</li>
<li>Encryption, using the key negotiated by the handshake protocol to do encryption/decryption</li>
<li>Calculate HMAC, calculate HMAC on the data and verify the correctness of the HMAC of the received packet</li>
<li>Send to tcp/ip, send data to TCP/IP for transmission (or other ipc mechanism).</li>
</ul>
<p><strong>SecurityParameters</strong></p>
<p>The above processing at the record layer is based entirely on the following parameters in SecurityParameters.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="p">{</span>
    <span class="n">ConnectionEnd</span>          <span class="n">entity</span><span class="p">;</span>
    <span class="n">PRFAlgorithm</span>           <span class="n">prf_algorithm</span><span class="p">;</span>
    <span class="n">BulkCipherAlgorithm</span>    <span class="n">bulk_cipher_algorithm</span><span class="p">;</span>
    <span class="n">CipherType</span>             <span class="n">cipher_type</span><span class="p">;</span>
    <span class="n">uint8</span>                  <span class="n">enc_key_length</span><span class="p">;</span>
    <span class="n">uint8</span>                  <span class="n">block_length</span><span class="p">;</span>
    <span class="n">uint8</span>                  <span class="n">fixed_iv_length</span><span class="p">;</span>
    <span class="n">uint8</span>                  <span class="n">record_iv_length</span><span class="p">;</span>
    <span class="n">MACAlgorithm</span>           <span class="n">mac_algorithm</span><span class="p">;</span>
    <span class="n">uint8</span>                  <span class="n">mac_length</span><span class="p">;</span>
    <span class="n">uint8</span>                  <span class="n">mac_key_length</span><span class="p">;</span>
    <span class="n">CompressionMethod</span>      <span class="n">compression_algorithm</span><span class="p">;</span>
    <span class="n">opaque</span>                 <span class="n">master_secret</span><span class="p">[</span><span class="mi">48</span><span class="p">];</span>
    <span class="n">opaque</span>                 <span class="n">client_random</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
    <span class="n">opaque</span>                 <span class="n">server_random</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
<span class="p">}</span> <span class="n">SecurityParameters</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>The record layer uses the above SecurityParameters to generate the following 6 parameters (not all CipherSuite&rsquo;s need all 6, if they don&rsquo;t, they are empty):</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">client write MAC key
server write MAC key
client write encryption key
server write encryption key
client write IV
server write IV
</code></pre></td></tr></table>
</div>
</div><p>When the handshake is complete and the above 6 parameters are generated, the connection state can be established. In addition to the above SecurityParameters, the connection state has the following parameters and updates the following parameters as data is sent/received.</p>
<ul>
<li>compression state : The state of the current compression algorithm.</li>
<li>cipher state : the current state of the encryption algorithm, for block encryption algorithms such as aes, it contains the round key generated by cipher preprocessing (thanks to Dr. Wen for pointing it out) &ldquo;round key&rdquo;, and IV, etc.; for stream encryption, it contains the state information that allows the stream encryption to continue to encrypt and decrypt</li>
<li>sequence number : each connection state contains a sequence number, and there are different sequence numbers for read and write states. sequence number must be set to sequence number when the connection starts transferring data. sequence number is of type uint64 and must not exceed 264-1. Sequence number must not be looped back. If a TLS implementation cannot avoid bypassing a sequence number, it MUST renegotiate. sequence number is incremented by 1 each time a record is sent. and the first Record transmitted MUST use 0 as the sequence number.</li>
</ul>
<p><strong>record layer segmentation</strong></p>
<p>The data stream to be sent is first segmented, as shown above, into the following format.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">struct</span> <span class="p">{</span>
    <span class="n">uint8</span> <span class="n">major</span><span class="p">;</span>
    <span class="n">uint8</span> <span class="n">minor</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ProtocolVersion</span><span class="p">;</span>

<span class="k">enum</span> <span class="p">{</span>
    <span class="n">change_cipher_spec</span><span class="p">(</span><span class="mi">20</span><span class="p">),</span> <span class="n">alert</span><span class="p">(</span><span class="mi">21</span><span class="p">),</span> <span class="n">handshake</span><span class="p">(</span><span class="mi">22</span><span class="p">),</span>
    <span class="n">application_data</span><span class="p">(</span><span class="mi">23</span><span class="p">),</span> <span class="p">(</span><span class="mi">255</span><span class="p">)</span>
<span class="p">}</span> <span class="n">ContentType</span><span class="p">;</span>

<span class="k">struct</span> <span class="p">{</span>
    <span class="n">ContentType</span> <span class="n">type</span><span class="p">;</span>
    <span class="n">ProtocolVersion</span> <span class="n">version</span><span class="p">;</span>
    <span class="n">uint16</span> <span class="n">length</span><span class="p">;</span>
    <span class="n">opaque</span> <span class="n">fragment</span><span class="p">[</span><span class="n">TLSPlaintext</span><span class="p">.</span><span class="n">length</span><span class="p">];</span>
<span class="p">}</span> <span class="n">TLSPlaintext</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>version field: defines the current negotiated TLS protocol version, for example, TLS 1.2 version is { 3, 3 }</li>
<li>length field: that is, the length, tls protocol stipulates that the length must be less than 214, generally we do not want the length too long, because the decryption side needs to receive the whole record, in order to decrypt, the length is too long will lead to the decryption side need to wait for more rtt, increase the latency, and destroy the user experience, refer to the Web Performance Authority Guide TLS The long length will cause the decryptor to wait for more rtt, increase the latency and break the user experience.</li>
<li>type field: to identify which of the four protocols is the current record.</li>
</ul>
<p>record compression: TLS protocol defines optional compression, however, because compression led to the 2012 outbreak of <a href="https://en.wikipedia.org/wiki/CRIME">CRIME attack, BREACH attack</a>, so in actual deployment, be sure to disable compression.</p>
<p>Cryptographic protection at the <strong>record layer</strong></p>
<p>The processed packet format is defined as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="p">{</span>
    <span class="n">ContentType</span> <span class="n">type</span><span class="p">;</span>
    <span class="n">ProtocolVersion</span> <span class="n">version</span><span class="p">;</span>
    <span class="n">uint16</span> <span class="n">length</span><span class="p">;</span>
    <span class="n">select</span> <span class="p">(</span><span class="n">SecurityParameters</span><span class="p">.</span><span class="n">cipher_type</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nl">stream</span><span class="p">:</span> <span class="n">GenericStreamCipher</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">block</span><span class="p">:</span>  <span class="n">GenericBlockCipher</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">aead</span><span class="p">:</span>   <span class="n">GenericAEADCipher</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">fragment</span><span class="p">;</span>
<span class="p">}</span> <span class="n">TLSCiphertext</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>The TLS protocol design goals of confidentiality (encryption), integrity (authentication) and anti-replay are implemented here. There are 3 types of implementations.</p>
<ol>
<li>Block Cipher (CBC mode of operation) + HMAC: e.g. aes-128-cbc+hmac-sha256</li>
<li>Stream Cipher (RC4) + HMAC</li>
<li>Authenticated-Encryption using block cipher (GCM/CCM mode): e.g. aes-128-gcm</li>
</ol>
<p>Block Cipher + HMAC and Stream Cipher + HMAC of all kinds of algorithms have now (2015) have exploded various vulnerabilities, the most reliable is currently 3.Authenticated-Encryption class of algorithms, mainly aes-gcm, the next generation of TLS v1.3 only retains Authenticated-Encryption, the 1 and 2 directly prohibited.</p>
<p>GCM mode is AEAD, so it does not need MAC algorithm. GCM mode is a type of AEAD, and AEAD works similar to Encrypt-then-HMAC, e.g. Sha256 + Salt + AES + IV</p>
<p>A pitfall needs to be introduced here. In the history of cryptography, three combinations of encryption and authentication have emerged.</p>
<ol>
<li>Encrypt-and-MAC</li>
<li>MAC-then-Encrypt</li>
<li>Encrypt-then-MAC</li>
</ol>
<p>In the era when the TLS protocol was first defined, people did not realize the difference in security between these 3 combinations, so the TLS protocol specified the use of 2. MAC-then-Encrypt, i.e., first calculate the MAC, and then encrypt the &ldquo;plaintext+MAC&rdquo; (block encryption or stream encryption) to do stream encryption+MAC, and block encryption+MAC. However, tragically, in recent years, it has been found that this structure of MAC-then-Encrypt leads to easy construction of padding oracle-related attacks, such as this in TLS, which indirectly forms exploited by attackers, which indirectly leads to the BEAST attack , Lucky 13 attack (CVE- 2013-0169), and the POODLE attack (CVE-2014-3566).</p>
<p>As a result, the academic community has now agreed that Encrypt-then-MAC is the most secure! In view of this trap is so sinister, some people in the academic community have proposed, simply set Encrypt and MAC directly into an algorithm, solve the security problem inside the algorithm, no longer let the coders choose, to avoid the crowd of coders again by this trap pitted, which is AEAD (Authenticated-Encryption With Additional data ) class of algorithms, GCM mode is the most important kind of AEAD.</p>
<p><strong>Cryptographic protection of the record layer - MAC</strong></p>
<p>TLS record layer MAC calculation method.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">MAC</span><span class="p">(</span><span class="n">MAC_write_key</span><span class="p">,</span> <span class="n">seq_num</span> <span class="o">+</span>
                      <span class="n">TLSCompressed</span><span class="p">.</span><span class="n">type</span> <span class="o">+</span>
                      <span class="n">TLSCompressed</span><span class="p">.</span><span class="n">version</span> <span class="o">+</span>
                      <span class="n">TLSCompressed</span><span class="p">.</span><span class="n">length</span> <span class="o">+</span>
                      <span class="n">TLSCompressed</span><span class="p">.</span><span class="n">fragment</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>where seq_num is the sequence number of the current record, each record will be ++, you can see the seq_num, and record header inside several fields are also counted, so as to solve the problem of anti-playback, and to ensure that any field of the record can not be tampered with.</p>
<p>After calculating the MAC, the format is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="n">stream</span><span class="o">-</span><span class="n">ciphered</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">opaque</span> <span class="n">content</span><span class="p">[</span><span class="n">TLSCompressed</span><span class="p">.</span><span class="n">length</span><span class="p">];</span>
    <span class="n">opaque</span> <span class="n">MAC</span><span class="p">[</span><span class="n">SecurityParameters</span><span class="p">.</span><span class="n">mac_length</span><span class="p">];</span>
<span class="p">}</span> <span class="n">GenericStreamCipher</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>Then, according to SecurityParameters.cipher_type, choose the corresponding symmetric encryption algorithm to encrypt.</p>
<p><strong>record layer cryptographic protection - stream cipher</strong></p>
<p>stream cipher: counting stream cipher, the state of stream cipher is multiplexed between successive records. The main power of stream cipher is RC4, but currently RC4 has exploded multiple vulnerabilities, so in practice, the stream cipher algorithm is basically not used.</p>
<p><strong>record layer cryptographic protection - CBC block cipher</strong></p>
<p>CBC mode block cipher TLS currently has few reliable block cipher, basically AES (the most reliable, the most mainstream), Camellia, SEED, (3DES, IDEA and so on already seems old, DES please disable), the encryption finished format is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="p">{</span>
    <span class="n">opaque</span> <span class="n">IV</span><span class="p">[</span><span class="n">SecurityParameters</span><span class="p">.</span><span class="n">record_iv_length</span><span class="p">];</span>
    <span class="n">block</span><span class="o">-</span><span class="n">ciphered</span> <span class="k">struct</span> <span class="p">{</span>
        <span class="n">opaque</span> <span class="n">content</span><span class="p">[</span><span class="n">TLSCompressed</span><span class="p">.</span><span class="n">length</span><span class="p">];</span>
        <span class="n">opaque</span> <span class="n">MAC</span><span class="p">[</span><span class="n">SecurityParameters</span><span class="p">.</span><span class="n">mac_length</span><span class="p">];</span>
        <span class="n">uint8</span> <span class="n">padding</span><span class="p">[</span><span class="n">GenericBlockCipher</span><span class="p">.</span><span class="n">padding_length</span><span class="p">];</span>
        <span class="n">uint8</span> <span class="n">padding_length</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span> <span class="n">GenericBlockCipher</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>This one is worth talking about, because we programmers usually see a lot of AES-CBC in the industry, with several parameters.</p>
<ul>
<li>IV: requires that it must be generated with a cryptographically secure pseudo-random number generator (CSPRNG) and must be unpredictable, which under Linux means using /dev/urandom, or using RAND_bytes() from the openssl library. Note: TLS did not have this IV field before version 1, and the last block of the previous record was used as the IV of the next record, and then the coarse thing was done, which led to the <a href="http://www.openssl.org/~bodo/tls-cbc.txt">BEAST attack</a>. So, TLS1.2 was changed to this. (For those of you who are still using CBC, we recommend paying attention to how your IV fields are generated. If you want to use it, do a good job of keeping it consistent with what TLS1.2 does). Where SecurityParameters.record_iv_length must be equal to SecurityParameters.block_size. For example, the IV of AES-256-CBC must be 16 bytes long, because the block size of AES 128/192/256 is 16 bytes.</li>
<li>padding: use the common CBC PKCS 7 padding (in the block size = 16 bytes in this case, and PKCS 5 algorithm is the same thing, java code can be so used in this case, and the results of PKCS 5 is the same).</li>
<li>padding_length: is the last byte of PKCS 7 padding. Note the 2 sinister traps.
<ul>
<li>the implemented code must receive all plaintexts before transmitting the ciphertext, otherwise there may be a BEAST attack</li>
<li>The implementation may perform a time-side channel attack based on the time calculated by the MAC, so it must be ensured that the -running time is irrelevant to whether the padding is correct or not.</li>
</ul>
</li>
</ul>
<p><strong>record layer of cryptographic protection - AEAD cipher</strong></p>
<p>AEAD to our focus on AEAD, AEAD is the emerging mainstream encryption mode, is currently the most important mode, where the mainstream AEAD mode is aes-gcm-128/aes-gcm-256/chacha20-poly1305</p>
<p>The finished AEAD encryption format is.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="p">{</span>
   <span class="n">opaque</span> <span class="n">nonce_explicit</span><span class="p">[</span><span class="n">SecurityParameters</span><span class="p">.</span><span class="n">record_iv_length</span><span class="p">];</span>
   <span class="n">aead</span><span class="o">-</span><span class="n">ciphered</span> <span class="k">struct</span> <span class="p">{</span>
       <span class="n">opaque</span> <span class="n">content</span><span class="p">[</span><span class="n">TLSCompressed</span><span class="p">.</span><span class="n">length</span><span class="p">];</span>
   <span class="p">};</span>
<span class="p">}</span> <span class="n">GenericAEADCipher</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>The inputs for AEAD ciphers are: key, nonce, plaintext, and &ldquo;additional data&rdquo;. The key is either client_write_key or the server_write_key. The MAC key is not required.</p>
<p>Each AEAD algorithm has to specify a different nonce construction algorithm and the length of GenericAEADCipher.nonce_explicit. In TLS 1.2, it is specified that in many cases, the technique of rfc5116 section 3.2.1 can be followed. where record_iv_length is the length of the explicit part of the nonce, and the implicit part of the nonce is derived from the key_block as client_write_iv and and server_write_iv, and the explicit part is placed in GenericAEAEDCipher.nonce_explicit. explicit.</p>
<p>In TLS 1.3 draft, this was changed:</p>
<ul>
<li>Specify that the length of the AEAD algorithm nonce is specified as max(8 bytes, N_MIN), i.e., if N_MIN is larger than 8, use N_MIN; if it is smaller than 8, use 8.</li>
<li>Specify that AEADs with N_MAX less than 8 bytes shall not be used for TLS.</li>
<li>Specify that the nonce of each record in a TLS AEAD is constructed by filling the right side of the 64-bit sequence number with zeros until the length reaches iv_length. write_iv (depending on the sender&rsquo;s choice). After the completion of the XOR, the obtained nonce of iv_length can be used as the nonce of each record.</li>
</ul>
<p>The plaintext of AEAD input is TLSCompressed.fragment (remember the introduction above? AEAD is the integration of MAC and encrypt, so the input data does not need to count MAC).</p>
<p>AEAD input additional_data is:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">additional_data</span> <span class="o">=</span> <span class="n">seq_num</span> <span class="o">+</span> <span class="n">TLSCompressed</span><span class="p">.</span><span class="n">type</span> <span class="o">+</span>
                  <span class="n">TLSCompressed</span><span class="p">.</span><span class="n">version</span> <span class="o">+</span> <span class="n">TLSCompressed</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>The &ldquo;+&rdquo; indicates string splicing. You can see that here, similar to the MAC calculation above, the seq_num is counted to prevent replay and the type,version,length and other fields prevent these metadata from being tampered with.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">AEADEncrypted</span> <span class="o">=</span> <span class="n">AEAD</span><span class="o">-</span><span class="n">Encrypt</span><span class="p">(</span><span class="n">write_key</span><span class="p">,</span> <span class="n">nonce</span><span class="p">,</span> <span class="n">plaintext</span><span class="p">,</span>
                             <span class="n">additional_data</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Decryption + Verification of Integrity.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">TLSCompressed</span><span class="p">.</span><span class="n">fragment</span> <span class="o">=</span> <span class="n">AEAD</span><span class="o">-</span><span class="n">Decrypt</span><span class="p">(</span><span class="n">write_key</span><span class="p">,</span> <span class="n">nonce</span><span class="p">,</span>
                                            <span class="n">AEADEncrypted</span><span class="p">,</span>
                                            <span class="n">additional_data</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>If the decryption/verification integrity fails, a fatal bad_record_mac alert message will be replied.</p>
<p>The iv length, nonce length, nonce composition, etc. of aes-gcm will be discussed in depth later.</p>
<p><strong>Cryptographic protection of record layer - Key extensions</strong></p>
<p>The master_secret generated by the TLS handshake is only 48 bytes, and the length of the two encryption keys, MAC key, and IV are generally longer than 48 (e.g. AES_256_CBC_SHA256 requires 128 bytes), so a function is used inside TLS to extend the 48 bytes to the required length, called PRF.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">key_block = PRF(SecurityParameters.master_secret,
                &#34;key expansion&#34;,
                SecurityParameters.server_random +
                SecurityParameters.client_random);
</code></pre></td></tr></table>
</div>
</div><p>Then, the key_block is split like the following.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">client_write_MAC_key[SecurityParameters.mac_key_length]
server_write_MAC_key[SecurityParameters.mac_key_length]
client_write_key[SecurityParameters.enc_key_length]
server_write_key[SecurityParameters.enc_key_length]
client_write_IV[SecurityParameters.fixed_iv_length]
server_write_IV[SecurityParameters.fixed_iv_length]
</code></pre></td></tr></table>
</div>
</div><p>TLS uses the HMAC structure, and the hash function specified in CipherSuite (with a security level of at least SHA256) to construct the PRF.</p>
<p>First define P_hash, which extends (secret,seed) into an infinitely long stream of bytes.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">P_hash</span><span class="p">(</span><span class="n">secret</span><span class="p">,</span> <span class="n">seed</span><span class="p">)</span> <span class="o">=</span> <span class="n">HMAC_hash</span><span class="p">(</span><span class="n">secret</span><span class="p">,</span> <span class="n">A</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">seed</span><span class="p">)</span> <span class="o">+</span>
                       <span class="n">HMAC_hash</span><span class="p">(</span><span class="n">secret</span><span class="p">,</span> <span class="n">A</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">seed</span><span class="p">)</span> <span class="o">+</span>
                       <span class="n">HMAC_hash</span><span class="p">(</span><span class="n">secret</span><span class="p">,</span> <span class="n">A</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="n">seed</span><span class="p">)</span> <span class="o">+</span> <span class="p">...</span>
</code></pre></td></tr></table>
</div>
</div><p>where &ldquo;+&rdquo; indicates string splicing. A() is defined as :</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">A</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">seed</span>
<span class="n">A</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">HMAC_hash</span><span class="p">(</span><span class="n">secret</span><span class="p">,</span> <span class="n">A</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>The PRF of TLS is to apply the P_hash to the secret:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">PRF</span><span class="p">(</span><span class="n">secret</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">seed</span><span class="p">)</span> <span class="o">=</span> <span class="n">P_</span><span class="o">&lt;</span><span class="n">hash</span><span class="o">&gt;</span><span class="p">(</span><span class="n">secret</span><span class="p">,</span> <span class="n">label</span> <span class="o">+</span> <span class="n">seed</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>where label is a protocol-defined, fixed ASCII string.</p>
<p>Note that this approach has been deprecated in TLS 1.3 in favor of the more reliable HKDF, which is also one of the standard algorithms for html5&rsquo;s WebCryptoAPI.</p>
<h3 id="digital-certificates">Digital certificates</h3>
<p>Digital certificates, also known as &ldquo;identity cards&rdquo; on the Internet, are used to uniquely identify an organization or a server, which is similar to the &ldquo;resident ID&rdquo; we use in our daily lives to uniquely identify a person.</p>
<p>The same is true for website certificates. Generally speaking, digital certificates are bought from a trusted authority (Certification Authority). Generally browsers are shipped with many well-known CAs built in.</p>
<p>In practice, HTTPS does not directly transmit the public key information, but uses the digital certificate carrying the public key information to ensure the security and integrity of the public key. It is used to protect the public key information sent to the client by the HTTPS server from being tampered with.</p>
<p><strong>Digital Certificates and CA Authorities</strong></p>
<p>A digital certificate typically contains.</p>
<ul>
<li>Server public key</li>
<li>Holder information</li>
<li>Certificate Authority (CA) information</li>
<li>The CA&rsquo;s digital signature for this document and the algorithm used</li>
<li>The certificate expiration date</li>
<li>And some other additional information</li>
</ul>
<p>The purpose of a digital certificate is to authenticate the identity of the public key holder to prevent impersonation by third parties. To put it simply, the certificate is used to tell the client whether the server is legitimate, because only if the certificate is legitimate, it means the identity of the server is trusted.</p>
<p>We use a certificate to authenticate the identity of the public key holder (the identity of the server), but where does the certificate come from? And how should we certify the certificate? In order to make the public key of the server side trusted, the certificates of the server side are signed by CA (Certificate Authority), which is the public security bureau and notary center in the network world and has high credibility, so it signs each public key and the certificate issued by the trusted party is inevitably trusted. The reason why the signature is needed is because the role of the signature can avoid the tampering of the certificate content by the intermediary in obtaining the certificate.</p>
<p><strong>Digital certificate issuance and verification process</strong></p>
<p>The following figure shows the digital certificate issuance and verification process.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/14/20e50482135d40bc98ada2f40fcfe45e.png" alt=""></p>
<ul>
<li>The process of CA issuing certificate, as shown in the left part of the above figure.
<ul>
<li>First the CA will type the holder&rsquo;s public key, usage, issuer, valid time and other information into a package (blue), and then perform Hash calculation on this information to get a Hash value</li>
<li>Then the CA will encrypt the Hash value with its own private key to generate Certificate Signature, that is, the CA has signed the certificate</li>
<li>Finally, the Certificate Signature is added to the file certificate to form a digital certificate.</li>
</ul>
</li>
<li>The client verifies the digital certificate of the server, as shown in the right part of the above figure.
<ul>
<li>First the client will use the same Hash algorithm to calculate the Hash value of the certificate H1</li>
<li>The browser receives the certificate from the server and decrypts the Certificate Signature content using the CA&rsquo;s public key to obtain a Hash value H2</li>
<li>Finally, compare H1 and H2, if the value is the same, the certificate is trusted, otherwise the server certificate is considered untrustworthy</li>
</ul>
</li>
</ul>
<p><strong>Certificate Chain</strong></p>
<p>But in fact, there is a certificate trust chain problem in the certificate verification process, because the certificate we apply to the CA is generally not issued by the root certificate, but by the intermediate certificate, such as Baidu&rsquo;s certificate, you can see from the following figure, the certificate hierarchy has three levels.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/14/cef7db22d7bb4d8cbcc3902d8dd36801.png" alt=""></p>
<p>The verification process for this certificate with three-level hierarchical relationship is as follows.</p>
<ul>
<li>After the client receives the certificate of com, it finds that the issuer of this certificate is not the root certificate, so it cannot verify whether the baidu.com certificate is trusted according to the public key in the locally available root certificate. So, the client finds that the issuer of this certificate is &ldquo;GlobalSign Organization Validation CA - SHA256 - G2&rdquo; according to the issuer in the baidu.com certificate and then requests this intermediate certificate from the CA.</li>
<li>After requesting the certificate, it finds that the certificate of &ldquo;GlobalSign Organization Validation CA - SHA256 - G2&rdquo; is issued by &ldquo;GlobalSign Since &ldquo;GlobalSign Root CA&rdquo; has no higher level issuing authority, it is a root certificate, that is, a self-signed certificate. The application software will check whether this certificate has been preloaded on the root certificate list, and if so, it can use the public key in the root certificate to verify the &ldquo;GlobalSign Organization Validation CA - SHA256 - G2 &quot; certificate, and if the validation is found to be passed, the intermediate certificate is considered to be trusted.</li>
<li>After the &ldquo;GlobalSign Organization Validation CA - SHA256 - G2&rdquo; certificate is trusted, you can use the &ldquo;GlobalSign Organization Validation CA - SHA256 - G2&rdquo; certificate to verify the trustworthiness of the com certificate, and if the verification is passed, the baidu.com certificate can be trusted.</li>
</ul>
<p>In these steps, at first the client only trusts the root certificate GlobalSign Root CA certificate, then the &ldquo;GlobalSign Root CA&rdquo; certificate trusts the &ldquo;GlobalSign Organization Validation CA - SHA256 - G2&rdquo; certificate, and &ldquo;GlobalSign Organization Validation CA - SHA256 - G2&rdquo; certificate in turn trusts baidu.com certificate, so the client also trusts baidu.com certificate.</p>
<p>In summary, since the user trusts GlobalSign, baidu.com guaranteed by GlobalSign can be trusted, and since the user trusts the software vendor of the operating system or browser, GlobalSign with the root certificate preloaded by the software vendor can be trusted.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/14/b17a65ed72514b9ab195cb7ad56d5b91.png" alt=""></p>
<p>There are usually some root certificates built into the operating system.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/14/13c90ed04e0c4bf1bc4e48d1d1a6fa65.png" alt=""></p>
<p>Such a layer of verification constitutes a trust chain, and the entire certificate trust chain verification process is shown in the following figure.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/14/f53b33555ab74e1bae204eed0181cef5.png" alt=""></p>
<p>The last question is, why do we need such a troublesome process of certificate chain, and why Root CA does not issue certificates directly, but has to make so many intermediate levels?</p>
<p>This is to ensure the absolute security of the root certificate, the stricter the isolation of the root certificate the better, otherwise if the root certificate is lost, then the whole trust chain will have problems.</p>
<h2 id="tls-13-vs-tls-12">TLS 1.3 vs TLS 1.2</h2>
<p>TLS 1.3 is a new update to previous versions such as TLS 1.2 after nine years, and is the most significant change to date. In response to known security threats, the IETF (Internet Engineering Task Force) is working on a new standard for TLS 1.3 that promises to be the most secure, but also the most complex TLS protocol ever.</p>
<p>TLS 1.3 differs significantly from previous versions of the protocol, mainly in that</p>
<ul>
<li>Introduction of a new key negotiation mechanism - PSK - compared to previous versions</li>
<li>Support for 0-RTT data transfer, which saves round-trip time when establishing a connection</li>
<li>Deprecated cryptographic components such as 3DES, RC4, AES-CBC, and hash algorithms such as SHA1 and MD5</li>
<li>All handshake messages after ServerHello are encrypted, and the visible plaintext is greatly reduced.</li>
<li>Compression of encrypted messages and renegotiation initiated by both parties are no longer allowed.</li>
<li>DSA certificates are no longer allowed in TLS 1.3</li>
</ul>
<p>TLS 1.3 is indeed a big step forward compared to the shortcomings of the old protocol. It avoids the flaws of the previous version and reduces the time required for the TLS handshake.</p>
<p>To summarize, TLS 1.3 has two big advantages over previous versions, which are.</p>
<h3 id="faster-access-speed">Faster access speed</h3>
<p>To compare the changes in TLS 1.3 during the TLS handshake phase, here is a comparison of TLS 1.2 and TLS 1.3 during the TLS handshake phase.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/14/607287c4147b4cbead8a210b24942e79.png" alt=""></p>
<p>As you can see from the above diagram, using TLS 1.2 requires two round trips (2-RTT) to complete the handshake before the request can be sent.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/14/55f8342297484320babe8fe99ff7d55e.png" alt=""></p>
<p>The TLS 1.3 handshake no longer supports static RSA key exchange, which means that a full handshake must be performed using Diffie-Hellman with forward security. As you can see from the figure above, only one round trip (1-RTT) is required to complete the handshake using the TLS 1.3 protocol.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/14/295033b48edb4318bb641acf201df690.png" alt=""></p>
<p>The right part of the diagram above is the handshake process of TLS 1.3. You can see that TLS 1.3 merges the two messages Hello and Public Key Exchange into one message, so that it reduces to only 1 RTT to complete the TLS handshake.</p>
<p>How is this done? The client brings the supported elliptic curves in the Client Hello message, along with the public keys corresponding to those elliptic curves.</p>
<p>The server receives it, selects an elliptic curve and other parameters, and then returns the message with the server&rsquo;s side of the public key. After this 1 RTT, both sides already have the material to generate the session key in hand, so the client calculates the session key and can carry out the encrypted transmission of application data.</p>
<p>Compared to TLS 1.2, TLS 1.3 handshake time is reduced by half. This means that accessing a mobile site, using the TLS 1.3 protocol, may reduce the time by almost 100ms.</p>
<h3 id="stronger-security">Stronger Security</h3>
<p>TLS has been in development for over 20 years. In previous versions, TLS 1.2 was highly configurable for better compatibility with older versions of browsers, which meant that vulnerable sites were always running insecure encryption algorithms that allowed Internet hackers to take advantage of them.</p>
<p>TLS 1.3 builds on previous versions by removing those insecure encryption algorithms, which include</p>
<ul>
<li>RSA key transfer - does not support forward security</li>
<li>CBC mode ciphers &ndash; vulnerable to BEAST and Lucky 13 attacks</li>
<li>RC4 stream ciphers &ndash; not secure for use in HTTPS</li>
<li>SHA-1 hash function - recommended to be replaced by SHA-2</li>
<li>Arbitrary Diffie-Hellman group &ndash; CVE-2016-0701 vulnerability</li>
<li>Exported passwords - vulnerable to FREAK and LogJam attacks</li>
</ul>
<p>TLS1.3 &ldquo;slims down&rdquo; the cipher suite by deprecating RSA and DH algorithms for key exchange algorithms, which do not support forward security, and supporting only ECDHE algorithms. For symmetric encryption and signature algorithms, only the most secure cipher suites are supported, for example, only the following 5 cipher suites are supported in openssl.</p>
<ul>
<li>TLS_AES_256_GCM_SHA384</li>
<li>TLS_CHACHA20_POLY1305_SHA256</li>
<li>TLS_AES_128_GCM_SHA256</li>
<li>TLS_AES_128_CCM_8_SHA256</li>
<li>TLS_AES_128_CCM_SHA256</li>
</ul>
<p>The reason why TLS1.3 only supports so few cipher suites is that TLS1.2 supports various old and insecure cipher suites, so a man-in-the-middle can use a degradation attack to forge the Client Hello message from the client and replace the client&rsquo;s supported cipher suite with some insecure cipher suite, so that the server is forced to use this cipher suite for HTTPS connection, thereby cracking the cipher text. The server is then forced to use this cipher suite for HTTPS connection, thus cracking the ciphertext.</p>
<p>In short, TLS 1.3 will be more secure than older versions of the TLS protocol, which also represents a major advance in Internet security.</p>
<h3 id="tls-13-specific-changes">TLS 1.3 specific changes</h3>
<p>Changes to TLS 1.3 Significant improvements of note include</p>
<ul>
<li>RTT support</li>
<li>RTT handshake support</li>
<li>Change to use HKDF for key expansion</li>
<li>Complete disabling of RC4</li>
<li>Complete prohibition of compression</li>
<li>Completely disable algorithms other than aead</li>
<li>Remove explicit IV from aead</li>
<li>Remove the length field in the AD of aead</li>
<li>Remove ChangeCipherSpec</li>
<li>Remove renegotiation</li>
<li>Removal of static RSA and DH key negotiation</li>
</ul>
<p>The improvements in TLS 1.3 are mainly for mobile Internet scenarios. TLS 1.3 removes ChangeCipherSpec so that there are three protocols on top of record: handshake, alert, and application data</p>
<p><strong>Record layer cryptography protection changes</strong></p>
<p>Since only aead is retained, so there is no need for MAC key. aead specific parameter usage has also been adjusted, the previous article has. kdf replaced with standard HKDF, there are 2 types of tls_kdf_sha256, tls_kdf_sha384</p>
<p><strong>handshake protocol changes</strong></p>
<p>In view of the session ticket is so good, simply people love, so TLS 1.3 directly built the session ticket, and renamed PSK. to note that this PSK and tls 1.2 in a very remote psk (see <a href="https://tools.ietf.org/html/rfc4279">rfc4279</a> ) is not the same thing.</p>
<p>After considering session resuming, session ticket, TLS 1.3 proposes three handshake models.</p>
<ul>
<li>Diffie-Hellman (including both DH and ECDH, please make up your own mind to &ldquo;ECDH/DH&rdquo; where ECDH is mentioned below).</li>
<li>A pre-shared symmetric key (PSK), a pre-shared symmetric key, here with a unified model for session resuming and rfc4279&rsquo;s psk</li>
<li>A combination of a symmetric key and Diffie-Hellman , the first two together</li>
</ul>
<p><strong>1-RTT Handshake</strong></p>
<p>First, the TLS 1.2 handshake has 2 rtt, the first rtt is ClientHello/ServerHello, the second rtt is ClientKeyExchange/ServerKeyExchange, the reason why KeyExchange is placed in the second rtt is because tls1.2 has to support A variety of key exchange algorithms, and a variety of different parameters (such as DH or ECDH or RSA, ECDHE with what curve, DH with what group generation element, with what modulus, and so on), these algorithms and parameters rely on the first rtt to negotiate out, TLS1.3 boldly cut a variety of custom DH group, cut the ECDH custom curve, cut the RSA In fact, we basically use ECDH P-256 in practical applications, and no one uses anything else, so we simply let the client cache what negotiation algorithm the server used last time, and put KeyExchange directly into the first rtt, and the client directly uses the cached algorithm to send the public key of KeyExchange in the first rtt. If the server finds that the algorithm sent up by the client is not correct, then it will tell the correct one and let the client retry. In this way, the HelloRetryRequest message is introduced.</p>
<p>This brings it down to 1-RTT with basically no side effects. This is the full handshake for TLS 1.3.</p>
<p>Obviously, if a protocol has only one key negotiation algorithm, for example, set dead to ECDH P-256, it must be possible to do 1-RTT</p>
<p><strong>The 0-RTT handshake with side effects</strong></p>
<p>0-RTT should be inspired by Google&rsquo;s QUIC protocol, if the server caches its ECDH public key in the client for a long time, then the client can use the ECDHE public key in the cache to construct an electronic envelope, in the first RTT, and send the application layer data directly. This long-term cached ECDH public key in the client is called semi-static (EC)DH share ECDH public key is sent to the client via ServerConfiguration message.</p>
<p>This 0-rtt optimization has the following side effects.</p>
<ul>
<li>Application data sent by RTT has no forward security.</li>
<li>Application data in 0-RTT can be replayed across connections (any server-side protocol without shared state cannot be replay-proof across connections)</li>
<li>If the private key corresponding to the server-side semi-static ECDH public key is leaked, the attacker can disguise as a client to tamper with the data at will.</li>
</ul>
<p>The server sends the semi-static ECDH public key to the client in the ServerConfiguration message. ServerConfiguration is worth looking at.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="p">{</span>
    <span class="n">opaque</span> <span class="n">configuration_id</span><span class="o">&lt;</span><span class="mf">1..2</span><span class="o">^</span><span class="mi">16</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="n">uint32</span> <span class="n">expiration_date</span><span class="p">;</span>
    <span class="n">NamedGroup</span> <span class="n">group</span><span class="p">;</span>
    <span class="n">opaque</span> <span class="n">server_key</span><span class="o">&lt;</span><span class="mf">1..2</span><span class="o">^</span><span class="mi">16</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="n">EarlyDataType</span> <span class="n">early_data_type</span><span class="p">;</span>
    <span class="n">ConfigurationExtension</span> <span class="n">extensions</span><span class="o">&lt;</span><span class="mf">0..2</span><span class="o">^</span><span class="mi">16</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ServerConfiguration</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>where expiration_date is the last expiration date of this ServerConfiguration. This value is never allowed to be greater than 7 days. Clients are never allowed to store ServerConfiguration for more than 7 days, no matter how the server fills in this value.</p>
<p>The application data in 0-RTT is sent in EarlyDataIndication, and TLS 1.3 also defines a ContentType for EarlyDataIndication: early_handshake (four types of alert(21), handshake(22), application_data(23), early_handshake(25))</p>
<p><strong>Resumption and PSK</strong></p>
<p>In TLS 1.3, the key recovered from session resumption/session ticket, and psk (rfc4279) are unified in a handshake PSK mode.</p>
<p>PSK CipherSuite can use PSK and ECDHE together, so that there is forward security. It is also possible to use PSK only, so there is no forward security.</p>
<p><strong>Changes to the Key Schedule process</strong></p>
<p>In TLS 1.3, after considering the various cases of session tickets, the concepts of ES and SS were introduced to unify the various cases of key negotiation. In various handshake modes, ES and SS take different values from different sources.</p>
<ul>
<li>Ephemeral Secret (ES): the value derived from fresh ECDHE negotiation for each connection. Any value derived from ES is forward-secure (not forward-secure in PSK only mode, of course).</li>
<li>Static Secret (SS): a value derived from a static, or semi-static key. For example, psk, or the server&rsquo;s semi-static ECDH public key.</li>
</ul>
<p>In various handshake modes.</p>
<table>
<thead>
<tr>
<th>Key Exchange</th>
<th>Static Secret (SS)</th>
<th>Ephemeral Secret (ES)</th>
</tr>
</thead>
<tbody>
<tr>
<td>(EC)DHE (Complete handshake)</td>
<td>Client ephemeral w/ server ephemeral</td>
<td>Client ephemeral w/ server ephemeral</td>
</tr>
<tr>
<td>(EC)DHE (w/ 0-RTT)</td>
<td>Client ephemeral w/ server static</td>
<td>Client ephemeral w/ server ephemeral</td>
</tr>
<tr>
<td>PSK</td>
<td>Pre-Shared Key</td>
<td>Pre-shared key</td>
</tr>
<tr>
<td>PSK + (EC)DHE</td>
<td>Pre-Shared Key</td>
<td>Client ephemeral w/ server ephemeral</td>
</tr>
</tbody>
</table>
<p>As in the table above.</p>
<ul>
<li>For a full 1-RTT handshake, the ephemeral key is used for both SS and ES, which is certain to have forward security.</li>
<li>With 0-RTT handshake, SS is generated using the ephemeral key on the client side and the semi-static ECDH public key on the server side.</li>
<li>Pure PSK, this scenario has no forward security at all and should be avoided.</li>
<li>PSK + ECDHE, this scenario is more interesting, SS is using Pre-Shared Key, which has no forward security, and ES is using ephemeral key, which has forward security.</li>
</ul>
<p>As you can see, compared with the session ticket of TLS 1.2, the PSK + ECDHE of TLS 1.3 is combined with ES, which has forward security and is relatively more secure.</p>
<p>Unlike TLS 1.2, the master_secret of TLS 1.3 is derived using both ES and SS.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="n">HKDF</span><span class="o">-</span><span class="n">Expand</span><span class="o">-</span><span class="n">Label</span><span class="p">(</span><span class="n">Secret</span><span class="p">,</span> <span class="n">Label</span><span class="p">,</span> <span class="n">HashValue</span><span class="p">,</span> <span class="n">Length</span><span class="p">)</span> <span class="o">=</span> <span class="n">HKDF</span><span class="o">-</span><span class="n">Expand</span><span class="p">(</span><span class="n">Secret</span><span class="p">,</span> <span class="n">Label</span> <span class="o">+</span> <span class="err">&#39;</span><span class="o">&lt;</span><span class="n">pre</span> <span class="n">class</span><span class="o">=</span><span class="s">&#34;EnlighterJSRAW&#34;</span> <span class="n">data</span><span class="o">-</span><span class="n">enlighter</span><span class="o">-</span><span class="n">language</span><span class="o">=</span><span class="s">&#34;generic&#34;</span><span class="o">&gt;</span><span class="n">HKDF</span><span class="o">-</span><span class="n">Expand</span><span class="o">-</span><span class="n">Label</span><span class="p">(</span><span class="n">Secret</span><span class="p">,</span> <span class="n">Label</span><span class="p">,</span> <span class="n">HashValue</span><span class="p">,</span> <span class="n">Length</span><span class="p">)</span> <span class="o">=</span> <span class="n">HKDF</span><span class="o">-</span><span class="n">Expand</span><span class="p">(</span><span class="n">Secret</span><span class="p">,</span> <span class="n">Label</span> <span class="o">+</span> <span class="sc">&#39;\0&#39;</span> <span class="o">+</span> <span class="n">HashValue</span><span class="p">,</span> <span class="n">Length</span><span class="p">)</span>
<span class="mf">1.</span> <span class="n">xSS</span> <span class="o">=</span> <span class="n">HKDF</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="s">&#34;extractedSS&#34;</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
<span class="mf">2.</span> <span class="n">xES</span> <span class="o">=</span> <span class="n">HKDF</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ES</span><span class="p">,</span> <span class="s">&#34;extractedES&#34;</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
<span class="mf">3.</span> <span class="n">master_secret</span> <span class="o">=</span> <span class="n">HKDF</span><span class="p">(</span><span class="n">xSS</span><span class="p">,</span> <span class="n">xES</span><span class="p">,</span> <span class="s">&#34;master secret&#34;</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
<span class="mf">4.</span> <span class="n">finished_secret</span> <span class="o">=</span> <span class="n">HKDF</span><span class="o">-</span><span class="n">Expand</span><span class="o">-</span><span class="n">Label</span><span class="p">(</span><span class="n">xSS</span><span class="p">,</span> <span class="s">&#34;finished secret&#34;</span><span class="p">,</span> <span class="n">handshake_hash</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
<span class="o">&lt;/</span><span class="n">pre</span><span class="o">&gt;</span><span class="err">&#39;</span> <span class="o">+</span> <span class="n">HashValue</span><span class="p">,</span> <span class="n">Length</span><span class="p">)</span>
<span class="mf">1.</span> <span class="n">xSS</span> <span class="o">=</span> <span class="n">HKDF</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">SS</span><span class="p">,</span> <span class="s">&#34;extractedSS&#34;</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
<span class="mf">2.</span> <span class="n">xES</span> <span class="o">=</span> <span class="n">HKDF</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ES</span><span class="p">,</span> <span class="s">&#34;extractedES&#34;</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
<span class="mf">3.</span> <span class="n">master_secret</span> <span class="o">=</span> <span class="n">HKDF</span><span class="p">(</span><span class="n">xSS</span><span class="p">,</span> <span class="n">xES</span><span class="p">,</span> <span class="s">&#34;master secret&#34;</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
<span class="mf">4.</span> <span class="n">finished_secret</span> <span class="o">=</span> <span class="n">HKDF</span><span class="o">-</span><span class="n">Expand</span><span class="o">-</span><span class="n">Label</span><span class="p">(</span><span class="n">xSS</span><span class="p">,</span> <span class="s">&#34;finished secret&#34;</span><span class="p">,</span> <span class="n">handshake_hash</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>Traffic Key Calculation</strong></p>
<p>The key used for encrypting traffic is called Traffic Key in TLS 1.3. Due to the introduction of one more ContentType, the Traffic Key is not the same under different ContentTypes. The following table.</p>
<table>
<thead>
<tr>
<th>Record Type</th>
<th>Secret</th>
<th>Label</th>
<th>Handshake Hash</th>
</tr>
</thead>
<tbody>
<tr>
<td>Early data</td>
<td>xSS</td>
<td>early data key expansion</td>
<td>ClientHello</td>
</tr>
<tr>
<td>Handshake</td>
<td>xES</td>
<td>handshake key expansion</td>
<td>ClientHello ServerKeyShare</td>
</tr>
<tr>
<td>Application</td>
<td>master secret</td>
<td>application data key expansion</td>
<td>All handshake messages but Finished</td>
</tr>
</tbody>
</table>
<p>The concern is that the Traffic Key for Early Data is calculated using xSS. That is, it is determined using the Pre-Shared Key. Therefore, there is no forward security.</p>
<p>It is up to CipherSuite to negotiate which handshake mode to use for a TLS connection.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/https/">https</a>
          <a href="/tags/ssl/">ssl</a>
          <a href="/tags/tls/">tls</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2021-12/remote-deploy-env-with-okteto/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Build remote development environments with PyCharm, Okteto and Kubernetes</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2021-12/learn-about-lambda-serialization/">
            <span class="next-text nav-default">Serialization of Lambda expressions in the JDK and the clever use of SerializedLambda</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
