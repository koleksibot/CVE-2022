<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Network Communication Protocol - QUIC - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="If you have an app, you can increase access speed by more than 15% without any modification. Especially when the network is weak, it can improve access speed by more than 20%. If your App, with frequent switching between 4G and WIFI networks, does not disconnect, does not require reconnection, and has no user perception. If you have an App that needs the security of TLS but also wants the power of HTTP2 multiplexing." /><meta name="keywords" content="Quic, udp" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2021-12/quic/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Network Communication Protocol - QUIC" />
<meta property="og:description" content="If you have an app, you can increase access speed by more than 15% without any modification. Especially when the network is weak, it can improve access speed by more than 20%. If your App, with frequent switching between 4G and WIFI networks, does not disconnect, does not require reconnection, and has no user perception. If you have an App that needs the security of TLS but also wants the power of HTTP2 multiplexing." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2021-12/quic/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-12-16T16:37:18+08:00" />
<meta property="article:modified_time" content="2021-12-16T16:37:18+08:00" />

<meta itemprop="name" content="Network Communication Protocol - QUIC">
<meta itemprop="description" content="If you have an app, you can increase access speed by more than 15% without any modification. Especially when the network is weak, it can improve access speed by more than 20%. If your App, with frequent switching between 4G and WIFI networks, does not disconnect, does not require reconnection, and has no user perception. If you have an App that needs the security of TLS but also wants the power of HTTP2 multiplexing."><meta itemprop="datePublished" content="2021-12-16T16:37:18+08:00" />
<meta itemprop="dateModified" content="2021-12-16T16:37:18+08:00" />
<meta itemprop="wordCount" content="7080">
<meta itemprop="keywords" content="quic,udp," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Network Communication Protocol - QUIC"/>
<meta name="twitter:description" content="If you have an app, you can increase access speed by more than 15% without any modification. Especially when the network is weak, it can improve access speed by more than 20%. If your App, with frequent switching between 4G and WIFI networks, does not disconnect, does not require reconnection, and has no user perception. If you have an App that needs the security of TLS but also wants the power of HTTP2 multiplexing."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Network Communication Protocol - QUIC</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-12-16 16:37:18 </span>
        <div class="post-category">
            <a href="/categories/skills/"> skills </a>
            </div>
          <span class="more-meta"> 7080 words </span>
          <span class="more-meta"> 34 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#what-is-quic">What is QUIC?</a>
          <ul>
            <li><a href="#http-protocol-development">HTTP protocol development</a></li>
          </ul>
        </li>
        <li><a href="#why-do-we-need-quic">Why do we need QUIC?</a>
          <ul>
            <li><a href="#rigidity-of-intermediate-devices">Rigidity of intermediate devices</a></li>
            <li><a href="#dependence-on-os-implementation-leads-to-protocol-rigidity">Dependence on OS implementation leads to protocol rigidity</a></li>
          </ul>
        </li>
        <li><a href="#key-features-of-quic">Key features of QUIC</a>
          <ul>
            <li><a href="#connection-migration">Connection Migration</a></li>
            <li><a href="#low-connection-latency">Low connection latency</a></li>
            <li><a href="#customizable-congestion-control">Customizable congestion control</a></li>
            <li><a href="#blocking-without-headers">Blocking without headers</a></li>
          </ul>
        </li>
        <li><a href="#quic-protocol-components">QUIC Protocol Components</a>
          <ul>
            <li><a href="#udp-layer">UDP layer</a></li>
            <li><a href="#connection-layer">Connection layer</a></li>
            <li><a href="#stream-layer">Stream layer</a></li>
            <li><a href="#http3-layer">HTTP3 layer</a></li>
            <li><a href="#other">Other</a></li>
          </ul>
        </li>
        <li><a href="#quic-application-scenarios">QUIC application scenarios</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>If you have an app, you can increase access speed by more than 15% without any modification. Especially when the network is weak, it can improve access speed by more than 20%. If your App, with frequent switching between 4G and WIFI networks, does not disconnect, does not require reconnection, and has no user perception. If you have an App that needs the security of TLS but also wants the power of HTTP2 multiplexing. If you&rsquo;ve just heard that HTTP2 is the next generation of Internet protocols, and if you&rsquo;ve just noticed that TLS 1.3 is a revolutionary landmark protocol, but both protocols are constantly being influenced and challenged by another, more emerging protocol. If this emerging protocol, its name is &ldquo;Fast&rdquo; and it is being standardized as the next generation of Internet transport protocols. Are you willing to spend a little time understanding this protocol? Are you willing to invest the effort to study this protocol? Are you willing to push your business to use this protocol?</p>
<h2 id="what-is-quic">What is QUIC?</h2>
<p>QUIC (Quick UDP Internet Connection) is a UDP-based transport protocol from Google that implements TCP + HTTPS + HTTP/2 with the goal of ensuring reliability while reducing network latency. Because UDP is a simple transport protocol, UDP-based can get rid of TCP transport confirmation, slow start of retransmission, etc., and establish a secure connection in a round-trip time, it also implements HTTP/2 multiplexing, header compression, etc.</p>
<p>The QUIC protocol is a collection of protocols, mainly including.</p>
<ul>
<li>Transport protocol (Transport)</li>
<li>Packet Loss Detection and Congestion Control (Recovery)</li>
<li>Secure Transport Protocol (TLS)</li>
<li>HTTP3 protocol</li>
<li>HTTP Header Compression Protocol (QPACK)</li>
<li>Load Balancing Protocol (Load Balance)</li>
</ul>
<p>It is well known that UDP is faster than TCP, and TCP is a reliable protocol, but at the cost of a series of consumptions derived from the confirmation of data by both sides. Secondly, TCP is implemented in the system kernel, if you upgrade the TCP protocol, you have to let the user upgrade the system, the threshold of this is relatively high, while QUIC on the basis of UDP by the client free play, as long as there is a server can be docked.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/16/38916e391c2c4ccf9b0fd7bf790caff2.png" alt=""></p>
<p>Quic has the following advantages over the now widely used http2+tcp+tls protocol.</p>
<ul>
<li>Reduced TCP triple handshake and TLS handshake time</li>
<li>Improved congestion control</li>
<li>Multiplexing to avoid queue head blocking</li>
<li>Connection migration</li>
<li>Forward redundancy error correction</li>
</ul>
<h3 id="http-protocol-development">HTTP protocol development</h3>
<p><strong>HTTP History Process</strong></p>
<ul>
<li>HTTP 0.9 (1991) only supports get method not request headers.</li>
<li>HTTP 1.0 (1996) basically shaped, supports request headers, rich text, status codes, caching, connections cannot be multiplexed.</li>
<li>HTTP 1.1 (1999) supports connection multiplexing, sending in chunks, breakpoints.</li>
<li>HTTP 2.0 (2015) binary split-frame transmission, multiplexing, header compression, server push, etc.</li>
<li>HTTP 3.0 (2018) QUIC was implemented in 2013; in October 2018, the IETF&rsquo;s HTTP Working Group and the QUIC Working Group jointly decided to call the HTTP mapping on QUIC &ldquo;HTTP/3&rdquo; in advance of making it a global standard.</li>
</ul>
<p><strong>HTTP1.0 and HTTP1.1</strong></p>
<ul>
<li>Head-of-queue blocking: the next request must be sent after the previous request returns, resulting in bandwidth not being fully utilized and subsequent requests being blocked (HTTP 1.1 attempted to use pipelining (Pipelining) techniques, but the innate FIFO (First In First Out) mechanism resulted in the execution of the current request being dependent on the completion of the previous request execution, which tended to cause head-of-queue blocking and did not fundamentally (solving the problem).</li>
<li>high protocol overhead: the content carried in the header is too large and can not be compressed, increasing the cost of transmission.</li>
<li>One-way request: only one-way request, what the client requests and what the server returns.</li>
<li>Differences between HTTP 1.0 and HTTP 1.1.
<ul>
<li>HTTP 1.0: only supports maintaining a short TCP connection (connection cannot be multiplexed); does not support breakpoints; the next request can only be sent after the previous request response arrives, and there is queue head blocking.</li>
<li>HTTP 1.1: Supports long connections by default (requests can be reused for TCP connections); supports breakpoints (by setting parameters in Header); optimized cache control policy; pipelined, can send multiple requests at once, but responses are still returned sequentially, still can&rsquo;t solve the problem of queue head blocking; new error status code notification; request and response messages both support Host header field</li>
</ul>
</li>
</ul>
<p><strong>HTTP2</strong></p>
<p>Solves some of the problems of HTTP1, but does not solve the underlying TCP protocol-level queue head blocking problem.</p>
<ul>
<li>Binary transfer: transferring data in binary format is more efficient than parsing text.</li>
<li>Multiplexing: redefines the underlying http semantic mapping to allow request and response bi-directional data streams to be used on the same connection. The same domain name only needs to occupy one TCP connection, with data streams (Stream) using frames as the basic protocol unit, avoiding latency due to frequent connection creation, reducing memory consumption and improving usage performance, parallel requests, and slow requests or requests sent first do not block the return of other requests.</li>
<li>Header compression: reduces redundant data in requests and reduces overhead.</li>
<li>Server can proactively push: push the necessary resources to the client in advance so that the latency time can be relatively reduced a little.</li>
<li>Stream prioritization: Controllable data transfer priority, allowing the site to achieve more flexible and powerful page control.</li>
<li>Resettable: the ability to stop the sending of data without breaking the TCP connection.</li>
</ul>
<p>Disadvantages: HTTP 2 does not perform as well as HTTP 1.1 in case of packet loss when multiple requests are in a TCP pipeline, because TCP has a special &ldquo;packet loss retransmission&rdquo; mechanism to ensure reliable transmission. When HTTP 2 loses a packet, the entire TCP has to start waiting for retransmission, and then all requests in that TCP connection will be blocked. For HTTP 1.1, multiple TCP connections can be opened, so this situation will only affect one of the connections, and the remaining TCP connections can still transmit data normally.</p>
<p><strong>HTTP3 &ndash; HTTP Over QUIC</strong></p>
<p>HTTP is built on top of the TCP protocol, and all the bottlenecks of the HTTP protocol and its optimization techniques are based on the characteristics of the TCP protocol itself. HTTP2 has implemented multiplexing, but the underlying TCP protocol level problems have not been solved (HTTP 2.0 only needs to use one TCP connection under the same domain. But if this connection has a packet loss, it causes the entire TCP to start waiting for retransmission and all the data behind it is blocked), and HTTP3&rsquo;s QUIC was created to solve HTTP2&rsquo;s TCP problem.</p>
<p>QUIC/HTTP3 features.</p>
<ul>
<li>Ordered transfers: The concept of stream is used to ensure that data is ordered. Different streams or packets are not guaranteed to arrive in an orderly fashion.</li>
<li>Message compression to improve the load ratio: for example, QUIC introduced variable-length integer encoding. another example is the introduction of QPACK for header compression</li>
<li>Reliable transmission: support for packet loss detection and retransmission</li>
<li>Secure transmission: TLS 1.3 security protocol</li>
</ul>
<h2 id="why-do-we-need-quic">Why do we need QUIC?</h2>
<p>With the rapid development of the mobile Internet and the gradual rise of the Internet of Things, the scenarios of network interaction are getting richer and richer, and the contents of network transmission are getting larger and larger, and the users' requirements for network transmission efficiency and WEB response speed are getting higher and higher.</p>
<p>On the one hand, it is an old protocol with a long history of widespread use, and on the other hand, the user&rsquo;s usage scenario has higher and higher requirements for transmission performance. The following long-standing problems and conflicts become more and more prominent.</p>
<h3 id="rigidity-of-intermediate-devices">Rigidity of intermediate devices</h3>
<p>It may be that the TCP protocol has been used for too long and is very reliable. So many of our intermediate devices, including firewalls, NAT gateways, rectifiers, etc., have developed some agreed-upon actions.</p>
<p>For example, some firewalls only allow through 80 and 443 and do not let through other ports, and NAT gateways rewrite the transport layer headers when converting network addresses, potentially preventing both sides from using the new transport format. Rectifiers and intermediate proxies sometimes remove option fields that they do not recognize for security reasons.</p>
<p>The TCP protocol originally supported the addition and modification of ports, options, and features. But because the TCP protocol and well-known ports and options have been in use for so long, intermediate devices have come to rely on these latent rules, so modifications to them are vulnerable to interference from intermediate links and fail.</p>
<p>And these interferences have caused many optimizations on the TCP protocol to become cautious and difficult to follow.</p>
<h3 id="dependence-on-os-implementation-leads-to-protocol-rigidity">Dependence on OS implementation leads to protocol rigidity</h3>
<p>TCP is implemented by the operating system at the kernel Western stack level and can only be used by applications, not directly modified. While it is very fast and easy for applications to iterate. However, TCP iterations are very slow because the operating system is a pain to upgrade.</p>
<p>Now mobile terminals are more popular, but some users on the mobile side may still be years behind in OS upgrades. the PC side of the system lags even more severely. windows xp is still in use by a large number of users, even though it has existed for almost 20 years.</p>
<p>Server-side systems do not rely on user upgrades, but are also conservative and slow because OS upgrades involve updates to the underlying software and runtime libraries.</p>
<p>This means that even when TCP has better feature updates, it is difficult to roll them out quickly. For example, TCP Fast Open, which was introduced in 2013, is still not supported on many versions of Windows.</p>
<h2 id="key-features-of-quic">Key features of QUIC</h2>
<h3 id="connection-migration">Connection Migration</h3>
<p><strong>tcp&rsquo;s connection reconnection pains</strong></p>
<p>A TCP connection is identified by a quadruplet (source IP, source port, destination IP, destination port). What does connection migration mean? It means that when any one of these elements changes, the connection is still maintained and the business logic can be kept uninterrupted. Of course, the main concern here is the change of the client, because the client is not controllable and the network environment often changes, while the server IP and port are generally fixed.</p>
<p>For example, when we use cell phones to switch between WIFI and 4G mobile networks, the IP of the client will definitely change and the TCP connection with the server needs to be re-established. Another example is when you use public NAT outlets, some connections need to rebind the port when competing, resulting in a change in the client&rsquo;s port, which also requires re-establishing the TCP connection. So from the perspective of TCP connection, this problem is unsolvable.</p>
<p><strong>UDP-based QUIC connection migration implementation</strong></p>
<p>So how does QUIC do connection migration? QUIC is based on the UDP protocol, and any QUIC connection is no longer identified by an IP and port quaternion, but by a 64-bit random number as an ID, so that even if the IP or port changes, as long as the ID remains unchanged, the connection is still maintained and the upper business logic does not perceive the change and does not break, so there is no need to reconnect. Since the ID is randomly generated by the client and has a length of 64 bits, the probability of conflict is very low.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/16/b47f4e9ef58a4c06b818b34cf4de7eea.png" alt=""></p>
<h3 id="low-connection-latency">Low connection latency</h3>
<p>0RTT connection building is arguably the biggest performance advantage of QUIC over HTTP2. So what is 0RTT connection building? There are two layers to this.</p>
<ul>
<li>0RTT at the transport layer is all it takes to establish a connection.</li>
<li>0RTT at the encryption layer is enough to establish an encrypted connection.</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/16/5da41efcca7e4d66b0f8513712fbc6fe.png" alt=""></p>
<p>For example, the above diagram on the left shows a full HTTPS handshake to build a connection, which requires 3 RTTs. Even for Session Resumption, at least 2 RTTs are required.</p>
<p>What about QUIC? Since it is based on UDP and implements a secure handshake with 0 RTT, in most cases, only 0 RTTs are needed to send data, based on forward encryption, and the success rate of 0 RTTs is much higher than the Sesison Ticket for TLS.</p>
<p><strong>TLS connection latency problem</strong></p>
<p>As an example, a simple browser visit, typing <a href="https://www.abc.com">https://www.abc.com</a> in the address bar, will actually result in the following actions.</p>
<ul>
<li>DNS recursive lookup of abc.com to obtain the corresponding IP for address resolution.</li>
<li>TCP handshake, with the familiar TCP triple handshake requiring 1 RTT.</li>
<li>TLS handshake, the most widely used TLS 1.2, requires 2 RTTs; for non-first-time connections, you can choose to enable session reuse, which reduces the handshake time to 1 RTT.</li>
<li>HTTP business data interactions, assuming that com data is retrieved in one interaction. Then the business data interaction requires 1 RTT; after the process analysis above, it can be seen that to complete a short HTTPS business data interaction, it needs to go through: 4 RTT + DNS for new connections; 3 RTT + DNS for session reuse.</li>
</ul>
<p>Therefore, for requests with small data volume, a single request handshake takes up a large amount of time, which has a great impact on user experience. At the same time, in the case of poor user network, RTT latency becomes high, which greatly affects user experience.</p>
<p>The following figure compares the latency of each version of TLS with the scenario.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/16/9b832477588247cfb5aef069fbc56e94.png" alt=""></p>
<p>We can see from the comparison that even with TLS 1.3, the handshake process has been streamlined to achieve the fastest 0-RTT handshake (1-RTT for the first time); however, for user perception, there is a TCP handshake overhead of 1RTT. Google has proposed a Fastopen solution to enable TCP to carry user data without the first handshake, but due to the TCP implementation However, due to the rigidity of the TCP implementation, it is not possible to upgrade the application, and the related RFC is experimental to date. Is there any way to further reduce the latency caused by this layered design? QUIC solves this problem by merging encryption and connection management, so let&rsquo;s see how it achieves a true 0-RTT handshake, allowing the first packet interaction with the server to bring the user data.</p>
<p><strong>True-0-RTT QUIC handshake</strong></p>
<p>Since QUIC is UDP-based and does not require a TCP connection, in the best case, QUIC can start data transfer with a short connection at 0RTT. For TCP-based HTTPS, even with the best TLS1.3 early data, 1RTT is still required to initiate data transfer. For TLS1.2 full handshake, which is common online today, 3RTT is required to start data transmission. For RTT-sensitive services, QUIC can effectively reduce connection establishment latency.</p>
<p>The reason for this is, on the one hand, the layered design of TCP and TLS: the layered design requires each logical level to establish its own connection state separately. On the other hand, it is due to the complex key negotiation mechanism in the handshake phase of TLS. To reduce the connection establishment time, we need to start from both aspects.</p>
<p>QUIC specific handshake process is as follows.</p>
<ul>
<li>the client determines whether all the configuration parameters (certificate configuration information) of the server are already available locally, if so, it jumps directly to (5), otherwise it continues.</li>
<li>The client sends an inchoate client hello (CHLO) message to the server, requesting the server to transmit the configuration parameters.</li>
<li>The server receives the CHLO and replies with a rejection(REJ) message, which contains some of the server&rsquo;s configuration parameters.</li>
<li>The client receives the REJ, extracts and stores the server configuration parameters, and jumps back to (1).</li>
<li>The client sends a full client hello message to the server to start the formal handshake, which includes the number of publics selected by the client. At this point, the client can calculate the initial key K1 based on the obtained server configuration parameters and the public number it has chosen.</li>
<li>the server receives the full client hello and replies REJ if it does not agree to connect, same as (3); if it agrees to connect, it calculates the initial key K1 based on the client&rsquo;s public number and replies server hello(SHLO) message, which SHLO encrypts with the initial key K1 and contains a temporary public number chosen by the server.</li>
<li>The client receives the reply from the server, and if it is REJ then the situation is the same as (4); if it is SHLO, it tries to decrypt it with the initial key K1 and extracts the temporary public number.</li>
<li>Client and server each derive session key K2 based on SHA-256 algorithm based on temporary public number and initial key K1.</li>
<li>The initial key K1 is useless and the QUIC handshake process is completed. After that, the process of session key K2 update is similar to the above process, but some fields in the packet are slightly different.</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/16/8c7afb2ac0814d73989c10dd7e8c8a28.png" alt=""></p>
<h3 id="customizable-congestion-control">Customizable congestion control</h3>
<p>Quic uses pluggable congestion control, which provides richer congestion control information compared to TCP. For example, each packet, original or retransmitted, has a new sequence number (seq), which allows Quic to distinguish between retransmitted and original ACKs, thus avoiding the problem of TCP retransmission ambiguity. In addition, Quic&rsquo;s ACK Frame supports 256 NACK intervals, which is more flexible than TCP&rsquo;s SACK (Selective Acknowledgment), and provides more information to the client and server about which packets have been received by each other.</p>
<p>QUIC transmission control no longer relies on the kernel&rsquo;s congestion control algorithm, but is implemented at the application layer, which means we can implement and configure different congestion control algorithms and parameters according to different business scenarios. The performance is also better. Under QUIC, we can specify the congestion control algorithm and parameters according to the service, and even different connections of the same service can use different congestion control algorithms.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/16/73910bf2ab374e5a87017ee936b24982.png" alt=""></p>
<p>TCP congestion control actually consists of four algorithms: slow start, congestion avoidance, fast retransmission, and fast recovery.</p>
<p>The QUIC protocol currently uses TCP&rsquo;s Cubic congestion control algorithm by default, and also supports the CubicBytes, Reno, RenoBytes, BBR, PCC, and other congestion control algorithms.</p>
<p>From the point of view of the congestion algorithm itself, QUIC is just a reimplementation of the TCP protocol, so what exactly has been improved in the QUIC protocol? The main points are as follows.</p>
<p><strong>Pluggable</strong></p>
<p>What do we mean by pluggable? It&rsquo;s the ability to take effect, change, and stop in a very flexible manner. This is reflected in the following aspects.</p>
<ul>
<li>Different congestion control algorithms can be implemented at the application level, without the need for an operating system and without kernel support. This is a leap forward, because traditional TCP congestion control must be supported by the end-to-end network stack to achieve the control effect. The kernel and operating system are very expensive to deploy and have a long upgrade cycle, which is obviously a bit too much for today&rsquo;s rapidly iterating products and explosive network growth.</li>
<li>Different connections of even a single application can support different configurations of congestion control. Even for a single server, the network environment of the connected users is very different. Combining with big data and artificial intelligence processing, we can provide different but more accurate and effective congestion control for each user. For example, BBR is suitable, Cubic is suitable.</li>
<li>We only need to modify the configuration and reload on the server side, and then we can switch the congestion control without stopping the service at all.</li>
</ul>
<p><strong>Monotonically Increasing Packet Number</strong></p>
<p>TCP uses Sequence Number and Ack, which are based on byte sequence numbers, to confirm the orderly arrival of messages for reliability.</p>
<p>QUIC, also a reliable protocol, uses Packet Number instead of TCP&rsquo;s sequence number, and each Packet Number is strictly incremental, meaning that even if Packet N is lost, the Packet Number of the retransmitted Packet N is no longer N, but a value larger than N. In the case of TCP, the sequence number of the retransmitted segment remains the same as the Sequence Number of the original segment, and it is this feature that introduces the ambiguity problem of Tcp retransmission.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/16/c3ff62e2b7034735b29d0a52196df7ff.png" alt=""></p>
<p>As shown above, after the timeout event RTO occurs, the client initiates a retransmission and then receives the Ack data. Since the sequence number is the same, is this Ack data the response of the original request or the response of the retransmission request? It is not easy to determine.</p>
<p>If it is counted as the response of the original request, but it is actually the response of the retransmission request (above left), it will cause the sampling RTT to become larger. If it is counted as the response to a retransmission request, but is actually the response to the original request, the sample RTT can easily be too small.</p>
<p>This problem is easily solved since the Pakcet Number of the Packet retransmitted by Quic and the original Packet are strictly incremental.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/16/ef4bc7be32c84a77b466856cc35c7391.png" alt=""></p>
<p>As shown above, after the RTO occurs, the exact RTT calculation is determined based on the retransmitted Packet Number. If Ack&rsquo;s Packet Number is N+M, the sample RTT is calculated based on the retransmission request. if Ack&rsquo;s Pakcet Number is N, the sample RTT is calculated based on the time of the original request, with no ambiguity.</p>
<p>QUIC also introduces a concept of Stream Offset.</p>
<p>That is, a Stream can be transmitted through multiple Packets with strictly incremental Packet Number and no dependencies. However, if the Payload in a Packet is a Stream, it needs to rely on the Stream Offset to ensure the order of the application data. If the error! Source not found. As shown, the sender sends Pakcet N and Pakcet N+1, and the Offset of Stream is x and x+y, respectively.</p>
<p>Suppose Packet N is lost and a retransmission is initiated, and the retransmitted Packet Number is N+2, but the Offset of its Stream is still x. This way, even if Packet N + 2 arrives later, Stream x and Stream x+y can still be organized in order and given to the application for processing.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/16/7d843becaf4f4b10994a641525974292.png" alt=""></p>
<p><strong>Reneging is not allowed</strong></p>
<p>What does Reneging mean? The TCP protocol does not encourage this behavior, but it is allowed at the protocol level. This is mainly because of limited server resources, such as Buffer overflow, lack of memory, etc.</p>
<p>Reneging can be very disruptive to data retransmission. This is because the Sack has indicated that it was received, but the data is in fact discarded by the receiver.</p>
<p>QUIC reduces this interference by disabling Reneging at the protocol level, so that a Packet must be received correctly as long as it is Acked.</p>
<p><strong>More Ack Blocks</strong></p>
<p>TCP&rsquo;s Sack option can tell the sender the range of consecutive Segments that have been received, facilitating selective retransmission by the sender.</p>
<p>Since the TCP header has a maximum of 60 bytes and the standard header takes up 20 bytes, the maximum length of the Tcp Option is only 40 bytes, plus the Tcp Timestamp option takes up 10 bytes [25], so there are only 30 bytes left for the Sack option.</p>
<p>The length of each Sack Block is 8, plus the 2 bytes of the Sack Option header, which means that the Tcp Sack Option can only provide a maximum of 3 blocks.</p>
<p>However, Quic Ack Frame can provide 256 Ack Blocks at the same time. In networks with high packet loss rate, more Sack Blocks can improve network recovery speed and reduce retransmission.</p>
<p><strong>Ack Delay time</strong>.</p>
<p>There is a problem with the Timestamp option of Tcp [25], it only echoes the timestamp of the sender, but does not calculate the time between the reception of the segment at the receiving end and the sending of Ack for that segment. This time can be abbreviated as Ack Delay.</p>
<p>This leads to RTT calculation errors. The following figure.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/16/1a1e8011ad22484c97927cf6f54b8e02.png" alt=""></p>
<p>It can be considered that the RTT of TCP is calculated as follows: RTT=timestamp2-timestamp1</p>
<p>And Quic calculated as follows: RTT = timestamp2 - timestamp1 - AckDelay</p>
<p>Of course the specific calculation of RTT is not so simple, it needs to be sampled and smoothed with reference to historical values, refer to the following formula.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/16/bbd08f37e84541ed983188037bddd221.png" alt=""></p>
<h3 id="blocking-without-headers">Blocking without headers</h3>
<p><strong>Head Blocking in TCP</strong></p>
<p>Although HTTP2 implements multiplexing, because it is based on byte-stream oriented TCP, packet loss will affect all request streams under multiplexing. quic is based on UDP and is designed to solve the head-of-queue blocking problem.</p>
<p>The main reason for TCP header blocking is that packet timeout or loss blocks the current window from sliding to the right, and the easiest way to solve header blocking is to not let timeout or lost packets block the current window in place.</p>
<p>To ensure reliability, TCP uses Sequence Number and Ack based on the byte sequence number to confirm the orderly arrival of messages.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/16/c59935a82acb4512bd106f16c82937af.png" alt=""></p>
<p>As shown above, the application layer can read the contents of stream1 without any problem, but because the third segment in stream2 has lost packets, TCP needs the sender to retransmit the third segment in order to ensure the reliability of the data before notifying the application layer to read the next data. Therefore, even if the contents of stream3 and stream4 have arrived successfully, the application layer still cannot read them and has to wait for the lost packets in stream2 to be retransmitted.</p>
<p>In a weak network environment, HTTP2&rsquo;s header blocking problem is extremely bad in terms of user experience.</p>
<p><strong>QUIC&rsquo;s non-header blocking solution</strong></p>
<p>QUIC is also a reliable protocol that uses Packet Number instead of TCP&rsquo;s Sequence Number, and each Packet Number is strictly incremental, meaning that even if Packet N is lost, the Packet Number of the retransmitted Packet N is no longer N, but a value larger than N, such as Packet N+M.</p>
<p>The monotonically increasing Packet Number design used by QUIC allows packets to be acknowledged out of order, unlike TCP, and QUIC supports out-of-order acknowledgements, so that when Packet N is lost, the current window continues to slide to the right as long as a new received packet is acknowledged. When the sender is informed that packet Packet N is lost, it will put the packet that needs to be retransmitted into the queue to be sent, renumber it as Packet N+M and resend it to the receiver, processing the retransmitted packet similar to sending a new packet, so that the current window will not be blocked in place due to packet loss and retransmission, thus solving the queue head blocking problem. So, since the Packet N+M of the retransmitted packet does not match the Packet N number of the lost packet, how can we be sure that the contents of the two packets are the same?</p>
<p>QUIC uses the Stream ID to identify which resource request the current data stream belongs to, which is also the basis for the packet to be assembled properly once it is multiplexed to the receiving end. The retransmitted packet Packet N+M and the lost packet Packet N still cannot be determined by the Stream ID alone, so a new field Stream Offset is needed to identify the byte offset of the current packet in the current Stream ID.</p>
<p>With the Stream Offset field information, packets belonging to the same Stream ID can be transmitted in disorder (HTTP/2 relies only on Stream ID identification and requires that data frames belonging to the same Stream ID must be transmitted in order), and the Stream ID and Stream Offset of two packets are consistent, which means that the contents of these two packets are consistent.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/16/08bbf2de1bee450185dd6f62d47270c3.png" alt=""></p>
<h2 id="quic-protocol-components">QUIC Protocol Components</h2>
<p>QUIC is a reliable TCP-like transport protocol built on top of UDP. HTTP3, on the other hand, completes HTTP transactions on top of QUIC. Networks are always discussed in layers, and here we discuss the QUIC protocol in layers from low to high.</p>
<ul>
<li>UDP layer: UDP messages are transmitted at the UDP layer. The concern here is what the UDP message load is and how to send UDP messages efficiently</li>
<li>Connection layer: Connection confirms the unique connection by CID, and connection carries out reliable and secure transmission of the packet.</li>
<li>Stream layer: Stream in the corresponding Connection, through the StreamID for unique stream confirmation, stream for stream frame transmission management</li>
<li>HTTP3 layer: HTTP3 is based on QUIC Stream, which provides more efficient HTTP transaction transfer compared to 1 and HTTP2.0. HTTP3 uses QPACK protocol for header compression.</li>
</ul>
<h3 id="udp-layer">UDP layer</h3>
<p>This section discusses issues related to the UDP portion of QUIC outgoing packets.</p>
<p><strong>UDP load size</strong></p>
<p>Load size is limited by 3 objects: QUIC protocol provisions; path MTU; endpoint acceptance capability</p>
<ul>
<li>QUIC cannot run on a single UDP transport network path that does not support 1200 bytes QUIC has a requirement that the initial packet size must not be less than 1200, and if the data itself is less than 1200 (e.g. initial ack), then it needs to be padded with padding to at least 1200 bytes</li>
<li>QUIC does not want IP layer fragmentation This requirement means that udp will not deliver more than 1 MTU of data to the ip layer, assuming an mtu of 1500, and the upper limit of udp load is 1472 bytes (1500-20-8) for ipv4 scenarios and 1452 (1500-40-8) for ipv6. QUIC recommends using PMTUD as well as DPLPMTUD for mtu probing. In practice, we recommend setting the MTU for IPv6 to 1280. Larger than this value, packet loss can exist in some networks.</li>
<li>The terminal can accept transport paraments with max_udp_payload_size(0x03) is the terminal&rsquo;s ability to accept a single udp packet size, and the sender should comply with this convention.</li>
</ul>
<p><strong>UDP load content</strong></p>
<ul>
<li>The UDP load content is the packet in the quic protocol, which states that multiple packets can be sent as a single udp message if the load size limit is not exceeded. In the quic implementation, if each udp message contains only one quic packet, it will be more likely to have disorder problems.</li>
</ul>
<p><strong>Efficient sending of UDP packets</strong></p>
<p>Unlike tcp, quic requires udp data assembly at the application layer, and each udp packet is no larger than 1 mtu. If not optimized, such as sending each packet directly with sendto/sendmsg, it will inevitably cause a large number of system calls and affect throughput</p>
<ul>
<li>Optimization is performed through the sendmmsg interface. sendmmsg can send multiple udp quic packets from the user state to the kernel state through a single system call. The kernel state sends out each udp quic packet independently as an udp packet</li>
<li>On) solves the problem of the number of system calls, and enabling GSO delays one packet until the moment before it is sent to the NIC driver, which can further improve throughput and reduce CPU consumption</li>
<li>On top of that, the mainstream NICs now support the hardware GSO offload scheme, which can further improve throughput and reduce cpu consumption.</li>
</ul>
<p>The sending method described above can in fact be interpreted as udp burst sending method, which brings up a problem, congestion control requires pacing capability!</p>
<h3 id="connection-layer">Connection layer</h3>
<p>In our discussion, we know that what is transmitted in a udp message is actually one or more packets defined by the quic protocol, so at the Connection level, it is actually managed in packets. When a packet arrives, the terminal needs to resolve the target ConnectionID (DCID) field and give the packet to the corresponding quic connection.</p>
<p><strong>connection id</strong></p>
<p>Unlike tcp, which uniquely identifies a connection by a 4-tuple, QUIC defines a ConnectionID that is independent of network routing to identify a unique connection. This has the advantage that the connection can be maintained when the quadruplet changes (e.g. nat rebinding or end network switching wifi-&gt;4G). Of course, while the connection state is still maintained, congestion control needs to be able to adjust in time due to path changes.</p>
<p><strong>packet header</strong></p>
<p>IETF quic header is divided into two types, long header, short header. long header is divided into four types: initial, 0rtt, handshake, retry. The definition of the type can be directly referred to the rfc document, so I will not repeat it here.</p>
<p>quic stipulates that packet number is always self-increasing, even if the content of a packet is retransmitted frame data, its packet number must be self-increasing, which brings an advantage compared with TCP, and can collect RTT attributes of the path more accurately.</p>
<p>packet number coding and decoding: packet number is a range of values from 0 to 262 - 1. quic introduces the concept of unacked when calculating packet number in order to save space, and by truncating (retaining only valid bit bits), only 1-4 bytes are used, i.e., it can encode/ There is an appendix in the rfc documentation that explains the enc/dec process in detail.</p>
<p>The packet header is protected in secure transmission, which means that timing analysis of the packet using wireshake is not possible without ssl information. Intermediate network devices are also unable to obtain packet numbers for chaotic reordering as TCP does.</p>
<p><strong>packet payload</strong>
After decrypting the packet and removing the packet header, the packet&rsquo;s load is all frames (including at least one).</p>
<p>If the packet load does not include three types of frames like ACK, PADDING, and CONNECTION_CLOSE, then the packet is defined as ack-eliciting, which means that the other end must generate the corresponding ack for this packet to notify the sender to ensure that no data is lost.</p>
<p>The types of frames in the packet load are up to 30 types, each type has its own application scenarios, such as ACK Frame for reliable transmission (Recovery), Crypto for secure transmission (TLS handshake), Stream Frame for business data delivery, MAX_DATA/DATA_BLOCKED for flow control, PING Frame can be used for mtu probing, refer to rfc document for specific description.</p>
<p><strong>Secure Transport</strong></p>
<p>QUIC&rsquo;s secure transport relies on TLS1.3, and boringssl is a dependent library for many QUIC implementations. The protocol protects the Packet header as well as the load (including the packet number.) TLS1.3 0RTT has the ability to provide data protection while sending the Response Header to the client at the first opportunity (when the server receives the first request message). This greatly reduces the first packet time in HTTP services. In order to support 0RTT, the client needs to save PSK information, as well as part of the transport parament information.</p>
<p>Secure transmission also often involves performance issues. in the current mainstream server, AESG has the best performance due to the hardware acceleration provided by the cpu. CHACHA20 requires more CPU resources. On short video service, for the requirement of first frame, it usually uses plaintext transmission directly.</p>
<p>Transport Paramenter (TP) negotiation is done in the handshake phase of secure transmission. In addition to the TP specified in the protocol, users can also extend the private TP content, a feature that brings great convenience, for example: clients can use tp to inform the server for plaintext transmission.</p>
<p><strong>Reliable Transmission</strong></p>
<p>QUIC protocol is required to be able to transmit reliably like TCP, so QUIC has a separate rfc describing the topics of packet loss detection and congestion control.</p>
<p>Packet loss detection: The protocol utilizes two ways to determine whether packet loss has occurred: one is ack-based detection, where the time threshold and packet threshold are used to infer whether packets sent out before this packet are lost based on the packet that has arrived. The second, in the case of lost reference packets, then only by way of PTO to infer whether the packet is lost. Generally speaking, a large number of being triggered should be the way of ACK detection. If PTO is triggered in large numbers, it will affect the efficiency of sending packets.</p>
<p>Congestion control: QUIC is optimized for some defects in the TCP protocol. For example, always increasing packet number, rich ack range, host delay calculation, etc. At the same time, tcp congestion control needs to be implemented in the kernel state, while QUIC is implemented in the user state, which greatly reduces the threshold for studying efficient and reliable transport protocols. newReno implementation is described in the Recovery protocol. In GOOGLE chrome, cubic, bbr, bbrv2 are implemented, while the mvfst project is much richer, including ccp, copa protocols.</p>
<h3 id="stream-layer">Stream layer</h3>
<p>Stream is an abstract concept that expresses an ordered stream of transmitted bytes that are actually composed of Stream Frames lined up together. On a quic connection, multiple streams can be transferred at the same time.</p>
<p><strong>Stream header</strong></p>
<p>In the Quic protocol, streams are classified as unidirectional or bidirectional, and as client-initiated or server-initiated. stream&rsquo;s different type definitions are fully exploited in HTTP3.</p>
<p><strong>Stream payload</strong></p>
<p>The payloadof a stream is a series of Stream Frames, and a single stream is identified by the Stream ID in the header of the Stream Frame.</p>
<p>In TCP, if a segment delivery is lost, then subsequent segments arrive out of order and are not used by the application layer until the lost segment is successfully retransmitted, so the TCP implementation of HTTP2 is constrained in its ability to multiplex. In the QUIC protocol, the concept of order is only maintained in a single stream, and neither the stream nor the packet is required to be ordered. Suppose a packet is lost, it will only affect the streams contained in this packet, and other streams can still extract the data they need from the subsequent packets that arrive in disorder to the application layer.</p>
<h3 id="http3-layer">HTTP3 layer</h3>
<p><strong>stream classification</strong></p>
<p>With the introduction of HTTP3, the unidirectional stream type of stream was extended into: Control stream, Push stream and other reserved types. Among them, HTTP3 setting is transmitted in the control stream, while HTTP data transmission is in the client-initiated bidirectional stream, so the reader will find that the stream id of HTTP data transmission is all mod 4 equal to 0.</p>
<p>With the introduction of QPACK, the one-way stream is further extended with two types, encoder stream, and decoder stream, on which the dynamic table updates in QPACK depend.</p>
<p><strong>QPACK</strong></p>
<p>The role of QPACK is header compression. Similar to HPACK, QPACK defines static tables and dynamic tables for header indexing. Static tables are predefined for common headers, protocols. Dynamic tables are built incrementally as the QUIC Connection serves HTTP, and the Encoder/Decoder stream created by QPACK accompanies the QUIC Connection lifecycle for HTTP transactions.</p>
<p>Dynamic tables are not a must for HTTP3 to work, so in some QUIC open source projects, there is no implementation of complex dynamic table functionality.</p>
<p>In QPACK&rsquo;s dynamic table business, the data stream, encoder stream, decoder stream 3 kinds of objects participate together, encoder stream and decoder stream is responsible for maintaining the dynamic table changes, the data stream is parsed out the index number of the header, go to the dynamic table query, to get the final header definition.</p>
<h3 id="other">Other</h3>
<p><strong>Flow Control</strong></p>
<p>The QUIC protocol introduces the concept of flow control, which is used to express the acceptance capabilities of the receiving end. There are two levels of flow control, Connection level, and Stream level. The data offset sent by the sender cannot exceed the flow control limit, and if the limit is reached, then the sender should notify the receiver via DATA_BLOCKED/STREAM_DATA_BLOCKED. If for the sake of transmission performance, the receiver side should try to keep the limit large enough, for example, update max_data in time to pass it to the sender side when it reaches half of max_data. If the receiver side does not want to accept data too quickly, it can also use flow control to constrain the sender side.</p>
<p><strong>QUIC version</strong></p>
<p>QUIC was designed and developed by google at the beginning, in the chromium project, you can see google quic (GQUIC) version number is defined as Q039,Q043,Q046,Q050 and so on.</p>
<p>With the launch of IETF version of QUIC, ietf quic (IQUIC) also has many versions, such as 29,30,34 (latest version), etc. Different versions may not be interoperable, such as different versions of the safe transmission of the salt variable provisions are not the same. So IQUIC introduces the function of version negotiation for different clients and servers to negotiate a version that can be interoperable.</p>
<p>In practice, there is also a requirement for a service to be able to serve different versions of GQUIC and different versions of IQUIC at the same time. This requires that the service, after receiving the packet, needs to make a judgment on the packet, analyze whether it belongs to QUIC or GQUIC, and then perform logical triage.</p>
<p>QUIC packets are authenticated in the header and encrypted in the body, except for individual messages such as PUBLIC_RESET and CHLO. This way, any modification to the QUIC packet can be detected by the receiver in time, effectively reducing the security risk.</p>
<p>As shown in the figure, the red part is the header of the Stream Frame message, with authentication. The green part is the content of the message, which is all encrypted.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/16/f99a98f13c62410895bf0c4555248ae6.png" alt=""></p>
<ul>
<li>Flags: used to indicate information such as Connection ID length, Packet Number length, etc.</li>
<li>Connection ID: unsigned integer with a maximum length of 64 bits chosen randomly by the client. However, the length is negotiable.</li>
<li>QUIC Version: the version number of the QUIC protocol, a 32-bit optional field. This field is required if Public Flag &amp; FLAG_VERSION ! = 0, this field is required. The client sets Bit0 in the Public Flag to 1 and fills in the desired version number. If the client&rsquo;s desired version number is not supported by the server, the server sets Bit0 in the Public Flag to 1 and lists the protocol versions (0 or more) supported by the server in this field, and no messages can follow this field.</li>
<li>Packet Number: The length depends on the value of the Bit4 and Bit5 bits in the Public Flag, and the maximum length is 6 bytes. The first packet sent by the sender has a sequence number of 1, and the sequence number of the subsequent packets is greater than the sequence number of the previous packet.</li>
<li>Stream ID: Identifies the resource request to which the current data stream belongs.</li>
<li>Offset: identifies the byte offset of the current packet in the current Stream ID.</li>
</ul>
<p>The size of the QUIC message needs to meet the path MTU size to avoid being fragmented. The current maximum message length for QUIC is 1350 under IPV6 and 1370 under IPV4.</p>
<h2 id="quic-application-scenarios">QUIC application scenarios</h2>
<ul>
<li>Image small files: significantly reduce the total file download time and improve efficiency</li>
<li>Video on demand: improve the first screen second opening rate, reduce the rate of lag, improve the user viewing experience</li>
<li>Dynamic request: apply to dynamic request, improve access speed, such as web page login, transaction and other interactive experience enhancement</li>
<li>Weak network environment: provide available services despite severe packet loss and network latency, and optimize transmission indicators such as lag rate, request failure rate, second open rate, and improve connection success rate</li>
<li>Large concurrent connections: strong connection reliability, support for access rate improvement in the case of high number of page resources and concurrent connections</li>
<li>Encrypted connection: secure and reliable transmission performance</li>
</ul>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/quic/">quic</a>
          <a href="/tags/udp/">udp</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2021-12/get-client-realip/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Get the real access IP of the client</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2021-12/gitlab-err/">
            <span class="next-text nav-default">Gitlab pulling code exception after updating Git version：The authenticity of host xxx can&#39;t be established</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
