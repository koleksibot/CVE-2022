<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Dockerfile Best Practices for Accelerating the Development Process - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="A Dockerfile is the starting point for creating a Docker image, which provides a well-defined set of instructions that allow us to copy files or folders, run commands, set environment variables, and perform other tasks needed to create a container image. It is important to write Dockerfile to ensure that the generated images are safe, small, fast to build and fast to update.
In this article we&amp;rsquo;ll see how to write good Dockerfiles to speed up the development process, ensure build reusability, and generate images that are safe to deploy to production." /><meta name="keywords" content="docker, dockerfile" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2021-12/speed-up-develop-flow-dockerfile-best-practices/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Dockerfile Best Practices for Accelerating the Development Process" />
<meta property="og:description" content="A Dockerfile is the starting point for creating a Docker image, which provides a well-defined set of instructions that allow us to copy files or folders, run commands, set environment variables, and perform other tasks needed to create a container image. It is important to write Dockerfile to ensure that the generated images are safe, small, fast to build and fast to update.
In this article we&rsquo;ll see how to write good Dockerfiles to speed up the development process, ensure build reusability, and generate images that are safe to deploy to production." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2021-12/speed-up-develop-flow-dockerfile-best-practices/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-12-15T18:01:17+08:00" />
<meta property="article:modified_time" content="2021-12-15T18:01:17+08:00" />

<meta itemprop="name" content="Dockerfile Best Practices for Accelerating the Development Process">
<meta itemprop="description" content="A Dockerfile is the starting point for creating a Docker image, which provides a well-defined set of instructions that allow us to copy files or folders, run commands, set environment variables, and perform other tasks needed to create a container image. It is important to write Dockerfile to ensure that the generated images are safe, small, fast to build and fast to update.
In this article we&rsquo;ll see how to write good Dockerfiles to speed up the development process, ensure build reusability, and generate images that are safe to deploy to production."><meta itemprop="datePublished" content="2021-12-15T18:01:17+08:00" />
<meta itemprop="dateModified" content="2021-12-15T18:01:17+08:00" />
<meta itemprop="wordCount" content="1565">
<meta itemprop="keywords" content="docker," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Dockerfile Best Practices for Accelerating the Development Process"/>
<meta name="twitter:description" content="A Dockerfile is the starting point for creating a Docker image, which provides a well-defined set of instructions that allow us to copy files or folders, run commands, set environment variables, and perform other tasks needed to create a container image. It is important to write Dockerfile to ensure that the generated images are safe, small, fast to build and fast to update.
In this article we&rsquo;ll see how to write good Dockerfiles to speed up the development process, ensure build reusability, and generate images that are safe to deploy to production."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Dockerfile Best Practices for Accelerating the Development Process</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-12-15 18:01:17 </span>
        <div class="post-category">
            <a href="/categories/skills/"> skills </a>
            </div>
          <span class="more-meta"> 1565 words </span>
          <span class="more-meta"> 8 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#development-process">Development Process</a>
          <ul>
            <li><a href="#incremental-builds">Incremental builds</a></li>
            <li><a href="#keep-live-loading-between-host-and-container">Keep live loading between host and container</a></li>
          </ul>
        </li>
        <li><a href="#build-consistency">Build consistency</a>
          <ul>
            <li><a href="#consistent-builds-from-source">Consistent builds from source</a></li>
            <li><a href="#multi-phase-and-matching-the-right-environment">Multi-phase and matching the right environment</a></li>
          </ul>
        </li>
        <li><a href="#preparing-for-production">Preparing for production</a>
          <ul>
            <li><a href="#no-more-recent-image-versions">No more recent image versions</a></li>
            <li><a href="#using-official-mirrors">Using Official Mirrors</a></li>
            <li><a href="#enough-privileges">Enough privileges!</a></li>
          </ul>
        </li>
        <li><a href="#conclusion">Conclusion</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>A Dockerfile is the starting point for creating a Docker image, which provides a well-defined set of instructions that allow us to copy files or folders, run commands, set environment variables, and perform other tasks needed to create a container image. It is important to write Dockerfile to ensure that the generated images are safe, small, fast to build and fast to update.</p>
<p>In this article we&rsquo;ll see how to write good Dockerfiles to speed up the development process, ensure build reusability, and generate images that are safe to deploy to production.</p>
<h2 id="development-process">Development Process</h2>
<p>As developers, we want to match our development environment as closely as possible to our production environment to ensure that the content we build will work when deployed.</p>
<p>We also want to be able to develop quickly, which means we want builds to be fast and we also want to be able to use development tools like debuggers. Containers are a great way to organize our development environment, but we need to define our Dockerfile properly to be able to interact with our containers quickly.</p>
<h3 id="incremental-builds">Incremental builds</h3>
<p>A Dockerfile is a declarative manifest for building container images. While the Docker builder caches the results of each step as an image layer, the cache may be invalidated, resulting in the step that invalidated the cache and all subsequent steps needing to be rerun and the corresponding layer regenerated.</p>
<p>The cache is invalidated when the <code>COPY</code> or <code>ADD</code> reference to a file in the build context changes. So the order of the build steps may have a very significant impact on the performance of the build.</p>
<p>Let&rsquo;s look at an example of building a NodeJs project in Dockerfile. In this project, a number of dependencies are specified in the package.json file, which are fetched when the npm ci command is run.</p>
<p>The simplest Dockerfile file looks like this.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="k">FROM</span><span class="s"> node:lts</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="k">ENV</span> <span class="nv">CI</span><span class="o">=</span><span class="nb">true</span>
<span class="k">ENV</span> <span class="nv">PORT</span><span class="o">=</span><span class="m">3000</span>

<span class="k">WORKDIR</span><span class="s"> /code</span><span class="err">
</span><span class="err"></span><span class="k">COPY</span> . /code<span class="err">
</span><span class="err"></span><span class="k">RUN</span> npm ci<span class="err">
</span><span class="err">
</span><span class="err"></span><span class="k">CMD</span> <span class="p">[</span> <span class="s2">&#34;npm&#34;</span><span class="p">,</span> <span class="s2">&#34;start&#34;</span> <span class="p">]</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><p>Whenever a file in the build context changes, building the Dockerfile as described above will cause the cache to be invalidated on the COPY line. This means that any changes to any file other than the package.json file, which will take a long time, will be re-fetched and placed in the node_modules directory.</p>
<p>To avoid this and only re-fetching dependencies when they change (i.e., when <code>package.json</code> or <code>package-lock.json</code> changes), we should consider separating the dependency installation from the build and run of the application.</p>
<p>The optimized Dockerfile looks like this.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="k">FROM</span><span class="s"> node:lts</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="k">ENV</span> <span class="nv">CI</span><span class="o">=</span><span class="nb">true</span>
<span class="k">ENV</span> <span class="nv">PORT</span><span class="o">=</span><span class="m">3000</span>

<span class="k">WORKDIR</span><span class="s"> /code</span><span class="err">
</span><span class="err"></span><span class="k">COPY</span> package.json package-lock.json /code/<span class="err">
</span><span class="err"></span><span class="k">RUN</span> npm ci<span class="err">
</span><span class="err"></span><span class="k">COPY</span> src /code/src<span class="err">
</span><span class="err">
</span><span class="err"></span><span class="k">CMD</span> <span class="p">[</span> <span class="s2">&#34;npm&#34;</span><span class="p">,</span> <span class="s2">&#34;start&#34;</span> <span class="p">]</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><p>Using this separation, if the <code>package.json</code> or <code>package-lock.json</code> file is not changed, the cache will be used for the layer generated by the <code>RUN npm ci</code> command. This means that when we edit the application source code and rebuild it, we won&rsquo;t have to re-download the dependencies, saving a lot of time ðŸŽ‰.</p>
<h3 id="keep-live-loading-between-host-and-container">Keep live loading between host and container</h3>
<p>This tip is not directly related to Dockerfile, but we often hear the question: How to keep the code hot updated when running the application in the container and modifying the source code from the IDE on the host?</p>
<p>In our example here, we need to mount our project directory to the container and pass an environment variable to enable <a href="https://github.com/paulmillr/chokidar">Chokidar</a>, which encapsulates the NodeJS file change events. Run the command as shown below.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">$ docker run -e <span class="nv">CHOKIDAR_USEPOLLING</span><span class="o">=</span><span class="nb">true</span>  -v <span class="si">${</span><span class="nv">PWD</span><span class="si">}</span>/src/:/code/src/ -p 3000:3000 repository/image_name
</code></pre></td></tr></table>
</div>
</div><p>Here we mount the code directory on top of the host to the container via <code>-v</code>, and any changes to the code on the host will be loaded and updated in the container in real time.</p>
<h2 id="build-consistency">Build consistency</h2>
<p>One of the most important things about Dockerfile is to build identical images from the same build context (sources, dependencies, &hellip;).</p>
<p>Here we will continue to improve the Dockerfile defined in the previous section.</p>
<h3 id="consistent-builds-from-source">Consistent builds from source</h3>
<p>As described in the previous section, we can build applications by adding source files and dependencies to the Dockerfile description and running commands on them.</p>
<p>But in the previous example, we can&rsquo;t actually confirm that the generated image is the same every time we run <code>docker build</code>, why? Because every time NodeJS is released, the lts tag points to the latest LTS version of the NodeJS image, which changes over time and can bring about significant changes. So we can easily solve this problem by using a deterministic tag for the base image. As follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="k">FROM</span><span class="s"> node:13.12.0</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="k">ENV</span> <span class="nv">CI</span><span class="o">=</span><span class="nb">true</span>
<span class="k">ENV</span> <span class="nv">PORT</span><span class="o">=</span><span class="m">3000</span>

<span class="k">WORKDIR</span><span class="s"> /code</span><span class="err">
</span><span class="err"></span><span class="k">COPY</span> package.json package-lock.json /code/<span class="err">
</span><span class="err"></span><span class="k">RUN</span> npm ci<span class="err">
</span><span class="err"></span><span class="k">COPY</span> src /code/src<span class="err">
</span><span class="err">
</span><span class="err"></span><span class="k">CMD</span> <span class="p">[</span> <span class="s2">&#34;npm&#34;</span><span class="p">,</span> <span class="s2">&#34;start&#34;</span> <span class="p">]</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><p>In the following we will also see that there are other advantages to using label-specific base images.</p>
<h3 id="multi-phase-and-matching-the-right-environment">Multi-phase and matching the right environment</h3>
<p>We are consistent for development builds, but how do we do this for production environments?</p>
<p>Starting with Docker 17.05, we can use multi-stage builds to define the steps to generate the final image. Using this mechanism in Dockerfile, we can separate the images used for the development process from those used for the production environment, as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="k">FROM</span><span class="s"> node:13.12.0 AS development</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="k">ENV</span> <span class="nv">CI</span><span class="o">=</span><span class="nb">true</span>
<span class="k">ENV</span> <span class="nv">PORT</span><span class="o">=</span><span class="m">3000</span>

<span class="k">WORKDIR</span><span class="s"> /code</span><span class="err">
</span><span class="err"></span><span class="k">COPY</span> package.json package-lock.json /code/<span class="err">
</span><span class="err"></span><span class="k">RUN</span> npm ci<span class="err">
</span><span class="err"></span><span class="k">COPY</span> src /code/src<span class="err">
</span><span class="err">
</span><span class="err"></span><span class="k">CMD</span> <span class="p">[</span> <span class="s2">&#34;npm&#34;</span><span class="p">,</span> <span class="s2">&#34;start&#34;</span> <span class="p">]</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="k">FROM</span><span class="s"> development AS builder</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="k">RUN</span> npm run build<span class="err">
</span><span class="err">
</span><span class="err"></span><span class="k">FROM</span><span class="s"> nginx:1.17.9 AS production</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="k">COPY</span> â€“from<span class="o">=</span>builder /code/build /usr/share/nginx/html<span class="err">
</span></code></pre></td></tr></table>
</div>
</div><p>When we see a directive like <code>FROM ...... AS</code> we can know it is a multi-build phase. We now have 3 phases: development, build and production. By using the <code>--target</code> tag to build the image for a specific development phase, we can continue to use the container for our development process.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">$ docker build â€“target development -t repository/image_name:development .
</code></pre></td></tr></table>
</div>
</div><p>The same can also be run like this.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">$ docker run -e <span class="nv">CHOKIDAR_USEPOLLING</span><span class="o">=</span><span class="nb">true</span> -v <span class="si">${</span><span class="nv">PWD</span><span class="si">}</span>/src/:/code/src/ repository/image_name:development
</code></pre></td></tr></table>
</div>
</div><p>A docker build without the <code>-target</code> flag will build the final stage, which in our case is the production image. Our production image is just an nginx image, where the files built in the previous steps are placed in the corresponding locations.</p>
<h2 id="preparing-for-production">Preparing for production</h2>
<p>It is important to keep the production image as lean and secure as possible. Here are a few things to check before running containers in production.</p>
<h3 id="no-more-recent-image-versions">No more recent image versions</h3>
<p>As we said earlier, the build step using a specific tag helps to make the generation of mirrors unique. There are also at least two very good reasons to use specific tags for mirrors.</p>
<ul>
<li>It is easy to find all containers running with a mirrored version in a container orchestration system (Swarm, Kubernetes&hellip;).</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="c1"># Search in Docker engine containers using our repository/image_name:development image</span>

$ docker inspect <span class="k">$(</span>docker ps -q<span class="k">)</span> <span class="p">|</span> jq -c â€˜.<span class="o">[]</span> <span class="p">|</span> <span class="k">select</span><span class="o">(</span>.Config.Image <span class="o">==</span> <span class="s2">&#34;repository/image_name:development&#34;</span><span class="o">)</span> <span class="p">|</span><span class="s2">&#34;\(.Id) \(.State) \(.Config)&#34;</span>â€˜

<span class="s2">&#34;89bf376620b0da039715988fba42e78d42c239446d8cfd79e4fbc9fbcc4fd897 {\&#34;Status\&#34;:\&#34;running\&#34;,\&#34;Running\&#34;:true,\&#34;Paused\&#34;:false,\&#34;Restarting\&#34;:false,\&#34;OOMKilled\&#34;:false,\&#34;Dead\&#34;:false,\&#34;Pid\&#34;:25463,\&#34;ExitCode\&#34;:0,\&#34;Error\&#34;:\&#34;\&#34;,\&#34;StartedAt\&#34;:\&#34;2020-04-20T09:38:31.600777983Z\&#34;,\&#34;FinishedAt\&#34;:\&#34;0001-01-01T00:00:00Z\&#34;}
</span><span class="s2">{\&#34;Hostname\&#34;:\&#34;89bf376620b0\&#34;,\&#34;Domainname\&#34;:\&#34;\&#34;,\&#34;User\&#34;:\&#34;\&#34;,\&#34;AttachStdin\&#34;:false,\&#34;AttachStdout\&#34;:true,\&#34;AttachStderr\&#34;:true,\&#34;ExposedPorts\&#34;:{\&#34;3000/tcp\&#34;:{}},\&#34;Tty\&#34;:false,\&#34;OpenStdin\&#34;:false,\&#34;StdinOnce\&#34;:false,\&#34;Env\&#34;:[\&#34;CHOKIDAR_USEPOLLING=true\&#34;,\&#34;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\&#34;,\&#34;NODE_VERSION=12.16.2\&#34;,\&#34;YARN_VERSION=1.22.4\&#34;,\&#34;CI=true\&#34;,\&#34;PORT=3000\&#34;],\&#34;Cmd\&#34;:[\&#34;npm\&#34;,\&#34;start\&#34;],\&#34;Image\&#34;:\&#34;repository/image_name:development\&#34;,\&#34;Volumes\&#34;:null,\&#34;WorkingDir\&#34;:\&#34;/code\&#34;,\&#34;Entrypoint\&#34;:[\&#34;docker-entrypoint.sh\&#34;],\&#34;OnBuild\&#34;:null,\&#34;Labels\&#34;:{}}&#34;</span>

<span class="c1">#Search in k8s pods running a container with our repository/image_name:development image (using jq cli)</span>
$ kubectl get pods â€“all-namespaces -o json <span class="p">|</span> jq -c â€˜.items<span class="o">[]</span> <span class="p">|</span> <span class="k">select</span><span class="o">(</span>.spec.containers<span class="o">[]</span>.image <span class="o">==</span> <span class="s2">&#34;repository/image_name:development&#34;</span><span class="o">)</span><span class="p">|</span> .metadataâ€™

<span class="o">{</span><span class="s2">&#34;creationTimestamp&#34;</span>:<span class="s2">&#34;2020-04-10T09:41:55Z&#34;</span>,<span class="s2">&#34;generateName&#34;</span>:<span class="s2">&#34;image_name-78f95d4f8c-&#34;</span>,<span class="s2">&#34;labels&#34;</span>:<span class="o">{</span><span class="s2">&#34;com.docker.default-service-type&#34;</span>:<span class="s2">&#34;&#34;</span>,<span class="s2">&#34;com.docker.deploy-namespace&#34;</span>:<span class="s2">&#34;docker&#34;</span>,<span class="s2">&#34;com.docker.fry&#34;</span>:<span class="s2">&#34;image_name&#34;</span>,<span class="s2">&#34;com.docker.image-tag&#34;</span>:<span class="s2">&#34;development&#34;</span>,<span class="s2">&#34;pod-template-hash&#34;</span>:<span class="s2">&#34;78f95d4f8c&#34;</span><span class="o">}</span>,<span class="s2">&#34;name&#34;</span>:<span class="s2">&#34;image_name-78f95d4f8c-gmlrz&#34;</span>,<span class="s2">&#34;namespace&#34;</span>:<span class="s2">&#34;docker&#34;</span>,<span class="s2">&#34;ownerReferences&#34;</span>:<span class="o">[{</span><span class="s2">&#34;apiVersion&#34;</span>:<span class="s2">&#34;apps/v1â€³,&#34;</span>blockOwnerDeletion<span class="s2">&#34;:true,&#34;</span>controller<span class="s2">&#34;:true,&#34;</span>kind<span class="s2">&#34;:&#34;</span>ReplicaSet<span class="s2">&#34;,&#34;</span>name<span class="s2">&#34;:&#34;</span>image_name-78f95d4f8c<span class="s2">&#34;,&#34;</span>uid<span class="s2">&#34;:&#34;</span>5ad21a59-e691-4873-a6f0-8dc51563de8d<span class="s2">&#34;}],&#34;</span>resourceVersion<span class="s2">&#34;:&#34;</span>532â€³,<span class="s2">&#34;selfLink&#34;</span>:<span class="s2">&#34;/api/v1/namespaces/docker/pods/image_name-78f95d4f8c-gmlrz&#34;</span>,<span class="s2">&#34;uid&#34;</span>:<span class="s2">&#34;5c70f340-05f1-418f-9a05-84d0abe7009d&#34;</span><span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>For CVE (Common Vulnerabilities and Disclosures), we can quickly know if we need to patch containers and images. In our example here, we can specify that our development and production images use the alpine version.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="k">FROM</span><span class="s"> node:13.12.0-alpine AS development</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="k">ENV</span> <span class="nv">CI</span><span class="o">=</span><span class="nb">true</span>
<span class="k">ENV</span> <span class="nv">PORT</span><span class="o">=</span><span class="m">3000</span>

<span class="k">WORKDIR</span><span class="s"> /code</span><span class="err">
</span><span class="err"></span><span class="k">COPY</span> package.json package-lock.json /code/<span class="err">
</span><span class="err"></span><span class="k">RUN</span> npm ci<span class="err">
</span><span class="err"></span><span class="k">COPY</span> src /code/src<span class="err">
</span><span class="err">
</span><span class="err"></span><span class="k">CMD</span> <span class="p">[</span> <span class="s2">&#34;npm&#34;</span><span class="p">,</span> <span class="s2">&#34;start&#34;</span> <span class="p">]</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="k">FROM</span><span class="s"> development AS builder</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="k">RUN</span> npm run build<span class="err">
</span><span class="err">
</span><span class="err"></span><span class="k">FROM</span><span class="s"> nginx:1.17.9-alpine</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="k">COPY</span> â€“from<span class="o">=</span>builder /code/build /usr/share/nginx/html<span class="err">
</span></code></pre></td></tr></table>
</div>
</div><h3 id="using-official-mirrors">Using Official Mirrors</h3>
<p>You can use Docker Hub to search for base mirrors to use in Dockerfile, some of which are officially supported mirrors. We strongly recommend using these mirrors.</p>
<ul>
<li>Their content has been verified</li>
<li>They will be updated quickly after fixing CVEs</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/15/8a892e6e56e04e28bc5c1d6ce5ff196b.png" alt=""></p>
<p>You can add the <code>image_filter</code> request query parameter to get the official version of the image.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh">https://hub.docker.com/search?q<span class="o">=</span>nginx<span class="p">&amp;</span><span class="nv">type</span><span class="o">=</span>image<span class="p">&amp;</span><span class="nv">image_filter</span><span class="o">=</span>official
</code></pre></td></tr></table>
</div>
</div><p>The examples we used above use the official images of NodeJS and NGINX.</p>
<h3 id="enough-privileges">Enough privileges!</h3>
<p>All applications, whether running in containers or not, should adhere to the principle of least privilege, which means that applications should only access the resources they need.</p>
<p>Processes running with too many privileges may have unintended consequences for the entire system at runtime if malicious behavior or errors occur.</p>
<p>Configuring the image itself with an unprivileged user identity is also very simple:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="k">FROM</span><span class="s"> maven:3.6.3-jdk-11 AS builder</span><span class="err">
</span><span class="err"></span><span class="k">WORKDIR</span><span class="s"> /workdir/server</span><span class="err">
</span><span class="err"></span><span class="k">COPY</span> pom.xml /workdir/server/pom.xml<span class="err">
</span><span class="err"></span><span class="k">RUN</span> mvn dependency:go-offline<span class="err">
</span><span class="err">
</span><span class="err"></span><span class="k">RUN</span> mvn package<span class="err">
</span><span class="err">
</span><span class="err"></span><span class="k">FROM</span><span class="s"> openjdk:11-jre-slim</span><span class="err">
</span><span class="err"></span><span class="k">RUN</span> addgroup -S java <span class="o">&amp;&amp;</span> adduser -S javauser -G java<span class="err">
</span><span class="err"></span><span class="k">USER</span><span class="s"> javauser</span><span class="err">
</span><span class="err">
</span><span class="err"></span><span class="k">EXPOSE</span><span class="s"> 8080</span><span class="err">
</span><span class="err"></span><span class="k">COPY</span> â€“from<span class="o">=</span>builder /workdir/server/target/project-0.0.1-SNAPSHOT.jar /project-0.0.1-SNAPSHOT.jar<span class="err">
</span><span class="err">
</span><span class="err"></span><span class="k">CMD</span> <span class="p">[</span><span class="s2">&#34;java&#34;</span><span class="p">,</span> <span class="s2">&#34;-Djava.security.egd=file:/dev/./urandom&#34;</span><span class="p">,</span> <span class="s2">&#34;-jar&#34;</span><span class="p">,</span> <span class="s2">&#34;/project-0.0.1-SNAPSHOT.jar&#34;</span><span class="p">]</span><span class="err">
</span></code></pre></td></tr></table>
</div>
</div><p>Simply create a new group, add a user to it, and then use the USER command and we can run the container with a non-root user.</p>
<h2 id="conclusion">Conclusion</h2>
<p>In this article we have shown just some of the many ways to optimize and protect Docker images by making a Dockerfile. If you want to learn more about how to do this, you can check out some of the following sources.</p>
<ul>
<li><a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/">Our official documentation about Dockerfile best practices</a></li>
<li><a href="https://www.docker.com/blog/intro-guide-to-dockerfile-best-practices/">A previous post on the subject by Tibor Vass</a></li>
<li><a href="https://www.docker.com/dockercon/2019-videos?watch=dockerfile-">A session during the DockerCon 2019 by Tibor Vass and Sebastiaan van Stijn</a> best-practices)</li>
<li><a href="https://www.youtube.com/watch?v=VjmOhWIRtTY">Another session during Devoxx 2019 by JÃ©rÃ©mie Drouet and myself</a></li>
</ul>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/docker/">docker</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2021-12/use-cdk8s-define-k8s-app/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Describing Kubernetes Applications Using Programming Languages - cdk8s</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2021-12/visualize-kubernetes-app/">
            <span class="next-text nav-default">Visually Create Kubernetes Microservice Applications</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
