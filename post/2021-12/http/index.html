<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>HTTP protocol evolution and features of each version - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Recently, I&amp;rsquo;ve been learning about TCP/IP, and I&amp;rsquo;ve found that most of the HTTP-related content is very old. Many of the materials are not updated with the HTTP version. So I took the time to do some simple organization. HTTP&amp;rsquo;s Past Life Saga Before the HTTP protocol was defined, Berners-Lee had already proposed the hypertext idea and eventually implemented the earliest hypertext systems. 1980 - The Birth of the Hypertext" /><meta name="keywords" content="http" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2021-12/http/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="HTTP protocol evolution and features of each version" />
<meta property="og:description" content="Recently, I&rsquo;ve been learning about TCP/IP, and I&rsquo;ve found that most of the HTTP-related content is very old. Many of the materials are not updated with the HTTP version. So I took the time to do some simple organization. HTTP&rsquo;s Past Life Saga Before the HTTP protocol was defined, Berners-Lee had already proposed the hypertext idea and eventually implemented the earliest hypertext systems. 1980 - The Birth of the Hypertext" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2021-12/http/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-12-22T16:15:42+08:00" />
<meta property="article:modified_time" content="2021-12-22T16:15:42+08:00" />

<meta itemprop="name" content="HTTP protocol evolution and features of each version">
<meta itemprop="description" content="Recently, I&rsquo;ve been learning about TCP/IP, and I&rsquo;ve found that most of the HTTP-related content is very old. Many of the materials are not updated with the HTTP version. So I took the time to do some simple organization. HTTP&rsquo;s Past Life Saga Before the HTTP protocol was defined, Berners-Lee had already proposed the hypertext idea and eventually implemented the earliest hypertext systems. 1980 - The Birth of the Hypertext"><meta itemprop="datePublished" content="2021-12-22T16:15:42+08:00" />
<meta itemprop="dateModified" content="2021-12-22T16:15:42+08:00" />
<meta itemprop="wordCount" content="8784">
<meta itemprop="keywords" content="http," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="HTTP protocol evolution and features of each version"/>
<meta name="twitter:description" content="Recently, I&rsquo;ve been learning about TCP/IP, and I&rsquo;ve found that most of the HTTP-related content is very old. Many of the materials are not updated with the HTTP version. So I took the time to do some simple organization. HTTP&rsquo;s Past Life Saga Before the HTTP protocol was defined, Berners-Lee had already proposed the hypertext idea and eventually implemented the earliest hypertext systems. 1980 - The Birth of the Hypertext"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SoByte</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SoByte</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">HTTP protocol evolution and features of each version</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-12-22 16:15:42 </span>
        <div class="post-category">
            <a href="/categories/skills/"> skills </a>
            </div>
          <span class="more-meta"> 8784 words </span>
          <span class="more-meta"> 18 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#https-past-life-saga">HTTP&rsquo;s Past Life Saga</a></li>
        <li><a href="#introduction-to-http-protocol">Introduction to HTTP Protocol</a>
          <ul>
            <li><a href="#http-request-message">HTTP request message</a></li>
            <li><a href="#http-response-message">HTTP response message</a></li>
            <li><a href="#http-connection-management">HTTP connection management</a></li>
            <li><a href="#stateless-http">Stateless HTTP</a></li>
            <li><a href="#http-and-https">HTTP and HTTPS</a></li>
          </ul>
        </li>
        <li><a href="#http-protocol-evolution">HTTP protocol evolution</a>
          <ul>
            <li><a href="#http09">HTTP/0.9</a></li>
            <li><a href="#http10">HTTP/1.0</a></li>
            <li><a href="#http11">HTTP/1.1</a></li>
            <li><a href="#sypd">SYPD</a></li>
            <li><a href="#http2">HTTP/2</a></li>
            <li><a href="#quic">QUIC</a></li>
            <li><a href="#http30">HTTP/3.0</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>Recently, I&rsquo;ve been learning about TCP/IP, and I&rsquo;ve found that most of the HTTP-related content is very old. Many of the materials are not updated with the HTTP version. So I took the time to do some simple organization.</p>
<h2 id="https-past-life-saga">HTTP&rsquo;s Past Life Saga</h2>
<p>Before the HTTP protocol was defined, Berners-Lee had already proposed the hypertext idea and eventually implemented the earliest hypertext systems.</p>
<p><strong>1980 - The Birth of the Hypertext Idea</strong></p>
<p>Between June and December 1980, Berners-Lee worked as an independent contractor at CERN (European Centre for Nuclear Research) in Geneva. During that time, he developed the idea of creating a project based on a hypertext system designed to facilitate the sharing and updating of information among researchers.</p>
<p>He also developed one of the first prototype systems, which he named <a href="https://zh.wikipedia.org/wiki/ENQUIRE">ENQUIRE</a>. This system allows one to store pieces of information and link related parts in any way. To find information, one links from one sheet of paper to another, just like in the old computer game &ldquo;Adventure&rdquo;. He uses it to keep personal records of individuals and modules. It is similar to Apple&rsquo;s original application Hypercard for the Macintosh, except that the query, despite its lack of fancy graphics, runs on a multi-user system and allows many people to access the same data.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/22/b6c6b281009e491b9fbb394f20576149.png" alt="image"></p>
<p>Thus, the first prototype of a hypertext system was born (there was no HTTP protocol at that time). It was also the experience with the ENQUIRE system that planted a solid seed for the birth of the World Wide Web.</p>
<p><strong>1989 - The Birth of the World Wide Web</strong></p>
<p>In 1980, Berners-Lee left CERN and returned after four years of bouncing around. In 1989, to solve the problem of information access at CERN, Berners-Lee used a concept similar to the <a href="https://zh.wikipedia.org/wiki/ENQUIRE">ENQUIRE</a> system to create the <a href="https://zh.wikipedia.org/wiki/%E4%B8%87%E7%BB%B4%E7%BD%91">World Wide Web </a>.</p>
<p>There were many problems with CERN information access at that time, also including.</p>
<ul>
<li>People move around and information is constantly lost?</li>
<li>Where is this module used?</li>
<li>Who wrote this code? Where does he work?</li>
<li>What is the documentation on this concept?</li>
<li>What labs are included in this project?</li>
<li>What systems depend on this device?</li>
<li>What documents cover this one?</li>
</ul>
<p>When Berners-Lee realized the problems, he wrote <a href="https://www.w3.org/History/1989/proposal.html">a proposal</a> to try to convince CERN management that a global hypertext system was in line with the current situation at CERN and would still be beneficial. Internet node in Europe. The proposal describes in detail how CERN&rsquo;s information access problems arose, and describes in detail the evolution of the solution. The final solution was to use a hypertext system.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/22/88ad82673eb24f20bc0fc9eac3922680.png" alt="image"></p>
<p>This is also the first time that linked resources are proposed instead of a hierarchical system, rather than keywords to locate resources. The linked resource here is also the system that will later become known as the unique authentication of global web resources, the Uniform Resource Identifier (<a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%AC%A6">URI</a>).</p>
<p>Then why did Berners-Lee not use a hierarchical system and keywords to locate resources. In fact, he did consider it, and in the <a href="https://www.w3.org/History/1989/proposal.html">proposal</a> he wrote describes in detail the problems of hierarchical systems and keyword-located resources. The main problems are.</p>
<ul>
<li>Problems with the hierarchical system: problems with the tree structure, no restrictions if you use links.</li>
<li>The problem of keywords: two people never choose the same keywords. These keywords only apply to people who are already familiar with the application.</li>
</ul>
<p>It was for these reasons that Berners-Lee first built a small linked information system, not realizing that a term had been coined for the idea: &ldquo;hypertext&rdquo;.</p>
<p>Eventually, in 1990 Berners-Lee redeveloped the configuration system after it was accepted by his manager, Mike Sendall.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/22/5400e30860b94ffcab6a899a356d17fa.png" alt="image"></p>
<p>The approximate system of the Berners-Lee redevelopment configuration system is what is shown in the figure. Users view data through a hypertext browser via a hypertext gateway.</p>
<p>It is because of this system that not only laid the foundation for the HTTP/0.9 protocol, but also gave birth to the familiar <a href="https://zh.wikipedia.org/wiki/%E4%B8%87%E7%BB%B4%E7%BD%91">World Wide Web</a> later.</p>
<p><strong>HTTP protocol was born</strong></p>
<p>In fact, having said all this does not explain the need for the HTTP protocol, <a href="https://www.w3.org/Protocols/WhyHTTP.html">why do we need to create a new protocol (HTTP protocol)</a>, can&rsquo;t we use other protocols?</p>
<p>The existing protocols at the time covered many different tasks.</p>
<ul>
<li>The mail protocol allows the transmission of ephemeral messages from a single author to a small number of recipients.</li>
<li>File transfer protocols allow data to be transmitted at the request of the sender or recipient, but do not allow data to be processed on the response side.</li>
<li>The News protocol allows the broadcast of transient data to a wide audience.</li>
<li>Search and retrieval protocols allow for indexed searches and document access.</li>
</ul>
<p>Considering that few protocols exist that can be extended as needed, the only one that is available, Z39.50, is considered a viable bar.</p>
<p>The HTTP protocol must provide.</p>
<ul>
<li>a subset of file transfer functionality</li>
<li>the ability to request indexed searches</li>
<li>Automatic format negotiation</li>
<li>the ability to refer clients to another server</li>
</ul>
<p>The HTTP protocol was born because it was difficult to extend on the original existing protocol.</p>
<h2 id="introduction-to-http-protocol">Introduction to HTTP Protocol</h2>
<p>HTTP (HyperText Transfer Protocol) is one of the most widely used network protocols on the Internet today. HTTP, like many protocols in the TCP/IP protocol cluster, is used for communication between clients and servers.</p>
<p>Hypertext&quot; refers to text that goes beyond ordinary text, and is a mixture of text, images, video, etc. It is a mixture of text, images, videos, etc. The key is to have &ldquo;hyperlinks&rdquo; that can jump from one hypertext to another.</p>
<p>The HTTP protocol states that when two computers communicate using the HTTP protocol, there must be a client at one end and a server at the other end of a communication line. When you enter a URL in your browser to access a website, your browser (client) encapsulates your request into an HTTP request and sends it to the server, which receives the request and then organizes the response data into an HTTP response back to the browser. In other words, the communication must be established from the client side first, and the server side does not send a response until the request is received.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/22/ee85545dc28e4592a5202ffb1e87b595.png" alt="image"></p>
<h3 id="http-request-message">HTTP request message</h3>
<p>The HTTP request message consists of 3 main parts.</p>
<ul>
<li>Request line (must be on the first line of the HTTP request message)</li>
<li>The request header (starts on the second line and ends on the first blank line. There is a blank line between the request header and the request body)</li>
<li>The request body (data is usually passed as a key-value pair {key:value})</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/22/c9d31cf5ede442358360f63b7e82e4f8.png" alt="image"></p>
<p>The POST at the beginning of the request line indicates the type of request to access the server, called method. The subsequent string /form/login specifies the resource object that is being requested, also called the request URI (request-URI). The final HTTP/1.1, the version number of HTTP, is used to indicate the HTTP protocol function used by the client.</p>
<p>In summary, this request means that it is a request to access the /form/login page resource on an HTTP server with the parameters name = veal, age = 37.</p>
<p>Note that for both HTTP request and HTTP response messages, there is a &ldquo;blank line&rdquo; between the request/response header and the request/response body, and the request/response body is not required.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/22/4dd18c7169a8442fa0bd9d108b5157e4.png" alt="image"></p>
<p><strong>HTTP Request Methods</strong></p>
<p>The role of the methods in the request line is to be able to specify that the requested resource produces a certain behavior according to expectations, i.e. to give commands to the server using the method. These include (HTTP 1.1): GET, POST, PUT, HEAD, DELETE, OPTIONS, CONNECT, TRACE, and of course, the first 2 are the most common and most often used in our development.</p>
<p><strong>HTTP Request Header</strong></p>
<p>Request headers are used to supplement the request with additional information, client information, priority related to the content of the response, etc. The following are common request headers.</p>
<ul>
<li>Referer: indicates from which URI this request is bounced. For example, if you search Taobao.com through Baidu, the value of Referer in the request message to Taobao.com is: baidu.com. If you access it directly, you will not have this header. This field is usually used for anti-theft links.</li>
<li>Accept: Tells the server the type of response data that the request can support. (Correspondingly, the HTTP response message also has such a similar field Content-Type, used to indicate the type of data sent by the server, if the type specified by Accept and the type returned by the server do not match, it will report an error)</li>
<li>Host: informs the server of the Internet host name and port number where the requested resource resides. This field is the only field in the HTTP/1.1 specification that must be included in the request header.</li>
<li>Cookie: The client&rsquo;s cookie is passed to the server through this header attribute!</li>
<li>Connection: indicates the type of client-server connection; Keep-Alive means persistent connection, close is closed.</li>
<li>Content-Length: the length of the request body</li>
<li>Accept-Language: The browser notifies the server of the language supported by the browser.</li>
<li>Range: For range requests that only require partial access to the resource, include the first field Range to inform the server of the specified range of the resource</li>
</ul>
<h3 id="http-response-message">HTTP response message</h3>
<p>The HTTP response message also consists of three parts.</p>
<ul>
<li>Response line (must be on the first line of the HTTP response message)</li>
<li>The response header (starts on the second line and ends on the first blank line. There is a blank line between the response header and the response body)</li>
<li>Response body</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/22/c689c74e5b234fc5b16ab50c8b576f05.png" alt="image"></p>
<p>The HTTP 1.1 at the beginning of the response line indicates the corresponding HTTP version of the server. The 200 OK that follows indicates the &ldquo;status code&rdquo; and &ldquo;reason phrase&rdquo; of the result of the request.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/22/5cf6e45fbba2417890d9ef32323e42bf.png" alt="image"></p>
<p><strong>HTTP Status Codes</strong></p>
<p>HTTP status codes are responsible for indicating the return result of a client HTTP request, marking whether the server side is processing properly, notifying of errors, etc. The status code consists of 3 digits, the first of which defines the category of the response.</p>
<p><strong>HTTP Response Header</strong></p>
<p>The response header, also in key-value pairs k:v, is used to supplement the response with additional information, server information, and additional requirements for the client, etc.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/22/d005c4de7b384ec5bb690855d4a2a265.png" alt="image"></p>
<h3 id="http-connection-management">HTTP connection management</h3>
<p><strong>Short connections (non-persistent connections)</strong></p>
<p>In the initial version of the HTTP protocol (HTTP/1.0), a connection is established for each HTTP session between the client and the server, and the connection is broken at the end of the task. When a client browser accesses an HTML or other type of Web page that contains other Web resources (such as JavaScript files, image files, CSS files, etc.), the browser re-establishes an HTTP session for each such Web resource encountered. This is called a short connection (also called a non-persistent connection).</p>
<p>This means that the connection is re-established once for each HTTP request. Since HTTP is based on the TCP/IP protocol, each establishment or disconnection of a connection requires the overhead of three TCP handshakes or four TCP waves.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/22/d41d663435cc43a98af6a7730ee2256a.png" alt="image"></p>
<p>Obviously, there are huge drawbacks to this approach. For example, accessing an HTML page containing multiple images causes needless TCP connections to be established and disconnected with each request for an image resource, greatly increasing the overhead of communication volume.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/22/f9294a7fe20640dba613fcfc09a8e848.png" alt="image"></p>
<p><strong>Long connections (persistent connections)</strong></p>
<p>Since HTTP/1.1, long connections, also called persistent connections, are used by default. HTTP protocols that use long connections include this line of code in the response header: Connection:keep-alive</p>
<p>In the case of long connections, when a web page is opened, the TCP connection used to transfer HTTP data between the client and the server is not closed, and the client will continue to use the established connection when it accesses the server again. This time can be set in different server software (e.g. Apache). Implementing a long connection requires that both the client and server support long connections.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/22/c7d759b2424b42e5a71116dae3e77270.png" alt="image"></p>
<p>Long and short connections for the HTTP protocol are essentially long and short connections for the TCP protocol.</p>
<p><strong>Pipelining</strong></p>
<p>By default, HTTP requests are sent sequentially, and the next request is sent only after the response is received for the current request. Due to network latency and bandwidth limitations, it can take a long time before the next request is sent to the server.</p>
<p>Persistent connections make it possible to send most requests in a &ldquo;pipelined&rdquo; fashion, i.e., to send requests continuously on the same persistent connection without waiting for a response to be returned, so that multiple requests can be sent in parallel without having to wait for a response one after another.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/22/941b6ee8dbf54e2a88d9abb2e60e2ef7.png" alt="image"></p>
<h3 id="stateless-http">Stateless HTTP</h3>
<p>The HTTP protocol is a stateless protocol. This means that he does not manage the state of requests and responses that have occurred previously, i.e. he cannot process the current request based on the previous state. This poses an obvious problem. If HTTP cannot remember the user&rsquo;s login state, wouldn&rsquo;t every page jump result in the user having to log in again?</p>
<p>Of course, there is no denying that statelessness has significant advantages, as it reduces the server&rsquo;s CPU and memory consumption by not having to save state. On the other hand, the simplicity of HTTP is the reason why it is so widely used.</p>
<p>While retaining this feature of stateless protocols, it is important to solve the problems caused by statelessness. There are various solutions, and one of the simpler ways is to use cookie technology.</p>
<p>Cookies control the state of the client by writing cookie information in the request and response messages. Specifically, the cookie notifies the client to save the cookie based on the information in the initial field called Set-Cookie in the response message sent from the server, and when the client sends the next request to the server, the client automatically adds the cookie value to the request message and sends it out. After receiving the cookie from the client, the server will check which client sent the connection request, and then compare the records on the server to get the previous status information.</p>
<p>Figuratively speaking, after the client&rsquo;s first request, the server will send an ID card with the client&rsquo;s information, and when the client subsequently requests the server, it will bring the ID card with it so that the server will recognize it.</p>
<p>The following diagram illustrates a scenario in which a cookie interaction occurs.</p>
<p>Requests in the state without cookie information.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/22/834ff39c8a7c4b4ebdab10f4bd47d93b.png" alt="image"></p>
<p>Requests after the 2nd time (with cookie information status)</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/22/44e5b99755704662b143b85c44e25166.png" alt="image"></p>
<h3 id="http-and-https">HTTP and HTTPS</h3>
<p>The <a href="https://www.biaodianfu.com/https-ssl-tls.html">HTTPS protocol</a> can be understood as an upgrade of the HTTP protocol, which is the addition of data encryption on top of HTTP. Before the data is transmitted, it is encrypted and then sent to the server. In this way, even if the data is intercepted by a third party, your personal information is still safe because the data is encrypted. This is the major difference between HTTP and HTTPS.</p>
<p>Internet communication security is based on SSL/TLS protocols, SSL &ldquo;Secure Sockets Layer&rdquo; protocol and TLS &ldquo;Secure Transport Layer&rdquo; protocol, both of which are encryption protocols that protect privacy and data integrity in the transmission of data over the network. This ensures that information transmitted over the network is not intercepted or modified by unauthorized elements, thus ensuring that only legitimate senders and receivers have full access to the information being transmitted.</p>
<ul>
<li>SSL : (Secure Socket Layer), a protocol layer that sits between the reliable connection-oriented network layer protocol and the application layer protocol. SSL enables secure communication between clients and servers by authenticating each other, using digital signatures to ensure integrity, and using encryption to ensure privacy. The protocol consists of two layers: the SSL Record Protocol and the SSL Handshake Protocol.</li>
<li>TLS : (Transport Layer Security), used between two applications to provide confidentiality and data integrity. The protocol consists of two layers: the TLS logging protocol and the TLS handshake protocol.</li>
</ul>
<p>HTTP communication without SSL/TLS is communication without encryption. All information is disseminated in clear text, which poses three major risks.</p>
<ul>
<li>Eavesdropping risk (eavesdropping): Third parties can be informed of the content of the communication.</li>
<li>tampering: Third parties can modify the content of the communication.</li>
<li>The risk of impersonation (pretending): Third parties can participate in the communication by impersonating someone else&rsquo;s identity.</li>
</ul>
<p>The SSL/TLS protocol is designed to address these three major risks, hoping to achieve.</p>
<ul>
<li>All messages are transmitted encrypted and cannot be eavesdropped by third parties.</li>
<li>Equipped with a checksum mechanism so that if tampered with, both sides of the communication will immediately discover it.</li>
<li>Equipped with an ID book to prevent identity impersonation.</li>
</ul>
<p>The Internet is an open environment and both communicating parties are unknown identities, which makes the design of the protocol very difficult. Moreover, the protocol must also be able to withstand all outlandish attacks, which makes the SSL/TLS protocol extremely complex.</p>
<h2 id="http-protocol-evolution">HTTP protocol evolution</h2>
<p>Up to now, the IETF has released five HTTP protocols, including HTTP 0.9, HTTP 1.0, HTTP 1.1, HTTP 2, HTTP 3. Here are the differences between the versions.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/22/4434a356bcb640899ac5287986f47301.png" alt="image"></p>
<h3 id="http09">HTTP/0.9</h3>
<p>The original version of the HTTP protocol did not have a version number, which was later positioned at 0.9 to distinguish it from later versions. The deprecated HTTP/0.9 was the first version of the HTTP protocol, born in 1989. It was extremely simple in composition, allowing clients to send only one request, GET, and did not support request headers. Since there was no protocol header, HTTP/0.9 could only support one type of content - plain text. The server can only respond with a string in HTML format, not any other format. Once the server has finished sending, it closes the TCP connection. HTTP/0.9 is typically stateless, with each access handled independently and disconnected when processing is complete. No error codes are returned if the requested page does not exist.</p>
<h3 id="http10">HTTP/1.0</h3>
<p>In November 1996, a new document (<a href="https://tools.ietf.org/html/rfc1945">RFC 1945</a>) was published. Document RFC 1945 defines HTTP/1.0, but it is narrowly defined and is not an official standard. HTTP 1.0 is the second version of the HTTP protocol and is still widely used today. It expands and improves upon HTTP/0.9 in a number of ways, including</p>
<ul>
<li>the ability to transfer documents other than plain text HTML files, such as images, videos, and binary files, not just text</li>
<li>In addition to GET commands, POST and HEAD commands have been introduced, enriching the means of interaction between the browser and the server.</li>
<li>The format of HTTP requests and responses has also changed. In addition to the data portion, each communication must include a header (HTTP header), which describes some metadata.</li>
<li>Other new features include status code, multi-character set support, multi-part type, authorization, cache, content encoding, and more.</li>
</ul>
<p><strong>Request Header</strong></p>
<p>Header information for a simple request</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">GET / HTTP/1.0
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)
Accept: */*
</code></pre></td></tr></table>
</div>
</div><p>You can see that after the request method there is the location of the requested resource + the request protocol version, followed by some client information configuration</p>
<p><strong>Response header</strong></p>
<p>Header information for a simple response (v1.0)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">HTTP/1.0 200 OK
Content-Type: text/plain
Content-Length: 137582
Expires: Thu, 05 Dec 1997 16:00:00 GMT
Last-Modified: Wed, 5 August 1996 15:55:28 GMT
// 这是一个空行
...数据内容
</code></pre></td></tr></table>
</div>
</div><p>The first response header of the server is the request protocol version, followed by the status code of the request, and the description of the status code, followed by a description of the returned content.</p>
<p><strong>Content-Type field</strong></p>
<p>In HTTP 1.0, any resource can be transmitted in a variety of formats, and the content of the response body is parsed by the client according to the Content-Type. Regarding the encoding of characters, version 1.0 specifies that the header information must be ASCII, and the data that follows can be in any format. Therefore, when the server responds, it must tell the client what format the data is in, so the server must return with this field.</p>
<p>Values of common Content-Type fields.</p>
<ul>
<li>text/html</li>
<li>text/css</li>
<li>image/png</li>
<li>image/gif</li>
<li>application/javascript</li>
<li>application/octet-stream</li>
</ul>
<p>These Content-Types have a general name called MIME type.</p>
<p>These data types are collectively called MIME type, and MIME type can also have parameters added at the end using a semicolon.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">Content-Type: text/html; charset=utf-8
</code></pre></td></tr></table>
</div>
</div><p>The client can also use Accept to declare the format of the data it receives when requesting</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">accept: */*
</code></pre></td></tr></table>
</div>
</div><p><strong>Content-Encoding field</strong></p>
<p>Since the data to be transmitted may be large, it can be compressed at one time for transmission. The Content-Encoding field is a description of how the data is compressed.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">Content-Encoding: gzip
Content-Encoding: compress
Content-Encoding: deflate
</code></pre></td></tr></table>
</div>
</div><p>When requesting, the client uses the Accept-Encoding field to indicate which compression methods it can accept.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">Accept-Encoding: gzip, deflate
</code></pre></td></tr></table>
</div>
</div><p><strong>status code</strong></p>
<p>The status code consists of three digits, the first of which defines the category of the response and has five possible values.</p>
<ul>
<li>1xx: indication message - indicates that the request has been received and processing continues</li>
<li>2xx: Success - indicates that the request has been successfully received, understood, accepted</li>
<li>3xx: Redirect - further actions must be taken to complete the request</li>
<li>4xx: Client-side error - the request has a syntax error or the request could not be fulfilled</li>
<li>5xx: Server-side error - the server failed to implement a legitimate request</li>
</ul>
<p><strong>Features of HTTP/1.0</strong></p>
<ul>
<li>Stateless: the server does not track or record the requested state (you can use the cookie/session mechanism to do authentication and state recording)</li>
<li>connectionless: the browser needs to establish a tcp connection for each request</li>
</ul>
<p><strong>Disadvantages of HTTP/1.0</strong></p>
<p>The most obvious disadvantage of version 1.0 of HTTP, which is the same as 0.9, is short connections, which can cause two problems that affect two aspects of HTTP communication: speed and bandwidth, respectively. Connections cannot be reused, resulting in processes such as three TCP handshakes for each request, resulting in slower speeds; the resulting lack of bandwidth can cause later responses to be blocked. This problem becomes more pronounced as more and more external resources (images, CSS, JavaScript files, etc.) are loaded on a web page.</p>
<p>To solve this problem, some browsers use a non-standard Connection field in their requests.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">Connection: keep-alive
</code></pre></td></tr></table>
</div>
</div><p>This field asks the server not to close the TCP connection so that other requests can be reused. The server responds to this field as well.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">Connection: keep-alive
</code></pre></td></tr></table>
</div>
</div><p>A reusable TCP connection is then established until the client or server actively closes the connection. However, this is not a standard field, and the behavior may not be consistent across implementations, so it is not a fundamental solution.</p>
<p>In addition, TCP as maintained by HTTP 1.0 can only handle one request at a time, and although it can receive multiple requests at once, it still has to process them one at a time in sequence, which can easily cause blocking while subsequent requests wait for the preceding request to complete. Also, it does not support breakpoint sequencing.</p>
<h3 id="http11">HTTP/1.1</h3>
<p>The third version of the HTTP protocol is HTTP 1.1. HTTP 1.1 was introduced six months after the release of 1.0 and completes version 1.0. HTTP 1.1 is the most widely used version of the protocol and is currently the dominant version of the HTTP protocol.</p>
<p>HTTP 1.1 introduces a number of key performance optimizations.</p>
<p><strong>1) Persistent connections/long connections</strong></p>
<p>The biggest change in version 1.1 is the introduction of persistent connection, which means that TCP connections are not closed by default and can be reused by multiple requests without having to declare Connection: keep-alive.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">Connection: Keep-Alive 
Keep-Alive: max=5, timeout=120
</code></pre></td></tr></table>
</div>
</div><p>Clients who want to close a connection can do so safely by adding Connection:close to the request header of the last request.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/22/ab5bbd4ff70347ba9bd9d65bb7041bc4.png" alt="image"></p>
<p>Currently for the same domain name, most browsers allow 6 persistent connections to be established at the same time.</p>
<p><strong>2) Pipelining mechanism</strong></p>
<p>Pipelining mechanism (pipelining): i.e., inside the same TCP link, the client can send multiple requests from colleagues. This further improves the efficiency of the HTTP protocol. For example, a client needs to request two resources. The previous practice was to send request A, then wait for the server to respond, and then send request B after receiving it. The pipeline mechanism allows the browser to send both A and B requests, but the server still responds to the A request in order, and then responds to the B request after it is completed.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/22/7919a9cba2574952b1f8118362c7a973.png" alt="image"></p>
<p>Here is the question, how does the client distinguish between where the first response is and where the next response is?</p>
<p>HTTP 1.1 adds a Content-Length prefix for this purpose, which marks the end of the response and the beginning of the next response.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">Content-Length:1234
</code></pre></td></tr></table>
</div>
</div><p>The above code tells the browser that the length of this response is 1234 bytes, and that the next bytes belong to the next response.</p>
<p>The pipeline mechanism solves the parallel request limitation problem mentioned above, because it supports sending multiple requests at once, but there is still a problem: the server still responds to requests in order, so if the previous request is slow, there will be many requests queued behind, which is called &ldquo;Head-of-line blocking&rdquo;.</p>
<p><strong>3) Chunked transmission</strong></p>
<p>The prerequisite for using the Content-Length field is that the server must know the data length of the response before it sends it. For some very time-consuming dynamic operations, this means that the server has to wait until all operations are completed before it can send the data, which is obviously not very efficient. A better way to handle this is to send a piece of data as it is generated, using &ldquo;stream mode&rdquo; instead of &ldquo;buffer mode&rdquo;. That is, send a piece of data as it is generated.</p>
<p>This takes the form of a Transfer-Encoding field returned in the response header, indicating that the data is composed of undefined chunks of data.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">Transfer-Encoding:chunked
</code></pre></td></tr></table>
</div>
</div><p>For each chunk, a Content-Length is added, and when all chunks have been transferred, an empty chunked is returned with Content-Length set to 0 to indicate that the transfer is complete.</p>
<p>Version 1.1 allows the use of &ldquo;chunked transfer encoding&rdquo; without the Content-Length field. Whenever a request or response has a Transfer-Encoding field in its header, it indicates that the response will consist of an undetermined number of chunks of data.</p>
<p><strong>4) New HTTP methods</strong></p>
<p>New HTTP methods are added, including PUT, PATCH, OPTIONS, DELETE.</p>
<ul>
<li>GET request gets the resource identified by Request-URI</li>
<li>POST appends new data to the resource identified by the Request-URI</li>
<li>HEAD request to get the response message header for the resource identified by the Request-URI</li>
<li>PUT request for the server to store a resource and use the Request-URI as its identifier</li>
<li>DELETE request for the server to delete the resource identified by the Request-URI</li>
<li>TRACE requests the server to send back information about the received request, primarily for testing or diagnostic purposes</li>
<li>CONNECT reserved for future use</li>
<li>OPTIONS requests to query the performance of the server, or to query options and requirements related to the resource</li>
</ul>
<p><strong>5) Added 24 new status response codes</strong></p>
<p>24 new status response codes were added in HTTP 1.1, such as.</p>
<ul>
<li>409 (Conflict) indicates that the requested resource conflicts with the current state of the resource.</li>
<li>410 (Gone) indicates that a resource on the server has been permanently deleted</li>
</ul>
<p><strong>6) Mandatory HOST header</strong></p>
<p>In HTTP 1.0 it was considered that each server was bound to a unique IP address, so the URL in the request message did not pass the hostname (hostname). However, with the development of virtual hosting technology, multiple virtual servers (Multi-homed Web Servers) can exist on a single physical server and they share a single IP address. HTTP 1.1 request and response messages should support the Host header field, and the absence of a Host header field in the request message will report an error (400 Bad Request). With the Host field, it is possible to send requests to different websites on the same server, laying the groundwork for the rise of web hosting.</p>
<p><strong>7) Introduced range header field/breakpoint</strong></p>
<p>HTTP/1.1 also supports the RANGE method, which transmits only a part of the content. This way when the client already has a part of the resource, it only needs to request the other part of the resource from the server. This is the basis for supporting file breakpoint sequencing. This feature is implemented by introducing the RANGE header field in the request message, which allows requesting only a certain part of the resource. The Content-Range header field in the response message declares the offset value and length of the returned part of the object. If the server returns the content of the requested range of the object accordingly, the response code 206 (Partial Content) is returned. When uploading/downloading resources, if the resources are too large, split them into multiple parts and upload/download them separately. If you encounter a network failure, you can continue the request from the place where it has been uploaded/downloaded well, without starting from the beginning, to improve efficiency.</p>
<p><strong>8) Cache handling</strong></p>
<p>HTTP/1.0 uses Pragma:no-cache + Last-Modified/If-Modified-Since + Expire as criteria for cache determination; HTTP/1.1 introduces more cache control policies: Cache-Control, Etag/If-None-Match</p>
<p>The response header in all HTTP 1.1 requests contains a &ldquo;Date:&rdquo; header, so each Response adds a timestamp to the cache.</p>
<p><strong>9) Added type, language, encoding and other header</strong></p>
<p><strong>10) Added TLS support, i.e., support for https transmission</strong></p>
<p><strong>11) Support more connection models</strong></p>
<p>Four models are supported: short connection, long link with reusable tcp, server-side push model (server-side actively pushes data into client-side cache), and websocket model.</p>
<h3 id="sypd">SYPD</h3>
<p>In 2009, Google made public its self-developed SPDY protocol, which mainly addresses the inefficiencies of HTTP/1.1. This protocol was used as the basis for HTTP/2 after it was proven to work on Chrome, and the main features were inherited from HTTP/2.</p>
<p>SPDY&rsquo;s solution optimizes HTTP1.X request latency and addresses HTTP1.X security, as follows.</p>
<ul>
<li>Reduce latency, for the problem of high HTTP latency, SPDY elegantly adopts multiplexing (multiplexing). Multiplexing solves the problem of HOL blocking by sharing a tcp connection with multiple request streams, reducing latency and increasing bandwidth utilization.</li>
<li>Request prioritization. SPDY allows to set priority to each request, so that important requests will be responded to first. For example, if the browser loads the home page, the html content of the home page should be displayed first, followed by various static resource files, script files, etc. This ensures that the user can see the page content first.</li>
<li>header compression. As mentioned earlier, the header of x is often duplicated and redundant. Choosing the right compression algorithm can reduce the size and number of packets.</li>
<li>HTTPS-based encryption protocol transmission, which greatly improves the reliability of the transmitted data.</li>
<li>Server push (server push), using the SPDY web page, for example, my web page has a request for css, while the client receives sytle.css data, the server will push the sytle.js file to the client, when the client tries to get sytle.js again it can get it directly from the cache, without sending a request.</li>
<li>SPDY sits below HTTP and above TCP and SSL, so that it can easily be compatible with older versions of the HTTP protocol (encapsulating x&rsquo;s content into a new frame format) while using the existing SSL functionality.</li>
</ul>
<p><strong>The difference between SPDY and HTTP/1.1</strong></p>
<p>SPDY is not used to replace HTTP, it simply modifies the way HTTP requests and answers are transmitted over the network; this means that only one SPDY transport layer is added and all existing server-side applications do not have to be modified in any way. When transported using the SPDY approach, HTTP requests are processed, tagged for simplicity and compressed. For example, each SPDY endpoint keeps track of every HTTP message header that has been sent in a previous request, thus avoiding the duplication of sending headers that have not yet been changed. And the data portion of the message that has not yet been sent will be sent after being compressed.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/22/eab67a8441974a2baff65a1ba3cd5256.gif" alt="image"></p>
<p>On the left is a normal HTTPS load, and on the right is a SPDY load.</p>
<p>The SPDY protocol only makes significant performance optimizations to HTTP. The core idea is to minimize the number of connections, but not to make significant changes to the semantics of HTTP. Specifically, SPDY uses the methods and headers of HTTP, but removes some headers and rewrites the parts of HTTP that manage connections and data transfer formats, so it&rsquo;s basically HTTP-compatible.</p>
<p>In the SPDY white paper, Google states that it wants to penetrate below the protocol stack and replace the transport layer protocol (TCP), but since this is quite difficult to deploy and implement for the time being, Google intends to improve the application layer protocol HTTP first by adding a session layer on top of SSL to implement the SPDY protocol, while the GET and POST message formats of HTTP remain unchanged, i.e. all existing server-side applications do not have to make any changes.</p>
<p>Therefore, at this point in time, SPDY is intended to enhance HTTP and is a better implementation and support for HTTP.</p>
<p>The core of SPDY is the framing layer, which manages the connection between two endpoints and the transfer of data. There can be multiple data streams between two endpoints. At the top of the framing layer, SPDY implements HTTP request/response processing. This allows us to use SPDY without much or no change to the existing website.</p>
<p>Shortcomings of the HTTP 1.1 protocol</p>
<ul>
<li>The biggest disadvantage of the HTTP protocol is that each TCP connection can only correspond to one HTTP request, i.e., each HTTP connection requests only one resource, and the browser can only solve this problem by establishing multiple connections. In addition, requests are made on a strict first-in-first-out (FIFO) basis in HTTP, so if an intermediate request takes longer to process, it will block later requests.</li>
<li>HTTP only allows requests to be initiated by the client. The server can only wait for the client to send a request, which is a shackle in the status quo that can satisfy preloading.</li>
<li>HTTP header redundancy. HTTP headers are sent repeatedly in the same session, and redundant information in between, such as User-Agent, Host, and other information that does not need to be sent repeatedly, is also being sent repeatedly, wasting bandwidth and resources.</li>
</ul>
<p>Benefits of SPDY protocol:</p>
<ul>
<li>Multiplexing request optimization. SPDY provides for an unlimited number of parallel requests within a single SPDY connection, i.e., it allows multiple concurrent HTTP requests to share a single TCP session. This makes SPDY more efficient by multiplexing multiple requests on a single TCP connection instead of opening separate connections for each request, so that only one TCP connection can be established to deliver all the resources on the web page, reducing message interaction round-trip time and avoiding delays caused by creating new connections. In addition, SPDY&rsquo;s multiplexing can set priority, unlike traditional HTTP, which processes requests one by one strictly on a first-in-first-out basis, it selectively transfers more important resources such as CSS first, and then less important resources such as website icons.</li>
<li>Supports server push technology. The server can initiate communication to the client to push data to the client. This preloading allows the user to maintain a fast network all the time.</li>
<li>SPDY compresses HTTP headers. The unnecessary headers are discarded and compressed to save the waiting time and bandwidth associated with redundant data transfers.</li>
<li>Google believes that the future of the Web must be a secure network connection, and all requests for SSL encryption make information transmission more secure.</li>
</ul>
<p>In 2015, Google decided to merge SPDY into the HTTP standard and named it HTTP / 2.</p>
<h3 id="http2">HTTP/2</h3>
<p>HTTP/2.0 is the first update to the HTTP protocol since the release of HTTP/1.1 in 1999, based primarily on the SPDY protocol, and was approved on February 17, 2015. Key features.</p>
<ul>
<li>HTTP/2 is in binary format rather than textual format</li>
<li>HTTP/2 is fully multiplexed, rather than ordered and blocking - only one connection is needed for parallelism</li>
<li>HTTP/2 uses header compression to reduce overhead</li>
<li>HTTP/2 allows servers to actively &ldquo;push&rdquo; responses to the client cache</li>
<li>HTTP/2&rsquo;s changes over HTTP/1.1 do not break existing programs, but new programs can take advantage of the new features to get better speed.</li>
<li>HTTP/2 retains much of the semantics of HTTP/1.1, such as request methods, status codes and even URIs, and most HTTP header fields are consistent. HTTP/2, however, uses a new approach to encoding and transferring data between clients and servers.</li>
</ul>
<p>HTTP 2.0 can be considered an upgrade of SPDY (in fact, it was originally designed based on SPDY), but there are still differences between HTTP 2.0 and SPDY, as follows.</p>
<ul>
<li>0 supports plaintext HTTP transmission, while SPDY forces the use of HTTPS</li>
<li>0 The message header compression algorithm uses <a href="http://http2.github.io/http2-spec/compression.html">HPACK</a> instead of <a href="http://zh.wikipedia.org/wiki/DEFLATE">DEFLATE</a>, which is used by SPDY</li>
</ul>
<p>Using the <a href="https://http2.akamai.com/demo">HTTP2.0 test</a> it can be seen that HTTP2.0 is a significant performance improvement over the previous protocol. Several features of the HTTP 2.0 protocol are summarized below.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/22/7e2ce58b9edc4a1595f738fb7edb761e.png" alt="image"></p>
<p><strong>1) Binary Transfer</strong></p>
<p>HTTP/1.1 has a header that is definitely text (ASCII) and a data body that can be either text or binary. HTTP/2 is a completely binary protocol, with both the header and the data body being binary and collectively referred to as &ldquo;frames&rdquo;: header frames and data frames.</p>
<p>HTTP/2 adds a binary framing layer between the application layer (HTTP/2) and the transport layer (TCP or UDP). It addresses the performance limitations of HTTP 1.1 without changing the semantics, methods, status codes, URIs, and prefix fields of HTTP/1.x. It improves transport performance and enables low latency and high throughput. In the binary framing layer, HTTP/2 splits all transmitted information into smaller messages and frames and encodes them in binary format, where the HTTP1.x header information is encapsulated in the HEADER frame and the corresponding Request Body is encapsulated in the DATA frame.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/22/3decd7a211e145a6a29e98097106d2dd.png" alt="image"></p>
<p>One of the benefits of the binary protocol is that additional frames can be defined. HTTP/2 defines nearly a dozen frames, laying the groundwork for advanced applications in the future. Parsing the data would become very cumbersome if such functionality were implemented using text, binary parsing is much easier.</p>
<p><strong>2) Multiplexing/</strong> <strong>Binary Framing</strong></p>
<p>Multiplexing allows multiple request-response messages to be initiated simultaneously over a single HTTP/2 connection. In the HTTP/1.1 protocol browser clients are limited to a certain number of requests for the same domain at the same time. Requests that exceed the limit are blocked. This is one of the reasons why some sites have multiple static resource CDN domains, while HTTP/2&rsquo;s Multiplexing allows multiple request-response messages to be initiated over a single HTTP/2 connection at the same time. HTTP/2 therefore makes it easy to implement multiple streams in parallel without relying on the establishment of multiple TCP connections. HTTP/2 reduces the basic unit of HTTP protocol communication to a single frame, which corresponds to a message in a logical stream. Messages are exchanged in both directions over the same TCP connection in parallel.</p>
<p>In HTTP 2.0, two concepts are important: the frame and the stream. A frame is the smallest unit of data, each frame identifies the stream to which it belongs, and a stream is a flow of data consisting of multiple frames.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/22/2879baf2ec4c46e58741cecb836c010f.png" alt="image"></p>
<p>By multiplexing, we mean that there are multiple streams in a TCP connection, i.e., multiple requests can be sent at the same time, and the other end can know which request the frame belongs to by the representation in the frame. At the client side, these frames are sent in a jumbled order and then reassembled at the other end based on the stream identifier at the beginning of each frame. With this technique, the queue head blocking problem of older versions of HTTP can be avoided, greatly improving transmission performance</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/22/337b2c14994b4f2fbacfe02805d649ed.png" alt="image"></p>
<p>Because HTTP/2 packets are sent out of order, consecutive packets inside the same connection may belong to different responses. Therefore, the packet must be marked to indicate which response it belongs to.</p>
<p>HTTP/2 refers to all packets of each request or response as a stream. Each stream is given a unique number. When a packet is sent, it must be marked with a stream ID to distinguish which stream it belongs to. It is also specified that the ID is always odd for streams sent by the client and even for those sent by the server.</p>
<p>The only way to cancel a stream in version 1.1 is to close the TCP connection. This means that HTTP/2 can cancel a request while ensuring that the TCP connection is still open and can be used by other requests.</p>
<p>The client can also specify the priority of the data stream. The higher the priority, the sooner the server will respond.</p>
<p>By splitting each frame with a stream ID to avoid sequential responses, the other side receives the frame and splices the stream according to the ID, thus avoiding head-of-queue blocking during requests by making the response chaotic. However, the blocking problem at the TCP level cannot be solved by HTTP/2 (HTTP is an application layer protocol, TCP is a transport layer protocol), because the TCP blocking problem is due to the possibility of packet loss during the transmission phase, and once the packet is lost, it will wait for resending and block the subsequent transmission. It does not solve the problem completely.</p>
<p><strong>3) Header Compression</strong></p>
<p>HTTP/1.1 does not support HTTP header compression, for this reason SPDY and HTTP/2 were created, SPDY uses the generic DEFLATE algorithm, while HTTP/2 uses the HPACK algorithm, which is designed specifically for header compression.</p>
<p>When a client requests many resources from the same server, like images from the same web page, there will be a large number of requests that look almost identical, which requires compression techniques to deal with this almost identical information. the HTTP protocol does not come with state, and all information must be attached to each request. So, many fields of the request are duplicated, such as Cookie and User Agent, exactly the same content that must be attached to each request, which wastes a lot of bandwidth and affects speed. Therefore, HTTP 2 can maintain a header information dictionary and update the header information in a differential amount to reduce the resources occupied by the header information transmission.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/22/c89d00ac5dee4d8b9ca7e5d1ea882917.png" alt="image"></p>
<p><strong>4) Server Push</strong></p>
<p>HTTP/2 allows the server to send resources to the client unsolicited, which is called server push.</p>
<p>A common scenario is that the client requests a web page that contains many static resources. Under normal circumstances, the client must receive the web page, parse the HTML source code, find static resources, and then send a static resource request. In fact, the server can expect that after the client requests the web page, it is likely to request static resources again, so it takes the initiative to send these static resources to the client along with the web page.</p>
<p>In HTTP 2.0, the server can take the initiative to push other resources after a certain request from the client. You can imagine that some resources will be requested by the client, and then you can take the server-side push technology to push the necessary resources to the client in advance, which can relatively reduce the delay time a little. You can also use prefetch in the case of browser compatibility.</p>
<h3 id="quic">QUIC</h3>
<p>Here are some brief introductions.</p>
<p><strong>The background of QUIC&rsquo;s creation</strong></p>
<p>HTTP 2.0, while already performing well, still has many shortcomings.</p>
<ul>
<li>Long connection establishment time (essentially a TCP problem)</li>
<li>Queue head blocking problem</li>
<li>Poor performance in mobile Internet (weak network environment)</li>
<li>&hellip;&hellip;</li>
</ul>
<p>All these shortcomings are basically due to the TCP protocol.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/22/c80499bb9b79465fb5f5a90c45eeb0e1.png" alt="image"></p>
<p>TCP is a connection-oriented, reliable transport layer protocol on which almost all important current protocols and applications are based.</p>
<p>The network environment is changing rapidly, but the TCP protocol is relatively slow, and it was this paradox that prompted Google to make a seemingly unexpected decision to develop a new generation of HTTP protocols based on UDP.</p>
<p>Looking at the shortcomings of TCP and some of the advantages of UDP alone.</p>
<ul>
<li>There are so many devices and protocols developed based on TCP that compatibility is difficult</li>
<li>The TCP stack is a significant part of Linux internals, and modifications and upgrades cost a lot</li>
<li>UDP itself is connectionless, no chain building and unlinking costs</li>
<li>UDP&rsquo;s packets have no queue head blocking problem</li>
<li>UDP retrofitting costs are small</li>
</ul>
<p>It is never easy for Google to modify and upgrade from TCP, but while UDP does not have the problems caused by TCP to ensure reliable connections, UDP itself is unreliable and cannot be used directly.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/22/9b30eb02e75d4d549da079102dbb1b57.png" alt="image"></p>
<p>In combination, it is logical that Google decided to transform a new protocol with the advantages of TCP protocol on top of UDP, and this new protocol is QUIC protocol.</p>
<p><strong>Introduction to QUIC</strong></p>
<p>QUIC is actually an abbreviation for Quick UDP Internet Connections, which directly translates to Fast UDP Internet Connection.</p>
<p>Some introduction to the QUIC protocol from Wikipedia: Originally designed, implemented and deployed by Jim Roskind at Google in 2012, the QUIC protocol was publicly announced in 2013 as experiments expanded and were described to the IETF. QUIC improves the performance of connection-oriented web applications that are currently using TCP. It does this by establishing multiple multiplexed connections between two endpoints using User Datagram Protocol (UDP). secondary goals of QUIC include reducing connection and transmission latency and performing bandwidth estimation in each direction to avoid congestion. It also moves the congestion control algorithm to user space rather than kernel space, in addition to scaling using forward error correction (FEC) to further improve performance in the event of errors.</p>
<h3 id="http30">HTTP/3.0</h3>
<p>HTTP 3.0, also known as HTTP Over QUIC, abandons the TCP protocol in favor of using the UDP-based QUIC protocol to implement it.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/22/cb17eb3239714b68955ce19e3a7465a1.png" alt="image"></p>
<p>Since HTTP 3.0 has chosen the QUIC protocol, it means that HTTP 3.0 basically inherits the powerful features of HTTP 2.0 and further solves some of the problems that existed in HTTP 2.0, while inevitably introducing new problems.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/22/e8d221be34f344b49b83e0541824fd9a.png" alt="image"></p>
<p>Although the HTTP2 protocol has significantly improved the performance of HTTP/1.1, the TCP-based implementation of HTTP2 leaves behind three problems.</p>
<ul>
<li>Head-of-line blocking induced by sequential byte streams, which makes HTTP2&rsquo;s multiplexing capability much worse.</li>
<li>TCP and TLS overlay the handshake delay, and there is room for a 1x reduction in the chain-building time.</li>
<li>Determining a connection based on TCP quaternions, a design born in wired networks, is not suitable for wireless networks in the mobile state, which means that frequent changes in IP addresses lead to repeated handshaking of TCP connections, TLS sessions, and high costs.</li>
</ul>
<p>The HTTP3 protocol addresses these issues.</p>
<ul>
<li>HTTP3 redefines connections based on the UDP protocol, enabling the transmission of unordered, concurrent byte streams at the QUIC layer, solving the head-of-queue blocking problem (including dynamic table-based head-of-queue blocking based on QPACK).</li>
<li>HTTP3 redefines the way the TLS protocol encrypts QUIC headers, both increasing the cost of network attacks and reducing the speed of establishing connections (only 1 RTT is needed to complete both chain building and key negotiation).</li>
<li>HTTP3 separates Packet, QUIC Frame, and HTTP3 Frame, which enables connection migration function and reduces the connection maintenance cost of high-speed mobile devices in 5G environment.</li>
</ul>
<p><strong>1) Head-of-line blocking problem</strong></p>
<p>Head-of-line blocking Head-of-line blocking (abbreviated as HOL blocking) is a computer network is a performance-limited phenomenon, in layman&rsquo;s terms: a packet affects a bunch of packets, it does not come everyone can not go.</p>
<p>Head-of-line blocking problem may exist in the HTTP layer and TCP layer, in HTTP1.x when both levels have the problem.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/22/3c1b56b2dc91468aaa7f3b5613240b3d.png" alt="image"></p>
<p>The multiplexing mechanism of the HTTP 2.0 protocol solves the queue head blocking problem at the HTTP layer, but the queue head blocking problem still exists at the TCP layer.</p>
<p>After the TCP protocol receives a packet, this data may arrive in disordered order, but TCP must collect and sort all the data for the upper layers to use, and if one of the packets is lost, it must wait for retransmission, thus a lost packet data blocks the data use of the whole connection.</p>
<p>The QUIC protocol is based on the UDP protocol, and there can be multiple streams on a link, and the streams do not affect each other, so when a stream has a packet loss, the impact is very small, thus solving the head blocking problem.</p>
<p><strong>2)0RTT Link Building</strong></p>
<p>A common metric for measuring network link building is RTT Round-Trip Time, which is the time consumed for one round-trip of data packets.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/22/a154af2d5cb14997babd337acf3521be.png" alt="image"></p>
<p>RTT consists of three components: round-trip propagation delay, queuing delay within network devices, and application data processing delay.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/22/cbaacc88010b41a698d81f4ca300e04e.png" alt="image"></p>
<p>Generally speaking HTTPS protocol requires at least 2-3 RTTs in total to establish a complete link including: TCP handshake and TLS handshake, and the normal HTTP protocol also requires at least 1 RTT to complete the handshake.</p>
<p>However, the QUIC protocol can achieve 0 RTT by including valid application data in the first packet, but this is also conditional.</p>
<p>Simply put, HTTP 2.0, based on TCP and TLS protocols, takes some time to complete the handshake and encryption negotiation before the packet is actually sent, and only after that can the actual business data be transmitted.</p>
<p>But QUIC, on the other hand, can send business data on the first packet, thus having a significant advantage in connection latency, saving hundreds of milliseconds.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/22/322e4eabaf8948888af8e8b14d06aaf9.png" alt="image"></p>
<p>QUIC&rsquo;s 0RTT also requires conditions, and for the first interaction between the client and the server 0RTT is also not doable, after all, both parties are completely unknown.</p>
<p>Therefore, the QUIC protocol can be discussed in two cases, first-time connection and non-first-time connection.</p>
<p>The client and server using the QUIC protocol have to use 1RTT for key exchange, and the exchange algorithm used is the DH (Diffie-Hellman) Diffie-Hellman algorithm.</p>
<p>First connection</p>
<p>Briefly, the key negotiation and data transfer process between the client and the server during the first connection involves the basic process of the DH algorithm.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/22/c3355aa22ece482883bef0f4816b573a.png" alt="image"></p>
<p>Non-first connection</p>
<p>As mentioned earlier, the client and the server pass the config package when they connect for the first time, which contains the server&rsquo;s public key and two random numbers, and the client stores the config, which can be used directly when connecting again, thus skipping the 1RTT and realizing the 0RTT business data interaction.</p>
<p>There is a time limit for the client to save the config, and the key exchange at the first connection is still required after the config expires.</p>
<p><strong>3) Forward Security Issues</strong></p>
<p>Forward security or forward secrecy Forward Secrecy is a security property of communication protocols in cryptography, which refers to the fact that the leakage of a long-used master key does not lead to the leakage of past session keys. Forward security protects communications conducted in the past from the threat of cryptographic or key exposure in the future. If a system has forward security, it can guarantee the security of historical communications in the event of a master key compromise, even if the system is actively attacked. In layman&rsquo;s terms, forward security means that a key leak will not allow previously encrypted data to be leaked even if the key is compromised, affecting only the present and having no effect on previous data.</p>
<p>As mentioned earlier, QUIC protocol generates two encryption keys when connecting for the first time, and since the config is stored by the client, if the private key of the server is leaked during the period, then the key K can be calculated based on K = mod p. If this key is used for encryption and decryption all the time, then all historical messages can be decrypted with K. Therefore, a new key is subsequently generated and used for encryption and decryption, and at that time is destroyed when the interaction is completed, thus achieving forward security.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/22/a5ecb511eaf74601865cd6e44d3eb76f.png" alt="image"></p>
<p><strong>4) Forward Error Correction</strong></p>
<p>Forward Error Correction also called Forward Error Correction Code Forward Error Correction abbreviated as FEC is a method to increase the trustworthiness of data communication, in a one-way communication channel, once the error is detected, its receiver will not have the right to request another transmission.FEC is a method to use data for transmission redundancy information, when an error occurs in transmission, will allow the receiver to build the data again.</p>
<p>The QUIC performs a heterodyne operation on each set of data sent and sends the result as a FEC packet. The receiver receives this set of data and can perform checksum and error correction based on the data packet and the FEC packet.</p>
<p><strong>5) Connection Migration</strong></p>
<p>Network switching happens almost all the time.</p>
<p>The TCP protocol uses a quintet to represent a unique connection, and when we switch from a 4G environment to a wifi environment, the IP address of the phone changes, and a new TCP connection must be created to continue transmitting data.</p>
<p>QUIC protocol based on UDP implementation discards the concept of quintet and uses a 64-bit random number as the ID of the connection and uses that ID to represent the connection.</p>
<p>Based on QUIC protocol, we can improve the service layer experience by not reconnecting during daily wifi and 4G switching, or switching between different base stations.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2021/12/22/b612117a59744ab49d0c5d972889cc3b.png" alt="image"></p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/http/">http</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2021-12/oauth-2/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">OAuth 2.0 Authorization Authentication Explained</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2021-12/no-parameterized-methods/">
            <span class="next-text nav-default">It&#39;s a sad story that Go generics don&#39;t support generic methods</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
